(function() {
  "use strict";
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = `.fortune-container {
  display: flex;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  flex-direction: column;
  font-family: "Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif;
  background-color: white;
}

.fortune-workarea {
  width: 100%;
}

.fortune-popover-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1003;
  /* should below .fortune-context-menu */
  height: 100%;
  width: 100%;
}

.fortune-modal-container {
  background: rgba(255, 255, 255, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

html::-webkit-scrollbar-button {
  display: none;
}

.fortune-stat-area {
  display: flex;
  justify-content: flex-end;
  align-items: center;
}

.fortune-sheet-container {
  display: flex;
  flex: 1;
  flex-direction: column;
}

.fortune-col-body {
  display: flex;
  flex: 1;
  flex-direction: row;
}

.fortune-sheet-area {
  flex: 1;
  position: relative;
}

.fortune-sheet-canvas-placeholder,
.fortune-sheet-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.fortune-sheet-canvas {
  position: absolute;
}
.fortune-sheet-overlay {
  position: absolute;
  width: 100%;
  height: 100%;
  outline-style: none;
}

.fortune-cell-area {
  border-collapse: collapse;
  position: relative;
  overflow: hidden;
  outline-style: none;
  cursor: default;
}

.fortune-row-body {
  display: flex;
  flex-direction: row;
}

.fortune-row-header {
  position: relative;
  flex-shrink: 0;
  outline-style: none;
  color: #5e5e5e;
  overflow: hidden;
  padding: 0;
  margin-top: -2px;
  padding-top: 2px;
  cursor: default;
  width: 45px;
}

.fortune-row-header-hover {
  position: absolute;
  z-index: 11;
  border: 0 none;
  right: 0;
  width: 100%;
  margin-top: 2px;
  display: none;
  background-color: rgba(194, 194, 194, 0.4);
}

.fortune-row-header-selected {
  position: absolute;
  z-index: 10;
  border-right: 1px solid #0188fb;
  right: 0;
  width: 100%;
  margin-top: 2px;
  display: none;
  background-color: rgba(76, 76, 76, 0.1);
}

.fortune-col-header-wrap {
  display: flex;
  flex-direction: row;
}

.fortune-col-header {
  color: #5e5e5e;
  overflow: hidden;
  padding: 0;
  cursor: default;
  flex: 1;
  height: 19px;
  outline-style: none;
  position: relative;
}

.fortune-col-header-hover {
  color: #5e5e5e;
  cursor: default;
  position: absolute;
  z-index: 11;
  border: 0 none;
  bottom: 0;
  height: 100%;
  margin-left: 0px;
  display: none;
  background-color: rgba(194, 194, 194, 0.4);
}

.fortune-col-header-hover .header-arrow {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translate(0%, -44%);
}

.fortune-col-header-selected {
  color: #5e5e5e;
  cursor: default;
  position: absolute;
  z-index: 10;
  border-bottom: 1px solid #0188fb;
  bottom: 0;
  height: 100%;
  margin-left: 0px;
  display: none;
  background-color: rgba(76, 76, 76, 0.1);
}

.fortune-left-top {
  width: 44.5px;
  height: 18.5px;
  border: solid 0 #dfdfdf;
  position: relative;
  padding-top: 0;
  border-width: 0 1px 1px 0;
  padding-left: 0;
  cursor: pointer;
  background-color: white;
}

.fortune-add-row-button {
  padding: 1px 20px;
  margin-right: 5px;
  display: inline-flex;
  align-items: center;
  margin: 0 8px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  line-height: 20px;
  outline: none;
  cursor: pointer;
  color: rgb(38, 42, 51);
  background-color: rgb(255, 255, 255);
  border: 1px solid rgb(200, 200, 200);
}

.luckysheet-cell-selected-focus {
  position: absolute;
  pointer-events: none;
  z-index: 14;
  /*border:1px solid #fff;*/
  margin: 0px 0 0 0px;
  background: rgba(0, 80, 208, 0.15);
  display: none;
}

.fortune-selection-copy {
  position: absolute;
  pointer-events: none;
  z-index: 18;
  border: none;
  margin: 0px 0 0 0px;
}

.fortune-selection-copy .fortune-copy {
  position: absolute;
  z-index: 18;
  background-color: transparent;
}

.fortune-selection-copy-hc {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border: 2px dashed #12a5ff;
  z-index: 8;
}

.fortune-selection-highlight {
  position: absolute;
  /*pointer-events: none;*/
  z-index: 14;
  border: none;
  margin: 0px 0 0 0px;
  /* display: none; */
}

.fortune-cell-selected-extend {
  position: absolute;
  pointer-events: none;
  z-index: 16;
  border: 1px dashed #0188fb;
  margin: -1px 0 0 -1px;
  display: none;
}

.fortune-cell-selected-move {
  cursor: move;
  position: absolute;
  /* pointer-events: none; */
  z-index: 16;
  border: 2px solid #0188fb;
  margin: -1px 0 0 -1px;
  display: none;
}

.luckysheet-cell-selected {
  position: absolute;
  pointer-events: none;
  z-index: 15;
  border: 1px solid #0188fb;
  margin: -1px 0 0 -1px;
  background: rgba(1, 136, 251, 0.15);
  display: none;
  box-sizing: content-box;
}

.luckysheet-cs-inner-border {
  pointer-events: none;
  border: 1px solid #fff;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
}

.luckysheet-cs-fillhandle {
  position: absolute;
  width: 6px;
  height: 6px;
  bottom: -5px;
  cursor: crosshair;
  background-color: #0188fb;
  border: solid 1px #fff;
  z-index: 16;
  pointer-events: auto;
  right: -5px;
}

.luckysheet-cs-draghandle {
  position: absolute;
  cursor: move;
  background-color: #fff;
  opacity: 0.01;
  z-index: 15;
  pointer-events: auto;
  border: 2px solid #fff;
}

.luckysheet-cs-draghandle-top {
  top: -4px;
  left: -2px;
  right: -2px;
  height: 2px;
}

.luckysheet-cs-draghandle-bottom {
  right: 0;
  left: -2px;
  bottom: -4px;
  height: 2px;
}

.luckysheet-cs-draghandle-left {
  top: 0;
  left: -4px;
  bottom: 0;
  width: 2px;
}

.luckysheet-cs-draghandle-right {
  top: 0;
  right: -4px;
  bottom: 0;
  width: 2px;
}

.luckysheet-cs-touchhandle {
  display: none;
  position: absolute;
  width: 16px;
  height: 16px;
  padding: 5px;
  z-index: 100;
  pointer-events: auto;
  touch-action: auto;
}

.luckysheet-cs-touchhandle:before {
  content: "";
  display: block;
  width: 16px;
  height: 16px;
  border: 0.5px solid rgba(0, 0, 0, 0.15);
  background-color: #ffffff;
  box-sizing: border-box;
  border-radius: 50%;
}

.luckysheet-cs-touchhandle-lt {
  left: -13px;
  top: -13px;
}

.luckysheet-cs-touchhandle-lb {
  left: -13px;
  bottom: -13px;
}

.luckysheet-cs-touchhandle-rt {
  right: -13px;
  top: -13px;
}

.luckysheet-cs-touchhandle-rb {
  right: -13px;
  bottom: -13px;
}

.luckysheet-cs-touchhandle .luckysheet-cs-touchhandle-btn {
  position: absolute;
  width: 10px;
  height: 10px;
  left: 8px;
  top: 8px;
  background-color: #018ffb;
  background-position: center;
  box-sizing: border-box;
  border-radius: 50%;
  z-index: 11;
}

.luckysheet-input-box {
  position: absolute;
  font: normal normal 400 13px arial, sans, sans-serif;
  z-index: 15;
  display: flex;
  flex-direction: column;
}

.luckysheet-input-box-inner {
  font: normal normal 400 13px arial, sans, sans-serif;
  text-align: left;
  max-height: 9900px;
  max-width: 9900px;
  border: 1px #5292f7 solid;
  padding: 0 2px;
  margin: 0;
  resize: none;
  overflow: hidden;
  white-space: pre-wrap;
  outline: none;
  -webkit-box-shadow: 0 2px 5px rgb(0 0 0 / 40%);
  -moz-box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
  box-shadow: 0 2px 5px rgb(0 0 0 / 40%);
  word-wrap: break-word;
  background-color: rgb(255, 255, 255);
  font-size: 13px;
  right: auto;
  overflow-y: auto;
  box-sizing: border-box;
}

.luckysheet-cell-input {
  width: 100%;
  margin: 0;
  outline: none;
  cursor: text;
  white-space: pre-wrap;
}

.luckysheet-formula-text-color {
  color: black;
}

.luckysheet-formula-text-string {
  color: forestgreen;
}

.luckysheet-cell-flow {
  margin: 0;
  padding: 0;
  border: none 0;
  position: relative;
  touch-action: manipulation;
}

.luckysheet-cell-flow-clip {
  border-collapse: collapse;
  cursor: default;
  width: 5000000px;
  touch-action: manipulation;
  overflow: hidden;
}

.luckysheet-cell-flow-col {
  margin: 0;
  padding: 0;
  border: none 0;
  position: relative;
  touch-action: manipulation;
  overflow: hidden;
  float: left;
  direction: ltr;
}

.luckysheet-cell-sheettable {
  position: relative;
  /*background-color: #fff;*/
  text-align: left;
  font-size: 11pt;
  color: #000000;
  text-decoration: none;
}

.luckysheet-bottom-controll-row {
  position: absolute;
  height: 30px;
  /*width: 400px;*/
  /* background: #000; */
  bottom: 38px;
  left: 0px;
  z-index: 1000;
}

#luckysheet-bottom-add-row {
  padding: 5px 20px;
  margin-right: 5px;
  margin-top: -2px;
}

#luckysheet-bottom-add-row-input {
  width: 40px;
  min-width: 40px;
}

#luckysheet-bottom-return-top {
  padding: 5px 6px;
  margin-left: 10px;
  margin-top: -2px;
}

.luckysheet-cell-flow-column {
  position: absolute;
  height: inherit;
  width: inherit;
  top: 0;
  left: 0;
  z-index: 1;
  touch-action: manipulation;
}

.luckysheet-cell-flow-column-line {
  position: absolute;
  border-right: 1px solid #d4d4d4;
  height: inherit;
}

.luckysheet-cell-flow-row {
  text-align: left;
  position: absolute;
  height: inherit;
  width: inherit;
  top: 0;
  left: 0;
  z-index: 1;
  touch-action: manipulation;
}

.luckysheet-cell-flow-row-line {
  position: absolute;
  border-bottom: 1px solid #d4d4d4;
  width: inherit;
}

.fortune-cols-change-size,
.fortune-rows-change-size,
.fortune-change-size-line,
.fortune-cols-freeze-handle,
.fortune-rows-freeze-handle,
.fortune-freeze-drag-line {
  /*display: none;*/
  -webkit-user-drag: none;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  position: absolute;
  z-index: 12;
}

.fortune-cols-change-size {
  width: 5px;
  height: 100%;
  background: #0188fb;
  cursor: ew-resize;
  opacity: 0;
}

.fortune-rows-change-size {
  width: 100%;
  height: 5px;
  background: #0188fb;
  cursor: ns-resize;
  opacity: 0;
}

.fortune-change-size-line {
  border-color: #0188fb;
  border-style: solid;
  z-index: 15;
  cursor: ew-resize;
}

.fortune-cols-freeze-handle {
  position: absolute;
  left: 0;
  width: 3px;
  height: 100%;
  background-color: #ddd;
  cursor: grab;
  z-index: 20;
}

.fortune-rows-freeze-handle {
  position: absolute;
  top: 0;
  height: 3px;
  width: 100%;
  background-color: #ddd;
  cursor: grab;
  z-index: 20;
}

.fortune-freeze-drag-line {
  border-color: #ccc;
  border-style: solid;
  z-index: 15;
  cursor: ew-resize;
}

/*批注聚焦框 移动 改变大小*/
.luckysheet-postil-dialog-move {
  position: absolute;
  margin: 0px;
  padding: 0px;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  pointer-events: none;
}

.luckysheet-postil-dialog-move .luckysheet-postil-dialog-move-item {
  /*background: #000;*/
  position: absolute;
  pointer-events: all;
  cursor: move;
}

.luckysheet-postil-dialog-move .luckysheet-postil-dialog-move-item-t {
  width: 100%;
  height: 3px;
  /* border-bottom: 1px solid #000; */
  left: 0;
  top: -4px;
}

.luckysheet-postil-dialog-move .luckysheet-postil-dialog-move-item-r {
  width: 3px;
  height: 100%;
  /* border-left: 1px solid #000; */
  right: -4px;
  top: 0;
}

.luckysheet-postil-dialog-move .luckysheet-postil-dialog-move-item-b {
  width: 100%;
  height: 3px;
  /* border-top: 1px solid #000; */
  left: 0;
  bottom: -4px;
}

.luckysheet-postil-dialog-move .luckysheet-postil-dialog-move-item-l {
  width: 3px;
  height: 100%;
  /* border-right: 1px solid #000; */
  left: -4px;
  top: 0;
}

.luckysheet-postil-show-active
  .luckysheet-postil-dialog-move
  .luckysheet-postil-dialog-move-item {
  border-color: #0188fb;
}

.luckysheet-postil-dialog-resize {
  position: absolute;
  margin: 0px;
  padding: 0px;
  top: -2px;
  left: -2px;
  bottom: -2px;
  right: -2px;
  pointer-events: none;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item {
  position: absolute;
  height: 6px;
  width: 6px;
  border: 1px solid #0188fb;
  pointer-events: all;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-lt {
  left: -6px;
  top: -6px;
  cursor: nw-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-mt {
  left: 50%;
  top: -6px;
  margin-left: -4px;
  cursor: n-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-lm {
  top: 50%;
  left: -6px;
  margin-top: -4px;
  cursor: w-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-rm {
  top: 50%;
  right: -6px;
  margin-top: -4px;
  cursor: e-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-rt {
  right: -6px;
  top: -6px;
  cursor: ne-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-lb {
  left: -6px;
  bottom: -6px;
  cursor: sw-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-mb {
  left: 50%;
  bottom: -6px;
  margin-left: -4px;
  cursor: s-resize;
}

.luckysheet-postil-dialog-resize .luckysheet-postil-dialog-resize-item-rb {
  right: -6px;
  bottom: -6px;
  cursor: se-resize;
}

.fortune-selection-copy-top {
  left: 0;
  right: 0;
  height: 2px;
  top: 0;
  background-position: bottom;
  /* background-image: url("EwaAntH.gif"); */
}

.fortune-selection-copy-right {
  top: 0;
  bottom: 0;
  width: 2px;
  right: 0;
  /* background-image: url("EwaAntV.gif"); */
}

.fortune-selection-copy-bottom {
  left: 0;
  right: 0;
  height: 2px;
  bottom: 0;
  /* background-image: url("EwaAntH.gif"); */
}

.fortune-selection-copy-left {
  top: 0;
  bottom: 0;
  width: 2px;
  left: 0;
  background-position: right;
  /* background-image: url("EwaAntV.gif"); */
}

.fortune-selection-copy-hc {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  border: 2px dashed #12a5ff;
  z-index: 8;
}

.luckysheet-modal-dialog-resize {
  position: absolute;
  border: 2px solid #0188fb;
  margin: 0px;
  padding: 0px;
  top: -2px;
  left: -2px;
  bottom: -2px;
  right: -2px;
  pointer-events: none;
}

.luckysheet-modal-dialog-resize-item {
  position: absolute;
  height: 6px;
  width: 6px;
  background: #ffffff;
  border: 2px solid #0188fb;
  pointer-events: all;
  border-radius: 6px;
}

.luckysheet-modal-dialog-resize-item-lt {
  left: -6px;
  top: -6px;
  cursor: se-resize;
}

.luckysheet-modal-dialog-resize-item-mt {
  left: 50%;
  top: -6px;
  margin-left: -4px;
  cursor: s-resize;
}

.luckysheet-modal-dialog-resize-item-rt {
  right: -6px;
  top: -6px;
  cursor: ne-resize;
}

.luckysheet-modal-dialog-resize-item-lm {
  top: 50%;
  left: -6px;
  margin-top: -4px;
  cursor: w-resize;
}

.luckysheet-modal-dialog-resize-item-rm {
  top: 50%;
  right: -6px;
  margin-top: -4px;
  cursor: w-resize;
}

.luckysheet-modal-dialog-resize-item-lb {
  left: -6px;
  bottom: -6px;
  cursor: ne-resize;
}

.luckysheet-modal-dialog-resize-item-mb {
  left: 50%;
  bottom: -6px;
  margin-left: -4px;
  cursor: s-resize;
}

.luckysheet-modal-dialog-resize-item-rb {
  right: -6px;
  bottom: -6px;
  cursor: se-resize;
}

.fortune-formula-functionrange-highlight .fortune-copy {
  background-image: none;
  background: #0188fb;
  position: absolute;
  z-index: 18;
  cursor: move;
  opacity: 0.9;
  box-sizing: content-box;
  /*border: 1px solid #fff;*/
}

.fortune-formula-functionrange-highlight .fortune-selection-copy-top {
  top: -2px;
  border-top: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.fortune-formula-functionrange-highlight .fortune-selection-copy-right {
  right: -2px;
  border-left: 2px solid #fff;
  border-right: 2px solid #fff;
}

.fortune-formula-functionrange-highlight .fortune-selection-copy-bottom {
  bottom: -2px;
  border-top: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.fortune-formula-functionrange-highlight .fortune-selection-copy-left {
  left: -2px;
  border-left: 2px solid #fff;
  border-right: 2px solid #fff;
}

.fortune-formula-functionrange-highlight .fortune-selection-copy-hc {
  border: 2px solid #5e5e5e;
  opacity: 0.03;
  z-index: initial;
}

.fortune-selection-highlight-lt {
  left: -3px;
  top: -3px;
  cursor: se-resize;
}

.fortune-selection-highlight-rt {
  right: -3px;
  top: -3px;
  cursor: ne-resize;
}

.fortune-selection-highlight-lb {
  left: -3px;
  bottom: -3px;
  cursor: ne-resize;
}

.fortune-selection-highlight-rb {
  right: -3px;
  bottom: -3px;
  cursor: se-resize;
}

.fortune-formula-functionrange-highlight .luckysheet-highlight {
  position: absolute;
  z-index: 19;
  border: 1px solid #fff;
  background: #0188fb;
  width: 6px;
  height: 6px;
}

.fortune-presence-username {
  position: absolute;
  padding-left: 6px;
  padding-right: 6px;
  padding-top: 2px;
  padding-bottom: 2px;
  left: -2px;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  box-sizing: content-box;
  color: #fff;
}

.fortune-presence-selection {
  position: absolute;
  border-style: solid;
  border-width: 1;
  opacity: 0.7;
}

.luckysheet-filter-options {
  color: #897bff;
  cursor: pointer;
  position: absolute;
  z-index: 200;
  border: 1px solid #897bff;
  border-radius: 3px;
  top: 3px;
  margin-left: 0px;
  display: "block";
  padding: 0px 4px;
  font-size: 12px;
  height: 15px;
  background: #fff;
}

.luckysheet-filter-options:hover {
  color: #fff;
  border: 1px solid #fff;
  background: #897bff;
}

.luckysheet-filter-options-active {
  color: #fff;
  border: 1px solid #897bff;
  padding: 0px 1px;
  background: #897bff;
}

.caret {
  margin-top: 6px;
  width: 0;
  height: 0;
  display: inline-block;
  border: 4px solid transparent;
}

.caret.down {
  border-top-color: #897bff;
}

.luckysheet-filter-options:hover .caret.down {
  border-top-color: #ffffff;
}

.luckysheet-filter-selected {
  background: #ffffff00;
}

#luckysheet-dataVerification-showHintBox {
  display: none;
  padding: 10px;
  background-color: #ffffff;
  border: 1px solid #ccc;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  position: absolute;
  z-index: 1000;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  cursor: default;
  white-space: nowrap;
  font-size: 12px;
}

#luckysheet-dataVerification-dropdown-btn {
  display: none;
  width: 20px;
  height: 20px;
  background-color: #ffffff;
  position: absolute;
  z-index: 10;
  overflow: hidden;
}

.luckysheet-formula-search-c {
  position: absolute;
  border: 1px solid rgba(0, 0, 0, 0.2);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  color: #535353;
  font-size: 12px;
  background: #fff;
  z-index: 1003;
  width: 300px;
}

.luckysheet-formula-search-c .luckysheet-formula-search-item {
  background: #fff;
  padding: 5px 10px;
  cursor: pointer;
}

.luckysheet-formula-search-c
  .luckysheet-formula-search-item
  .luckysheet-formula-search-detail {
  display: none;
  color: #444;
}

.luckysheet-formula-search-c
  .luckysheet-formula-search-item
  .luckysheet-formula-search-func {
  color: #222;
  font-size: 14px;
}

.luckysheet-formula-search-c .luckysheet-formula-search-item-active {
  display: block;
  border-top: 1px solid #ebebeb;
  border-bottom: 1px solid #ebebeb;
  background: #f5f5f5;
}

.luckysheet-formula-search-c
  .luckysheet-formula-search-item-active
  .luckysheet-formula-search-detail {
  display: block;
}

.luckysheet-formula-help-c {
  position: absolute;
  border: 1px solid rgba(0, 0, 0, 0.2);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  color: #535353;
  font-size: 12px;
  background: #fff;
  z-index: 1003;
  width: 300px;
}

.luckysheet-formula-help-c .luckysheet-formula-help-content {
  max-height: 300px;
  overflow-y: scroll;
}

.luckysheet-formula-help-content-example {
  margin-top: 5px;
}

.luckysheet-formula-help-title {
  display: block;
  border-top: 1px solid #ebebeb;
  border-bottom: 1px solid #ebebeb;
  background: #f5f5f5;
  padding: 2px 10px;
  font-size: 14px;
}

.luckysheet-formula-help-title-formula {
  width: 250px;
  word-break: break-word;
}

.luckysheet-arguments-help-section {
  margin-top: 5px;
  margin-bottom: 5px;
  color: #222;
}

.luckysheet-arguments-help-section-title {
  padding: 1px 10px;
  color: #666;
}

.luckysheet-arguments-help-parameter-content {
  padding: 1px 10px;
  display: inline-block;
  word-wrap: break-word;
}

.luckysheet-arguments-help-formula {
  padding: 1px 10px;
  font-size: 14px;
}

.luckysheet-arguments-help-parameter-active {
  background-color: #fff9b2;
}

.luckysheet-formula-help-collapse {
  position: absolute;
  top: 0px;
  right: 25px;
  font-size: 16px;
  cursor: pointer;
  color: #bbb;
}

.luckysheet-formula-help-close {
  position: absolute;
  top: 0px;
  right: 5px;
  font-size: 16px;
  cursor: pointer;
  color: #bbb;
}

.luckysheet-formula-help-close:hover,
.luckysheet-formula-help-collapse:hover {
  color: #555;
}

.luckysheet-scrollbar-ltr {
  position: absolute;
  overflow: hidden;
  z-index: 1003;
}

.luckysheet-scrollbar-ltr div {
  height: 1px;
  width: 1px;
}

.luckysheet-scrollbar-x {
  bottom: 0px;
  overflow-x: scroll;
}

.luckysheet-scrollbar-y {
  right: 0px;
  top: 0px;
  overflow-y: scroll;
}

.luckysheet-scrollbar-ltr::-webkit-scrollbar {
  background-color: transparent;
  width: 8px;
  height: 8px;
}

.luckysheet-scrollbar-ltr::-webkit-scrollbar-track {
  background-color: transparent;
}

.luckysheet-scrollbar-ltr::-webkit-scrollbar-thumb {
  background-color: #babac0;
  border-radius: 16px;
}

.luckysheet-scrollbar-ltr::-webkit-scrollbar-button {
  display: none;
}

.fortune-dialog {
  max-width: 90%;
  max-height: 90%;
  overflow: scroll;
  border-radius: 6px;
  background: white;
  box-shadow: rgb(0 0 0 / 10%) 5px 5px 30px;
  box-sizing: border-box;
  overflow: auto;
}

.fortune-dialog-box-button-container {
  display: flex;
  align-items: center;
  justify-content: center;
}

.fortune-dialog-box-content {
  padding: 0px 25px;
}

.fortune-dialog-box-button-container {
  padding-top: 10px;
  padding-bottom: 20px;
}

.fortune-message-box-button {
  display: inline-flex;
  align-items: center;
  padding: 6px 12px;
  margin: 0 8px;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  line-height: 20px;
  outline: none;
  cursor: pointer;
}

.fortune-message-box-button.button-default {
  color: rgb(38, 42, 51);
  background-color: rgb(255, 255, 255);
  border: 1px solid rgb(235, 235, 235);
}

.fortune-message-box-button.button-primary {
  color: white;
  background-color: #0188FB;
}

.fortune-modal-dialog-header {
  outline: 0;
  display: flex;
  justify-content: flex-end;
}

.fortune-modal-dialog-icon-close {
  color: #d4d4d4;
  opacity: 0.3;
}

.fortune-modal-dialog-icon-close:hover {
  opacity: 0.7;
}
/*查找替换弹出框样式*/
#fortune-search-replace {
  position: absolute;
  padding: 30px 42px;
  z-index: 1002;
}

#fortune-search-replace .icon-close {
  position: absolute;
  right: 3px;
  top: 3px;
}

#fortune-search-replace .tabBox {
  margin-top: 10px;
  font-size: 0;
}

#fortune-search-replace .tabBox span {
  display: inline-block;
  text-align: center;
  width: 100px;
  border: 1px solid rgb(235, 235, 235);
  font-size: 14px;
  line-height: 2;
}

#fortune-search-replace .tabBox span.on {
  background-color: #8C89FE;
  border-color: #726EFE;
  color: #fff;
}

#fortune-search-replace .ctBox {
  padding: 5px 10px;
  border: 1px solid rgb(235, 235, 235);
  font-size: 14px;
  min-width: 500px;
}

#fortune-search-replace .ctBox .row {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
}

#fortune-search-replace .inputBox {
  height: 90px;
  position: relative;
}

#fortune-search-replace .inputBox .textboxs {
  height: 30px;
  line-height: 30px;
}

#fortune-search-replace .checkboxs {
  height: 90px;
}

#fortune-search-replace .checkboxs div {
  height: 30px;
  line-height: 30px;
}

#fortune-search-replace .checkboxs input[type="checkbox"] {
  float: left;
  margin-top: 9px;
}

#fortune-search-replace .btnBox {
  margin-top: 10px;
}

#fortune-search-replace .btnBox .button-default {
  margin-right: 8px;
  margin-left: 0px;
}

#fortune-search-replace .close-button {
  margin-left: 0px;
  margin-top: 10px;
}

#fortune-search-replace #searchAllbox {
  height: 210px;
  border: 1px solid #d4d4d4;
  margin-top: 10px;
  overflow-y: auto;
  position: relative;
}

#fortune-search-replace #searchAllbox .boxTitle {
  width: 100%;
  height: 30px;
  line-height: 29px;
  padding: 0 5px;
  background-color: #fff;
  border-bottom: 1px solid #d4d4d4;
  box-sizing: border-box;
  position: sticky;
  left: 0;
  top: 0;
}

#fortune-search-replace #searchAllbox .boxTitle span {
  display: inline-block;
  text-align: center;
}

#fortune-search-replace #searchAllbox .boxTitle span:nth-of-type(1) {
  width: 25%;
}

#fortune-search-replace #searchAllbox .boxTitle span:nth-of-type(2) {
  width: 25%;
}

#fortune-search-replace #searchAllbox .boxTitle span:nth-of-type(3) {
  width: 50%;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem {
  height: 30px;
  line-height: 29px;
  border-bottom: 1px solid #d4d4d4;
  padding: 0 5px;
  box-sizing: border-box;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem.on {
  background-color: #8C89FE;
  color: #fff;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem span {
  display: block;
  text-align: center;
  float: left;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem span:nth-of-type(1) {
  width: 25%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem span:nth-of-type(2) {
  width: 25%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#fortune-search-replace #searchAllbox .boxMain .boxItem span:nth-of-type(3) {
  width: 50%;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.fortune-link-modify-modal {
  position: absolute;
  overflow: hidden;
  background-color: #fff;
  z-index: 300;
  padding: 6px 20px 10px 20px;
  box-shadow: 0 2px 6px 0 rgb(0 0 0 / 16%);
  border: solid 0.5px #e5e5e5;
  border-radius: 6px;
}

.fortune-link-modify-modal.link-toolbar {
  display: flex;
  flex-direction: row;
  padding: 2px 8px 2px 16px;
  align-items: center;
}


.fortune-link-modify-modal .link-content {
  margin-right: 6px;
}

.fortune-link-modify-modal .link-content:hover {
  color: #2674fb;
  cursor: pointer;
}

.fortune-link-modify-modal .divider {
  width: 1px;
  height: 16px;
  margin: 0px 6px ;
  background-color: #e0e0e0;
  flex-shrink: 0;
}

.fortune-link-modify-modal .fortune-toolbar-button {
  padding: 6px;
}

.fortune-link-modify-modal .fortune-toolbar-button:hover {
  background-color: rgba(0, 0, 0, 0.06);
  cursor: pointer;
}

.fortune-link-modify-modal.range-selection-modal {
  width: 380px;
  padding: 22px;
  -webkit-user-select: auto;
     -moz-user-select: auto;
      -ms-user-select: auto;
          user-select: auto;
  background-color: #fff;
}

.fortune-link-modify-line {
  padding-top: 10px;
}

.fortune-link-modify-title {
  font-size: 12px;
  display: inline-block;
  height: 16px;
  width: 74px;
  line-height: 16px;
  padding: 7px 0;
  color: #333333;
  margin-right: 6px;
}

.fortune-link-modify-input,
.fortune-link-modify-select {
  width: 232px;
  box-sizing: border-box;
  height: 26px;
  border-radius: 5px;
  border: 1px solid #d9d9d9;
  font-size: 12px;
  padding: 1px 8px;
  outline: none;
  -webkit-user-select: auto;
  -moz-user-select: auto;
  -ms-user-select: auto;
  user-select: auto;
}

.fortune-link-modify-input:focus,
.fortune-link-modify-modal .range-selection-input:focus {
  border-color: #4d90fe;
}

.fortune-link-modify-input.error-input,
.fortune-link-modify-modal .range-selection-input.error-input {
  border: 1px solid #EF4E2F !important;
}

.fortune-link-modify-cell-selector {
  width: 20px;
  right: 24px;
  padding: 4px;
  position: absolute;
  display: inline-block;
  border: none;
  cursor: pointer;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
}

.fortune-link-modify-modal .modal-title {
  font-weight: 500;
  font-size: 16px;
  color: rgba(0, 0, 0, .88);
  margin-bottom: 12px;
  line-height: 24px;
}

.fortune-link-modify-modal .range-selection-input {
  display: block;
  outline: none;
  font-size: 14px;
  height: 32px;
  width: 100%;
  -webkit-box-sizing: border-box;
  box-sizing: border-box;
  padding: 7px 11px;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  margin: 0;
}

.fortune-link-modify-modal .modal-icon-close {
  position: absolute;
  right: 22px;
  top: 22px;
  cursor: pointer;
}

.fortune-link-modify-modal .validation-input-tip {
  height: 17px;
  font-size: 12px;
  color: #EF4E2F;
  margin: 3px 0px ;
}

.fortune-link-modify-modal .button-group {
  display: flex;
}

.fortune-link-modify-modal .modal-footer {
  display: flex;
  justify-content: flex-end;
  padding: 0px 0px 5px 0px;
}

.fortune-link-modify-modal.range-selection-modal .modal-footer {
  padding: 0px;
}

.fortune-link-modify-modal .button-basic {
  display: flex;
  flex-flow: row nowrap;
  justify-content: center;
  align-items: center;
  font-size: 14px;
  height: 32px;
  width: 88px;
  padding: 0;
  border-radius: 4px;
  cursor: pointer;
}

.fortune-link-modify-modal .button-default {
  color: rgb(38, 42, 51);
  background-color: rgb(255, 255, 255);
  border: 1px solid rgb(235, 235, 235);
}

.fortune-link-modify-modal .button-primary {
  color: white;
  background-color: #0188FB;
  margin-left: 14px;
}
#fortune-data-verification {
  min-width: 500px;
  padding: 10px 0px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

#fortune-data-verification .title {
  font-size: 16px;
}

#fortune-data-verification .box {
  font-size: 14px;
}

#fortune-data-verification .box .box-item {
  padding: 10px;
  border-bottom: 1px solid #E1E4E8;
}

#fortune-data-verification .box .box-item .box-item-title {
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 10px;
}

#fortune-data-verification .box .box-item .data-verification-range {
  width: 100%;
  height: 30px;
  border: 1px solid #d4d4d4;
}

#fortune-data-verification .box .box-item .show-box-item {
  margin-top: 6px;
  font-size: 12px;
}

#fortune-data-verification .box .box-item .show-box-item .check-box {
  height: 30px;
  line-height: 30px;
  margin-bottom: 10px;

}

#fortune-data-verification .box .box-item .show-box-item .check-box input {
  height: 30px;
  padding: 0 10px;
  border: 1px solid #d4d4d4;
  box-sizing: border-box;
}

#fortune-data-verification .input-box input {
  height: 30px;
  padding: 4px 10px 4px 10px;
  border: 1px solid #d4d4d4;
  box-sizing: border-box;
  margin-top: 6px;
}

#fortune-data-verification .input-box span {
  margin: 0px 16px;
}

.data-verification-range .formulaInputFocus {
  width: calc(100% - 30px);
  height: 30px;
  padding: 0 10px px;
  float: left;
  border: none;
  outline-style: none;
  box-sizing: border-box;
}

.data-verification-range .icon {
  float: right;
  margin-top: 4px;
  margin-right: 5px;
  cursor: pointer;
}

#fortune-data-verification .box .box-item .data-verification-type-select {
  width: 100%;
  height: 30px;
  border-color: #d4d4d4;
  outline-style: none;
}

#fortune-data-verification .box .box-item .check {
  font-size: 12px;
  line-height: 24px;
}

#fortune-data-verification .box .box-item .check input {
  vertical-align: text-top;
}

#fortune-data-verification .button-basic {
  display: inline-block;
  margin-bottom: 0;
  font-weight: 400;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  white-space: nowrap;
  padding: 4px 8px;
  font-size: 14px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  margin-top: 10px;
}

#fortune-data-verification .button-primary {
  background: #0188fb;
  border: 1px solid #0188fb;
  color: #fff;
  margin-right: 10px;
}

#fortune-data-verification .button-close {
  color: #333;
  background-color: #fff;
  border: 1px solid #ccc;
  margin-right: 10px;
}


#range-dialog {
  box-shadow: 0 4px 16px rgb(0 0 0 / 20%);
  background: #fff;
  background-clip: padding-box;
  border: 1px solid rgba(0, 0, 0, .333);
  outline: 0;
  position: absolute;
  color: #000;
  padding: 30px 42px;
  z-index: 100003;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -90%);
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

#range-dialog .dialog-title {
  background-color: #fff;
  color: #000;
  cursor: default;
  font-size: 16px;
  font-weight: normal;
  line-height: 24px;
  margin: 0 0 16px;
}

#range-dialog input {
  height: 30px;
  padding: 0 10px;
  border: 1px solid #d4d4d4;
  outline-style: none;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

#range-dialog .button-primary {
  background: #0188fb;
  border: 1px solid #0188fb;
  color: #fff;
  margin-right: 10px;
}

#range-dialog .button-close {
  color: #333;
  background-color: #fff;
  border: 1px solid #ccc;
  margin-right: 10px;
}

#luckysheet-dataVerification-dropdown-List {
  background-color: #fff;
  border: 1px solid #ccc;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  position: absolute;
  z-index: 10000;
  box-sizing: border-box;
  font-size: 12px;
}

#luckysheet-dataVerification-dropdown-List .dropdown-List-item {
  padding: 5px 10px;
  box-sizing: border-box;
  cursor: pointer;
}

#luckysheet-dataVerification-dropdown-List .dropdown-List-item:hover {
  background-color: #E1E1E1;
}
.condition-format-sub-menu {
  position: absolute;
  top: -8px;
  box-shadow: 0 2px 4px rgb(0 0 0 / 20%);
  background: #fff;
  border: 1px solid rgba(0, 0, 0, .2);
  cursor: default;
  font-size: 12px;
  z-index: 1004;
  box-sizing: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  outline: none;
}

.condition-format-item {
  display: flex;
  justify-content: space-between;
  padding: 6px 18px;
  z-index: 1005;
}

.condition-format-item:hover {
  background: #efefef;
}

.condition-format-item span {
  font-size: 10px;
  color: #afafaf;
}

.horizontal-line {
  border-top: 1px solid #ebebeb;
  margin-top: 6px;
  margin-bottom: 6px;
}



.condition-rules .button-basic {
  display: inline-block;
  margin-bottom: 0;
  font-weight: 400;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  white-space: nowrap;
  padding: 4px 8px;
  font-size: 14px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  margin-top: 10px;
}

.condition-rules .button-primary {
  background: #0188fb;
  border: 1px solid #0188fb;
  color: #fff;
  margin-right: 10px;
}

.condition-rules .button-close {
  color: #333;
  background-color: #fff;
  border: 1px solid #ccc;
}

.condition-rules {
  padding: 0px 42px 34px 42px;
  font-size: 12px;
}

.condition-rules-title {
  color: #000;
  cursor: default;
  font-size: 16px;
  margin-bottom: 18px;
}

.conditin-rules-value {
  margin: 5px 0;
  font-weight: 600;
}

.condition-rules-inpbox {
  width: 198px;
  height: 28px;
  border: 1px solid #d4d4d4;
}

.condition-rules-input {
  width: 150px;
  height: 28px;
  padding: 0 10px;
  border: none;
  outline-style: none;
  float: left;
}

.condition-relues-inputicon {
  float: right;
  margin-top: 2px;
  margin-right: 5px;
  cursor: pointer;
}

.condition-rules-set-title {
  margin: 6px 0px;
}

.condition-rules-setbox {
  border: 1px solid #d4d4d4;
}

.condition-rules-set {
  padding: 5px 10px;
}

.condition-rules-color {
  height: 30px;
  line-height: 30px;
  position: relative;
}

.condition-rules-check {
  float: left;
  margin-top: 10px;
}

.condition-rules-label {
  display: inline-block;
  width: 80px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.condition-rules-select-color {
  padding: 2px;
  border: solid 1px #E5E5E5;
  background: #F5F5F5;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(20%, -50%);
}

.condition-rules-between-box {
  display: flex;
  align-items: center;
}

.condition-rules-between-inpbox {
  width: 108px;
  height: 28px;
  border: 1px solid #d4d4d4;
}

.condition-rules-between-input {
  width: 60px;
  height: 28px;
  padding: 0 10px;
  border: none;
  outline-style: none;
  float: left;
}

.condition-rules-date {
  width: 98%;
  border: none;
  line-height: 26px;
}

.condition-rules-select {
  width: 150px;
  height: 30px;
}

.condition-rules-project-box {
  display: flex;
  align-items: center;
}

.condition-rules-project-input {
  margin: 0px 6px;
}
.fortune-toolbar {
  display: flex;
  flex-direction: row;
  background: #fafafc;
  position: relative;
  padding: 5px 0px 3px 15px;
  border-bottom: 1px solid #d4d4d4;
  white-space: nowrap;
  align-items: center;
}

.fortune-toolbar-divider {
  width: 1px;
  height: 20px;
  margin: 0 6px;
  background-color: #e0e0e0;
  flex-shrink: 0;
}

.fortune-toolbar-menu-line {
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.fortune-toolbar-menu-divider {
  width: "100%";
  height: 1px;
  margin: 2px 6px;
  background-color: #e0e0e0;
}

.fortune-toolbar-button,
.fortune-toolbar-combo {
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  background: 0;
  outline: none;
  padding: 0;
  list-style: none;
  text-decoration: none;
  display: flex;
  align-items: center;
  padding: 2px;
  margin: 2px 4px;
}

.fortune-toolbar-combo-button,
.fortune-toolbar-combo-arrow {
  display: flex;
  align-items: center;
}

.fortune-toolbar-button:hover,
.fortune-toolbar-combo:hover {
  background-color: rgba(0, 0, 0, 0.06);
  cursor: pointer;
}

.fortune-toolbar-combo-arrow:hover {
  background-color: rgba(0, 0, 0, 0.06);
  cursor: pointer;
}

.fortune-toolbar-button:active,
.fortune-toolbar-combo:active {
  background-color: rgba(0, 0, 0, 0.12);
  cursor: pointer;
}

.fortune-toobar-combo-container {
  position: relative;
}

.fortune-toolbar-combo-popup {
  position: absolute;
  white-space: nowrap;
  top: 32px;
  left: 0;
  z-index: 1004;
}

.fortune-toolbar-select::-webkit-scrollbar {
  display: none ;
}

.fortune-toolbar-select,
.fortune-toolbar-color-picker {
  box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
  padding: 10px;
  border-radius: 6px;
  background: white;
}

.fortune-toolbar-select {
  padding-left: 0;
  padding-right: 0;
  overflow: auto;
  max-height: 75vh;
}

.fortune-toolbar-combo-button {
  font-size: 12px;
}

.fortune-toolbar-select-option {
  font-size: 12px;
  min-width: 60px;
  padding: 8px 12px;
  cursor: pointer;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.fortune-toolbar-select-option:hover {
  background: #efefef;
}

.fortune-toolbar-select::-webkit-scrollbar {
  display: none;
}

.fortune-toolbar-color-picker-row {
  display: flex;
  flex-direction: row;
}

.fortune-toolbar-combo-text {
  margin: 0 4px;
}

.fortune-toolbar-color-picker-item {
  width: 16px;
  height: 16px;
  margin: 1px;
  cursor: pointer;
}

.fortune-tooltip {
  visibility: hidden;
  background-color: #666;
  color: #fff;
  text-align: center;
  border-radius: 2px;
  padding: 6px;
  font-size: 12px;
  position: absolute;
  z-index: 25; /* higher than toolbar tips */
  top: 40px;
  white-space: nowrap;
}

.fortune-toolbar-button:hover .fortune-tooltip,
.fortune-toolbar-combo:hover .fortune-tooltip {
  visibility: visible;
}

.fortune-toolbar-more-container {
  position: absolute;
  display: flex;
  flex-direction: row;
  align-items: center;
  align-self: flex-end;
  margin-right: 40px;
  top: 40px;
  max-width: 348px;
  box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
  background: white;
  flex-wrap: wrap;
  z-index: 1002;
}

.fortune-toolbar-subtext {
  -webkit-transition: all 0.218s;
  -moz-transition: all 0.218s;
  -o-transition: all 0.218s;
  transition: all 0.218s;
  font-size: 12px;
  left: auto;
  padding-top: 1px;
  padding-left: 24px;
  text-align: right;
  opacity: .5;
  filter: alpha(opacity=50);
  color: #000;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  font-family: Arial;
  line-height: 100%;
}

.toolbar-item-sub-menu {
  position: absolute;
  box-shadow: 0 2px 4px rgb(0 0 0 / 20%);
  background: #fff;
  border: 1px solid rgba(0, 0, 0, .2);
  cursor: default;
  font-size: 12px;
  z-index: 1004;
  box-sizing: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  outline: none;
  border-radius: 6px;
}

#fortune-custom-color {
  min-width: 164px;
  background: rgb(240, 240, 240);
  border-radius: 6px;
  box-shadow: 0 2px 4px rgb(0 0 0 / 20%);
  border: 1px solid rgba(0, 0, 0, .2);
  font-size: 12px;
}

#fortune-custom-color .color-reset {
  position: relative;
  color: #333;
  cursor: pointer;
  list-style: none;
  padding: 10px;
  white-space: nowrap;
  padding-left: 8px;
  vertical-align: middle;
  padding-right: 24px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  border-radius: 6px;
  background: white;
}

#fortune-custom-color .color-reset:hover {
  background: rgb(230, 230, 230);
}

#fortune-custom-color .custom-color {
  position: relative;
  margin: auto;
  padding: 10px;
  border-radius: 6px;
  background: white;
  display: flex;
  align-items: center;
  margin: 1px 0px;
  display: flex;
  justify-content: space-around;
}

.button-basic {
  display: inline-block;
  margin-bottom: 0;
  font-weight: 400;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  white-space: nowrap;
  padding: 4px 8px;
  font-size: 12px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.button-primary {
  background: #0188fb;
  border: 1px solid #0188fb;
  color: #fff;
  margin-right: -4px;
}

.fortune-border-select-menu{
    position: absolute;
    bottom: 0px;
}

.fortune-border-color-preview {
  height: 3px;
}

.fortune-border-select-option {
  font-size: 12px;
  height: 24px;
  line-height: 24px;
  min-width: 60px;
  padding: 8px 12px;
}

.fortune-border-select-option:hover {
  background: #efefef;
  cursor: pointer;
}

.fortune-border-style-preview{
  height: 3px;
  overflow: hidden;
}

.fortune-border-style-picker-menu{
  padding: 0px 10px;
}

.fortune-border-style-picker-menu:hover{
  background: #efefef;
  cursor: pointer;
}

/*函数公式查找样式*/
#luckysheet-search-formula {
  font-size: 12px;
}

#luckysheet-search-formula .inpbox {
  margin-bottom: 5px;
}

#luckysheet-search-formula .inpbox div {
  display: block;
  margin-bottom: 5px;
}

#luckysheet-search-formula .inpbox input {
  width: 100%;
  height: 24px;
  line-height: 24px;
  border: 1px solid #d4d4d4;
  padding: 0 10px;
  box-sizing: border-box;
  font-size: 12px;
}

#luckysheet-search-formula .selbox {
  margin-bottom: 5px;
}

#luckysheet-search-formula .selbox select {
  width: 50%;
  height: 24px;
  line-height: 24px;
  border: 1px solid #d4d4d4;
  box-sizing: border-box;
  font-size: 12px;
}

#luckysheet-search-formula .listbox label {
  display: block;
  margin-bottom: 5px;
}

#formulaTypeList {
  width: 300px;
  height: 170px;
  border: 1px solid #d4d4d4;
  overflow-y: scroll;
}

.formulaList {
  width: 300px;
  height: 170px;
  border: 1px solid #d4d4d4;
  overflow-y: scroll;
}

.listBox {
  padding: 5px;
  border-bottom: 1px solid #d4d4d4;
}

.listBox.on {
  background-color: #8C89FE;
  color: #fff;
}

#fortune-split-column {\r
    /* position: absolute;\r
    padding: 30px 42px;\r
    z-index: 1002; */\r
    min-width: 500px;\r
}\r
#fortune-split-column label {\r
    -webkit-user-select: none;\r
       -moz-user-select: none;\r
        -ms-user-select: none;\r
            user-select: none\r
}\r
#fortune-split-column .title {\r
    font-size: 16px;\r
}\r
#fortune-split-column .splitDelimiters {\r
    margin-top: 10px;\r
}\r
#fortune-split-column .splitSymbols {\r
    position: relative;\r
    border: 1px solid #dfdfdf;\r
    padding: 5px;\r
    margin: 5px 0px;\r
}\r
#fortune-split-column .splitSymbol {\r
    font-size: 14px;\r
}\r
#fortune-split-column .splitSimple {\r
    position: absolute;\r
    top: 114px;\r
    left: 0px;\r
}\r
#fortune-split-column #otherValue {\r
    margin-left: 5px;\r
    width: 50px;\r
    padding: 0 5px;\r
}\r
#fortune-split-column .splitDataPreview {\r
    font-size: 14px;\r
    margin-top: 26px;\r
}\r
#fortune-split-column .splitColumnData {\r
    border: 1px solid #dfdfdf;\r
    padding: 5px;\r
    margin: 5px 0px;\r
    height: 100px;\r
    overflow-y: scroll;\r
}\r
#fortune-split-column .button-basic {\r
    display: inline-block;\r
    margin-bottom: 0;\r
    font-weight: 400;\r
    text-align: center;\r
    vertical-align: middle;\r
    touch-action: manipulation;\r
    cursor: pointer;\r
    white-space: nowrap;\r
    padding: 4px 8px;\r
    font-size: 14px;\r
    line-height: 1.42857143;\r
    border-radius: 2px;\r
    -webkit-user-select: none;\r
       -moz-user-select: none;\r
        -ms-user-select: none;\r
            user-select: none;\r
}\r
#fortune-split-column .button-primary {\r
    background: #0188fb;\r
    border: 1px solid #0188fb;\r
    color: #fff;\r
    margin-right: 10px;\r
}\r
#fortune-split-column .button-close {\r
    color: #333;\r
    background-color: #fff;\r
    border: 1px solid #ccc;\r
}\r
#fortune-split-column table {\r
    border-collapse: collapse;\r
}\r
#fortune-split-column tr {\r
    display: table-row;\r
    vertical-align: inherit;\r
    border-color: inherit;\r
}\r
#fortune-split-column td {\r
    border: 1px solid #333;\r
    display: table-cell;\r
    vertical-align: inherit;\r
}
label {
    cursor: default;
}
#fortune-location-condition {
    min-width: 500px;
}
#fortune-location-condition .title {
    background-color: #fff;
    color: #000;
    cursor: default;
    font-size: 16px;
    font-weight: normal;
    line-height: 48px;
}
#fortune-location-condition .listbox {
    border: 1px solid #dfdfdf;
    padding: 10px;
    font-size: 14px;
    color: #000;
}
#fortune-location-condition .listbox .listItem {
    padding: 5px 0;
}
#fortune-location-condition .listbox .listItem input[type="radio"] {
    float: left;
    margin-top: 5px;
}
#fortune-location-condition .listItem {
    padding: 5px 0;
}
#fortune-location-condition .listItem .subItem {
    height: 30px;
    padding: 0 10px;
    display: block;
}
#fortune-location-condition input[type="radio"] {
    float: left;
    margin-top: 3px;
}
#fortune-location-condition .listbox .listItem .subbox {
    height: 30px;
    padding: 0 10px;
}
#fortune-location-condition .listbox .listItem .subbox .subItem {
    float: left;
    margin-right: 5px;
}
#fortune-location-condition .button-basic {
    display: inline-block;
    margin-bottom: 0;
    font-weight: 400;
    text-align: center;
    vertical-align: middle;
    touch-action: manipulation;
    cursor: pointer;
    white-space: nowrap;
    padding: 4px 8px;
    font-size: 14px;
    line-height: 1.42857143;
    border-radius: 2px;
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
            user-select: none;
    margin-top: 10px;
}
#fortune-location-condition .button-primary {
    background: #0188fb;
    border: 1px solid #0188fb;
    color: #fff;
    margin-right: 10px;
}
#fortune-location-condition .button-close {
    color: #333;
    background-color: #fff;
    border: 1px solid #ccc;
}
.listBox {
  display: flex;
  justify-content: space-between;
}

.inpbox {
  margin-bottom: 10px;
}

.decimal-places-input {
  width: 70px;
}


.format-list {
  width: 300px;
  height: 170px;
  border: 1px solid #d4d4d4;
  overflow-y: scroll;
}



.fortune-fx-editor {
  display: flex;
  flex-direction: row;
  height: 28px;
  border-bottom: 1px solid #d4d4d4;
}

.fortune-fx-icon {
  display: flex;
  align-items: center;
  margin: 0 12px;
}

.fortune-name-box-container {
  width: 99px;
  border-right: 1px solid #d4d4d4;
  font-size: 14px;
  display: flex;
  align-items: center;
}

.fortune-name-box {
  width: 100%;
  text-align: center;
  margin: 0;
  outline: none;
  cursor: text;
  /* -webkit-user-modify: read-write-plaintext-only; */
  white-space: nowrap;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  background-color: white;
  word-wrap: break-word;
  -webkit-nbsp-mode: space;
  -webkit-line-break: after-white-space;
}

.fortune-fx-input-container {
  padding-left: 10px;
  overflow: visible;
  padding: 0;
  flex: 1;
  display: flex;
  align-items: center;
  position: relative;
  border-left: 1px solid #e5e5e5;
}

.fortune-fx-input {
  flex: 1;
  height: 100%;
  overflow-y: scroll;
  padding-left: 2px;
  font-size: 14px;
  line-height: 14px;
  margin: 0;
  outline: none;
  cursor: text;
  white-space: pre-wrap;
  word-wrap: break-word;
  -webkit-transform: translateZ(0);
  -webkit-nbsp-mode: space;
  -webkit-line-break: after-white-space;
  background-color: white;
  padding-top: 7px;
  box-sizing: border-box;
  color:black;
  text-align: left;
}
.fortune-fx-input[contenteditable="true"] {
  -webkit-user-modify: read-write-plaintext-only;
}
.luckysheet-sheet-area {
  width: 100%;
  box-sizing: border-box;
  background-color: #fafafc;
  color: #444;
  height: 31px;
  padding: 0 30px 0 44px;
  margin: 0;
  -webkit-touch-callout: none;
  cursor: default;
  transition: 0.3s ease all;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

#luckysheet-sheet-content {
  width: 0;
  flex: 3;
  display: flex;
  align-items: center;
}

#luckysheet-bottom-pager {
  width: 0;
  background-color: #fafafc;
  z-index: 1;
  flex: 2;
  text-align: right;
  white-space: nowrap;
}

.luckysheet-sheet-area>div,
.luckysheet-sheet-area .luckysheet-sheets-item {
  display: inline-block;
  /* margin-right: 6px;
	margin-top: 1px;
	padding: 1px 6px; */
  /* padding: 6px 10px; */
}

.fortune-sheettab-container {
  padding: 0px 0px;
  margin-left: 0px;
  position: relative;
  max-width: 54%;
  vertical-align: bottom;
  display: inline-block;
}

.fortune-sheettab-container .boundary {
  position: absolute;
  top: 0;
  width: 6px;
  height: 100%;
  z-index: 1;
  background: rgb(255, 255, 255);
}

.fortune-sheettab-container .boundary-left {
  left: 0;
  background-image: linear-gradient(to right, var(--tw-gradient-stops));
  --tw-gradient-from: #4445;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, #8880);
}

.fortune-sheettab-container .boundary-right {
  right: 0;
  background-image: linear-gradient(to left, var(--tw-gradient-stops));
  --tw-gradient-from: #4445;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, #8880);
}

.fortune-sheettab-container .fortune-sheettab-container-c {
  padding: 0px 0px;
  margin-left: 0px;
  overflow: hidden;
  white-space: nowrap;
  position: relative;
  max-width: 100%;
  vertical-align: bottom;
  display: inline-block;
}

.luckysheet-sheet-container-menu-hide .luckysheet-sheets-item {
  padding-right: 5px !important;
}

.luckysheet-sheet-container-menu-hide .luckysheet-sheets-item-menu {
  display: none !important;
}

.luckysheet-sheet-area div.luckysheet-sheets-item {
  padding: 2px 6px;
  height: 29px;
  line-height: 29px;
  background-color: #fafafc;
  color: #676464;
  min-width: 30px;
  top: 0px;
  position: relative;
  margin-right: -1px;
  cursor: pointer;
  transition: all 0.1s;
  font-size: 13px;
  padding: 2px 19px 0px 5px;
  box-sizing: border-box;
  border-left: 1px solid #e0e0e0;
  border-right: 1px solid #e0e0e0;
  vertical-align: middle;
}

.luckysheet-sheet-area div.luckysheet-sheets-item:last-child {
  margin-right: 1px;
}

.luckysheet-sheet-area div.luckysheet-sheets-item:hover {
  background-color: #efefef;
  /* border-color: #a5a5a5; */
  color: #490500;
}

.luckysheet-sheet-area div.luckysheet-sheets-item .luckysheet-sheets-item-menu {
  margin-left: 2px;
  display: inline-block;
  top: -2px;
  position: relative;
  color: #a1a1a1;
  position: absolute;
  height: 100%;
  width: 15px;
  right: 0px;
  text-align: center;
}

.luckysheet-sheet-area div.luckysheet-sheets-item .luckysheet-sheets-item-menu:hover {
  color: #2a2a2a;
  cursor: pointer;
}

.luckysheet-sheet-area div.luckysheet-sheets-item .luckysheet-sheets-item-name {
  padding: 0px 3px;
}

.luckysheet-sheets-item-color {
  width: 100%;
  height: 10%;
  position: absolute;
  bottom: 0;
  left: 0;
}

.luckysheet-sheet-area div.luckysheet-sheets-item .luckysheet-sheets-item-name[contenteditable="true"] {
  border: 1px solid #d9d9d9;
  display: inline-block;
  height: 18px;
  line-height: 18px;
  min-width: 8px;
  margin: -4px -1px;
  -moz-user-modify: read-write-plaintext-only;
  -webkit-user-modify: read-write-plaintext-only;
  -moz-user-select: text !important;
  -ms-user-select: text !important;
  -webkit-user-select: text !important;
}

.luckysheet-sheet-area div.luckysheet-sheets-item .luckysheet-sheets-item-name[contenteditable="true"]:focus {
  -webkit-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
  -moz-box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
  border: 1px solid #4d90fe;
  outline: none;
}

.luckysheet-sheet-area div.luckysheet-sheets-item-active {
  /* padding: 2px 8px; */
  height: 29px;
  line-height: 29px;
  background-color: #efefef;
  /* border-color: #aaa; */
  border-top-color: #fff;
  color: #222;
  /* box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); */
  cursor: default;
  /* top: -2px; */
  /* border-bottom: none; */
  /* padding-right: 20px; */
}

.luckysheet-sheet-area div.luckysheet-sheets-item-active:hover {
  background-color: #ececec;
  /* border-color: #aaa; */
  color: #222;
}

.fortune-sheettab-button {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 29px;
  width: 29px;
}

.fortune-sheettab-button:hover {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 29px;
  width: 29px;
  background-color: #efefef;
}

.luckysheet-noselected-text {
  -moz-user-select: -moz-test;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.fortune-sheettab-scroll {
  display: flex;
  align-items: center;
  padding: 0 5px;
  height: 29px;
  cursor: pointer;
}

.fortune-sheettab-scroll:hover {
  background-color: #e0e0e0;
}

.fortune-sheettab-placeholder {
  display: inline-block;
  width: 30px;
  height: 29px;
  line-height: 29px;
  vertical-align: middle;
}

.sheet-list-container {
  overflow: visible;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
}

.luckysheet-sheet-selection-calInfo {
  display: flex;
  font-size: 12px;
  align-content: center;
  padding: 0 0 0 44px;
  height: 22px;
  align-self: flex-end;
}

.luckysheet-sheet-selection-calInfo div {
  margin: auto 0;
  white-space: nowrap;
  margin-right: 7px;
}

.luckysheet-sheets-item-function {
  width: 12px;
  height: 24px;
  position: absolute;
  top: 4px;
  right: 2px;
}

.fortune-sheet-area-right {
  display: flex !important;
}
.fortune-zoom-container {
  white-space: nowrap;
  overflow: visible;
  display: flex;
  align-items: center;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.fortune-zoom-button {
  display: flex;
  cursor: pointer;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
}

.fortune-zoom-button:hover {
  background: #efefef;
}

.fortune-zoom-ratio {
  position: relative;
  display: flex;
  justify-content: center;
  width: 48px;
  color: #1e1e1f;
  font-size: 12px;
  cursor: pointer;
}

.fortune-zoom-ratio-current {
  width: 100%;
}

.fortune-zoom-ratio-item:hover {
  background: #efefef;
}

.fortune-zoom-ratio-menu {
  position: absolute;
  bottom: 30px;
  left: 0;
  line-height: 24px;
  box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
  padding: 10px 0px 10px 0px;
  border-radius: 6px;
  background: white;
  z-index: 1004;
}

.fortune-zoom-ratio-text {
  padding: 0px 10px 0px 10px;
}

.fortune-context-menu {
  max-height: 100%;
  overflow-y: auto;
  border-radius: 4px;
  box-shadow: 2px 2px 20px rgba(0, 0, 0, 0.15);
  transition: opacity 0.218s;
  background: #fff;
  border: 1px solid #ccc;
  border: 1px solid rgba(0, 0, 0, 0.2);
  cursor: default;
  font-size: 13px;
  margin: 0;
  outline: none;
  padding: 6px 0;
  position: absolute;
  z-index: 1004;
  box-sizing: border-box;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.fortune-context-menu input.luckysheet-mousedown-cancel {
  width: 35px;
  text-align: center;
  margin-left: 5px;
  margin-right: 5px;
}

.fortune-context-menu-divider {
  width: "100%";
  height: 1px;
  margin: 4px 0;
  background-color: #e0e0e0;
}

.luckysheet-cols-menu .luckysheet-cols-menuitem {
  position: relative;
  color: #333;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding: 1px 6em 1px 20px;
  white-space: nowrap;
  padding-left: 8px;
  vertical-align: middle;
  padding-right: 24px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

/* 右击菜单项目 hover背景色 */
.luckysheet-cols-menu .luckysheet-cols-menuitem:hover,
.luckysheet-cols-menu .luckysheet-cols-menuitem-hover {
  background: #EFEFEF;
}

.luckysheet-cols-menu .luckysheet-cols-menuitem .luckysheet-cols-menuitem-content {
  position: relative;
  color: #333;
  cursor: pointer;
  list-style: none;
  margin: 0;
  padding: 6px 7em 6px 30px;
  white-space: nowrap;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.fortune-filter-menu .luckysheet-cols-menuitem {
  padding: 0px;
}

.fortune-filter-menu .luckysheet-cols-menuitem .luckysheet-cols-menuitem-content {
  padding: 7px 24px;
}

.fortune-menuitem-row {
  display: flex;
  padding: 7px 24px;
  white-space: pre;
  align-items: center;
}

.fortune-byvalue-btn {
  cursor: pointer;
  color: blue;
  text-decoration: underline;
}


.luckysheet-filter-bycolor-submenu .button-basic,
.fortune-filter-menu .button-basic {
  display: flex;
  flex-flow: row nowrap;
  justify-content: center;
  align-items: center;
  font-size: 14px;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
}

.luckysheet-filter-bycolor-submenu .button-basic {
  margin: 5px 20px;
}

.luckysheet-filter-bycolor-submenu .button-default,
.fortune-filter-menu .button-default {
  color: rgb(38, 42, 51);
  background-color: rgb(255, 255, 255);
  border: 1px solid rgb(235, 235, 235);
  margin-left: 10px;
}

.luckysheet-filter-bycolor-submenu .button-default:hover,
.fortune-filter-menu .button-default:hover {
  background-color: #e6e6e6;
}

.luckysheet-filter-bycolor-submenu .button-primary,
.fortune-filter-menu .button-primary {
  color: white;
  background-color: #0188FB;
}

.luckysheet-filter-bycolor-submenu .button-primary:hover,
.fortune-filter-menu .button-primary:hover {
  background: #5391ff;
}

.fortune-filter-menu .button-danger {
  color: white;
  background-color: #d9534f;
  margin-left: 10px;
}

.fortune-filter-menu .button-danger:hover {
  background-color: #c9302c;
}

.filter-bycolor-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.filtermenu-input-container {
  padding: 0px;
}

.filtermenu-input-container input.luckysheet-mousedown-cancel {
  margin: 0px 20px;
  width: 230px;
  box-sizing: border-box;
  height: 26px;
  border-radius: 3px;
  border: 1px solid #d9d9d9;
  font-size: 12px;
  padding: 1px 8px;
  outline: none;
  -webkit-user-select: auto;
  -moz-user-select: auto;
  -ms-user-select: auto;
  user-select: auto;
  text-align: start;
}

.filtermenu-input-container input.luckysheet-mousedown-cancel {
  border: 1px solid #A1A1A1;
}

.filtermenu-input-container input.luckysheet-mousedown-cancel:focus {
  border: 1px solid rgb(1, 136, 251);
  outline: none;
}

.byvalue-btn-row {
  justify-content: space-between;
  padding-bottom: 0px;
  align-items: flex-start;
}

.filter-caret {
  width: 0;
  height: 0;
  display: inline-block;
  border: 4px solid transparent;
}

.filter-caret.right {
  margin-left: 2px;
  margin-right: 3px;
  border-left-color: #000000;
}

.filter-caret.down {
  margin-top: 5px;
  margin-right: 5px;
  border-top-color: #000000;
}

.filter-checkbox {
  margin-left: 0px;
  margin-right: 5px;
}

#luckysheet-filter-byvalue-select {
  min-height: 100px;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 4px 24px;
}

#luckysheet-filter-byvalue-select .count,
#luckysheet-pivotTableFilter-byvalue-select .count {
  color: gray;
  margin-left: 5px;
}

#luckysheet-filter-byvalue-select .select-item {
  display: flex;
  align-items: center;
}

/*颜色筛选 -- pan*/
.luckysheet-filter-bycolor-submenu {
  position: absolute;
  min-width: 170px;
  font-size: 12px;
  padding: 5px 0;
  z-index: 1004;
  border: 1px solid rgba(0, 0, 0, .2);
  background-color: #ffffff;
}

.luckysheet-filter-bycolor-submenu .title {
  padding: 10px;
  font-weight: 600;
  color: #333;
  background-color: #f4f4f4;
  text-align: center;
}

.luckysheet-filter-bycolor-submenu .one-color-tip {
  padding: 7px 30px;
  text-align: center;
}

.luckysheet-filter-bycolor-submenu .color-list {
  max-height: 128px;
  overflow: auto;
}

.luckysheet-filter-bycolor-submenu .item {
  padding: 5px 40px 5px 20px;
  cursor: pointer;
  position: relative;
  background-color: #ffffff;
}

.luckysheet-filter-bycolor-submenu .item:hover {
  background-color: #d3d3d3;
}

.luckysheet-filter-bycolor-submenu .item .color-label {
  display: block;
  width: 70px;
  height: 20px;
  border: 1px solid #d1d1d1;
}

.luckysheet-filter-bycolor-submenu .item input[type="checkbox"] {
  position: absolute;
  right: 10px;
  top: 6px;
}

.change-color-triangle {
  position: absolute;
  top: 3px;
  right: -18px;
}
.fortune-sort-title {
  background-color: #fff;
  color: #000;
  cursor: default;
  font-size: 16px;
  font-weight: 400;
  line-height: 24px;
  margin: 0 0 16px;
}

.fortune-sort-modal > div {
  margin-bottom: 10px;
}

.fortune-sort-tablec td {
  padding: 5px;
  white-space: nowrap;
}

.fortune-sort-button {
  margin-top: 10px;
  margin-bottom: 25px;
}

#fortune-change-color {
  min-width: 164px;
  height: 252px;
  background: rgb(240, 240, 240);
  position: absolute;
  bottom: -110px;
  left: 197px;
  border-radius: 6px;
  box-shadow: 0 2px 4px rgb(0 0 0 / 20%);
  border: 1px solid rgba(0, 0, 0, .2);
}

#fortune-change-color .color-reset {
  position: relative;
  color: #333;
  cursor: pointer;
  list-style: none;
  padding: 10px;
  white-space: nowrap;
  padding-left: 8px;
  vertical-align: middle;
  padding-right: 24px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  border-radius: 6px;
  background: white;
}

#fortune-change-color .color-reset:hover {
  background: rgb(230, 230, 230);
}

#fortune-change-color .custom-color {
  position: relative;
  margin: auto;
  padding: 10px;
  border-radius: 6px;
  background: white;
  display: flex;
  align-items: center;
  margin: 1px 0px;
  display: flex;
  justify-content: space-around;
}

.button-basic {
  display: inline-block;
  margin-bottom: 0;
  font-weight: 400;
  text-align: center;
  vertical-align: middle;
  touch-action: manipulation;
  cursor: pointer;
  white-space: nowrap;
  padding: 4px 8px;
  font-size: 12px;
  line-height: 1.42857143;
  border-radius: 2px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}

.button-primary {
  background: #0188fb;
  border: 1px solid #0188fb;
  color: #fff;
  margin-right: -4px;
}
.fortune-sheet-list {
  overflow-y: auto;
  overflow-x: hidden;
  min-width: 120px;
  position: absolute;
  z-index: 10002;
  bottom: 53px;
  margin-left: 72px;
  max-height: 60%;
}

.fortune-sheet-list-item {
  height: 30px;
  line-height: 30px;
  width: 100%;
  margin-right: 46px;
  cursor: pointer;
}

.fortune-sheet-list-item-name {
  margin-right: 15px;
  position: relative;
}

.fortune-sheet-list-item-name .luckysheet-sheets-list-item-color {
  width: 6%;
  height: 100%;
  position: absolute;
  bottom: 0;
  left: -6px;
}

.fortune-sheet-list :hover {
  background-color: #EFEFEF;
}

.fortune-sheet-hidden-button {
  margin-right: 15px;
  display: inline-flex;
  position: absolute;
  right: 0;
  justify-content: flex-end;
}

.fortune-sheet-hidden-button :hover {
  background-color: #D0D0D0;
}

.fortune-sheet-selected-check-sapce {
  width: 20px;
  display: inline-block;
  margin-left: 15px;
}
html,
body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
}

.fortune-sheet-mount {
  width: 100%;
  height: 100%;
}

/* Ensure fortune sheet doesn't overflow or collapse unexpectedly */
.fortune-sheet-container {
  box-sizing: border-box;
  width: 100% !important;
  height: 100% !important;
  min-height: calc(70vh - 100px);
  /* Absolute fallback */
  display: flex;
  flex-direction: column;
}

/* Ensure container is relative for absolute children */
.fortune-sheet-container {
  position: relative;
}

/* Force placeholder to take up space in the flex container */
.fortune-sheet-canvas-placeholder {
  flex: 1;
  min-height: 0;
  /* Crucial for nested flex containers */
  width: 100% !important;
}

/* Layer canvas and overlay ensuring they don't collapse */
.fortune-sheet-canvas,
.fortune-sheet-overlay {
  height: 100% !important;
}/*$vite$:1*/`;
  document.head.appendChild(__vite_style__);
  function _mergeNamespaces(n2, m2) {
    for (var i2 = 0; i2 < m2.length; i2++) {
      const e = m2[i2];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k2 in e) {
          if (k2 !== "default" && !(k2 in n2)) {
            const d2 = Object.getOwnPropertyDescriptor(e, k2);
            if (d2) {
              Object.defineProperty(n2, k2, d2.get ? d2 : {
                enumerable: true,
                get: () => e[k2]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  var react = { exports: {} };
  var react_production_min = {};
  /**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var l$2 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$1 = Symbol.for("react.profiler"), t$1 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w$1 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
  function A$2(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z$2 && a2[z$2] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B$2 = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C$1 = Object.assign, D$2 = {};
  function E$3(a2, b2, e) {
    this.props = a2;
    this.context = b2;
    this.refs = D$2;
    this.updater = e || B$2;
  }
  E$3.prototype.isReactComponent = {};
  E$3.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E$3.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E$3.prototype;
  function G$2(a2, b2, e) {
    this.props = a2;
    this.context = b2;
    this.refs = D$2;
    this.updater = e || B$2;
  }
  var H$2 = G$2.prototype = new F();
  H$2.constructor = G$2;
  C$1(H$2, E$3.prototype);
  H$2.isPureReactComponent = true;
  var I$2 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
  function M$2(a2, b2, e) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c2.children = e;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l$2, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
  }
  function N$2(a2, b2) {
    return { $$typeof: l$2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O$2(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$2;
  }
  function escape(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b2[a3];
    });
  }
  var P$2 = /\/+/g;
  function Q$2(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
  }
  function R$2(a2, b2, e, d2, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$2:
          case n$2:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$2(h2, 0) : d2, I$2(c2) ? (e = "", null != a2 && (e = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e, "", function(a3) {
      return a3;
    })) : null != c2 && (O$2(c2) && (c2 = N$2(c2, e + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I$2(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$2(k2, g2);
      h2 += R$2(k2, b2, e, f2, c2);
    }
    else if (f2 = A$2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q$2(k2, g2++), h2 += R$2(k2, b2, e, f2, c2);
    else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S$2(a2, b2, e) {
    if (null == a2) return a2;
    var d2 = [], c2 = 0;
    R$2(a2, d2, "", "", function(a3) {
      return b2.call(e, a3, c2++);
    });
    return d2;
  }
  function T$2(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b3) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
      }, function(b3) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U$2 = { current: null }, V$1 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
  function X$2() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S$2, forEach: function(a2, b2, e) {
    S$2(a2, function() {
      b2.apply(this, arguments);
    }, e);
  }, count: function(a2) {
    var b2 = 0;
    S$2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S$2(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O$2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E$3;
  react_production_min.Fragment = p$3;
  react_production_min.Profiler = r$1;
  react_production_min.PureComponent = G$2;
  react_production_min.StrictMode = q$2;
  react_production_min.Suspense = w$1;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
  react_production_min.act = X$2;
  react_production_min.cloneElement = function(a2, b2, e) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C$1({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b2) J.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l$2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t$1, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M$2;
  react_production_min.createFactory = function(a2) {
    var b2 = M$2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v$2, render: a2 };
  };
  react_production_min.isValidElement = O$2;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y$1, _payload: { _status: -1, _result: a2 }, _init: T$2 };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x$1, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V$1.transition;
    V$1.transition = {};
    try {
      a2();
    } finally {
      V$1.transition = b2;
    }
  };
  react_production_min.unstable_act = X$2;
  react_production_min.useCallback = function(a2, b2) {
    return U$2.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U$2.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U$2.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U$2.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U$2.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e) {
    return U$2.current.useImperativeHandle(a2, b2, e);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U$2.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U$2.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U$2.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e) {
    return U$2.current.useReducer(a2, b2, e);
  };
  react_production_min.useRef = function(a2) {
    return U$2.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U$2.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e) {
    return U$2.current.useSyncExternalStore(a2, b2, e);
  };
  react_production_min.useTransition = function() {
    return U$2.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  {
    react.exports = react_production_min;
  }
  var reactExports = react.exports;
  const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$1 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
  function q$1(c2, a2, g2) {
    var b2, d2 = {}, e = null, h2 = null;
    void 0 !== g2 && (e = "" + g2);
    void 0 !== a2.key && (e = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m$2.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k$1, type: c2, key: e, ref: h2, props: d2, _owner: n$1.current };
  }
  reactJsxRuntime_production_min.Fragment = l$1;
  reactJsxRuntime_production_min.jsx = q$1;
  reactJsxRuntime_production_min.jsxs = q$1;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var reactDom = { exports: {} };
  var reactDom_production_min = {};
  var scheduler = { exports: {} };
  var scheduler_production_min = {};
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  (function(exports$1) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a: for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e = a2[d2];
        if (0 < g2(e, b2)) a2[d2] = b2, a2[c2] = e, c2 = d2;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a: for (var d2 = 0, e = a2.length, w2 = e >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2)) n2 < e && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else break a;
        }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports$1.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q2 = p2.now();
      exports$1.unstable_now = function() {
        return p2.now() - q2;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B2 = false;
      G2(a2);
      if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
    }
    function J2(a2, b2) {
      A2 = false;
      B2 && (B2 = false, E2(L2), L2 = -1);
      z2 = true;
      var c2 = y2;
      try {
        G2(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e = d2(v2.expirationTime <= b2);
            b2 = exports$1.unstable_now();
            "function" === typeof e ? v2.callback = e : v2 === h2(r2) && k2(r2);
            G2(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K2(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z2 = false;
      }
    }
    var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return exports$1.unstable_now() - Q2 < P2 ? false : true;
    }
    function R2() {
      if (null !== O2) {
        var a2 = exports$1.unstable_now();
        Q2 = a2;
        var b2 = true;
        try {
          b2 = O2(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O2 = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F2) S2 = function() {
      F2(R2);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2;
      S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a2) {
      O2 = a2;
      N2 || (N2 = true, S2());
    }
    function K2(a2, b2) {
      L2 = D2(function() {
        a2(exports$1.unstable_now());
      }, b2);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports$1.unstable_continueExecution = function() {
      A2 || z2 || (A2 = true, I2(J2));
    };
    exports$1.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports$1.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports$1.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports$1.unstable_pauseExecution = function() {
    };
    exports$1.unstable_requestPaint = function() {
    };
    exports$1.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports$1.unstable_scheduleCallback = function(a2, b2, c2) {
      var d2 = exports$1.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a2) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c2 + e;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e, sortIndex: -1 };
      c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
      return a2;
    };
    exports$1.unstable_shouldYield = M2;
    exports$1.unstable_wrapCallback = function(a2) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  {
    scheduler.exports = scheduler_production_min;
  }
  var schedulerExports = scheduler.exports;
  /**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var aa = reactExports, ca = schedulerExports;
  function p$1(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b2) {
    ha(a2, b2);
    ha(a2 + "Capture", b2);
  }
  function ha(a2, b2) {
    ea[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
    if (d2) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v$1(a2, b2, c2, d2, e, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z$1 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z$1[a2] = new v$1(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z$1[b2] = new v$1(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z$1[a2] = new v$1(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra,
      sa
    );
    z$1[b2] = new v$1(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z$1[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z$1[b2] = new v$1(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z$1[a2] = new v$1(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b2, c2, d2) {
    var e = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
    if (null !== e ? 0 !== e.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e, d2) && (c2 = null), d2 || null === e ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e.mustUseProperty ? a2[e.propertyName] = null === c2 ? 3 === e.type ? false : "" : c2 : (b2 = e.attributeName, d2 = e.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e = e.type, c2 = 3 === e || 4 === e && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A$1 = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b2) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e[g2] !== f2[h2]) {
                var k2 = "\n" + e[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a2) {
    var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b2 = a2._valueTracker;
    if (!b2) return true;
    var c2 = b2.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya(a2, b2) {
    var c2 = b2.checked;
    return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2) if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d2) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e = 0; e < c2.length; e++) b2["$" + c2[e]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e && (a2[c2].selected = e), e && d2 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e = 0; e < a2.length; e++) {
        if (a2[e].value === c2) {
          a2[e].selected = true;
          d2 && (a2[e].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e].disabled || (b2 = a2[e]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
    return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2) throw Error(p$1(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p$1(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d2, e);
      });
    } : a2;
  }(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e) : a2[c2] = e;
    }
  }
  var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p$1(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p$1(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib) return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d2 = Db(c2);
    if (null === d2) return null;
    c2 = d2[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p$1(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b2, c2, d2, e, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d2, e, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d2, e, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p$1(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p$1(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2) throw Error(p$1(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d2 = b2; ; ) {
      var e = c2.return;
      if (null === e) break;
      var f2 = e.alternate;
      if (null === f2) {
        d2 = e.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e.child === f2.child) {
        for (f2 = e.child; f2; ) {
          if (f2 === c2) return Xb(e), a2;
          if (f2 === d2) return Xb(e), b2;
          f2 = f2.sibling;
        }
        throw Error(p$1(188));
      }
      if (c2.return !== d2.return) c2 = e, d2 = f2;
      else {
        for (var g2 = false, h2 = e.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p$1(189));
        }
      }
      if (c2.alternate !== d2) throw Error(p$1(190));
    }
    if (3 !== c2.tag) throw Error(p$1(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2) return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d2 = 0, e = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else g2 = c2 & ~e, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2) return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e) && (e = d2 & -d2, f2 = b2 & -b2, e >= f2 || 16 === e && 0 !== (f2 & 4194240))) return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e = 1 << c2, d2 |= a2[c2], b2 &= ~e;
    return d2;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2)) e[g2] = vc(h2, b2);
      } else k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e = 31 - oc(c2), f2 = 1 << e;
      b2[e] = 0;
      d2[e] = -1;
      a2[e] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e = 1 << d2;
      e & b2 | a2[d2] & b2 && (a2[d2] |= b2);
      c2 &= ~e;
    }
  }
  var C = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d2, e, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d2;
    b2 = a2.targetContainers;
    null !== e && -1 === b2.indexOf(e) && b2.push(e);
    return a2;
  }
  function Uc(a2, b2, c2, d2, e) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d2, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d2, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d2, e), true;
      case "pointerover":
        var f2 = e.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e));
        return true;
      case "gotpointercapture":
        return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d2) {
    var e = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b2, c2, d2);
    } finally {
      C = e, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d2) {
    var e = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b2, c2, d2);
    } finally {
      C = e, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d2) {
    if (dd) {
      var e = Yc(a2, b2, c2, d2);
      if (null === e) hd(a2, b2, d2, id, c2), Sc(a2, d2);
      else if (Uc(e, a2, b2, c2, d2)) d2.stopPropagation();
      else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e; ) {
          var f2 = Cb(e);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d2);
          null === f2 && hd(a2, b2, d2, id, c2);
          if (f2 === e) break;
          e = f2;
        }
        null !== e && d2.stopPropagation();
      } else hd(a2, b2, d2, null, c2);
    }
  }
  var id = null;
  function Yc(a2, b2, c2, d2) {
    id = null;
    a2 = xb(d2);
    a2 = Wc(a2);
    if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else b2 !== a2 && (a2 = null);
    id = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b2 = ld, c2 = b2.length, d2, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e[a2]; a2++) ;
    var g2 = c2 - a2;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e[f2 - d2]; d2++) ;
    return md = e.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d2, e, f2, g2) {
      this._reactName = b3;
      this._targetInst = e;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A$1(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A$1({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie = false;
  function je(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a2 = b2.data, a2 === ee && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b2) {
    if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne(a2, b2, c2, d2) {
    Eb(d2);
    b2 = oe(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re(a2) {
    se(a2, 0);
  }
  function te(a2) {
    var b2 = ue(a2);
    if (Wa(b2)) return a2;
  }
  function ve(a2, b2) {
    if ("change" === a2) return b2;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a2, xb(a2));
      Jb(re, b2);
    }
  }
  function Ce(a2, b2, c2) {
    "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
  }
  function Ee(a2, b2) {
    if ("click" === a2) return te(b2);
  }
  function Fe(a2, b2) {
    if ("input" === a2 || "change" === a2) return te(b2);
  }
  function Ge(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b2) {
    if (He(a2, b2)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
    var c2 = Object.keys(a2), d2 = Object.keys(b2);
    if (c2.length !== d2.length) return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e = c2[d2];
      if (!ja.call(b2, e) || !He(a2[e], b2[e])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b2) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a2 + c2.textContent.length;
        if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
        a2 = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2) a2 = b2.contentWindow;
      else break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne(c2)) {
        if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e = c2.textContent.length, f2 = Math.min(d2.start, e);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e);
          !a2.extend && f2 > d2 && (e = d2, d2 = f2, f2 = e);
          e = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d2
          );
          e && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e.node || a2.anchorOffset !== e.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e.node, e.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b2 = We[a2], c2;
    for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df.set(a2, b2);
    fa(b2, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b2, c2) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d2, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2], e = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D$1(a2, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
  }
  function qf(a2, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a2, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a2, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c2 = e.bind(null, b2, c2, a2);
    e = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e = true);
    d2 ? void 0 !== e ? a2.addEventListener(b2, c2, { capture: true, passive: e }) : a2.addEventListener(b2, c2, true) : void 0 !== e ? a2.addEventListener(b2, c2, { passive: e }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d2, e) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e || 8 === h2.nodeType && h2.parentNode === e) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e2 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F2 = u2.stateNode;
            5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
            if (J2) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e2), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h3) {
            h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F2 = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J2 = null == k3 ? h3 : ue(k3);
              u2 = null == n2 ? h3 : ue(n2);
              h3 = new t2(F2, w2 + "leave", k3, c2, e2);
              h3.target = J2;
              h3.relatedTarget = u2;
              F2 = null;
              Wc(e2) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
              J2 = F2;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a2, d3))) {
            ne(g3, na, c2, e2);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e2);
        }
        var $a;
        if (ae) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e2), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c2, e2), g3.push({ event: e2, listeners: d3 }), e2.data = $a);
      }
      se(g3, b2);
    });
  }
  function tf(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe(a2, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
      var e = a2, f2 = e.stateNode;
      5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b2, c2, d2, e) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2) throw Error(p$1(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e = c2.nextSibling;
      a2.removeChild(c2);
      if (e && 8 === e.nodeType) if (c2 = e.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e);
          bd(b2);
          return;
        }
        d2--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2) return a2;
          b2--;
        } else "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b2 = a2[Of];
    if (b2) return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p$1(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E$2(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G$1(a2, b2) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H$1 = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f2;
    for (f2 in c2) e[f2] = b2[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E$2(Wf);
    E$2(H$1);
  }
  function ag(a2, b2, c2) {
    if (H$1.current !== Vf) throw Error(p$1(168));
    G$1(H$1, b2);
    G$1(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d2 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c2;
    d2 = d2.getChildContext();
    for (var e in d2) if (!(e in b2)) throw Error(p$1(108, Ra(a2) || "Unknown", e));
    return A$1({}, c2, d2);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H$1.current;
    G$1(H$1, a2);
    G$1(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d2 = a2.stateNode;
    if (!d2) throw Error(p$1(169));
    c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$1), G$1(H$1, a2)) : E$2(Wf);
    G$1(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C;
      try {
        var c2 = eg;
        for (C = 1; a2 < c2.length; a2++) {
          var d2 = c2[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d2 = rg;
    a2 = sg;
    var e = 32 - oc(d2) - 1;
    d2 &= ~(1 << e);
    c2 += 1;
    var f2 = 32 - oc(b2) + e;
    if (30 < f2) {
      var g2 = e - e % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e -= g2;
      rg = 1 << 32 - oc(b2) + e | c2 << e | d2;
      sg = f2 + a2;
    } else rg = 1 << f2 | c2 << e | d2, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I$1 = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I$1) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2)) throw Error(p$1(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p$1(418));
        a2.flags = a2.flags & -4097 | 2;
        I$1 = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I$1) return Fg(a2), I$1 = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2)) throw Hg(), Error(p$1(418));
      for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p$1(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I$1 = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p$1(309));
          var d2 = c2.stateNode;
        }
        if (!d2) throw Error(p$1(147, a2));
        var e = d2, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a3) {
          var b3 = e.refs;
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2) throw Error(p$1(284));
      if (!c2._owner) throw Error(p$1(290, a2));
    }
    return a2;
  }
  function Mg(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p$1(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function Og(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a2) return null;
      for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e(a3, b3) {
      a3 = Pg(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a2) return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
      d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
      d3.ref = Lg(a3, b3, c3);
      d3.return = a3;
      return d3;
    }
    function l2(a3, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m2(a3, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
      b3 = e(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q2(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
          case wa:
            return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha:
            var d3 = b3._init;
            return q2(a3, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
        Mg(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d3) {
      var e2 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e2 ? null : h2(a3, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e2 ? k2(a3, b3, c3, d3) : null;
          case wa:
            return c3.key === e2 ? l2(a3, b3, c3, d3) : null;
          case Ha:
            return e2 = c3._init, r2(
              a3,
              b3,
              e2(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e2 ? null : m2(a3, b3, c3, d3, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y2(a3, b3, c3, d3, e2) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e2);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e2);
          case wa:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e2);
          case Ha:
            var f3 = d3._init;
            return y2(a3, b3, c3, f3(d3._payload), e2);
        }
        if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e2, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e2, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e2, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n3.alternate && b2(e2, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length) return c2(e2, u2), I$1 && tg(e2, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q2(e2, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I$1 && tg(e2, w2);
        return l3;
      }
      for (u2 = d2(e2, u2); w2 < h3.length; w2++) x2 = y2(u2, e2, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e2, a3);
      });
      I$1 && tg(e2, w2);
      return l3;
    }
    function t2(e2, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3) throw Error(p$1(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p$1(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e2, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t3.alternate && b2(e2, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c2(
        e2,
        m3
      ), I$1 && tg(e2, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e2, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I$1 && tg(e2, w2);
        return l3;
      }
      for (m3 = d2(e2, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b2(e2, a3);
      });
      I$1 && tg(e2, w2);
      return l3;
    }
    function J2(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d3 = e(l3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d3 = e(l3, f3.props);
                    d3.ref = Lg(a3, l3, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
                else b2(a3, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha:
            return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
        }
        if (eb(f3)) return n2(a3, d3, f3, h3);
        if (Ka(f3)) return t2(a3, d3, f3, h3);
        Mg(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
    }
    return J2;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b2 = Wg.current;
    E$2(Wg);
    a2._currentValue = b2;
  }
  function bh(a2, b2, c2) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b2) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b2 = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg) throw Error(p$1(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b2;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b2, c2, d2) {
    var e = b2.interleaved;
    null === e ? (c2.next = c2, gh(b2)) : (c2.next = e.next, e.next = c2);
    b2.interleaved = c2;
    return ih(a2, d2);
  }
  function ih(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b2, c2) {
    var d2 = a2.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e = d2.pending;
      null === e ? b2.next = b2 : (b2.next = e.next, e.next = b2);
      d2.pending = b2;
      return ih(a2, c2);
    }
    e = d2.interleaved;
    null === e ? (b2.next = b2, gh(d2)) : (b2.next = e.next, e.next = b2);
    d2.interleaved = b2;
    return ih(a2, c2);
  }
  function oh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b2) {
    var c2 = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e = f2 = b2 : f2 = f2.next = b2;
      } else e = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a2, b2, c2, d2) {
    var e = a2.updateQueue;
    jh = false;
    var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h2 = e.shared.pending;
    if (null !== h2) {
      e.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q2 = e.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q2 = n2.call(y2, q2, r2);
                  break a;
                }
                q2 = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q2 = A$1({}, q2, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q2);
      e.baseState = k2;
      e.firstBaseUpdate = l2;
      e.lastBaseUpdate = m2;
      b2 = e.shared.interleaved;
      if (null !== b2) {
        e = b2;
        do
          g2 |= e.lane, e = e.next;
        while (e !== b2);
      } else null === f2 && (e.shared.lanes = 0);
      rh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q2;
    }
  }
  function sh(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e = d2.callback;
      if (null !== e) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e) throw Error(p$1(191, e));
        e.call(d2);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th) throw Error(p$1(174));
    return a2;
  }
  function yh(a2, b2) {
    G$1(wh, b2);
    G$1(vh, a2);
    G$1(uh, th);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E$2(uh);
    G$1(uh, b2);
  }
  function zh$1() {
    E$2(uh);
    E$2(vh);
    E$2(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G$1(vh, a2), G$1(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E$2(uh), E$2(vh));
  }
  var L$1 = Uf(0);
  function Ch(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$1 = null, N$1 = null, O$1 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P$1() {
    throw Error(p$1(321));
  }
  function Mh(a2, b2) {
    if (null === b2) return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
    return true;
  }
  function Nh(a2, b2, c2, d2, e, f2) {
    Hh = f2;
    M$1 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d2, e);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p$1(301));
        f2 += 1;
        O$1 = N$1 = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d2, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N$1 && null !== N$1.next;
    Hh = 0;
    O$1 = N$1 = M$1 = null;
    Ih = false;
    if (b2) throw Error(p$1(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
    return O$1;
  }
  function Uh() {
    if (null === N$1) {
      var a2 = M$1.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N$1.next;
    var b2 = null === O$1 ? M$1.memoizedState : O$1.next;
    if (null !== b2) O$1 = b2, N$1 = a2;
    else {
      if (null === a2) throw Error(p$1(310));
      N$1 = a2;
      a2 = { memoizedState: N$1.memoizedState, baseState: N$1.baseState, baseQueue: N$1.baseQueue, queue: N$1.queue, next: null };
      null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
    }
    return O$1;
  }
  function Vh(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Wh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p$1(311));
    c2.lastRenderedReducer = a2;
    var d2 = N$1, e = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e) {
        var g2 = e.next;
        e.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e = f2;
      c2.pending = null;
    }
    if (null !== e) {
      f2 = e.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
          M$1.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e = a2;
      do
        f2 = e.lane, M$1.lanes |= f2, rh |= f2, e = e.next;
      while (e !== a2);
    } else null === e && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p$1(311));
    c2.lastRenderedReducer = a2;
    var d2 = c2.dispatch, e = c2.pending, f2 = b2.memoizedState;
    if (null !== e) {
      c2.pending = null;
      var g2 = e = e.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a2, b2) {
    var c2 = M$1, d2 = Uh(), e = b2(), f2 = !He(d2.memoizedState, e);
    f2 && (d2.memoizedState = e, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c2, d2, a2), [a2]);
    if (d2.getSnapshot !== b2 || f2 || null !== O$1 && O$1.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d2, e, b2), void 0, null);
      if (null === Q$1) throw Error(p$1(349));
      0 !== (Hh & 30) || di(c2, b2, e);
    }
    return e;
  }
  function di(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = M$1.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    ei(b2) && fi(a2);
  }
  function ai(a2, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a2);
    });
  }
  function ei(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He(a2, c2);
    } catch (d2) {
      return true;
    }
  }
  function fi(a2) {
    var b2 = ih(a2, 1);
    null !== b2 && gi(b2, a2, 1, -1);
  }
  function hi(a2) {
    var b2 = Th();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M$1, a2);
    return [b2.memoizedState, a2];
  }
  function bi(a2, b2, c2, d2) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
    b2 = M$1.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b2, c2, d2) {
    var e = Th();
    M$1.flags |= a2;
    e.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function li(a2, b2, c2, d2) {
    var e = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N$1) {
      var g2 = N$1.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e.memoizedState = bi(b2, c2, f2, d2);
        return;
      }
    }
    M$1.flags |= a2;
    e.memoizedState = bi(1 | b2, c2, f2, d2);
  }
  function mi(a2, b2) {
    return ki(8390656, 8, a2, b2);
  }
  function $h(a2, b2) {
    return li(2048, 8, a2, b2);
  }
  function ni(a2, b2) {
    return li(4, 2, a2, b2);
  }
  function oi(a2, b2) {
    return li(4, 4, a2, b2);
  }
  function pi(a2, b2) {
    if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
  }
  function qi(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b2, a2), c2);
  }
  function ri() {
  }
  function si(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ti(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ui(a2, b2, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), M$1.lanes |= c2, rh |= c2, a2.baseState = true);
    return b2;
  }
  function vi(a2, b2) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C = c2, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b2, c2) {
    var d2 = yi(a2);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, c2);
    else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
      var e = R$1();
      gi(c2, a2, d2, e);
      Bi(c2, b2, d2);
    }
  }
  function ii(a2, b2, c2) {
    var d2 = yi(a2), e = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, e);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e.next = e, gh(b2)) : (e.next = k2.next, k2.next = e);
          b2.interleaved = e;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = hh(a2, b2, e, d2);
      null !== c2 && (e = R$1(), gi(c2, a2, d2, e), Bi(c2, b2, d2));
    }
  }
  function zi(a2) {
    var b2 = a2.alternate;
    return a2 === M$1 || null !== b2 && b2 === M$1;
  }
  function Ai(a2, b2) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Bi(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
    Th().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ki(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ki(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d2 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d2.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M$1, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = Th();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b2 = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d2 = M$1, e = Th();
    if (I$1) {
      if (void 0 === c2) throw Error(p$1(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q$1) throw Error(p$1(349));
      0 !== (Hh & 30) || di(d2, b2, c2);
    }
    e.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b2 = Q$1.identifierPrefix;
    if (I$1) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b2 = Uh();
      return ui(b2, N$1.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a2, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b2 = Uh();
    return null === N$1 ? b2.memoizedState = a2 : ui(b2, N$1.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A$1({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Di(a2, b2, c2, d2) {
    b2 = a2.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R$1(), e = yi(a2), f2 = mh(d2, e);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e);
    null !== b2 && (gi(b2, a2, e, d2), oh(b2, a2, e));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R$1(), e = yi(a2), f2 = mh(d2, e);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e);
    null !== b2 && (gi(b2, a2, e, d2), oh(b2, a2, e));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = R$1(), d2 = yi(a2), e = mh(c2, d2);
    e.tag = 2;
    void 0 !== b2 && null !== b2 && (e.callback = b2);
    b2 = nh(a2, e, d2);
    null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
  } };
  function Fi(a2, b2, c2, d2, e, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e, f2) : true;
  }
  function Gi(a2, b2, c2) {
    var d2 = false, e = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e = Zf(b2) ? Xf : H$1.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a2, b2, c2, d2) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a2, b2, c2, d2) {
    var e = a2.stateNode;
    e.props = c2;
    e.state = a2.memoizedState;
    e.refs = {};
    kh(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e.context = eh(f2) : (f2 = Zf(b2) ? Xf : H$1.current, e.context = Yf(a2, f2));
    e.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a2, b2, f2, c2), e.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b2 = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b2 !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a2, c2, e, d2), e.state = a2.memoizedState);
    "function" === typeof e.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e = c2;
    } catch (f2) {
      e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e, digest: null };
  }
  function Ki(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a2, b2);
    };
    return c2;
  }
  function Qi(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e = b2.value;
      c2.payload = function() {
        return d2(e);
      };
      c2.callback = function() {
        Li(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li(a2, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b2, c2) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d2.set(b2, e);
    } else e = d2.get(b2), void 0 === e && (e = /* @__PURE__ */ new Set(), d2.set(b2, e));
    e.has(c2) || (e.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b2, c2, d2, e) {
    if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e;
    return a2;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a2, b2, c2, d2) {
    b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
  }
  function Yi(a2, b2, c2, d2, e) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e);
    d2 = Nh(a2, b2, c2, d2, f2, e);
    c2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e, Zi(a2, b2, e);
    I$1 && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, d2, e);
    return b2.child;
  }
  function $i(a2, b2, c2, d2, e) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e);
      a2 = Rg(c2.type, null, d2, b2, b2.mode, e);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e);
    }
    b2.flags |= 1;
    a2 = Pg(f2, d2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function bj(a2, b2, c2, d2, e) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b2.lanes = a2.lanes, Zi(a2, b2, e);
    }
    return cj(a2, b2, c2, d2, e);
  }
  function dj(a2, b2, c2) {
    var d2 = b2.pendingProps, e = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(ej, fj), fj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(ej, fj);
      fj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(ej, fj), fj |= d2;
    Xi(a2, b2, e, c2);
    return b2.child;
  }
  function gj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a2, b2, c2, d2, e) {
    var f2 = Zf(c2) ? Xf : H$1.current;
    f2 = Yf(b2, f2);
    ch(b2, e);
    c2 = Nh(a2, b2, c2, d2, f2, e);
    d2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e, Zi(a2, b2, e);
    I$1 && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, c2, e);
    return b2.child;
  }
  function hj(a2, b2, c2, d2, e) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    ch(b2, e);
    if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e), d2 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H$1.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q2 = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$1.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e);
      var n2 = b2.memoizedState;
      h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a2, b2, c2, d2, f2, e);
  }
  function jj(a2, b2, c2, d2, e, f2) {
    gj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2) return e && dg(b2, c2, false), Zi(a2, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
    b2.memoizedState = d2.state;
    e && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    yh(a2, b2.containerInfo);
  }
  function lj(a2, b2, c2, d2, e) {
    Ig();
    Jg(e);
    b2.flags |= 256;
    Xi(a2, b2, c2, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b2, c2) {
    var d2 = b2.pendingProps, e = L$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e |= 1;
    G$1(L$1, e & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
    }
    e = a2.memoizedState;
    if (null !== e && (h2 = e.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e = a2.child;
      h2 = e.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e, k2), d2.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a2, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function sj(a2, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a2.child, null, c2);
    a2 = qj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function rj(a2, b2, c2, d2, e, f2, g2) {
    if (c2) {
      if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$1(422))), sj(a2, b2, g2, d2);
      if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e, 0, null);
      f2 = Tg(f2, e, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
    if ("$!" === e.data) {
      d2 = e.nextSibling && e.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p$1(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a2, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh || h2) {
      d2 = Q$1;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d2.suspendedLanes | g2)) ? 0 : e;
        0 !== e && e !== f2.retryLane && (f2.retryLane = e, ih(a2, e), gi(d2, a2, e, -1));
      }
      tj();
      d2 = Ki(Error(p$1(421)));
      return sj(a2, b2, g2, d2);
    }
    if ("$?" === e.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e.nextSibling);
    xg = b2;
    I$1 = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a2, b2, c2) {
    a2.lanes |= b2;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a2.return, b2, c2);
  }
  function wj(a2, b2, c2, d2, e) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e);
  }
  function xj(a2, b2, c2) {
    var d2 = b2.pendingProps, e = d2.revealOrder, f2 = d2.tail;
    Xi(a2, b2, d2.children, c2);
    d2 = L$1.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
        else if (19 === a2.tag) vj(a2, c2, b2);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b2) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b2) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d2 &= 1;
    }
    G$1(L$1, d2);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e) {
      case "forwards":
        c2 = b2.child;
        for (e = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e = c2), c2 = c2.sibling;
        c2 = e;
        null === c2 ? (e = b2.child, b2.child = null) : (e = c2.sibling, c2.sibling = null);
        wj(b2, false, e, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e = b2.child;
        for (b2.child = null; null !== e; ) {
          a2 = e.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b2.child = e;
            break;
          }
          a2 = e.sibling;
          e.sibling = c2;
          c2 = e;
          e = a2;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function ij(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes)) return null;
    if (null !== a2 && b2.child !== a2.child) throw Error(p$1(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Pg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e = b2.memoizedProps.value;
        G$1(Wg, d2._currentValue);
        d2._currentValue = e;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G$1(L$1, L$1.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
          G$1(L$1, L$1.current & 1);
          a2 = Zi(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G$1(L$1, L$1.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2) return xj(a2, b2, c2);
          b2.flags |= 128;
        }
        e = b2.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G$1(L$1, L$1.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a2, b2, c2);
    }
    return Zi(a2, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b2, c2, d2) {
    var e = a2.memoizedProps;
    if (e !== d2) {
      a2 = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e = Ya(a2, e);
          d2 = Ya(a2, d2);
          f2 = [];
          break;
        case "select":
          e = A$1({}, e, { value: void 0 });
          d2 = A$1({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e = gb(a2, e);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e) if (!d2.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2]) if ("style" === l2) {
        var h2 = e[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e ? e[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
        } else c2 || (f2 || (f2 = []), f2.push(
          l2,
          c2
        )), c2 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Cj = function(a2, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Dj(a2, b2) {
    if (!I$1) switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
  }
  function S$1(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
    if (b2) for (var e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d2 |= e.subtreeFlags & 14680064, d2 |= e.flags & 14680064, e.return = a2, e = e.sibling;
    else for (e = a2.child; null !== e; ) c2 |= e.lanes | e.childLanes, d2 |= e.subtreeFlags, d2 |= e.flags, e.return = a2, e = e.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c2;
    return b2;
  }
  function Ej(a2, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S$1(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S$1(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh$1();
        E$2(Wf);
        E$2(H$1);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b2);
        S$1(b2);
        return null;
      case 5:
        Bh(b2);
        var e = xh(wh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode) throw Error(p$1(166));
            S$1(b2);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D$1("cancel", d2);
                D$1("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", d2);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D$1(lf[e], d2);
                break;
              case "source":
                D$1("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  d2
                );
                D$1("load", d2);
                break;
              case "details":
                D$1("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D$1("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D$1("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D$1("invalid", d2);
            }
            ub(c2, f2);
            e = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
            }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of] = b2;
            a2[Pf] = d2;
            zj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D$1("cancel", a2);
                  D$1("close", a2);
                  e = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D$1("load", a2);
                  e = d2;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D$1(lf[e], a2);
                  e = d2;
                  break;
                case "source":
                  D$1("error", a2);
                  e = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D$1(
                    "error",
                    a2
                  );
                  D$1("load", a2);
                  e = d2;
                  break;
                case "details":
                  D$1("toggle", a2);
                  e = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e = Ya(a2, d2);
                  D$1("invalid", a2);
                  break;
                case "option":
                  e = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e = A$1({}, d2, { value: void 0 });
                  D$1("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e = gb(a2, d2);
                  D$1("invalid", a2);
                  break;
                default:
                  e = d2;
              }
              ub(c2, e);
              h2 = e;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S$1(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$1(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S$1(b2);
        return null;
      case 13:
        E$2(L$1);
        d2 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p$1(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p$1(317));
              f2[Of] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S$1(b2);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L$1.current & 1) ? 0 === T$1 && (T$1 = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S$1(b2);
        return null;
      case 4:
        return zh$1(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
      case 10:
        return ah(b2.type._context), S$1(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S$1(b2), null;
      case 19:
        E$2(L$1);
        f2 = b2.memoizedState;
        if (null === f2) return S$1(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Dj(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
            g2 = Ch(a2);
            if (null !== g2) {
              b2.flags |= 128;
              Dj(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d2 = c2;
              for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G$1(L$1, L$1.current & 1 | 2);
              return b2.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B$1() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d2) if (a2 = Ch(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1) return S$1(b2), null;
          } else 2 * B$1() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c2 = L$1.current, G$1(L$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S$1(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p$1(156, b2.tag));
  }
  function Ij(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return zh$1(), E$2(Wf), E$2(H$1), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E$2(L$1);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate) throw Error(p$1(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E$2(L$1), null;
      case 4:
        return zh$1(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U$1 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d2) {
      W$1(a2, b2, d2);
    }
    else c2.current = null;
  }
  function Mj(a2, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W$1(a2, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a2, b2) {
    Cf = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q2 !== c2 || 0 !== e && 3 !== q2.nodeType || (h2 = g2 + e);
              q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
              3 === q2.nodeType && (g2 += q2.nodeValue.length);
              if (null === (y2 = q2.firstChild)) break;
              r2 = q2;
              q2 = y2;
            }
            for (; ; ) {
              if (q2 === a2) break b;
              r2 === c2 && ++l2 === e && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q2.nextSibling)) break;
              q2 = r2;
              r2 = q2.parentNode;
            }
            q2 = y2;
          }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V = b2; null !== V; ) if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V = a2;
    else for (; null !== V; ) {
      b2 = V;
      try {
        var n2 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p$1(163));
        }
      } catch (F2) {
        W$1(b2, b2.return, F2);
      }
      a2 = b2.sibling;
      if (null !== a2) {
        a2.return = b2.return;
        V = a2;
        break;
      }
      V = b2.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e = d2 = d2.next;
      do {
        if ((e.tag & a2) === a2) {
          var f2 = e.destroy;
          e.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e = e.next;
      } while (e !== d2);
    }
  }
  function Qj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Sj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Sj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
  }
  function Wj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
  }
  var X$1 = null, Xj = false;
  function Yj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
  }
  function Zj(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
    switch (c2.tag) {
      case 5:
        U$1 || Lj(c2, b2);
      case 6:
        var d2 = X$1, e = Xj;
        X$1 = null;
        Yj(a2, b2, c2);
        X$1 = d2;
        Xj = e;
        null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
        break;
      case 4:
        d2 = X$1;
        e = Xj;
        X$1 = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b2, c2);
        X$1 = d2;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e = d2 = d2.next;
          do {
            var f2 = e, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e = e.next;
          } while (e !== d2);
        }
        Yj(a2, b2, c2);
        break;
      case 1:
        if (!U$1 && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
        Yj(a2, b2, c2);
        break;
      case 21:
        Yj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Yj(a2, b2, c2), U$1 = d2) : Yj(a2, b2, c2);
        break;
      default:
        Yj(a2, b2, c2);
    }
  }
  function ak(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
      var e = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X$1 = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X$1 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X$1 = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X$1) throw Error(p$1(160));
        Zj(f2, g2, e);
        X$1 = null;
        Xj = false;
        var k2 = e.alternate;
        null !== k2 && (k2.return = null);
        e.return = null;
      } catch (l2) {
        W$1(e, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
  }
  function dk(a2, b2) {
    var c2 = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e = a2.stateNode;
          try {
            ob(e, "");
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        if (d2 & 4 && (e = a2.stateNode, null != e)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e, f2);
                break;
              case "textarea":
                ib(e, f2);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          if (null === a2.stateNode) throw Error(p$1(162));
          e = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e.nodeValue = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b2, a2);
        ek(a2);
        break;
      case 13:
        ck(b2, a2);
        ek(a2);
        e = a2.child;
        e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B$1()));
        d2 & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, ck(b2, a2), U$1 = l2) : ck(b2, a2);
        ek(a2);
        if (d2 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t2) {
                W$1(a2, a2.return, t2);
              }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2) break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2) break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b2, a2);
        ek(a2);
        d2 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p$1(160));
        }
        switch (d2.tag) {
          case 5:
            var e = d2.stateNode;
            d2.flags & 32 && (ob(e, ""), d2.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p$1(161));
        }
      } catch (k2) {
        W$1(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b2, c2) {
    V = a2;
    ik(a2);
  }
  function ik(a2, b2, c2) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
      var e = V, f2 = e.child;
      if (22 === e.tag && d2) {
        var g2 = null !== e.memoizedState || Jj;
        if (!g2) {
          var h2 = e.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
          h2 = Jj;
          var l2 = U$1;
          Jj = g2;
          if ((U$1 = k2) && !l2) for (V = e; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e) : null !== k2 ? (k2.return = g2, V = k2) : jk(e);
          for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
          V = e;
          Jj = h2;
          U$1 = l2;
        }
        kk(a2);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1) if (null === c2) d2.componentDidMount();
              else {
                var e = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                d2.componentDidUpdate(e, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c2 = b2.child.stateNode;
                    break;
                  case 1:
                    c2 = b2.child.stateNode;
                }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
          U$1 || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W$1(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function gk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      if (b2 === a2) {
        V = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function jk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W$1(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W$1(b2, e, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W$1(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W$1(b2, g2, k2);
            }
        }
      } catch (k2) {
        W$1(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V = h2;
        break;
      }
      V = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q$1 = null, Y = null, Z$1 = 0, fj = 0, ej = Uf(0), T$1 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R$1() {
    return 0 !== (K & 6) ? B$1() : -1 !== Ak ? Ak : Ak = B$1();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z$1) return Z$1 & -Z$1;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b2, c2, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
    Ac(a2, c2, d2);
    if (0 === (K & 2) || a2 !== Q$1) a2 === Q$1 && (0 === (K & 2) && (qk |= c2), 4 === T$1 && Ck(a2, Z$1)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B$1() + 500, fg && jg());
  }
  function Dk(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d2 = uc(a2, a2 === Q$1 ? Z$1 : 0);
    if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p$1(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d2 = uc(a2, a2 === Q$1 ? Z$1 : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
    else {
      b2 = d2;
      var e = K;
      K |= 2;
      var f2 = Jk();
      if (Q$1 !== a2 || Z$1 !== b2) uk = null, Gj = B$1() + 500, Kk(a2, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e;
      null !== Y ? b2 = 0 : (Q$1 = null, Z$1 = 0, b2 = T$1);
    }
    if (0 !== b2) {
      2 === b2 && (e = xc(a2), 0 !== e && (d2 = e, b2 = Nk(a2, e)));
      if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B$1()), c2;
      if (6 === b2) Ck(a2, d2);
      else {
        e = a2.current.alternate;
        if (0 === (d2 & 30) && !Ok(e) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B$1()), c2;
        a2.finishedWork = e;
        a2.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p$1(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B$1(), 10 < b2)) {
              if (0 !== uc(a2, 0)) break;
              e = a2.suspendedLanes;
              if ((e & d2) !== d2) {
                R$1();
                a2.pingedLanes |= a2.suspendedLanes & e;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d2);
            if ((d2 & 4194240) === d2) break;
            b2 = a2.eventTimes;
            for (e = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e && (e = g2);
              d2 &= ~f2;
            }
            d2 = e;
            d2 = B$1() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p$1(329));
        }
      }
    }
    Dk(a2, B$1());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b2) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
    a2 = Ik(a2, b2);
    2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
          var e = c2[d2], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f2(), e)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
      else {
        if (b2 === a2) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a2) {
    if (0 !== (K & 6)) throw Error(p$1(327));
    Hk();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1)) return Dk(a2, B$1()), null;
    var c2 = Ik(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d2 = xc(a2);
      0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B$1()), c2;
    if (6 === c2) throw Error(p$1(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Pk(a2, tk, uk);
    Dk(a2, B$1());
    return null;
  }
  function Qk(a2, b2) {
    var c2 = K;
    K |= 1;
    try {
      return a2(b2);
    } finally {
      K = c2, 0 === K && (Gj = B$1() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b2 = K;
    K |= 1;
    var c2 = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a2) return a2();
    } finally {
      C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E$2(ej);
  }
  function Kk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y) for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh$1();
          E$2(Wf);
          E$2(H$1);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh$1();
          break;
        case 13:
          E$2(L$1);
          break;
        case 19:
          E$2(L$1);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q$1 = a2;
    Y = a2 = Pg(a2.current, null);
    Z$1 = fj = b2;
    T$1 = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e;
          d2.next = g2;
        }
        c2.pending = d2;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b2) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M$1.memoizedState; null !== d2; ) {
            var e = d2.queue;
            null !== e && (e.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O$1 = N$1 = M$1 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T$1 = 1;
          pk = b2;
          Y = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z$1;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p$1(426));
            }
          } else if (I$1 && h2.mode & 1) {
            var J2 = Ui(g2);
            if (null !== J2) {
              0 === (J2.flags & 65536) && (J2.flags |= 256);
              Vi(J2, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T$1 && (T$1 = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F2 = Qi(f2, h2, b2);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na) {
        b2 = na;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T$1 || 3 === T$1 || 2 === T$1) T$1 = 4;
    null === Q$1 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$1, Z$1);
  }
  function Ik(a2, b2) {
    var c2 = K;
    K |= 2;
    var d2 = Jk();
    if (Q$1 !== a2 || Z$1 !== b2) uk = null, Kk(a2, b2);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a2, e);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d2;
    if (null !== Y) throw Error(p$1(261));
    Q$1 = null;
    Z$1 = 0;
    return T$1;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a2) {
    var b2 = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Sk(a2) : Y = b2;
    nk.current = null;
  }
  function Sk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T$1 = 6;
          Y = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y = b2;
        return;
      }
      Y = b2 = a2;
    } while (null !== b2);
    0 === T$1 && (T$1 = 5);
  }
  function Pk(a2, b2, c2) {
    var d2 = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
    } finally {
      ok.transition = e, C = d2;
    }
    return null;
  }
  function Wk(a2, b2, c2, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p$1(327));
    c2 = a2.finishedWork;
    var e = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p$1(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === Q$1 && (Y = Q$1 = null, Z$1 = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K = h2;
      C = g2;
      ok.transition = f2;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B$1());
    if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e = b2[c2], d2(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b2 = ok.transition, c2 = C;
      try {
        ok.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === wk) var d2 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p$1(331));
          var e = K;
          K |= 4;
          for (V = a2.current; null !== V; ) {
            var f2 = V, g2 = f2.child;
            if (0 !== (V.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (null !== q2) q2.return = m2, V = q2;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J2 = t2.sibling;
                      t2.sibling = null;
                      t2 = J2;
                    } while (null !== t2);
                  }
                }
                V = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
            else b: for (; null !== V; ) {
              f2 = V;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V = x2;
                break b;
              }
              V = f2.return;
            }
          }
          var w2 = a2.current;
          for (V = w2; null !== V; ) {
            g2 = V;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
            else b: for (g2 = w2; null !== V; ) {
              h2 = V;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W$1(h2, h2.return, na);
              }
              if (h2 === g2) {
                V = null;
                break b;
              }
              var F2 = h2.sibling;
              if (null !== F2) {
                F2.return = h2.return;
                V = F2;
                break b;
              }
              V = h2.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a2, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni(a2, b2, 1);
    a2 = nh(a2, b2, 1);
    b2 = R$1();
    null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
  }
  function W$1(a2, b2, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b2, a2, 1);
          b2 = nh(b2, a2, 1);
          a2 = R$1();
          null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ti(a2, b2, c2) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R$1();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q$1 === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b2);
  }
  function Yk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R$1();
    a2 = ih(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e = a2.memoizedState;
        null !== e && (c2 = e.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p$1(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b2, c2) {
    if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a2, b2);
        a2 = b2.pendingProps;
        var e = Yf(b2, H$1.current);
        ch(b2, c2);
        e = Nh(null, b2, d2, a2, e, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b2), e.updater = Ei, b2.stateNode = e, e._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Xi(null, b2, e, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a2, b2);
          a2 = b2.pendingProps;
          e = d2._init;
          d2 = e(d2._payload);
          b2.type = d2;
          e = b2.tag = Zk(d2);
          a2 = Ci(d2, a2);
          switch (e) {
            case 0:
              b2 = cj(null, b2, d2, a2, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a2, c2);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a2, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
              break a;
          }
          throw Error(p$1(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e = b2.pendingProps, e = b2.elementType === d2 ? e : Ci(d2, e), cj(a2, b2, d2, e, c2);
      case 1:
        return d2 = b2.type, e = b2.pendingProps, e = b2.elementType === d2 ? e : Ci(d2, e), hj(a2, b2, d2, e, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a2) throw Error(p$1(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e = f2.element;
          lh(a2, b2);
          qh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e = Ji(Error(p$1(423)), b2);
            b2 = lj(a2, b2, d2, c2, e);
            break a;
          } else if (d2 !== e) {
            e = Ji(Error(p$1(424)), b2);
            b2 = lj(a2, b2, d2, c2, e);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
            Xi(a2, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e.children, Ef(d2, e) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return oj(a2, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e = b2.pendingProps, e = b2.elementType === d2 ? e : Ci(d2, e), Yi(a2, b2, d2, e, c2);
      case 7:
        return Xi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e.value;
          G$1(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e.children && !Wf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c2 & -c2);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c2;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c2);
                  bh(
                    f2.return,
                    c2,
                    b2
                  );
                  h2.lanes |= c2;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p$1(341));
              g2.lanes |= c2;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c2);
              bh(g2, c2, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi(a2, b2, e.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e = eh(e), d2 = d2(e), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e = Ci(d2, b2.pendingProps), e = Ci(d2.type, e), $i(a2, b2, d2, e, c2);
      case 15:
        return bj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e = b2.pendingProps, e = b2.elementType === d2 ? e : Ci(d2, e), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e), Ii(b2, d2, e, c2), jj(null, b2, d2, true, a2, c2);
      case 19:
        return xj(a2, b2, c2);
      case 22:
        return dj(a2, b2, c2);
    }
    throw Error(p$1(156, b2.tag));
  };
  function Fk(a2, b2) {
    return ac(a2, b2);
  }
  function $k(a2, b2, c2, d2) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d2) {
    return new $k(a2, b2, c2, d2);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function Pg(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b2, c2, d2, e, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2) aj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya:
        return Tg(c2.children, e, f2, b2);
      case za:
        g2 = 8;
        e |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b2, e | 2), a2.elementType = Aa, a2.lanes = f2, a2;
      case Ea:
        return a2 = Bg(13, c2, b2, e), a2.elementType = Ea, a2.lanes = f2, a2;
      case Fa:
        return a2 = Bg(19, c2, b2, e), a2.elementType = Fa, a2.lanes = f2, a2;
      case Ia:
        return pj(c2, e, f2, b2);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p$1(130, null == a2 ? a2 : typeof a2, ""));
    }
    b2 = Bg(g2, c2, b2, e);
    b2.elementType = a2;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a2, b2, c2, d2) {
    a2 = Bg(7, a2, d2, b2);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b2, c2, d2) {
    a2 = Bg(22, a2, d2, b2);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function al(a2, b2, c2, d2, e) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b2, c2, d2, e, f2, g2, h2, k2) {
    a2 = new al(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl(a2, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p$1(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p$1(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b2);
    }
    return b2;
  }
  function el(a2, b2, c2, d2, e, f2, g2, h2, k2) {
    a2 = bl(c2, d2, true, a2, e, f2, g2, h2, k2);
    a2.context = dl(null);
    c2 = a2.current;
    d2 = R$1();
    e = yi(c2);
    f2 = mh(d2, e);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e);
    a2.current.lanes = e;
    Ac(a2, e, d2);
    Dk(a2, d2);
    return a2;
  }
  function fl(a2, b2, c2, d2) {
    var e = b2.current, f2 = R$1(), g2 = yi(e);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a2 = nh(e, b2, g2);
    null !== a2 && (gi(a2, e, g2, f2), oh(a2, e, g2));
    return g2;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a2, b2) {
    hl(a2, b2);
    (a2 = a2.alternate) && hl(a2, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p$1(409));
    fl(a2, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b2, c2, d2, e) {
    if (e) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = gl(g2);
          f2.call(a3);
        };
      }
      var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e = a2.lastChild; ) a2.removeChild(e);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = gl(k2);
        h2.call(a3);
      };
    }
    var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b2, k2, c2, d2);
    });
    return k2;
  }
  function rl(a2, b2, c2, d2, e) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e) {
        var h2 = e;
        e = function() {
          var a3 = gl(g2);
          h2.call(a3);
        };
      }
      fl(b2, g2, a2, e);
    } else g2 = ql(c2, b2, a2, e, d2);
    return gl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B$1()), 0 === (K & 6) && (Gj = B$1() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a2, 1);
          if (null !== b3) {
            var c3 = R$1();
            gi(b3, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = ih(a2, 134217728);
      if (null !== b2) {
        var c2 = R$1();
        gi(b2, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = yi(a2), c2 = ih(a2, b2);
      if (null !== c2) {
        var d2 = R$1();
        gi(c2, a2, b2, d2);
      }
      il(a2, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a2, b2) {
    var c2 = C;
    try {
      return C = a2, b2();
    } finally {
      C = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a2 && d2.form === a2.form) {
              var e = Db(d2);
              if (!e) throw Error(p$1(90));
              Wa(d2);
              bb(d2, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2)) throw Error(p$1(200));
    return cl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!nl(a2)) throw Error(p$1(299));
    var c2 = false, d2 = "", e = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e = b2.onRecoverableError));
    b2 = bl(a2, 1, false, null, null, c2, false, d2, e);
    a2[uf] = b2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render) throw Error(p$1(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p$1(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p$1(200));
    return rl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!nl(a2)) throw Error(p$1(405));
    var d2 = null != c2 && c2.hydratedSources || null, e = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e, false, f2, g2);
    a2[uf] = b2.current;
    sf(a2);
    if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e = c2._getVersion, e = e(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e] : b2.mutableSourceEagerHydrationData.push(
      c2,
      e
    );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p$1(200));
    return rl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p$1(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
    if (!ol(c2)) throw Error(p$1(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p$1(38));
    return rl(a2, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }
  var reactDomExports = reactDom.exports;
  var m$1 = reactDomExports;
  {
    client.createRoot = m$1.createRoot;
    client.hydrateRoot = m$1.hydrateRoot;
  }
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module, exports$1) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports$1 && !exports$1.nodeType && exports$1;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func2, thisArg, args) {
        switch (args.length) {
          case 0:
            return func2.call(thisArg);
          case 1:
            return func2.call(thisArg, args[0]);
          case 2:
            return func2.call(thisArg, args[0], args[1]);
          case 3:
            return func2.call(thisArg, args[0], args[1], args[2]);
        }
        return func2.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          var value = array[index2];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (!predicate(array[index2], index2, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (comparator(value, array[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset = array.length;
        while (++index2 < length) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index2 = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index2];
        }
        while (++index2 < length) {
          accumulator = iteratee(accumulator, array[index2], index2, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (comparator(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index2 = -1, length = array.length;
        while (++index2 < length) {
          var current = iteratee(array[index2]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func2) {
        return function(value) {
          return func2(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length = strSymbols.length;
        while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func2, transform) {
        return function(arg) {
          return func2(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index2 = -1, length = array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index2 = fromIndex - 1, length = array.length;
        while (++index2 < length) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index2 = string.length;
        while (index2-- && reWhitespace.test(string.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func2 = getNative(Object2, "defineProperty");
            func2({}, "", {});
            return func2;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined$1 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size3 = data.size;
          data.set(key, value);
          this.size += data.size == size3 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n2) {
          return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index2 < length) {
            result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func2, wait, args) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func2.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index2 = -1, length = array.length;
          while (++index2 < length) {
            var value = array[index2], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index2 = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length) {
            var value = array[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length && result2.length < maxLength) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func2 = object == null ? object : object[toKey(last(path))];
          return func2 == null ? undefined$1 : apply(func2, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n2) {
          var length = array.length;
          if (!length) {
            return;
          }
          n2 += n2 < 0 ? length : 0;
          return isIndex(n2, length) ? array[n2] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index2 = -1, length = paths.length, result2 = {};
          while (++index2 < length) {
            var path = paths[index2], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index2 < length) {
            var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index2 = indexes[length];
            if (length == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice.call(array, index2, 1);
              } else {
                baseUnset(array, index2);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n2) {
          var result2 = "";
          if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string += string;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func2, start) {
          return setToString(overRest(func2, start, identity), func2 + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n2, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index2 < length) {
            var key = toKey(path[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func2, data) {
          metaMap.set(func2, data);
          return func2;
        };
        var baseSetToString = !defineProperty ? identity : function(func2, string) {
          return defineProperty(func2, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index2 = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index2 < length) {
            result2[index2] = array[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index2 = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index2 = fromRight ? length : -1;
          while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length);
          while (++index2 < length) {
            var array = arrays[index2], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length) {
            var value = index2 < valsLength ? values2[index2] : undefined$1;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index2 = -1, length = source.length;
          array || (array = Array2(length));
          while (++index2 < length) {
            array[index2] = source[index2];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index2 = -1, length = props.length;
          while (++index2 < length) {
            var key = props[index2];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func2 = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func2(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index2 < length) {
              var source = sources[index2];
              if (source) {
                assigner(object, source, index2, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func2, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return fn2.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func2, bitmask, arity) {
          var Ctor = createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
            return apply(fn2, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func2 = funcs[index2];
              if (typeof func2 != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func2) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index2 = wrapper ? index2 : length;
            while (++index2 < length) {
              func2 = funcs[index2];
              var funcName = getFuncName(func2), data = funcName == "wrapper" ? getData(func2) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func2.length == 1 && isLaziable(func2) ? wrapper[funcName]() : wrapper.thru(func2);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
              while (++index3 < length) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func2, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func2);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index2 = length;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func2,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func2] : func2;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn2 = Ctor || createCtor(fn2);
            }
            return fn2.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func2, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func2);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func2;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn2, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber2(value);
              other = toNumber2(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func2, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= -4;
          }
          var newData = [
            func2,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func2)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func2, bitmask);
        }
        function createRound(methodName) {
          var func2 = Math2[methodName];
          return function(number, precision) {
            number = toNumber2(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func2(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func2(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func2, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= -97;
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func2);
          var newData = [
            func2,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func2 = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func2.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= -25;
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func2, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func2, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func2, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func2, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func2) {
          return setToString(overRest(func2, undefined$1, flatten), func2 + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func2) {
          return metaMap.get(func2);
        };
        function getFuncName(func2) {
          var result2 = func2.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func2) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func2) {
          var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func2;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length = transforms.length;
          while (++index2 < length) {
            var data = transforms[index2], size3 = data.size;
            switch (data.type) {
              case "drop":
                start += size3;
                break;
              case "dropRight":
                end -= size3;
                break;
              case "take":
                end = nativeMin(end, start + size3);
                break;
              case "takeRight":
                start = nativeMax(start, end - size3);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index2 = -1, length = path.length, result2 = false;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index2 != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index2, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index2;
          if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
            return eq(object[index2], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func2) {
          var funcName = getFuncName(func2), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func2 === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func2 === data[0];
        }
        function isMasked(func2) {
          return !!maskSrcKey && maskSrcKey in func2;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped(func2) {
          var result2 = memoize(func2, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func2, start, transform2) {
          start = nativeMax(start === undefined$1 ? func2.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index2 < length) {
              array[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array);
            return apply(func2, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index2 = indexes[length];
            array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func2, wait) {
          return root.setTimeout(func2, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func2) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func2.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size3) {
          var index2 = -1, length = array.length, lastIndex = length - 1;
          size3 = size3 === undefined$1 ? length : size3;
          while (++index2 < size3) {
            var rand = baseRandom(index2, lastIndex), value = array[rand];
            array[rand] = array[index2];
            array[index2] = value;
          }
          array.length = size3;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func2) {
          if (func2 != null) {
            try {
              return funcToString.call(func2);
            } catch (e) {
            }
            try {
              return func2 + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size3, guard) {
          if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
            size3 = 1;
          } else {
            size3 = nativeMax(toInteger(size3), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size3 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
          while (index2 < length) {
            result2[resIndex++] = baseSlice(array, index2, index2 += size3);
          }
          return result2;
        }
        function compact(array) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index2 < length) {
            var value = array[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index2 = length;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function dropRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length - 1;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length + index2, 0);
          }
          return baseIndexOf(array, value, index2);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index2 = length;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
        }
        function nth(array, n2) {
          return array && array.length ? baseNth(array, toInteger(n2)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index2) {
            return isIndex(index2, length) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value);
            if (index2 < length && eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index2 = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n2, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array, n2, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length - n2;
          return baseSlice(array, n2 < 0 ? 0 : n2, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index2) {
            return arrayMap(array, baseProperty(index2));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func2 = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEach : baseEach;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayEachRight : baseEachRight;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func2 = isArray(collection) ? arrayMap : baseMap;
          return func2(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func2 = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func2(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func2 = isArray(collection) ? arrayFilter : baseFilter;
          return func2(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func2 = isArray(collection) ? arraySample : baseSample;
          return func2(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func2 = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func2(collection, n2);
        }
        function shuffle(collection) {
          var func2 = isArray(collection) ? arrayShuffle : baseShuffle;
          return func2(collection);
        }
        function size2(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func2 = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func2(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func2) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func2.apply(this, arguments);
            }
          };
        }
        function ary(func2, n2, guard) {
          n2 = guard ? undefined$1 : n2;
          n2 = func2 && n2 == null ? func2.length : n2;
          return createWrap(func2, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
        }
        function before(n2, func2) {
          var result2;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func2.apply(this, arguments);
            }
            if (n2 <= 1) {
              func2 = undefined$1;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func2, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func2, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func2, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func2, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func2, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func2, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber2(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func2.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func2, args) {
          return baseDelay(func2, 1, args);
        });
        var delay = baseRest(function(func2, wait, args) {
          return baseDelay(func2, toNumber2(wait) || 0, args);
        });
        function flip(func2) {
          return createWrap(func2, WRAP_FLIP_FLAG);
        }
        function memoize(func2, resolver) {
          if (typeof func2 != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func2.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func2) {
          return before(2, func2);
        }
        var overArgs = castRest(function(func2, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length = nativeMin(args.length, funcsLength);
            while (++index2 < length) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func2, this, args);
          });
        });
        var partial = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func2, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func2, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func2, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func2, indexes) {
          return createWrap(func2, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func2, start);
        }
        function spread(func2, start) {
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func2, this, otherArgs);
          });
        }
        function throttle(func2, wait, options) {
          var leading = true, trailing = true;
          if (typeof func2 != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func2, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func2) {
          return ary(func2, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func2 = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func2(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber2(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber2(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index2 = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index2 < length) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index2 = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index2 < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index2])];
            if (value === undefined$1) {
              index2 = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set2(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
            return iteratee2(accumulator, value, index2, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber2(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber2(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber2(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber2(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n2, guard) {
          if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString(string), n2);
        }
        function replace2() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func2, args) {
          try {
            return apply(func2, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func2) {
          return baseIteratee(typeof func2 == "function" ? func2 : baseClone(func2, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func2 = source[methodName];
            object[methodName] = func2;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func2, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func2.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString(prefix) + id2;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set2;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update2;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size2;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber2;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func2, methodName) {
            if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
              source[methodName] = func2;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func2.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func2.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func2 = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func2.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func2.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func2, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  const _$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
  var numeral$1 = { exports: {} };
  /*! @preserve
   * numeral.js
   * version : 2.0.6
   * author : Adam Draper
   * license : MIT
   * http://adamwdraper.github.com/Numeral-js/
   */
  (function(module) {
    (function(global2, factory) {
      if (module.exports) {
        module.exports = factory();
      } else {
        global2.numeral = factory();
      }
    })(commonjsGlobal, function() {
      var numeral2, _2, VERSION = "2.0.6", formats = {}, locales = {}, defaults = {
        currentLocale: "en",
        zeroFormat: null,
        nullFormat: null,
        defaultFormat: "0,0",
        scalePercentBy100: true
      }, options = {
        currentLocale: defaults.currentLocale,
        zeroFormat: defaults.zeroFormat,
        nullFormat: defaults.nullFormat,
        defaultFormat: defaults.defaultFormat,
        scalePercentBy100: defaults.scalePercentBy100
      };
      function Numeral(input, number) {
        this._input = input;
        this._value = number;
      }
      numeral2 = function(input) {
        var value, kind, unformatFunction, regexp;
        if (numeral2.isNumeral(input)) {
          value = input.value();
        } else if (input === 0 || typeof input === "undefined") {
          value = 0;
        } else if (input === null || _2.isNaN(input)) {
          value = null;
        } else if (typeof input === "string") {
          if (options.zeroFormat && input === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            for (kind in formats) {
              regexp = typeof formats[kind].regexps.unformat === "function" ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;
              if (regexp && input.match(regexp)) {
                unformatFunction = formats[kind].unformat;
                break;
              }
            }
            unformatFunction = unformatFunction || numeral2._.stringToNumber;
            value = unformatFunction(input);
          }
        } else {
          value = Number(input) || null;
        }
        return new Numeral(input, value);
      };
      numeral2.version = VERSION;
      numeral2.isNumeral = function(obj) {
        return obj instanceof Numeral;
      };
      numeral2._ = _2 = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function(value, format, roundingFunction) {
          var locale2 = locales[numeral2.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = "", trillion = 1e12, billion = 1e9, million = 1e6, thousand = 1e3, decimal = "", neg = false, abbrForce, abs, int, precision, signed, thousands, output;
          value = value || 0;
          abs = Math.abs(value);
          if (numeral2._.includes(format, "(")) {
            negP = true;
            format = format.replace(/[\(|\)]/g, "");
          } else if (numeral2._.includes(format, "+") || numeral2._.includes(format, "-")) {
            signed = numeral2._.includes(format, "+") ? format.indexOf("+") : value < 0 ? format.indexOf("-") : -1;
            format = format.replace(/[\+|\-]/g, "");
          }
          if (numeral2._.includes(format, "a")) {
            abbrForce = format.match(/a(k|m|b|t)?/);
            abbrForce = abbrForce ? abbrForce[1] : false;
            if (numeral2._.includes(format, " a")) {
              abbr = " ";
            }
            format = format.replace(new RegExp(abbr + "a[kmbt]?"), "");
            if (abs >= trillion && !abbrForce || abbrForce === "t") {
              abbr += locale2.abbreviations.trillion;
              value = value / trillion;
            } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === "b") {
              abbr += locale2.abbreviations.billion;
              value = value / billion;
            } else if (abs < billion && abs >= million && !abbrForce || abbrForce === "m") {
              abbr += locale2.abbreviations.million;
              value = value / million;
            } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === "k") {
              abbr += locale2.abbreviations.thousand;
              value = value / thousand;
            }
          }
          if (numeral2._.includes(format, "[.]")) {
            optDec = true;
            format = format.replace("[.]", ".");
          }
          int = value.toString().split(".")[0];
          precision = format.split(".")[1];
          thousands = format.indexOf(",");
          leadingCount = (format.split(".")[0].split(",")[0].match(/0/g) || []).length;
          if (precision) {
            if (numeral2._.includes(precision, "[")) {
              precision = precision.replace("]", "");
              precision = precision.split("[");
              decimal = numeral2._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
            } else {
              decimal = numeral2._.toFixed(value, precision.length, roundingFunction);
            }
            int = decimal.split(".")[0];
            if (numeral2._.includes(decimal, ".")) {
              decimal = locale2.delimiters.decimal + decimal.split(".")[1];
            } else {
              decimal = "";
            }
            if (optDec && Number(decimal.slice(1)) === 0) {
              decimal = "";
            }
          } else {
            int = numeral2._.toFixed(value, 0, roundingFunction);
          }
          if (abbr && !abbrForce && Number(int) >= 1e3 && abbr !== locale2.abbreviations.trillion) {
            int = String(Number(int) / 1e3);
            switch (abbr) {
              case locale2.abbreviations.thousand:
                abbr = locale2.abbreviations.million;
                break;
              case locale2.abbreviations.million:
                abbr = locale2.abbreviations.billion;
                break;
              case locale2.abbreviations.billion:
                abbr = locale2.abbreviations.trillion;
                break;
            }
          }
          if (numeral2._.includes(int, "-")) {
            int = int.slice(1);
            neg = true;
          }
          if (int.length < leadingCount) {
            for (var i2 = leadingCount - int.length; i2 > 0; i2--) {
              int = "0" + int;
            }
          }
          if (thousands > -1) {
            int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + locale2.delimiters.thousands);
          }
          if (format.indexOf(".") === 0) {
            int = "";
          }
          output = int + decimal + (abbr ? abbr : "");
          if (negP) {
            output = (negP && neg ? "(" : "") + output + (negP && neg ? ")" : "");
          } else {
            if (signed >= 0) {
              output = signed === 0 ? (neg ? "-" : "+") + output : output + (neg ? "-" : "+");
            } else if (neg) {
              output = "-" + output;
            }
          }
          return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function(string) {
          var locale2 = locales[options.currentLocale], stringOriginal = string, abbreviations = {
            thousand: 3,
            million: 6,
            billion: 9,
            trillion: 12
          }, abbreviation, value, regexp;
          if (options.zeroFormat && string === options.zeroFormat) {
            value = 0;
          } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, "").length) {
            value = null;
          } else {
            value = 1;
            if (locale2.delimiters.decimal !== ".") {
              string = string.replace(/\./g, "").replace(locale2.delimiters.decimal, ".");
            }
            for (abbreviation in abbreviations) {
              regexp = new RegExp("[^a-zA-Z]" + locale2.abbreviations[abbreviation] + "(?:\\)|(\\" + locale2.currency.symbol + ")?(?:\\))?)?$");
              if (stringOriginal.match(regexp)) {
                value *= Math.pow(10, abbreviations[abbreviation]);
                break;
              }
            }
            value *= (string.split("-").length + Math.min(string.split("(").length - 1, string.split(")").length - 1)) % 2 ? 1 : -1;
            string = string.replace(/[^0-9\.]+/g, "");
            value *= Number(string);
          }
          return value;
        },
        isNaN: function(value) {
          return typeof value === "number" && isNaN(value);
        },
        includes: function(string, search) {
          return string.indexOf(search) !== -1;
        },
        insert: function(string, subString, start) {
          return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function(array, callback) {
          if (this === null) {
            throw new TypeError("Array.prototype.reduce called on null or undefined");
          }
          if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
          }
          var t2 = Object(array), len = t2.length >>> 0, k2 = 0, value;
          if (arguments.length === 3) {
            value = arguments[2];
          } else {
            while (k2 < len && !(k2 in t2)) {
              k2++;
            }
            if (k2 >= len) {
              throw new TypeError("Reduce of empty array with no initial value");
            }
            value = t2[k2++];
          }
          for (; k2 < len; k2++) {
            if (k2 in t2) {
              value = callback(value, t2[k2], k2, t2);
            }
          }
          return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function(x2) {
          var parts = x2.toString().split(".");
          return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function() {
          var args = Array.prototype.slice.call(arguments);
          return args.reduce(function(accum, next) {
            var mn = _2.multiplier(next);
            return accum > mn ? accum : mn;
          }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function(value, maxDecimals, roundingFunction, optionals) {
          var splitValue = value.toString().split("."), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
          if (splitValue.length === 2) {
            boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
          } else {
            boundedPrecision = minDecimals;
          }
          power = Math.pow(10, boundedPrecision);
          output = (roundingFunction(value + "e+" + boundedPrecision) / power).toFixed(boundedPrecision);
          if (optionals > maxDecimals - boundedPrecision) {
            optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
            output = output.replace(optionalsRegExp, "");
          }
          return output;
        }
      };
      numeral2.options = options;
      numeral2.formats = formats;
      numeral2.locales = locales;
      numeral2.locale = function(key) {
        if (key) {
          options.currentLocale = key.toLowerCase();
        }
        return options.currentLocale;
      };
      numeral2.localeData = function(key) {
        if (!key) {
          return locales[options.currentLocale];
        }
        key = key.toLowerCase();
        if (!locales[key]) {
          throw new Error("Unknown locale : " + key);
        }
        return locales[key];
      };
      numeral2.reset = function() {
        for (var property in defaults) {
          options[property] = defaults[property];
        }
      };
      numeral2.zeroFormat = function(format) {
        options.zeroFormat = typeof format === "string" ? format : null;
      };
      numeral2.nullFormat = function(format) {
        options.nullFormat = typeof format === "string" ? format : null;
      };
      numeral2.defaultFormat = function(format) {
        options.defaultFormat = typeof format === "string" ? format : "0.0";
      };
      numeral2.register = function(type, name, format) {
        name = name.toLowerCase();
        if (this[type + "s"][name]) {
          throw new TypeError(name + " " + type + " already registered.");
        }
        this[type + "s"][name] = format;
        return format;
      };
      numeral2.validate = function(val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
        if (typeof val !== "string") {
          val += "";
          if (console.warn) {
            console.warn("Numeral.js: Value is not string. It has been co-erced to: ", val);
          }
        }
        val = val.trim();
        if (!!val.match(/^\d+$/)) {
          return true;
        }
        if (val === "") {
          return false;
        }
        try {
          localeData = numeral2.localeData(culture);
        } catch (e) {
          localeData = numeral2.localeData(numeral2.locale());
        }
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === ".") {
          _thousandSep = "\\.";
        } else {
          _thousandSep = localeData.delimiters.thousands;
        }
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
          val = val.substr(1);
          if (temp[0] !== _currSymbol) {
            return false;
          }
        }
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
          val = val.slice(0, -1);
          if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
            return false;
          }
        }
        _thousandRegEx = new RegExp(_thousandSep + "{2}");
        if (!val.match(/[^\d.,]/g)) {
          _valArray = val.split(_decimalSep);
          if (_valArray.length > 2) {
            return false;
          } else {
            if (_valArray.length < 2) {
              return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
            } else {
              if (_valArray[0].length === 1) {
                return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              } else {
                return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
              }
            }
          }
        }
        return false;
      };
      numeral2.fn = Numeral.prototype = {
        clone: function() {
          return numeral2(this);
        },
        format: function(inputString, roundingFunction) {
          var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;
          roundingFunction = roundingFunction || Math.round;
          if (value === 0 && options.zeroFormat !== null) {
            output = options.zeroFormat;
          } else if (value === null && options.nullFormat !== null) {
            output = options.nullFormat;
          } else {
            for (kind in formats) {
              if (format.match(formats[kind].regexps.format)) {
                formatFunction = formats[kind].format;
                break;
              }
            }
            formatFunction = formatFunction || numeral2._.numberToFormat;
            output = formatFunction(value, format, roundingFunction);
          }
          return output;
        },
        value: function() {
          return this._value;
        },
        input: function() {
          return this._input;
        },
        set: function(value) {
          this._value = Number(value);
          return this;
        },
        add: function(value) {
          var corrFactor = _2.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O2) {
            return accum + Math.round(corrFactor * curr);
          }
          this._value = _2.reduce([this._value, value], cback, 0) / corrFactor;
          return this;
        },
        subtract: function(value) {
          var corrFactor = _2.correctionFactor.call(null, this._value, value);
          function cback(accum, curr, currI, O2) {
            return accum - Math.round(corrFactor * curr);
          }
          this._value = _2.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
          return this;
        },
        multiply: function(value) {
          function cback(accum, curr, currI, O2) {
            var corrFactor = _2.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);
          }
          this._value = _2.reduce([this._value, value], cback, 1);
          return this;
        },
        divide: function(value) {
          function cback(accum, curr, currI, O2) {
            var corrFactor = _2.correctionFactor(accum, curr);
            return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
          }
          this._value = _2.reduce([this._value, value], cback);
          return this;
        },
        difference: function(value) {
          return Math.abs(numeral2(this._value).subtract(value).value());
        }
      };
      numeral2.register("locale", "en", {
        delimiters: {
          thousands: ",",
          decimal: "."
        },
        abbreviations: {
          thousand: "k",
          million: "m",
          billion: "b",
          trillion: "t"
        },
        ordinal: function(number) {
          var b2 = number % 10;
          return ~~(number % 100 / 10) === 1 ? "th" : b2 === 1 ? "st" : b2 === 2 ? "nd" : b2 === 3 ? "rd" : "th";
        },
        currency: {
          symbol: "$"
        }
      });
      (function() {
        numeral2.register("format", "bps", {
          regexps: {
            format: /(BPS)/,
            unformat: /(BPS)/
          },
          format: function(value, format, roundingFunction) {
            var space = numeral2._.includes(format, " BPS") ? " " : "", output;
            value = value * 1e4;
            format = format.replace(/\s?BPS/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (numeral2._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "BPS");
              output = output.join("");
            } else {
              output = output + space + "BPS";
            }
            return output;
          },
          unformat: function(string) {
            return +(numeral2._.stringToNumber(string) * 1e-4).toFixed(15);
          }
        });
      })();
      (function() {
        var decimal = {
          base: 1e3,
          suffixes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }, binary = {
          base: 1024,
          suffixes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        };
        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function(item) {
          return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join("|");
        unformatRegex = "(" + unformatRegex.replace("B", "B(?!PS)") + ")";
        numeral2.register("format", "bytes", {
          regexps: {
            format: /([0\s]i?b)/,
            unformat: new RegExp(unformatRegex)
          },
          format: function(value, format, roundingFunction) {
            var output, bytes = numeral2._.includes(format, "ib") ? binary : decimal, suffix = numeral2._.includes(format, " b") || numeral2._.includes(format, " ib") ? " " : "", power, min, max;
            format = format.replace(/\s?i?b/, "");
            for (power = 0; power <= bytes.suffixes.length; power++) {
              min = Math.pow(bytes.base, power);
              max = Math.pow(bytes.base, power + 1);
              if (value === null || value === 0 || value >= min && value < max) {
                suffix += bytes.suffixes[power];
                if (min > 0) {
                  value = value / min;
                }
                break;
              }
            }
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            return output + suffix;
          },
          unformat: function(string) {
            var value = numeral2._.stringToNumber(string), power, bytesMultiplier;
            if (value) {
              for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                if (numeral2._.includes(string, decimal.suffixes[power])) {
                  bytesMultiplier = Math.pow(decimal.base, power);
                  break;
                }
                if (numeral2._.includes(string, binary.suffixes[power])) {
                  bytesMultiplier = Math.pow(binary.base, power);
                  break;
                }
              }
              value *= bytesMultiplier || 1;
            }
            return value;
          }
        });
      })();
      (function() {
        numeral2.register("format", "currency", {
          regexps: {
            format: /(\$)/
          },
          format: function(value, format, roundingFunction) {
            var locale2 = numeral2.locales[numeral2.options.currentLocale], symbols = {
              before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
              after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
            }, output, symbol, i2;
            format = format.replace(/\s?\$\s?/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (value >= 0) {
              symbols.before = symbols.before.replace(/[\-\(]/, "");
              symbols.after = symbols.after.replace(/[\-\)]/, "");
            } else if (value < 0 && (!numeral2._.includes(symbols.before, "-") && !numeral2._.includes(symbols.before, "("))) {
              symbols.before = "-" + symbols.before;
            }
            for (i2 = 0; i2 < symbols.before.length; i2++) {
              symbol = symbols.before[i2];
              switch (symbol) {
                case "$":
                  output = numeral2._.insert(output, locale2.currency.symbol, i2);
                  break;
                case " ":
                  output = numeral2._.insert(output, " ", i2 + locale2.currency.symbol.length - 1);
                  break;
              }
            }
            for (i2 = symbols.after.length - 1; i2 >= 0; i2--) {
              symbol = symbols.after[i2];
              switch (symbol) {
                case "$":
                  output = i2 === symbols.after.length - 1 ? output + locale2.currency.symbol : numeral2._.insert(output, locale2.currency.symbol, -(symbols.after.length - (1 + i2)));
                  break;
                case " ":
                  output = i2 === symbols.after.length - 1 ? output + " " : numeral2._.insert(output, " ", -(symbols.after.length - (1 + i2) + locale2.currency.symbol.length - 1));
                  break;
              }
            }
            return output;
          }
        });
      })();
      (function() {
        numeral2.register("format", "exponential", {
          regexps: {
            format: /(e\+|e-)/,
            unformat: /(e\+|e-)/
          },
          format: function(value, format, roundingFunction) {
            var output, exponential = typeof value === "number" && !numeral2._.isNaN(value) ? value.toExponential() : "0e+0", parts = exponential.split("e");
            format = format.replace(/e[\+|\-]{1}0/, "");
            output = numeral2._.numberToFormat(Number(parts[0]), format, roundingFunction);
            return output + "e" + parts[1];
          },
          unformat: function(string) {
            var parts = numeral2._.includes(string, "e+") ? string.split("e+") : string.split("e-"), value = Number(parts[0]), power = Number(parts[1]);
            power = numeral2._.includes(string, "e-") ? power *= -1 : power;
            function cback(accum, curr, currI, O2) {
              var corrFactor = numeral2._.correctionFactor(accum, curr), num = accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
              return num;
            }
            return numeral2._.reduce([value, Math.pow(10, power)], cback, 1);
          }
        });
      })();
      (function() {
        numeral2.register("format", "ordinal", {
          regexps: {
            format: /(o)/
          },
          format: function(value, format, roundingFunction) {
            var locale2 = numeral2.locales[numeral2.options.currentLocale], output, ordinal = numeral2._.includes(format, " o") ? " " : "";
            format = format.replace(/\s?o/, "");
            ordinal += locale2.ordinal(value);
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            return output + ordinal;
          }
        });
      })();
      (function() {
        numeral2.register("format", "percentage", {
          regexps: {
            format: /(%)/,
            unformat: /(%)/
          },
          format: function(value, format, roundingFunction) {
            var space = numeral2._.includes(format, " %") ? " " : "", output;
            if (numeral2.options.scalePercentBy100) {
              value = value * 100;
            }
            format = format.replace(/\s?\%/, "");
            output = numeral2._.numberToFormat(value, format, roundingFunction);
            if (numeral2._.includes(output, ")")) {
              output = output.split("");
              output.splice(-1, 0, space + "%");
              output = output.join("");
            } else {
              output = output + space + "%";
            }
            return output;
          },
          unformat: function(string) {
            var number = numeral2._.stringToNumber(string);
            if (numeral2.options.scalePercentBy100) {
              return number * 0.01;
            }
            return number;
          }
        });
      })();
      (function() {
        numeral2.register("format", "time", {
          regexps: {
            format: /(:)/,
            unformat: /(:)/
          },
          format: function(value, format, roundingFunction) {
            var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
            return hours + ":" + (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
          },
          unformat: function(string) {
            var timeArray = string.split(":"), seconds = 0;
            if (timeArray.length === 3) {
              seconds = seconds + Number(timeArray[0]) * 60 * 60;
              seconds = seconds + Number(timeArray[1]) * 60;
              seconds = seconds + Number(timeArray[2]);
            } else if (timeArray.length === 2) {
              seconds = seconds + Number(timeArray[0]) * 60;
              seconds = seconds + Number(timeArray[1]);
            }
            return Number(seconds);
          }
        });
      })();
      return numeral2;
    });
  })(numeral$1);
  var numeralExports = numeral$1.exports;
  const numeral = /* @__PURE__ */ getDefaultExportFromCjs(numeralExports);
  var dayjs_min = { exports: {} };
  (function(module, exports$1) {
    !function(t2, e) {
      module.exports = e();
    }(commonjsGlobal, function() {
      var t2 = 1e3, e = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f2 = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e2 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
        return "[" + t3 + (e2[(n3 - 20) % 10] || e2[n3] || e2[0]) + "]";
      } }, m2 = function(t3, e2, n3) {
        var r3 = String(t3);
        return !r3 || r3.length >= e2 ? t3 : "" + Array(e2 + 1 - r3.length).join(n3) + t3;
      }, v2 = { s: m2, z: function(t3) {
        var e2 = -t3.utcOffset(), n3 = Math.abs(e2), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
        return (e2 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
      }, m: function t3(e2, n3) {
        if (e2.date() < n3.date()) return -t3(n3, e2);
        var r3 = 12 * (n3.year() - e2.year()) + (n3.month() - e2.month()), i3 = e2.clone().add(r3, c2), s3 = n3 - i3 < 0, u3 = e2.clone().add(r3 + (s3 ? -1 : 1), c2);
        return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: f2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g2 = "en", D2 = {};
      D2[g2] = M2;
      var p2 = "$isDayjsObject", S2 = function(t3) {
        return t3 instanceof _2 || !(!t3 || !t3[p2]);
      }, w2 = function t3(e2, n3, r3) {
        var i3;
        if (!e2) return g2;
        if ("string" == typeof e2) {
          var s3 = e2.toLowerCase();
          D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
          var u3 = e2.split("-");
          if (!i3 && u3.length > 1) return t3(u3[0]);
        } else {
          var a3 = e2.name;
          D2[a3] = e2, i3 = a3;
        }
        return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
      }, O2 = function(t3, e2) {
        if (S2(t3)) return t3.clone();
        var n3 = "object" == typeof e2 ? e2 : {};
        return n3.date = t3, n3.args = arguments, new _2(n3);
      }, b2 = v2;
      b2.l = w2, b2.i = S2, b2.w = function(t3, e2) {
        return O2(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M3(t3) {
          this.$L = w2(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p2] = true;
        }
        var m3 = M3.prototype;
        return m3.parse = function(t3) {
          this.$d = function(t4) {
            var e2 = t4.date, n3 = t4.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b2.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r3 = e2.match($);
              if (r3) {
                var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
                return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
              }
            }
            return new Date(e2);
          }(t3), this.init();
        }, m3.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m3.$utils = function() {
          return b2;
        }, m3.isValid = function() {
          return !(this.$d.toString() === l2);
        }, m3.isSame = function(t3, e2) {
          var n3 = O2(t3);
          return this.startOf(e2) <= n3 && n3 <= this.endOf(e2);
        }, m3.isAfter = function(t3, e2) {
          return O2(t3) < this.startOf(e2);
        }, m3.isBefore = function(t3, e2) {
          return this.endOf(e2) < O2(t3);
        }, m3.$g = function(t3, e2, n3) {
          return b2.u(t3) ? this[e2] : this.set(n3, t3);
        }, m3.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m3.valueOf = function() {
          return this.$d.getTime();
        }, m3.startOf = function(t3, e2) {
          var n3 = this, r3 = !!b2.u(e2) || e2, f3 = b2.p(t3), l3 = function(t4, e3) {
            var i3 = b2.w(n3.$u ? Date.UTC(n3.$y, e3, t4) : new Date(n3.$y, e3, t4), n3);
            return r3 ? i3 : i3.endOf(a2);
          }, $2 = function(t4, e3) {
            return b2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n3);
          }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
          switch (f3) {
            case h2:
              return r3 ? l3(1, 0) : l3(31, 11);
            case c2:
              return r3 ? l3(1, M4) : l3(0, M4 + 1);
            case o2:
              var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
              return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
            case a2:
            case d2:
              return $2(v3 + "Hours", 0);
            case u2:
              return $2(v3 + "Minutes", 1);
            case s2:
              return $2(v3 + "Seconds", 2);
            case i2:
              return $2(v3 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m3.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m3.$set = function(t3, e2) {
          var n3, o3 = b2.p(t3), f3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f3 + "Date", n3[d2] = f3 + "Date", n3[c2] = f3 + "Month", n3[h2] = f3 + "FullYear", n3[u2] = f3 + "Hours", n3[s2] = f3 + "Minutes", n3[i2] = f3 + "Seconds", n3[r2] = f3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o3 === c2 || o3 === h2) {
            var y3 = this.clone().set(d2, 1);
            y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
          } else l3 && this.$d[l3]($2);
          return this.init(), this;
        }, m3.set = function(t3, e2) {
          return this.clone().$set(t3, e2);
        }, m3.get = function(t3) {
          return this[b2.p(t3)]();
        }, m3.add = function(r3, f3) {
          var d3, l3 = this;
          r3 = Number(r3);
          var $2 = b2.p(f3), y3 = function(t3) {
            var e2 = O2(l3);
            return b2.w(e2.date(e2.date() + Math.round(t3 * r3)), l3);
          };
          if ($2 === c2) return this.set(c2, this.$M + r3);
          if ($2 === h2) return this.set(h2, this.$y + r3);
          if ($2 === a2) return y3(1);
          if ($2 === o2) return y3(7);
          var M4 = (d3 = {}, d3[s2] = e, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
          return b2.w(m4, this);
        }, m3.subtract = function(t3, e2) {
          return this.add(-1 * t3, e2);
        }, m3.format = function(t3) {
          var e2 = this, n3 = this.$locale();
          if (!this.isValid()) return n3.invalidDate || l2;
          var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = b2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f3 = n3.meridiem, h3 = function(t4, n4, i4, s4) {
            return t4 && (t4[n4] || t4(e2, r3)) || i4[n4].slice(0, s4);
          }, d3 = function(t4) {
            return b2.s(s3 % 12 || 12, t4, "0");
          }, $2 = f3 || function(t4, e3, n4) {
            var r4 = t4 < 12 ? "AM" : "PM";
            return n4 ? r4.toLowerCase() : r4;
          };
          return r3.replace(y2, function(t4, r4) {
            return r4 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b2.s(e2.$y, 4, "0");
                case "M":
                  return a3 + 1;
                case "MM":
                  return b2.s(a3 + 1, 2, "0");
                case "MMM":
                  return h3(n3.monthsShort, a3, c3, 3);
                case "MMMM":
                  return h3(c3, a3);
                case "D":
                  return e2.$D;
                case "DD":
                  return b2.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h3(n3.weekdaysMin, e2.$W, o3, 2);
                case "ddd":
                  return h3(n3.weekdaysShort, e2.$W, o3, 3);
                case "dddd":
                  return o3[e2.$W];
                case "H":
                  return String(s3);
                case "HH":
                  return b2.s(s3, 2, "0");
                case "h":
                  return d3(1);
                case "hh":
                  return d3(2);
                case "a":
                  return $2(s3, u3, true);
                case "A":
                  return $2(s3, u3, false);
                case "m":
                  return String(u3);
                case "mm":
                  return b2.s(u3, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b2.s(e2.$s, 2, "0");
                case "SSS":
                  return b2.s(e2.$ms, 3, "0");
                case "Z":
                  return i3;
              }
              return null;
            }(t4) || i3.replace(":", "");
          });
        }, m3.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m3.diff = function(r3, d3, l3) {
          var $2, y3 = this, M4 = b2.p(d3), m4 = O2(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e, g3 = this - m4, D3 = function() {
            return b2.m(y3, m4);
          };
          switch (M4) {
            case h2:
              $2 = D3() / 12;
              break;
            case c2:
              $2 = D3();
              break;
            case f2:
              $2 = D3() / 3;
              break;
            case o2:
              $2 = (g3 - v3) / 6048e5;
              break;
            case a2:
              $2 = (g3 - v3) / 864e5;
              break;
            case u2:
              $2 = g3 / n2;
              break;
            case s2:
              $2 = g3 / e;
              break;
            case i2:
              $2 = g3 / t2;
              break;
            default:
              $2 = g3;
          }
          return l3 ? $2 : b2.a($2);
        }, m3.daysInMonth = function() {
          return this.endOf(c2).$D;
        }, m3.$locale = function() {
          return D2[this.$L];
        }, m3.locale = function(t3, e2) {
          if (!t3) return this.$L;
          var n3 = this.clone(), r3 = w2(t3, e2, true);
          return r3 && (n3.$L = r3), n3;
        }, m3.clone = function() {
          return b2.w(this.$d, this);
        }, m3.toDate = function() {
          return new Date(this.valueOf());
        }, m3.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m3.toISOString = function() {
          return this.$d.toISOString();
        }, m3.toString = function() {
          return this.$d.toUTCString();
        }, M3;
      }(), k2 = _2.prototype;
      return O2.prototype = k2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t3) {
        k2[t3[1]] = function(e2) {
          return this.$g(e2, t3[0], t3[1]);
        };
      }), O2.extend = function(t3, e2) {
        return t3.$i || (t3(e2, _2, O2), t3.$i = true), O2;
      }, O2.locale = w2, O2.isDayjs = S2, O2.unix = function(t3) {
        return O2(1e3 * t3);
      }, O2.en = D2[g2], O2.Ls = D2, O2.p = {}, O2;
    });
  })(dayjs_min);
  var dayjs_minExports = dayjs_min.exports;
  const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
  var tinyEmitter = { exports: {} };
  function E$1() {
  }
  E$1.prototype = {
    on: function(name, callback, ctx) {
      var e = this.e || (this.e = {});
      (e[name] || (e[name] = [])).push({
        fn: callback,
        ctx
      });
      return this;
    },
    once: function(name, callback, ctx) {
      var self2 = this;
      function listener() {
        self2.off(name, listener);
        callback.apply(ctx, arguments);
      }
      listener._ = callback;
      return this.on(name, listener, ctx);
    },
    emit: function(name) {
      var data = [].slice.call(arguments, 1);
      var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
      var i2 = 0;
      var len = evtArr.length;
      for (i2; i2 < len; i2++) {
        evtArr[i2].fn.apply(evtArr[i2].ctx, data);
      }
      return this;
    },
    off: function(name, callback) {
      var e = this.e || (this.e = {});
      var evts = e[name];
      var liveEvents = [];
      if (evts && callback) {
        for (var i2 = 0, len = evts.length; i2 < len; i2++) {
          if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
            liveEvents.push(evts[i2]);
        }
      }
      liveEvents.length ? e[name] = liveEvents : delete e[name];
      return this;
    }
  };
  tinyEmitter.exports = E$1;
  tinyEmitter.exports.TinyEmitter = E$1;
  var tinyEmitterExports = tinyEmitter.exports;
  const Emitter = /* @__PURE__ */ getDefaultExportFromCjs(tinyEmitterExports);
  function toNumber(number) {
    var result;
    if (typeof number === "number") {
      result = number;
    } else if (typeof number === "string") {
      result = number.indexOf(".") > -1 ? parseFloat(number) : parseInt(number, 10);
    }
    return result;
  }
  function invertNumber(number) {
    return -1 * toNumber(number);
  }
  var _errors;
  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ERROR = "ERROR";
  var ERROR_DIV_ZERO = "DIV/0";
  var ERROR_NAME = "NAME";
  var ERROR_NOT_AVAILABLE = "N/A";
  var ERROR_NULL = "NULL";
  var ERROR_NUM = "NUM";
  var ERROR_REF = "REF";
  var ERROR_VALUE = "VALUE";
  var errors = (_errors = {}, _defineProperty$2(_errors, ERROR, "#ERROR!"), _defineProperty$2(_errors, ERROR_DIV_ZERO, "#DIV/0!"), _defineProperty$2(_errors, ERROR_NAME, "#NAME?"), _defineProperty$2(_errors, ERROR_NOT_AVAILABLE, "#N/A"), _defineProperty$2(_errors, ERROR_NULL, "#NULL!"), _defineProperty$2(_errors, ERROR_NUM, "#NUM!"), _defineProperty$2(_errors, ERROR_REF, "#REF!"), _defineProperty$2(_errors, ERROR_VALUE, "#VALUE!"), _errors);
  function error$4(type) {
    var result;
    type = (type + "").replace(/#|!|\?/g, "");
    if (errors[type]) {
      result = errors[type];
    }
    return result ? result : null;
  }
  function isValidStrict(type) {
    var valid = false;
    for (var i2 in errors) {
      if (Object.prototype.hasOwnProperty.call(errors, i2) && errors[i2] === type) {
        valid = true;
        break;
      }
    }
    return valid;
  }
  var SYMBOL$c = "+";
  function func$c(first) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    var result = rest.reduce(function(acc, value) {
      return acc + toNumber(value || 0);
    }, toNumber(first || 0));
    if (isNaN(result)) {
      throw Error(ERROR_VALUE);
    }
    return result;
  }
  func$c.SYMBOL = SYMBOL$c;
  var SYMBOL$b = "&";
  function func$b() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    return params.reduce(function(acc, value) {
      return acc + value.toString();
    }, "");
  }
  func$b.SYMBOL = SYMBOL$b;
  var SYMBOL$a = "/";
  function func$a(first) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    var result = rest.reduce(function(acc, value) {
      return acc / toNumber(value);
    }, toNumber(first));
    if (result === Infinity) {
      return ERROR_DIV_ZERO;
    }
    if (isNaN(result)) {
      return ERROR_VALUE;
    }
    return result;
  }
  func$a.SYMBOL = SYMBOL$a;
  var SYMBOL$9 = "=";
  function func$9(exp1, exp2) {
    return exp1 === exp2;
  }
  func$9.SYMBOL = SYMBOL$9;
  var formulajs$1 = {};
  var compatibility = {};
  var mathTrig$1 = {};
  var common = {};
  var error$3 = {};
  error$3.nil = new Error("#NULL!");
  error$3.div0 = new Error("#DIV/0!");
  error$3.value = new Error("#VALUE!");
  error$3.ref = new Error("#REF!");
  error$3.name = new Error("#NAME?");
  error$3.num = new Error("#NUM!");
  error$3.na = new Error("#N/A");
  error$3.error = new Error("#ERROR!");
  error$3.data = new Error("#GETTING_DATA");
  (function(exports$1) {
    var error2 = error$3;
    exports$1.flattenShallow = function(array) {
      if (!array || !array.reduce) {
        return array;
      }
      return array.reduce(function(a2, b2) {
        var aIsArray = Array.isArray(a2);
        var bIsArray = Array.isArray(b2);
        if (aIsArray && bIsArray) {
          return a2.concat(b2);
        }
        if (aIsArray) {
          a2.push(b2);
          return a2;
        }
        if (bIsArray) {
          return [a2].concat(b2);
        }
        return [a2, b2];
      });
    };
    exports$1.isFlat = function(array) {
      if (!array) {
        return false;
      }
      for (var i2 = 0; i2 < array.length; ++i2) {
        if (Array.isArray(array[i2])) {
          return false;
        }
      }
      return true;
    };
    exports$1.flatten = function() {
      var result = exports$1.argsToArray.apply(null, arguments);
      while (!exports$1.isFlat(result)) {
        result = exports$1.flattenShallow(result);
      }
      return result;
    };
    exports$1.argsToArray = function(args) {
      var result = [];
      exports$1.arrayEach(args, function(value) {
        result.push(value);
      });
      return result;
    };
    exports$1.numbers = function() {
      var possibleNumbers = this.flatten.apply(null, arguments);
      return possibleNumbers.filter(function(el2) {
        return typeof el2 === "number";
      });
    };
    exports$1.cleanFloat = function(number) {
      var power = 1e14;
      return Math.round(number * power) / power;
    };
    exports$1.parseBool = function(bool) {
      if (typeof bool === "boolean") {
        return bool;
      }
      if (bool instanceof Error) {
        return bool;
      }
      if (typeof bool === "number") {
        return bool !== 0;
      }
      if (typeof bool === "string") {
        var up = bool.toUpperCase();
        if (up === "TRUE") {
          return true;
        }
        if (up === "FALSE") {
          return false;
        }
      }
      if (bool instanceof Date && !isNaN(bool)) {
        return true;
      }
      return error2.value;
    };
    exports$1.parseNumber = function(string) {
      if (string instanceof Error) {
        return string;
      }
      if (string === void 0 || string === null || string === "") {
        return 0;
      }
      if (typeof string === "boolean") {
        string = +string;
      }
      if (!isNaN(string)) {
        return parseFloat(string);
      }
      return error2.value;
    };
    exports$1.parseString = function(string) {
      if (string instanceof Error) {
        return string;
      }
      if (string === void 0 || string === null) {
        return "";
      }
      return string.toString();
    };
    exports$1.parseNumberArray = function(arr) {
      var len;
      if (!arr || (len = arr.length) === 0) {
        return error2.value;
      }
      var parsed;
      while (len--) {
        if (arr[len] instanceof Error) {
          return arr[len];
        }
        parsed = exports$1.parseNumber(arr[len]);
        if (parsed instanceof Error) {
          return parsed;
        }
        arr[len] = parsed;
      }
      return arr;
    };
    exports$1.parseMatrix = function(matrix) {
      if (!matrix || matrix.length === 0) {
        return error2.value;
      }
      var pnarr;
      for (var i2 = 0; i2 < matrix.length; i2++) {
        pnarr = exports$1.parseNumberArray(matrix[i2]);
        matrix[i2] = pnarr;
        if (pnarr instanceof Error) {
          return pnarr;
        }
      }
      return matrix;
    };
    function serialNumberToDate(serial) {
      if (serial < 60) {
        serial += 1;
      }
      var utc_days = Math.floor(serial - 25569);
      var utc_value = utc_days * 86400;
      var date_info = new Date(utc_value * 1e3);
      var fractional_day = serial - Math.floor(serial) + 1e-7;
      var total_seconds = Math.floor(86400 * fractional_day);
      var seconds = total_seconds % 60;
      total_seconds -= seconds;
      var hours = Math.floor(total_seconds / (60 * 60));
      var minutes = Math.floor(total_seconds / 60) % 60;
      var days = date_info.getDate();
      var month = date_info.getMonth();
      if (serial >= 60 && serial < 61) {
        var days = 29;
        var month = 1;
      }
      return new Date(date_info.getFullYear(), month, days, hours, minutes, seconds);
    }
    exports$1.parseDate = function(date) {
      if (!isNaN(date)) {
        if (date instanceof Date) {
          return new Date(date);
        }
        var d2 = parseFloat(date);
        if (d2 < 0 || d2 >= 2958466) {
          return error2.num;
        }
        return serialNumberToDate(d2);
      }
      if (typeof date === "string") {
        date = new Date(date);
        if (!isNaN(date)) {
          return date;
        }
      }
      return error2.value;
    };
    exports$1.parseDateArray = function(arr) {
      var len = arr.length;
      var parsed;
      while (len--) {
        parsed = this.parseDate(arr[len]);
        if (parsed === error2.value) {
          return parsed;
        }
        arr[len] = parsed;
      }
      return arr;
    };
    exports$1.anyError = function() {
      for (var n2 = 0; n2 < arguments.length; n2++) {
        if (arguments[n2] instanceof Error) {
          return arguments[n2];
        }
      }
      return void 0;
    };
    exports$1.isDefined = function(arg) {
      return arg !== void 0 && arg !== null;
    };
    exports$1.anyIsError = function() {
      var n2 = arguments.length;
      while (n2--) {
        if (arguments[n2] instanceof Error) {
          return true;
        }
      }
      return false;
    };
    exports$1.anyIsString = function() {
      var n2 = arguments.length;
      while (n2--) {
        if (typeof arguments[n2] === "string") {
          return true;
        }
      }
      return false;
    };
    exports$1.arrayValuesToNumbers = function(arr) {
      var n2 = arr.length;
      var el2;
      while (n2--) {
        el2 = arr[n2];
        if (typeof el2 === "number") {
          continue;
        }
        if (el2 === true) {
          arr[n2] = 1;
          continue;
        }
        if (el2 === false) {
          arr[n2] = 0;
          continue;
        }
        if (typeof el2 === "string") {
          var number = this.parseNumber(el2);
          if (number instanceof Error) {
            arr[n2] = 0;
          } else {
            arr[n2] = number;
          }
        }
      }
      return arr;
    };
    exports$1.rest = function(array, idx) {
      idx = idx || 1;
      if (!array || typeof array.slice !== "function") {
        return array;
      }
      return array.slice(idx);
    };
    exports$1.initial = function(array, idx) {
      idx = idx || 1;
      if (!array || typeof array.slice !== "function") {
        return array;
      }
      return array.slice(0, array.length - idx);
    };
    exports$1.arrayEach = function(array, iteratee) {
      var index2 = -1, length = array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    };
    exports$1.transpose = function(matrix) {
      if (!matrix) {
        return error2.value;
      }
      return matrix[0].map(function(col, i2) {
        return matrix.map(function(row) {
          return row[i2];
        });
      });
    };
  })(common);
  var statistical$1 = {};
  var text = {};
  (function(exports$1) {
    var utils2 = common;
    var error2 = error$3;
    exports$1.ASC = function() {
      throw new Error("ASC is not implemented");
    };
    exports$1.BAHTTEXT = function() {
      throw new Error("BAHTTEXT is not implemented");
    };
    exports$1.CHAR = function(number) {
      number = utils2.parseNumber(number);
      if (number === 0) {
        return error2.value;
      }
      if (number instanceof Error) {
        return number;
      }
      return String.fromCharCode(number);
    };
    exports$1.CLEAN = function(text2) {
      if (utils2.anyIsError(text2)) {
        return text2;
      }
      text2 = text2 || "";
      var re2 = /[\0-\x1F]/g;
      return text2.replace(re2, "");
    };
    exports$1.CODE = function(text2) {
      if (utils2.anyIsError(text2)) {
        return text2;
      }
      text2 = text2 || "";
      var result = text2.charCodeAt(0);
      if (isNaN(result)) {
        result = error2.value;
      }
      return result;
    };
    exports$1.CONCATENATE = function() {
      var args = utils2.flatten(arguments);
      var someError = utils2.anyError.apply(void 0, args);
      if (someError) {
        return someError;
      }
      var trueFound = 0;
      while ((trueFound = args.indexOf(true)) > -1) {
        args[trueFound] = "TRUE";
      }
      var falseFound = 0;
      while ((falseFound = args.indexOf(false)) > -1) {
        args[falseFound] = "FALSE";
      }
      return args.join("");
    };
    exports$1.CONCAT = exports$1.CONCATENATE;
    exports$1.DBCS = function() {
      throw new Error("DBCS is not implemented");
    };
    exports$1.DOLLAR = function() {
      throw new Error("DOLLAR is not implemented");
    };
    exports$1.EXACT = function(text1, text2) {
      if (arguments.length !== 2) {
        return error2.na;
      }
      var someError = utils2.anyError(text1, text2);
      if (someError) {
        return someError;
      }
      text1 = utils2.parseString(text1);
      text2 = utils2.parseString(text2);
      return text1 === text2;
    };
    exports$1.FIND = function(find_text, within_text, position) {
      if (arguments.length < 2) {
        return error2.na;
      }
      find_text = utils2.parseString(find_text);
      within_text = utils2.parseString(within_text);
      position = position === void 0 ? 0 : position;
      var found_index = within_text.indexOf(find_text, position - 1);
      if (found_index === -1) {
        return error2.value;
      }
      return found_index + 1;
    };
    exports$1.FIXED = function() {
      throw new Error("FIXED is not implemented");
    };
    exports$1.HTML2TEXT = function(value) {
      if (utils2.anyIsError(value)) {
        return value;
      }
      var result = "";
      if (value) {
        if (value instanceof Array) {
          value.forEach(function(line) {
            if (result !== "") {
              result += "\n";
            }
            result += line.replace(/<(?:.|\n)*?>/gm, "");
          });
        } else {
          result = value.replace(/<(?:.|\n)*?>/gm, "");
        }
      }
      return result;
    };
    exports$1.LEFT = function(text2, number) {
      var someError = utils2.anyError(text2, number);
      if (someError) {
        return someError;
      }
      text2 = utils2.parseString(text2);
      number = number === void 0 ? 1 : number;
      number = utils2.parseNumber(number);
      if (number instanceof Error || typeof text2 !== "string") {
        return error2.value;
      }
      return text2.substring(0, number);
    };
    exports$1.LEN = function(text2) {
      if (arguments.length === 0) {
        return error2.error;
      }
      if (text2 instanceof Error) {
        return text2;
      }
      if (Array.isArray(text2)) {
        return error2.value;
      }
      var textAsString = utils2.parseString(text2);
      return textAsString.length;
    };
    exports$1.LOWER = function(text2) {
      if (arguments.length !== 1) {
        return error2.value;
      }
      text2 = utils2.parseString(text2);
      if (utils2.anyIsError(text2)) {
        return text2;
      }
      return text2.toLowerCase();
    };
    exports$1.MID = function(text2, start, number) {
      if (start === void 0 || start === null) {
        return error2.value;
      }
      start = utils2.parseNumber(start);
      number = utils2.parseNumber(number);
      if (utils2.anyIsError(start, number) || typeof text2 !== "string") {
        return number;
      }
      var begin = start - 1;
      var end = begin + number;
      return text2.substring(begin, end);
    };
    exports$1.NUMBERVALUE = function(text2, decimal_separator, group_separator) {
      decimal_separator = typeof decimal_separator === "undefined" ? "." : decimal_separator;
      group_separator = typeof group_separator === "undefined" ? "," : group_separator;
      return Number(text2.replace(decimal_separator, ".").replace(group_separator, ""));
    };
    exports$1.PRONETIC = function() {
      throw new Error("PRONETIC is not implemented");
    };
    exports$1.PROPER = function(text2) {
      if (utils2.anyIsError(text2)) {
        return text2;
      }
      if (isNaN(text2) && typeof text2 === "number") {
        return error2.value;
      }
      text2 = utils2.parseString(text2);
      return text2.replace(/\w\S*/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
      });
    };
    exports$1.REGEXEXTRACT = function(text2, regular_expression) {
      if (arguments.length < 2) {
        return error2.na;
      }
      var match = text2.match(new RegExp(regular_expression));
      return match ? match[match.length > 1 ? match.length - 1 : 0] : null;
    };
    exports$1.REGEXMATCH = function(text2, regular_expression, full) {
      if (arguments.length < 2) {
        return error2.na;
      }
      var match = text2.match(new RegExp(regular_expression));
      return full ? match : !!match;
    };
    exports$1.REGEXREPLACE = function(text2, regular_expression, replacement) {
      if (arguments.length < 3) {
        return error2.na;
      }
      return text2.replace(new RegExp(regular_expression), replacement);
    };
    exports$1.REPLACE = function(text2, position, length, new_text) {
      position = utils2.parseNumber(position);
      length = utils2.parseNumber(length);
      if (utils2.anyIsError(position, length) || typeof text2 !== "string" || typeof new_text !== "string") {
        return error2.value;
      }
      return text2.substr(0, position - 1) + new_text + text2.substr(position - 1 + length);
    };
    exports$1.REPT = function(text2, number) {
      var someError = utils2.anyError(text2, number);
      if (someError) {
        return someError;
      }
      text2 = utils2.parseString(text2);
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return new Array(number + 1).join(text2);
    };
    exports$1.RIGHT = function(text2, number) {
      var someError = utils2.anyError(text2, number);
      if (someError) {
        return someError;
      }
      text2 = utils2.parseString(text2);
      number = number === void 0 ? 1 : number;
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      return text2.substring(text2.length - number);
    };
    exports$1.SEARCH = function(find_text, within_text, position) {
      var foundAt;
      if (typeof find_text !== "string" || typeof within_text !== "string") {
        return error2.value;
      }
      position = position === void 0 ? 0 : position;
      foundAt = within_text.toLowerCase().indexOf(find_text.toLowerCase(), position - 1) + 1;
      return foundAt === 0 ? error2.value : foundAt;
    };
    exports$1.SPLIT = function(text2, separator) {
      return text2.split(separator);
    };
    exports$1.SUBSTITUTE = function(text2, old_text, new_text, occurrence) {
      if (arguments.length < 3) {
        return error2.na;
      }
      if (!text2 || !old_text) {
        return text2;
      } else if (occurrence === void 0) {
        return text2.split(old_text).join(new_text);
      } else {
        occurrence = Math.floor(Number(occurrence));
        if (Number.isNaN(occurrence) || occurrence <= 0) {
          return error2.value;
        }
        var index2 = 0;
        var i2 = 0;
        while (index2 > -1 && text2.indexOf(old_text, index2) > -1) {
          index2 = text2.indexOf(old_text, index2 + 1);
          i2++;
          if (index2 > -1 && i2 === occurrence) {
            return text2.substring(0, index2) + new_text + text2.substring(index2 + old_text.length);
          }
        }
        return text2;
      }
    };
    exports$1.T = function(value) {
      if (value instanceof Error) {
        return value;
      }
      return typeof value === "string" ? value : "";
    };
    exports$1.TEXT = function() {
      throw new Error("TEXT is not implemented");
    };
    exports$1.TRIM = function(text2) {
      text2 = utils2.parseString(text2);
      if (text2 instanceof Error) {
        return text2;
      }
      return text2.replace(/\s+/g, " ").trim();
    };
    exports$1.UNICHAR = exports$1.CHAR;
    exports$1.UNICODE = exports$1.CODE;
    exports$1.UPPER = function(text2) {
      text2 = utils2.parseString(text2);
      if (text2 instanceof Error) {
        return text2;
      }
      return text2.toUpperCase();
    };
    exports$1.VALUE = function(num) {
      var anyError = utils2.anyError(num);
      if (anyError) {
        return anyError;
      }
      if (typeof num !== "string") {
        return error2.value;
      }
      var isPercent = /(%)$/.test(num) || /^(%)/.test(num);
      num = num.replace(/^[^0-9-]{0,3}/, "");
      num = num.replace(/[^0-9]{0,3}$/, "");
      num = num.replace(/[\ ,]/g, "");
      if (num === "") {
        return error2.value;
      }
      var output = Number(num);
      if (isNaN(output)) {
        return error2.value;
      }
      output = output || 0;
      if (isPercent) {
        output = output * 0.01;
      }
      return output;
    };
  })(text);
  var jstat = { exports: {} };
  (function(module, exports$1) {
    (function(window2, factory) {
      {
        module.exports = factory();
      }
    })(commonjsGlobal, function() {
      var jStat = function(Math2, undefined$1) {
        var concat = Array.prototype.concat;
        var slice = Array.prototype.slice;
        var toString = Object.prototype.toString;
        function calcRdx(n2, m2) {
          var val = n2 > m2 ? n2 : m2;
          return Math2.pow(
            10,
            17 - ~~(Math2.log(val > 0 ? val : -val) * Math2.LOG10E)
          );
        }
        var isArray = Array.isArray || function isArray2(arg) {
          return toString.call(arg) === "[object Array]";
        };
        function isFunction(arg) {
          return toString.call(arg) === "[object Function]";
        }
        function isNumber(num) {
          return typeof num === "number" ? num - num === 0 : false;
        }
        function toVector(arr) {
          return concat.apply([], arr);
        }
        function jStat2() {
          return new jStat2._init(arguments);
        }
        jStat2.fn = jStat2.prototype;
        jStat2._init = function _init(args) {
          if (isArray(args[0])) {
            if (isArray(args[0][0])) {
              if (isFunction(args[1]))
                args[0] = jStat2.map(args[0], args[1]);
              for (var i2 = 0; i2 < args[0].length; i2++)
                this[i2] = args[0][i2];
              this.length = args[0].length;
            } else {
              this[0] = isFunction(args[1]) ? jStat2.map(args[0], args[1]) : args[0];
              this.length = 1;
            }
          } else if (isNumber(args[0])) {
            this[0] = jStat2.seq.apply(null, args);
            this.length = 1;
          } else if (args[0] instanceof jStat2) {
            return jStat2(args[0].toArray());
          } else {
            this[0] = [];
            this.length = 1;
          }
          return this;
        };
        jStat2._init.prototype = jStat2.prototype;
        jStat2._init.constructor = jStat2;
        jStat2.utils = {
          calcRdx,
          isArray,
          isFunction,
          isNumber,
          toVector
        };
        jStat2._random_fn = Math2.random;
        jStat2.setRandom = function setRandom(fn2) {
          if (typeof fn2 !== "function")
            throw new TypeError("fn is not a function");
          jStat2._random_fn = fn2;
        };
        jStat2.extend = function extend(obj) {
          var i2, j2;
          if (arguments.length === 1) {
            for (j2 in obj)
              jStat2[j2] = obj[j2];
            return this;
          }
          for (i2 = 1; i2 < arguments.length; i2++) {
            for (j2 in arguments[i2])
              obj[j2] = arguments[i2][j2];
          }
          return obj;
        };
        jStat2.rows = function rows(arr) {
          return arr.length || 1;
        };
        jStat2.cols = function cols(arr) {
          return arr[0].length || 1;
        };
        jStat2.dimensions = function dimensions(arr) {
          return {
            rows: jStat2.rows(arr),
            cols: jStat2.cols(arr)
          };
        };
        jStat2.row = function row(arr, index2) {
          if (isArray(index2)) {
            return index2.map(function(i2) {
              return jStat2.row(arr, i2);
            });
          }
          return arr[index2];
        };
        jStat2.rowa = function rowa(arr, i2) {
          return jStat2.row(arr, i2);
        };
        jStat2.col = function col(arr, index2) {
          if (isArray(index2)) {
            var submat = jStat2.arange(arr.length).map(function() {
              return new Array(index2.length);
            });
            index2.forEach(function(ind, i3) {
              jStat2.arange(arr.length).forEach(function(j2) {
                submat[j2][i3] = arr[j2][ind];
              });
            });
            return submat;
          }
          var column = new Array(arr.length);
          for (var i2 = 0; i2 < arr.length; i2++)
            column[i2] = [arr[i2][index2]];
          return column;
        };
        jStat2.cola = function cola(arr, i2) {
          return jStat2.col(arr, i2).map(function(a2) {
            return a2[0];
          });
        };
        jStat2.diag = function diag(arr) {
          var nrow = jStat2.rows(arr);
          var res = new Array(nrow);
          for (var row = 0; row < nrow; row++)
            res[row] = [arr[row][row]];
          return res;
        };
        jStat2.antidiag = function antidiag(arr) {
          var nrow = jStat2.rows(arr) - 1;
          var res = new Array(nrow);
          for (var i2 = 0; nrow >= 0; nrow--, i2++)
            res[i2] = [arr[i2][nrow]];
          return res;
        };
        jStat2.transpose = function transpose(arr) {
          var obj = [];
          var objArr, rows, cols, j2, i2;
          if (!isArray(arr[0]))
            arr = [arr];
          rows = arr.length;
          cols = arr[0].length;
          for (i2 = 0; i2 < cols; i2++) {
            objArr = new Array(rows);
            for (j2 = 0; j2 < rows; j2++)
              objArr[j2] = arr[j2][i2];
            obj.push(objArr);
          }
          return obj.length === 1 ? obj[0] : obj;
        };
        jStat2.map = function map(arr, func2, toAlter) {
          var row, nrow, ncol, res, col;
          if (!isArray(arr[0]))
            arr = [arr];
          nrow = arr.length;
          ncol = arr[0].length;
          res = toAlter ? arr : new Array(nrow);
          for (row = 0; row < nrow; row++) {
            if (!res[row])
              res[row] = new Array(ncol);
            for (col = 0; col < ncol; col++)
              res[row][col] = func2(arr[row][col], row, col);
          }
          return res.length === 1 ? res[0] : res;
        };
        jStat2.cumreduce = function cumreduce(arr, func2, toAlter) {
          var row, nrow, ncol, res, col;
          if (!isArray(arr[0]))
            arr = [arr];
          nrow = arr.length;
          ncol = arr[0].length;
          res = toAlter ? arr : new Array(nrow);
          for (row = 0; row < nrow; row++) {
            if (!res[row])
              res[row] = new Array(ncol);
            if (ncol > 0)
              res[row][0] = arr[row][0];
            for (col = 1; col < ncol; col++)
              res[row][col] = func2(res[row][col - 1], arr[row][col]);
          }
          return res.length === 1 ? res[0] : res;
        };
        jStat2.alter = function alter(arr, func2) {
          return jStat2.map(arr, func2, true);
        };
        jStat2.create = function create(rows, cols, func2) {
          var res = new Array(rows);
          var i2, j2;
          if (isFunction(cols)) {
            func2 = cols;
            cols = rows;
          }
          for (i2 = 0; i2 < rows; i2++) {
            res[i2] = new Array(cols);
            for (j2 = 0; j2 < cols; j2++)
              res[i2][j2] = func2(i2, j2);
          }
          return res;
        };
        function retZero() {
          return 0;
        }
        jStat2.zeros = function zeros(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retZero);
        };
        function retOne() {
          return 1;
        }
        jStat2.ones = function ones(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retOne);
        };
        jStat2.rand = function rand(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, jStat2._random_fn);
        };
        function retIdent(i2, j2) {
          return i2 === j2 ? 1 : 0;
        }
        jStat2.identity = function identity(rows, cols) {
          if (!isNumber(cols))
            cols = rows;
          return jStat2.create(rows, cols, retIdent);
        };
        jStat2.symmetric = function symmetric(arr) {
          var size2 = arr.length;
          var row, col;
          if (arr.length !== arr[0].length)
            return false;
          for (row = 0; row < size2; row++) {
            for (col = 0; col < size2; col++)
              if (arr[col][row] !== arr[row][col])
                return false;
          }
          return true;
        };
        jStat2.clear = function clear(arr) {
          return jStat2.alter(arr, retZero);
        };
        jStat2.seq = function seq(min, max, length, func2) {
          if (!isFunction(func2))
            func2 = false;
          var arr = [];
          var hival = calcRdx(min, max);
          var step = (max * hival - min * hival) / ((length - 1) * hival);
          var current = min;
          var cnt;
          for (cnt = 0; current <= max && cnt < length; cnt++, current = (min * hival + step * hival * cnt) / hival) {
            arr.push(func2 ? func2(current, cnt) : current);
          }
          return arr;
        };
        jStat2.arange = function arange(start, end, step) {
          var rl2 = [];
          var i2;
          step = step || 1;
          if (end === undefined$1) {
            end = start;
            start = 0;
          }
          if (start === end || step === 0) {
            return [];
          }
          if (start < end && step < 0) {
            return [];
          }
          if (start > end && step > 0) {
            return [];
          }
          if (step > 0) {
            for (i2 = start; i2 < end; i2 += step) {
              rl2.push(i2);
            }
          } else {
            for (i2 = start; i2 > end; i2 += step) {
              rl2.push(i2);
            }
          }
          return rl2;
        };
        jStat2.slice = /* @__PURE__ */ function() {
          function _slice(list, start, end, step) {
            var i2;
            var rl2 = [];
            var length = list.length;
            if (start === undefined$1 && end === undefined$1 && step === undefined$1) {
              return jStat2.copy(list);
            }
            start = start || 0;
            end = end || list.length;
            start = start >= 0 ? start : length + start;
            end = end >= 0 ? end : length + end;
            step = step || 1;
            if (start === end || step === 0) {
              return [];
            }
            if (start < end && step < 0) {
              return [];
            }
            if (start > end && step > 0) {
              return [];
            }
            if (step > 0) {
              for (i2 = start; i2 < end; i2 += step) {
                rl2.push(list[i2]);
              }
            } else {
              for (i2 = start; i2 > end; i2 += step) {
                rl2.push(list[i2]);
              }
            }
            return rl2;
          }
          function slice2(list, rcSlice) {
            var colSlice, rowSlice;
            rcSlice = rcSlice || {};
            if (isNumber(rcSlice.row)) {
              if (isNumber(rcSlice.col))
                return list[rcSlice.row][rcSlice.col];
              var row = jStat2.rowa(list, rcSlice.row);
              colSlice = rcSlice.col || {};
              return _slice(row, colSlice.start, colSlice.end, colSlice.step);
            }
            if (isNumber(rcSlice.col)) {
              var col = jStat2.cola(list, rcSlice.col);
              rowSlice = rcSlice.row || {};
              return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);
            }
            rowSlice = rcSlice.row || {};
            colSlice = rcSlice.col || {};
            var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);
            return rows.map(function(row2) {
              return _slice(row2, colSlice.start, colSlice.end, colSlice.step);
            });
          }
          return slice2;
        }();
        jStat2.sliceAssign = function sliceAssign(A2, rcSlice, B2) {
          var nl2, ml2;
          if (isNumber(rcSlice.row)) {
            if (isNumber(rcSlice.col))
              return A2[rcSlice.row][rcSlice.col] = B2;
            rcSlice.col = rcSlice.col || {};
            rcSlice.col.start = rcSlice.col.start || 0;
            rcSlice.col.end = rcSlice.col.end || A2[0].length;
            rcSlice.col.step = rcSlice.col.step || 1;
            nl2 = jStat2.arange(
              rcSlice.col.start,
              Math2.min(A2.length, rcSlice.col.end),
              rcSlice.col.step
            );
            var m2 = rcSlice.row;
            nl2.forEach(function(n3, i2) {
              A2[m2][n3] = B2[i2];
            });
            return A2;
          }
          if (isNumber(rcSlice.col)) {
            rcSlice.row = rcSlice.row || {};
            rcSlice.row.start = rcSlice.row.start || 0;
            rcSlice.row.end = rcSlice.row.end || A2.length;
            rcSlice.row.step = rcSlice.row.step || 1;
            ml2 = jStat2.arange(
              rcSlice.row.start,
              Math2.min(A2[0].length, rcSlice.row.end),
              rcSlice.row.step
            );
            var n2 = rcSlice.col;
            ml2.forEach(function(m3, j2) {
              A2[m3][n2] = B2[j2];
            });
            return A2;
          }
          if (B2[0].length === undefined$1) {
            B2 = [B2];
          }
          rcSlice.row.start = rcSlice.row.start || 0;
          rcSlice.row.end = rcSlice.row.end || A2.length;
          rcSlice.row.step = rcSlice.row.step || 1;
          rcSlice.col.start = rcSlice.col.start || 0;
          rcSlice.col.end = rcSlice.col.end || A2[0].length;
          rcSlice.col.step = rcSlice.col.step || 1;
          ml2 = jStat2.arange(
            rcSlice.row.start,
            Math2.min(A2.length, rcSlice.row.end),
            rcSlice.row.step
          );
          nl2 = jStat2.arange(
            rcSlice.col.start,
            Math2.min(A2[0].length, rcSlice.col.end),
            rcSlice.col.step
          );
          ml2.forEach(function(m3, i2) {
            nl2.forEach(function(n3, j2) {
              A2[m3][n3] = B2[i2][j2];
            });
          });
          return A2;
        };
        jStat2.diagonal = function diagonal(diagArray) {
          var mat = jStat2.zeros(diagArray.length, diagArray.length);
          diagArray.forEach(function(t2, i2) {
            mat[i2][i2] = t2;
          });
          return mat;
        };
        jStat2.copy = function copy2(A2) {
          return A2.map(function(row) {
            if (isNumber(row))
              return row;
            return row.map(function(t2) {
              return t2;
            });
          });
        };
        var jProto = jStat2.prototype;
        jProto.length = 0;
        jProto.push = Array.prototype.push;
        jProto.sort = Array.prototype.sort;
        jProto.splice = Array.prototype.splice;
        jProto.slice = Array.prototype.slice;
        jProto.toArray = function toArray() {
          return this.length > 1 ? slice.call(this) : slice.call(this)[0];
        };
        jProto.map = function map(func2, toAlter) {
          return jStat2(jStat2.map(this, func2, toAlter));
        };
        jProto.cumreduce = function cumreduce(func2, toAlter) {
          return jStat2(jStat2.cumreduce(this, func2, toAlter));
        };
        jProto.alter = function alter(func2) {
          jStat2.alter(this, func2);
          return this;
        };
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function(func2) {
              var self2 = this, results;
              if (func2) {
                setTimeout(function() {
                  func2.call(self2, jProto[passfunc].call(self2));
                });
                return this;
              }
              results = jStat2[passfunc](this);
              return isArray(results) ? jStat2(results) : results;
            };
          })(funcs[i2]);
        })("transpose clear symmetric rows cols dimensions diag antidiag".split(" "));
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function(index2, func2) {
              var self2 = this;
              if (func2) {
                setTimeout(function() {
                  func2.call(self2, jProto[passfunc].call(self2, index2));
                });
                return this;
              }
              return jStat2(jStat2[passfunc](this, index2));
            };
          })(funcs[i2]);
        })("row col".split(" "));
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function() {
              return jStat2(jStat2[passfunc].apply(null, arguments));
            };
          })(funcs[i2]);
        })("create zeros ones rand identity".split(" "));
        return jStat2;
      }(Math);
      (function(jStat2, Math2) {
        var isFunction = jStat2.utils.isFunction;
        function ascNum(a2, b2) {
          return a2 - b2;
        }
        function clip(arg, min, max) {
          return Math2.max(min, Math2.min(arg, max));
        }
        jStat2.sum = function sum(arr) {
          var sum2 = 0;
          var i2 = arr.length;
          while (--i2 >= 0)
            sum2 += arr[i2];
          return sum2;
        };
        jStat2.sumsqrd = function sumsqrd(arr) {
          var sum = 0;
          var i2 = arr.length;
          while (--i2 >= 0)
            sum += arr[i2] * arr[i2];
          return sum;
        };
        jStat2.sumsqerr = function sumsqerr(arr) {
          var mean = jStat2.mean(arr);
          var sum = 0;
          var i2 = arr.length;
          var tmp;
          while (--i2 >= 0) {
            tmp = arr[i2] - mean;
            sum += tmp * tmp;
          }
          return sum;
        };
        jStat2.sumrow = function sumrow(arr) {
          var sum = 0;
          var i2 = arr.length;
          while (--i2 >= 0)
            sum += arr[i2];
          return sum;
        };
        jStat2.product = function product(arr) {
          var prod = 1;
          var i2 = arr.length;
          while (--i2 >= 0)
            prod *= arr[i2];
          return prod;
        };
        jStat2.min = function min(arr) {
          var low = arr[0];
          var i2 = 0;
          while (++i2 < arr.length)
            if (arr[i2] < low)
              low = arr[i2];
          return low;
        };
        jStat2.max = function max(arr) {
          var high = arr[0];
          var i2 = 0;
          while (++i2 < arr.length)
            if (arr[i2] > high)
              high = arr[i2];
          return high;
        };
        jStat2.unique = function unique(arr) {
          var hash = {}, _arr = [];
          for (var i2 = 0; i2 < arr.length; i2++) {
            if (!hash[arr[i2]]) {
              hash[arr[i2]] = true;
              _arr.push(arr[i2]);
            }
          }
          return _arr;
        };
        jStat2.mean = function mean(arr) {
          return jStat2.sum(arr) / arr.length;
        };
        jStat2.meansqerr = function meansqerr(arr) {
          return jStat2.sumsqerr(arr) / arr.length;
        };
        jStat2.geomean = function geomean(arr) {
          var logs = arr.map(Math2.log);
          var meanOfLogs = jStat2.mean(logs);
          return Math2.exp(meanOfLogs);
        };
        jStat2.median = function median(arr) {
          var arrlen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          return !(arrlen & 1) ? (_arr[arrlen / 2 - 1] + _arr[arrlen / 2]) / 2 : _arr[arrlen / 2 | 0];
        };
        jStat2.cumsum = function cumsum(arr) {
          return jStat2.cumreduce(arr, function(a2, b2) {
            return a2 + b2;
          });
        };
        jStat2.cumprod = function cumprod(arr) {
          return jStat2.cumreduce(arr, function(a2, b2) {
            return a2 * b2;
          });
        };
        jStat2.diff = function diff2(arr) {
          var diffs = [];
          var arrLen = arr.length;
          var i2;
          for (i2 = 1; i2 < arrLen; i2++)
            diffs.push(arr[i2] - arr[i2 - 1]);
          return diffs;
        };
        jStat2.rank = function(arr) {
          var i2;
          var distinctNumbers = [];
          var numberCounts = {};
          for (i2 = 0; i2 < arr.length; i2++) {
            var number = arr[i2];
            if (numberCounts[number]) {
              numberCounts[number]++;
            } else {
              numberCounts[number] = 1;
              distinctNumbers.push(number);
            }
          }
          var sortedDistinctNumbers = distinctNumbers.sort(ascNum);
          var numberRanks = {};
          var currentRank = 1;
          for (i2 = 0; i2 < sortedDistinctNumbers.length; i2++) {
            var number = sortedDistinctNumbers[i2];
            var count = numberCounts[number];
            var first = currentRank;
            var last = currentRank + count - 1;
            var rank = (first + last) / 2;
            numberRanks[number] = rank;
            currentRank += count;
          }
          return arr.map(function(number2) {
            return numberRanks[number2];
          });
        };
        jStat2.mode = function mode(arr) {
          var arrLen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          var count = 1;
          var maxCount = 0;
          var numMaxCount = 0;
          var mode_arr = [];
          var i2;
          for (i2 = 0; i2 < arrLen; i2++) {
            if (_arr[i2] === _arr[i2 + 1]) {
              count++;
            } else {
              if (count > maxCount) {
                mode_arr = [_arr[i2]];
                maxCount = count;
                numMaxCount = 0;
              } else if (count === maxCount) {
                mode_arr.push(_arr[i2]);
                numMaxCount++;
              }
              count = 1;
            }
          }
          return numMaxCount === 0 ? mode_arr[0] : mode_arr;
        };
        jStat2.range = function range(arr) {
          return jStat2.max(arr) - jStat2.min(arr);
        };
        jStat2.variance = function variance(arr, flag) {
          return jStat2.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
        };
        jStat2.pooledvariance = function pooledvariance(arr) {
          var sumsqerr = arr.reduce(function(a2, samples) {
            return a2 + jStat2.sumsqerr(samples);
          }, 0);
          var count = arr.reduce(function(a2, samples) {
            return a2 + samples.length;
          }, 0);
          return sumsqerr / (count - arr.length);
        };
        jStat2.deviation = function(arr) {
          var mean = jStat2.mean(arr);
          var arrlen = arr.length;
          var dev = new Array(arrlen);
          for (var i2 = 0; i2 < arrlen; i2++) {
            dev[i2] = arr[i2] - mean;
          }
          return dev;
        };
        jStat2.stdev = function stdev(arr, flag) {
          return Math2.sqrt(jStat2.variance(arr, flag));
        };
        jStat2.pooledstdev = function pooledstdev(arr) {
          return Math2.sqrt(jStat2.pooledvariance(arr));
        };
        jStat2.meandev = function meandev(arr) {
          var mean = jStat2.mean(arr);
          var a2 = [];
          for (var i2 = arr.length - 1; i2 >= 0; i2--) {
            a2.push(Math2.abs(arr[i2] - mean));
          }
          return jStat2.mean(a2);
        };
        jStat2.meddev = function meddev(arr) {
          var median = jStat2.median(arr);
          var a2 = [];
          for (var i2 = arr.length - 1; i2 >= 0; i2--) {
            a2.push(Math2.abs(arr[i2] - median));
          }
          return jStat2.median(a2);
        };
        jStat2.coeffvar = function coeffvar(arr) {
          return jStat2.stdev(arr) / jStat2.mean(arr);
        };
        jStat2.quartiles = function quartiles(arr) {
          var arrlen = arr.length;
          var _arr = arr.slice().sort(ascNum);
          return [
            _arr[Math2.round(arrlen / 4) - 1],
            _arr[Math2.round(arrlen / 2) - 1],
            _arr[Math2.round(arrlen * 3 / 4) - 1]
          ];
        };
        jStat2.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
          var sortedArray = arr.slice().sort(ascNum);
          var quantileVals = [quantilesArray.length];
          var n2 = arr.length;
          var i2, p2, m2, aleph, k2, gamma;
          if (typeof alphap === "undefined")
            alphap = 3 / 8;
          if (typeof betap === "undefined")
            betap = 3 / 8;
          for (i2 = 0; i2 < quantilesArray.length; i2++) {
            p2 = quantilesArray[i2];
            m2 = alphap + p2 * (1 - alphap - betap);
            aleph = n2 * p2 + m2;
            k2 = Math2.floor(clip(aleph, 1, n2 - 1));
            gamma = clip(aleph - k2, 0, 1);
            quantileVals[i2] = (1 - gamma) * sortedArray[k2 - 1] + gamma * sortedArray[k2];
          }
          return quantileVals;
        };
        jStat2.percentile = function percentile(arr, k2, exclusive) {
          var _arr = arr.slice().sort(ascNum);
          var realIndex = k2 * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);
          var index2 = parseInt(realIndex);
          var frac = realIndex - index2;
          if (index2 + 1 < _arr.length) {
            return _arr[index2 - 1] + frac * (_arr[index2] - _arr[index2 - 1]);
          } else {
            return _arr[index2 - 1];
          }
        };
        jStat2.percentileOfScore = function percentileOfScore(arr, score, kind) {
          var counter = 0;
          var len = arr.length;
          var strict = false;
          var value, i2;
          if (kind === "strict")
            strict = true;
          for (i2 = 0; i2 < len; i2++) {
            value = arr[i2];
            if (strict && value < score || !strict && value <= score) {
              counter++;
            }
          }
          return counter / len;
        };
        jStat2.histogram = function histogram(arr, binCnt) {
          binCnt = binCnt || 4;
          var first = jStat2.min(arr);
          var binWidth = (jStat2.max(arr) - first) / binCnt;
          var len = arr.length;
          var bins = [];
          var i2;
          for (i2 = 0; i2 < binCnt; i2++)
            bins[i2] = 0;
          for (i2 = 0; i2 < len; i2++)
            bins[Math2.min(Math2.floor((arr[i2] - first) / binWidth), binCnt - 1)] += 1;
          return bins;
        };
        jStat2.covariance = function covariance(arr1, arr2) {
          var u2 = jStat2.mean(arr1);
          var v2 = jStat2.mean(arr2);
          var arr1Len = arr1.length;
          var sq_dev = new Array(arr1Len);
          var i2;
          for (i2 = 0; i2 < arr1Len; i2++)
            sq_dev[i2] = (arr1[i2] - u2) * (arr2[i2] - v2);
          return jStat2.sum(sq_dev) / (arr1Len - 1);
        };
        jStat2.corrcoeff = function corrcoeff(arr1, arr2) {
          return jStat2.covariance(arr1, arr2) / jStat2.stdev(arr1, 1) / jStat2.stdev(arr2, 1);
        };
        jStat2.spearmancoeff = function(arr1, arr2) {
          arr1 = jStat2.rank(arr1);
          arr2 = jStat2.rank(arr2);
          return jStat2.corrcoeff(arr1, arr2);
        };
        jStat2.stanMoment = function stanMoment(arr, n2) {
          var mu = jStat2.mean(arr);
          var sigma = jStat2.stdev(arr);
          var len = arr.length;
          var skewSum = 0;
          for (var i2 = 0; i2 < len; i2++)
            skewSum += Math2.pow((arr[i2] - mu) / sigma, n2);
          return skewSum / arr.length;
        };
        jStat2.skewness = function skewness(arr) {
          return jStat2.stanMoment(arr, 3);
        };
        jStat2.kurtosis = function kurtosis(arr) {
          return jStat2.stanMoment(arr, 4) - 3;
        };
        var jProto = jStat2.prototype;
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function(fullbool, func2) {
              var arr = [];
              var i3 = 0;
              var tmpthis = this;
              if (isFunction(fullbool)) {
                func2 = fullbool;
                fullbool = false;
              }
              if (func2) {
                setTimeout(function() {
                  func2.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                });
                return this;
              }
              if (this.length > 1) {
                tmpthis = fullbool === true ? this : this.transpose();
                for (; i3 < tmpthis.length; i3++)
                  arr[i3] = jStat2[passfunc](tmpthis[i3]);
                return arr;
              }
              return jStat2[passfunc](this[0], fullbool);
            };
          })(funcs[i2]);
        })("cumsum cumprod".split(" "));
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function(fullbool, func2) {
              var arr = [];
              var i3 = 0;
              var tmpthis = this;
              if (isFunction(fullbool)) {
                func2 = fullbool;
                fullbool = false;
              }
              if (func2) {
                setTimeout(function() {
                  func2.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
                });
                return this;
              }
              if (this.length > 1) {
                if (passfunc !== "sumrow")
                  tmpthis = fullbool === true ? this : this.transpose();
                for (; i3 < tmpthis.length; i3++)
                  arr[i3] = jStat2[passfunc](tmpthis[i3]);
                return fullbool === true ? jStat2[passfunc](jStat2.utils.toVector(arr)) : arr;
              }
              return jStat2[passfunc](this[0], fullbool);
            };
          })(funcs[i2]);
        })("sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr geomean median diff rank mode range variance deviation stdev meandev meddev coeffvar quartiles histogram skewness kurtosis".split(" "));
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jProto[passfunc] = function() {
              var arr = [];
              var i3 = 0;
              var tmpthis = this;
              var args = Array.prototype.slice.call(arguments);
              var callbackFunction;
              if (isFunction(args[args.length - 1])) {
                callbackFunction = args[args.length - 1];
                var argsToPass = args.slice(0, args.length - 1);
                setTimeout(function() {
                  callbackFunction.call(
                    tmpthis,
                    jProto[passfunc].apply(tmpthis, argsToPass)
                  );
                });
                return this;
              } else {
                callbackFunction = void 0;
                var curriedFunction = function curriedFunction2(vector) {
                  return jStat2[passfunc].apply(tmpthis, [vector].concat(args));
                };
              }
              if (this.length > 1) {
                tmpthis = tmpthis.transpose();
                for (; i3 < tmpthis.length; i3++)
                  arr[i3] = curriedFunction(tmpthis[i3]);
                return arr;
              }
              return curriedFunction(this[0]);
            };
          })(funcs[i2]);
        })("quantiles percentileOfScore".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        jStat2.gammaln = function gammaln(x2) {
          var j2 = 0;
          var cof = [
            76.18009172947146,
            -86.50532032941678,
            24.01409824083091,
            -1.231739572450155,
            0.001208650973866179,
            -5395239384953e-18
          ];
          var ser = 1.000000000190015;
          var xx, y2, tmp;
          tmp = (y2 = xx = x2) + 5.5;
          tmp -= (xx + 0.5) * Math2.log(tmp);
          for (; j2 < 6; j2++)
            ser += cof[j2] / ++y2;
          return Math2.log(2.5066282746310007 * ser / xx) - tmp;
        };
        jStat2.loggam = function loggam(x2) {
          var x0, x22, xp, gl2, gl0;
          var k2, n2;
          var a2 = [
            0.08333333333333333,
            -0.002777777777777778,
            7936507936507937e-19,
            -5952380952380952e-19,
            8417508417508418e-19,
            -0.001917526917526918,
            0.00641025641025641,
            -0.02955065359477124,
            0.1796443723688307,
            -1.3924322169059
          ];
          x0 = x2;
          n2 = 0;
          if (x2 == 1 || x2 == 2) {
            return 0;
          }
          if (x2 <= 7) {
            n2 = Math2.floor(7 - x2);
            x0 = x2 + n2;
          }
          x22 = 1 / (x0 * x0);
          xp = 2 * Math2.PI;
          gl0 = a2[9];
          for (k2 = 8; k2 >= 0; k2--) {
            gl0 *= x22;
            gl0 += a2[k2];
          }
          gl2 = gl0 / x0 + 0.5 * Math2.log(xp) + (x0 - 0.5) * Math2.log(x0) - x0;
          if (x2 <= 7) {
            for (k2 = 1; k2 <= n2; k2++) {
              gl2 -= Math2.log(x0 - 1);
              x0 -= 1;
            }
          }
          return gl2;
        };
        jStat2.gammafn = function gammafn(x2) {
          var p2 = [
            -1.716185138865495,
            24.76565080557592,
            -379.80425647094563,
            629.3311553128184,
            866.9662027904133,
            -31451.272968848367,
            -36144.413418691176,
            66456.14382024054
          ];
          var q2 = [
            -30.8402300119739,
            315.35062697960416,
            -1015.1563674902192,
            -3107.771671572311,
            22538.11842098015,
            4755.846277527881,
            -134659.9598649693,
            -115132.2596755535
          ];
          var fact = false;
          var n2 = 0;
          var xden = 0;
          var xnum = 0;
          var y2 = x2;
          var i2, z2, yi2, res;
          if (x2 > 171.6243769536076) {
            return Infinity;
          }
          if (y2 <= 0) {
            res = y2 % 1 + 36e-17;
            if (res) {
              fact = (!(y2 & 1) ? 1 : -1) * Math2.PI / Math2.sin(Math2.PI * res);
              y2 = 1 - y2;
            } else {
              return Infinity;
            }
          }
          yi2 = y2;
          if (y2 < 1) {
            z2 = y2++;
          } else {
            z2 = (y2 -= n2 = (y2 | 0) - 1) - 1;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            xnum = (xnum + p2[i2]) * z2;
            xden = xden * z2 + q2[i2];
          }
          res = xnum / xden + 1;
          if (yi2 < y2) {
            res /= yi2;
          } else if (yi2 > y2) {
            for (i2 = 0; i2 < n2; ++i2) {
              res *= y2;
              y2++;
            }
          }
          if (fact) {
            res = fact / res;
          }
          return res;
        };
        jStat2.gammap = function gammap(a2, x2) {
          return jStat2.lowRegGamma(a2, x2) * jStat2.gammafn(a2);
        };
        jStat2.lowRegGamma = function lowRegGamma(a2, x2) {
          var aln = jStat2.gammaln(a2);
          var ap = a2;
          var sum = 1 / a2;
          var del = sum;
          var b2 = x2 + 1 - a2;
          var c2 = 1 / 1e-30;
          var d2 = 1 / b2;
          var h2 = d2;
          var i2 = 1;
          var ITMAX = -~(Math2.log(a2 >= 1 ? a2 : 1 / a2) * 8.5 + a2 * 0.4 + 17);
          var an2;
          if (x2 < 0 || a2 <= 0) {
            return NaN;
          } else if (x2 < a2 + 1) {
            for (; i2 <= ITMAX; i2++) {
              sum += del *= x2 / ++ap;
            }
            return sum * Math2.exp(-x2 + a2 * Math2.log(x2) - aln);
          }
          for (; i2 <= ITMAX; i2++) {
            an2 = -i2 * (i2 - a2);
            b2 += 2;
            d2 = an2 * d2 + b2;
            c2 = b2 + an2 / c2;
            d2 = 1 / d2;
            h2 *= d2 * c2;
          }
          return 1 - h2 * Math2.exp(-x2 + a2 * Math2.log(x2) - aln);
        };
        jStat2.factorialln = function factorialln(n2) {
          return n2 < 0 ? NaN : jStat2.gammaln(n2 + 1);
        };
        jStat2.factorial = function factorial(n2) {
          return n2 < 0 ? NaN : jStat2.gammafn(n2 + 1);
        };
        jStat2.combination = function combination(n2, m2) {
          return n2 > 170 || m2 > 170 ? Math2.exp(jStat2.combinationln(n2, m2)) : jStat2.factorial(n2) / jStat2.factorial(m2) / jStat2.factorial(n2 - m2);
        };
        jStat2.combinationln = function combinationln(n2, m2) {
          return jStat2.factorialln(n2) - jStat2.factorialln(m2) - jStat2.factorialln(n2 - m2);
        };
        jStat2.permutation = function permutation(n2, m2) {
          return jStat2.factorial(n2) / jStat2.factorial(n2 - m2);
        };
        jStat2.betafn = function betafn(x2, y2) {
          if (x2 <= 0 || y2 <= 0)
            return void 0;
          return x2 + y2 > 170 ? Math2.exp(jStat2.betaln(x2, y2)) : jStat2.gammafn(x2) * jStat2.gammafn(y2) / jStat2.gammafn(x2 + y2);
        };
        jStat2.betaln = function betaln(x2, y2) {
          return jStat2.gammaln(x2) + jStat2.gammaln(y2) - jStat2.gammaln(x2 + y2);
        };
        jStat2.betacf = function betacf(x2, a2, b2) {
          var fpmin = 1e-30;
          var m2 = 1;
          var qab = a2 + b2;
          var qap = a2 + 1;
          var qam = a2 - 1;
          var c2 = 1;
          var d2 = 1 - qab * x2 / qap;
          var m22, aa2, del, h2;
          if (Math2.abs(d2) < fpmin)
            d2 = fpmin;
          d2 = 1 / d2;
          h2 = d2;
          for (; m2 <= 100; m2++) {
            m22 = 2 * m2;
            aa2 = m2 * (b2 - m2) * x2 / ((qam + m22) * (a2 + m22));
            d2 = 1 + aa2 * d2;
            if (Math2.abs(d2) < fpmin)
              d2 = fpmin;
            c2 = 1 + aa2 / c2;
            if (Math2.abs(c2) < fpmin)
              c2 = fpmin;
            d2 = 1 / d2;
            h2 *= d2 * c2;
            aa2 = -(a2 + m2) * (qab + m2) * x2 / ((a2 + m22) * (qap + m22));
            d2 = 1 + aa2 * d2;
            if (Math2.abs(d2) < fpmin)
              d2 = fpmin;
            c2 = 1 + aa2 / c2;
            if (Math2.abs(c2) < fpmin)
              c2 = fpmin;
            d2 = 1 / d2;
            del = d2 * c2;
            h2 *= del;
            if (Math2.abs(del - 1) < 3e-7)
              break;
          }
          return h2;
        };
        jStat2.gammapinv = function gammapinv(p2, a2) {
          var j2 = 0;
          var a1 = a2 - 1;
          var EPS = 1e-8;
          var gln = jStat2.gammaln(a2);
          var x2, err, t2, u2, pp, lna1, afac;
          if (p2 >= 1)
            return Math2.max(100, a2 + 100 * Math2.sqrt(a2));
          if (p2 <= 0)
            return 0;
          if (a2 > 1) {
            lna1 = Math2.log(a1);
            afac = Math2.exp(a1 * (lna1 - 1) - gln);
            pp = p2 < 0.5 ? p2 : 1 - p2;
            t2 = Math2.sqrt(-2 * Math2.log(pp));
            x2 = (2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2;
            if (p2 < 0.5)
              x2 = -x2;
            x2 = Math2.max(
              1e-3,
              a2 * Math2.pow(1 - 1 / (9 * a2) - x2 / (3 * Math2.sqrt(a2)), 3)
            );
          } else {
            t2 = 1 - a2 * (0.253 + a2 * 0.12);
            if (p2 < t2)
              x2 = Math2.pow(p2 / t2, 1 / a2);
            else
              x2 = 1 - Math2.log(1 - (p2 - t2) / (1 - t2));
          }
          for (; j2 < 12; j2++) {
            if (x2 <= 0)
              return 0;
            err = jStat2.lowRegGamma(a2, x2) - p2;
            if (a2 > 1)
              t2 = afac * Math2.exp(-(x2 - a1) + a1 * (Math2.log(x2) - lna1));
            else
              t2 = Math2.exp(-x2 + a1 * Math2.log(x2) - gln);
            u2 = err / t2;
            x2 -= t2 = u2 / (1 - 0.5 * Math2.min(1, u2 * ((a2 - 1) / x2 - 1)));
            if (x2 <= 0)
              x2 = 0.5 * (x2 + t2);
            if (Math2.abs(t2) < EPS * x2)
              break;
          }
          return x2;
        };
        jStat2.erf = function erf(x2) {
          var cof = [
            -1.3026537197817094,
            0.6419697923564902,
            0.019476473204185836,
            -0.00956151478680863,
            -946595344482036e-18,
            366839497852761e-18,
            42523324806907e-18,
            -20278578112534e-18,
            -1624290004647e-18,
            130365583558e-17,
            15626441722e-18,
            -85238095915e-18,
            6529054439e-18,
            5059343495e-18,
            -991364156e-18,
            -227365122e-18,
            96467911e-18,
            2394038e-18,
            -6886027e-18,
            894487e-18,
            313092e-18,
            -112708e-18,
            381e-18,
            7106e-18,
            -1523e-18,
            -94e-18,
            121e-18,
            -28e-18
          ];
          var j2 = cof.length - 1;
          var isneg = false;
          var d2 = 0;
          var dd2 = 0;
          var t2, ty, tmp, res;
          if (x2 < 0) {
            x2 = -x2;
            isneg = true;
          }
          t2 = 2 / (2 + x2);
          ty = 4 * t2 - 2;
          for (; j2 > 0; j2--) {
            tmp = d2;
            d2 = ty * d2 - dd2 + cof[j2];
            dd2 = tmp;
          }
          res = t2 * Math2.exp(-x2 * x2 + 0.5 * (cof[0] + ty * d2) - dd2);
          return isneg ? res - 1 : 1 - res;
        };
        jStat2.erfc = function erfc(x2) {
          return 1 - jStat2.erf(x2);
        };
        jStat2.erfcinv = function erfcinv(p2) {
          var j2 = 0;
          var x2, err, t2, pp;
          if (p2 >= 2)
            return -100;
          if (p2 <= 0)
            return 100;
          pp = p2 < 1 ? p2 : 2 - p2;
          t2 = Math2.sqrt(-2 * Math2.log(pp / 2));
          x2 = -0.70711 * ((2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2);
          for (; j2 < 2; j2++) {
            err = jStat2.erfc(x2) - pp;
            x2 += err / (1.1283791670955126 * Math2.exp(-x2 * x2) - x2 * err);
          }
          return p2 < 1 ? x2 : -x2;
        };
        jStat2.ibetainv = function ibetainv(p2, a2, b2) {
          var EPS = 1e-8;
          var a1 = a2 - 1;
          var b1 = b2 - 1;
          var j2 = 0;
          var lna, lnb, pp, t2, u2, err, x2, al2, h2, w2, afac;
          if (p2 <= 0)
            return 0;
          if (p2 >= 1)
            return 1;
          if (a2 >= 1 && b2 >= 1) {
            pp = p2 < 0.5 ? p2 : 1 - p2;
            t2 = Math2.sqrt(-2 * Math2.log(pp));
            x2 = (2.30753 + t2 * 0.27061) / (1 + t2 * (0.99229 + t2 * 0.04481)) - t2;
            if (p2 < 0.5)
              x2 = -x2;
            al2 = (x2 * x2 - 3) / 6;
            h2 = 2 / (1 / (2 * a2 - 1) + 1 / (2 * b2 - 1));
            w2 = x2 * Math2.sqrt(al2 + h2) / h2 - (1 / (2 * b2 - 1) - 1 / (2 * a2 - 1)) * (al2 + 5 / 6 - 2 / (3 * h2));
            x2 = a2 / (a2 + b2 * Math2.exp(2 * w2));
          } else {
            lna = Math2.log(a2 / (a2 + b2));
            lnb = Math2.log(b2 / (a2 + b2));
            t2 = Math2.exp(a2 * lna) / a2;
            u2 = Math2.exp(b2 * lnb) / b2;
            w2 = t2 + u2;
            if (p2 < t2 / w2)
              x2 = Math2.pow(a2 * w2 * p2, 1 / a2);
            else
              x2 = 1 - Math2.pow(b2 * w2 * (1 - p2), 1 / b2);
          }
          afac = -jStat2.gammaln(a2) - jStat2.gammaln(b2) + jStat2.gammaln(a2 + b2);
          for (; j2 < 10; j2++) {
            if (x2 === 0 || x2 === 1)
              return x2;
            err = jStat2.ibeta(x2, a2, b2) - p2;
            t2 = Math2.exp(a1 * Math2.log(x2) + b1 * Math2.log(1 - x2) + afac);
            u2 = err / t2;
            x2 -= t2 = u2 / (1 - 0.5 * Math2.min(1, u2 * (a1 / x2 - b1 / (1 - x2))));
            if (x2 <= 0)
              x2 = 0.5 * (x2 + t2);
            if (x2 >= 1)
              x2 = 0.5 * (x2 + t2 + 1);
            if (Math2.abs(t2) < EPS * x2 && j2 > 0)
              break;
          }
          return x2;
        };
        jStat2.ibeta = function ibeta(x2, a2, b2) {
          var bt = x2 === 0 || x2 === 1 ? 0 : Math2.exp(jStat2.gammaln(a2 + b2) - jStat2.gammaln(a2) - jStat2.gammaln(b2) + a2 * Math2.log(x2) + b2 * Math2.log(1 - x2));
          if (x2 < 0 || x2 > 1)
            return false;
          if (x2 < (a2 + 1) / (a2 + b2 + 2))
            return bt * jStat2.betacf(x2, a2, b2) / a2;
          return 1 - bt * jStat2.betacf(1 - x2, b2, a2) / b2;
        };
        jStat2.randn = function randn(n2, m2) {
          var u2, v2, x2, y2, q2;
          if (!m2)
            m2 = n2;
          if (n2)
            return jStat2.create(n2, m2, function() {
              return jStat2.randn();
            });
          do {
            u2 = jStat2._random_fn();
            v2 = 1.7156 * (jStat2._random_fn() - 0.5);
            x2 = u2 - 0.449871;
            y2 = Math2.abs(v2) + 0.386595;
            q2 = x2 * x2 + y2 * (0.196 * y2 - 0.25472 * x2);
          } while (q2 > 0.27597 && (q2 > 0.27846 || v2 * v2 > -4 * Math2.log(u2) * u2 * u2));
          return v2 / u2;
        };
        jStat2.randg = function randg(shape, n2, m2) {
          var oalph = shape;
          var a1, a2, u2, v2, x2, mat;
          if (!m2)
            m2 = n2;
          if (!shape)
            shape = 1;
          if (n2) {
            mat = jStat2.zeros(n2, m2);
            mat.alter(function() {
              return jStat2.randg(shape);
            });
            return mat;
          }
          if (shape < 1)
            shape += 1;
          a1 = shape - 1 / 3;
          a2 = 1 / Math2.sqrt(9 * a1);
          do {
            do {
              x2 = jStat2.randn();
              v2 = 1 + a2 * x2;
            } while (v2 <= 0);
            v2 = v2 * v2 * v2;
            u2 = jStat2._random_fn();
          } while (u2 > 1 - 0.331 * Math2.pow(x2, 4) && Math2.log(u2) > 0.5 * x2 * x2 + a1 * (1 - v2 + Math2.log(v2)));
          if (shape == oalph)
            return a1 * v2;
          do {
            u2 = jStat2._random_fn();
          } while (u2 === 0);
          return Math2.pow(u2, 1 / oalph) * a1 * v2;
        };
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jStat2.fn[passfunc] = function() {
              return jStat2(
                jStat2.map(this, function(value) {
                  return jStat2[passfunc](value);
                })
              );
            };
          })(funcs[i2]);
        })("gammaln gammafn factorial factorialln".split(" "));
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jStat2.fn[passfunc] = function() {
              return jStat2(jStat2[passfunc].apply(null, arguments));
            };
          })(funcs[i2]);
        })("randn".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        (function(list) {
          for (var i2 = 0; i2 < list.length; i2++) (function(func2) {
            jStat2[func2] = function f2(a2, b2, c2) {
              if (!(this instanceof f2))
                return new f2(a2, b2, c2);
              this._a = a2;
              this._b = b2;
              this._c = c2;
              return this;
            };
            jStat2.fn[func2] = function(a2, b2, c2) {
              var newthis = jStat2[func2](a2, b2, c2);
              newthis.data = this;
              return newthis;
            };
            jStat2[func2].prototype.sample = function(arr) {
              var a2 = this._a;
              var b2 = this._b;
              var c2 = this._c;
              if (arr)
                return jStat2.alter(arr, function() {
                  return jStat2[func2].sample(a2, b2, c2);
                });
              else
                return jStat2[func2].sample(a2, b2, c2);
            };
            (function(vals) {
              for (var i3 = 0; i3 < vals.length; i3++) (function(fnfunc) {
                jStat2[func2].prototype[fnfunc] = function(x2) {
                  var a2 = this._a;
                  var b2 = this._b;
                  var c2 = this._c;
                  if (!x2 && x2 !== 0)
                    x2 = this.data;
                  if (typeof x2 !== "number") {
                    return jStat2.fn.map.call(x2, function(x3) {
                      return jStat2[func2][fnfunc](x3, a2, b2, c2);
                    });
                  }
                  return jStat2[func2][fnfunc](x2, a2, b2, c2);
                };
              })(vals[i3]);
            })("pdf cdf inv".split(" "));
            (function(vals) {
              for (var i3 = 0; i3 < vals.length; i3++) (function(fnfunc) {
                jStat2[func2].prototype[fnfunc] = function() {
                  return jStat2[func2][fnfunc](this._a, this._b, this._c);
                };
              })(vals[i3]);
            })("mean median mode variance".split(" "));
          })(list[i2]);
        })("beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy laplace lognormal noncentralt normal pareto studentt weibull uniform binomial negbin hypgeom poisson triangular tukey arcsine".split(" "));
        jStat2.extend(jStat2.beta, {
          pdf: function pdf(x2, alpha, beta) {
            if (x2 > 1 || x2 < 0)
              return 0;
            if (alpha == 1 && beta == 1)
              return 1;
            if (alpha < 512 && beta < 512) {
              return Math2.pow(x2, alpha - 1) * Math2.pow(1 - x2, beta - 1) / jStat2.betafn(alpha, beta);
            } else {
              return Math2.exp((alpha - 1) * Math2.log(x2) + (beta - 1) * Math2.log(1 - x2) - jStat2.betaln(alpha, beta));
            }
          },
          cdf: function cdf(x2, alpha, beta) {
            return x2 > 1 || x2 < 0 ? (x2 > 1) * 1 : jStat2.ibeta(x2, alpha, beta);
          },
          inv: function inv(x2, alpha, beta) {
            return jStat2.ibetainv(x2, alpha, beta);
          },
          mean: function mean(alpha, beta) {
            return alpha / (alpha + beta);
          },
          median: function median(alpha, beta) {
            return jStat2.ibetainv(0.5, alpha, beta);
          },
          mode: function mode(alpha, beta) {
            return (alpha - 1) / (alpha + beta - 2);
          },
          // return a random sample
          sample: function sample(alpha, beta) {
            var u2 = jStat2.randg(alpha);
            return u2 / (u2 + jStat2.randg(beta));
          },
          variance: function variance(alpha, beta) {
            return alpha * beta / (Math2.pow(alpha + beta, 2) * (alpha + beta + 1));
          }
        });
        jStat2.extend(jStat2.centralF, {
          // This implementation of the pdf function avoids float overflow
          // See the way that R calculates this value:
          // https://svn.r-project.org/R/trunk/src/nmath/df.c
          pdf: function pdf(x2, df1, df2) {
            var p2, q2, f2;
            if (x2 < 0)
              return 0;
            if (df1 <= 2) {
              if (x2 === 0 && df1 < 2) {
                return Infinity;
              }
              if (x2 === 0 && df1 === 2) {
                return 1;
              }
              return 1 / jStat2.betafn(df1 / 2, df2 / 2) * Math2.pow(df1 / df2, df1 / 2) * Math2.pow(x2, df1 / 2 - 1) * Math2.pow(1 + df1 / df2 * x2, -(df1 + df2) / 2);
            }
            p2 = df1 * x2 / (df2 + x2 * df1);
            q2 = df2 / (df2 + x2 * df1);
            f2 = df1 * q2 / 2;
            return f2 * jStat2.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p2);
          },
          cdf: function cdf(x2, df1, df2) {
            if (x2 < 0)
              return 0;
            return jStat2.ibeta(df1 * x2 / (df1 * x2 + df2), df1 / 2, df2 / 2);
          },
          inv: function inv(x2, df1, df2) {
            return df2 / (df1 * (1 / jStat2.ibetainv(x2, df1 / 2, df2 / 2) - 1));
          },
          mean: function mean(df1, df2) {
            return df2 > 2 ? df2 / (df2 - 2) : void 0;
          },
          mode: function mode(df1, df2) {
            return df1 > 2 ? df2 * (df1 - 2) / (df1 * (df2 + 2)) : void 0;
          },
          // return a random sample
          sample: function sample(df1, df2) {
            var x1 = jStat2.randg(df1 / 2) * 2;
            var x2 = jStat2.randg(df2 / 2) * 2;
            return x1 / df1 / (x2 / df2);
          },
          variance: function variance(df1, df2) {
            if (df2 <= 4)
              return void 0;
            return 2 * df2 * df2 * (df1 + df2 - 2) / (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
          }
        });
        jStat2.extend(jStat2.cauchy, {
          pdf: function pdf(x2, local, scale) {
            if (scale < 0) {
              return 0;
            }
            return scale / (Math2.pow(x2 - local, 2) + Math2.pow(scale, 2)) / Math2.PI;
          },
          cdf: function cdf(x2, local, scale) {
            return Math2.atan((x2 - local) / scale) / Math2.PI + 0.5;
          },
          inv: function(p2, local, scale) {
            return local + scale * Math2.tan(Math2.PI * (p2 - 0.5));
          },
          median: function median(local) {
            return local;
          },
          mode: function mode(local) {
            return local;
          },
          sample: function sample(local, scale) {
            return jStat2.randn() * Math2.sqrt(1 / (2 * jStat2.randg(0.5))) * scale + local;
          }
        });
        jStat2.extend(jStat2.chisquare, {
          pdf: function pdf(x2, dof) {
            if (x2 < 0)
              return 0;
            return x2 === 0 && dof === 2 ? 0.5 : Math2.exp((dof / 2 - 1) * Math2.log(x2) - x2 / 2 - dof / 2 * Math2.log(2) - jStat2.gammaln(dof / 2));
          },
          cdf: function cdf(x2, dof) {
            if (x2 < 0)
              return 0;
            return jStat2.lowRegGamma(dof / 2, x2 / 2);
          },
          inv: function(p2, dof) {
            return 2 * jStat2.gammapinv(p2, 0.5 * dof);
          },
          mean: function(dof) {
            return dof;
          },
          // TODO: this is an approximation (is there a better way?)
          median: function median(dof) {
            return dof * Math2.pow(1 - 2 / (9 * dof), 3);
          },
          mode: function mode(dof) {
            return dof - 2 > 0 ? dof - 2 : 0;
          },
          sample: function sample(dof) {
            return jStat2.randg(dof / 2) * 2;
          },
          variance: function variance(dof) {
            return 2 * dof;
          }
        });
        jStat2.extend(jStat2.exponential, {
          pdf: function pdf(x2, rate) {
            return x2 < 0 ? 0 : rate * Math2.exp(-rate * x2);
          },
          cdf: function cdf(x2, rate) {
            return x2 < 0 ? 0 : 1 - Math2.exp(-rate * x2);
          },
          inv: function(p2, rate) {
            return -Math2.log(1 - p2) / rate;
          },
          mean: function(rate) {
            return 1 / rate;
          },
          median: function(rate) {
            return 1 / rate * Math2.log(2);
          },
          mode: function mode() {
            return 0;
          },
          sample: function sample(rate) {
            return -1 / rate * Math2.log(jStat2._random_fn());
          },
          variance: function(rate) {
            return Math2.pow(rate, -2);
          }
        });
        jStat2.extend(jStat2.gamma, {
          pdf: function pdf(x2, shape, scale) {
            if (x2 < 0)
              return 0;
            return x2 === 0 && shape === 1 ? 1 / scale : Math2.exp((shape - 1) * Math2.log(x2) - x2 / scale - jStat2.gammaln(shape) - shape * Math2.log(scale));
          },
          cdf: function cdf(x2, shape, scale) {
            if (x2 < 0)
              return 0;
            return jStat2.lowRegGamma(shape, x2 / scale);
          },
          inv: function(p2, shape, scale) {
            return jStat2.gammapinv(p2, shape) * scale;
          },
          mean: function(shape, scale) {
            return shape * scale;
          },
          mode: function mode(shape, scale) {
            if (shape > 1) return (shape - 1) * scale;
            return void 0;
          },
          sample: function sample(shape, scale) {
            return jStat2.randg(shape) * scale;
          },
          variance: function variance(shape, scale) {
            return shape * scale * scale;
          }
        });
        jStat2.extend(jStat2.invgamma, {
          pdf: function pdf(x2, shape, scale) {
            if (x2 <= 0)
              return 0;
            return Math2.exp(-(shape + 1) * Math2.log(x2) - scale / x2 - jStat2.gammaln(shape) + shape * Math2.log(scale));
          },
          cdf: function cdf(x2, shape, scale) {
            if (x2 <= 0)
              return 0;
            return 1 - jStat2.lowRegGamma(shape, scale / x2);
          },
          inv: function(p2, shape, scale) {
            return scale / jStat2.gammapinv(1 - p2, shape);
          },
          mean: function(shape, scale) {
            return shape > 1 ? scale / (shape - 1) : void 0;
          },
          mode: function mode(shape, scale) {
            return scale / (shape + 1);
          },
          sample: function sample(shape, scale) {
            return scale / jStat2.randg(shape);
          },
          variance: function variance(shape, scale) {
            if (shape <= 2)
              return void 0;
            return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
          }
        });
        jStat2.extend(jStat2.kumaraswamy, {
          pdf: function pdf(x2, alpha, beta) {
            if (x2 === 0 && alpha === 1)
              return beta;
            else if (x2 === 1 && beta === 1)
              return alpha;
            return Math2.exp(Math2.log(alpha) + Math2.log(beta) + (alpha - 1) * Math2.log(x2) + (beta - 1) * Math2.log(1 - Math2.pow(x2, alpha)));
          },
          cdf: function cdf(x2, alpha, beta) {
            if (x2 < 0)
              return 0;
            else if (x2 > 1)
              return 1;
            return 1 - Math2.pow(1 - Math2.pow(x2, alpha), beta);
          },
          inv: function inv(p2, alpha, beta) {
            return Math2.pow(1 - Math2.pow(1 - p2, 1 / beta), 1 / alpha);
          },
          mean: function(alpha, beta) {
            return beta * jStat2.gammafn(1 + 1 / alpha) * jStat2.gammafn(beta) / jStat2.gammafn(1 + 1 / alpha + beta);
          },
          median: function median(alpha, beta) {
            return Math2.pow(1 - Math2.pow(2, -1 / beta), 1 / alpha);
          },
          mode: function mode(alpha, beta) {
            if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
              return void 0;
            return Math2.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
          },
          variance: function variance() {
            throw new Error("variance not yet implemented");
          }
        });
        jStat2.extend(jStat2.lognormal, {
          pdf: function pdf(x2, mu, sigma) {
            if (x2 <= 0)
              return 0;
            return Math2.exp(-Math2.log(x2) - 0.5 * Math2.log(2 * Math2.PI) - Math2.log(sigma) - Math2.pow(Math2.log(x2) - mu, 2) / (2 * sigma * sigma));
          },
          cdf: function cdf(x2, mu, sigma) {
            if (x2 < 0)
              return 0;
            return 0.5 + 0.5 * jStat2.erf((Math2.log(x2) - mu) / Math2.sqrt(2 * sigma * sigma));
          },
          inv: function(p2, mu, sigma) {
            return Math2.exp(-1.4142135623730951 * sigma * jStat2.erfcinv(2 * p2) + mu);
          },
          mean: function mean(mu, sigma) {
            return Math2.exp(mu + sigma * sigma / 2);
          },
          median: function median(mu) {
            return Math2.exp(mu);
          },
          mode: function mode(mu, sigma) {
            return Math2.exp(mu - sigma * sigma);
          },
          sample: function sample(mu, sigma) {
            return Math2.exp(jStat2.randn() * sigma + mu);
          },
          variance: function variance(mu, sigma) {
            return (Math2.exp(sigma * sigma) - 1) * Math2.exp(2 * mu + sigma * sigma);
          }
        });
        jStat2.extend(jStat2.noncentralt, {
          pdf: function pdf(x2, dof, ncp) {
            var tol = 1e-14;
            if (Math2.abs(ncp) < tol)
              return jStat2.studentt.pdf(x2, dof);
            if (Math2.abs(x2) < tol) {
              return Math2.exp(jStat2.gammaln((dof + 1) / 2) - ncp * ncp / 2 - 0.5 * Math2.log(Math2.PI * dof) - jStat2.gammaln(dof / 2));
            }
            return dof / x2 * (jStat2.noncentralt.cdf(x2 * Math2.sqrt(1 + 2 / dof), dof + 2, ncp) - jStat2.noncentralt.cdf(x2, dof, ncp));
          },
          cdf: function cdf(x2, dof, ncp) {
            var tol = 1e-14;
            var min_iterations = 200;
            if (Math2.abs(ncp) < tol)
              return jStat2.studentt.cdf(x2, dof);
            var flip = false;
            if (x2 < 0) {
              flip = true;
              ncp = -ncp;
            }
            var prob = jStat2.normal.cdf(-ncp, 0, 1);
            var value = tol + 1;
            var lastvalue = value;
            var y2 = x2 * x2 / (x2 * x2 + dof);
            var j2 = 0;
            var p2 = Math2.exp(-ncp * ncp / 2);
            var q2 = Math2.exp(-ncp * ncp / 2 - 0.5 * Math2.log(2) - jStat2.gammaln(3 / 2)) * ncp;
            while (j2 < min_iterations || lastvalue > tol || value > tol) {
              lastvalue = value;
              if (j2 > 0) {
                p2 *= ncp * ncp / (2 * j2);
                q2 *= ncp * ncp / (2 * (j2 + 1 / 2));
              }
              value = p2 * jStat2.beta.cdf(y2, j2 + 0.5, dof / 2) + q2 * jStat2.beta.cdf(y2, j2 + 1, dof / 2);
              prob += 0.5 * value;
              j2++;
            }
            return flip ? 1 - prob : prob;
          }
        });
        jStat2.extend(jStat2.normal, {
          pdf: function pdf(x2, mean, std) {
            return Math2.exp(-0.5 * Math2.log(2 * Math2.PI) - Math2.log(std) - Math2.pow(x2 - mean, 2) / (2 * std * std));
          },
          cdf: function cdf(x2, mean, std) {
            return 0.5 * (1 + jStat2.erf((x2 - mean) / Math2.sqrt(2 * std * std)));
          },
          inv: function(p2, mean, std) {
            return -1.4142135623730951 * std * jStat2.erfcinv(2 * p2) + mean;
          },
          mean: function(mean) {
            return mean;
          },
          median: function median(mean) {
            return mean;
          },
          mode: function(mean) {
            return mean;
          },
          sample: function sample(mean, std) {
            return jStat2.randn() * std + mean;
          },
          variance: function(mean, std) {
            return std * std;
          }
        });
        jStat2.extend(jStat2.pareto, {
          pdf: function pdf(x2, scale, shape) {
            if (x2 < scale)
              return 0;
            return shape * Math2.pow(scale, shape) / Math2.pow(x2, shape + 1);
          },
          cdf: function cdf(x2, scale, shape) {
            if (x2 < scale)
              return 0;
            return 1 - Math2.pow(scale / x2, shape);
          },
          inv: function inv(p2, scale, shape) {
            return scale / Math2.pow(1 - p2, 1 / shape);
          },
          mean: function mean(scale, shape) {
            if (shape <= 1)
              return void 0;
            return shape * Math2.pow(scale, shape) / (shape - 1);
          },
          median: function median(scale, shape) {
            return scale * (shape * Math2.SQRT2);
          },
          mode: function mode(scale) {
            return scale;
          },
          variance: function(scale, shape) {
            if (shape <= 2)
              return void 0;
            return scale * scale * shape / (Math2.pow(shape - 1, 2) * (shape - 2));
          }
        });
        jStat2.extend(jStat2.studentt, {
          pdf: function pdf(x2, dof) {
            dof = dof > 1e100 ? 1e100 : dof;
            return 1 / (Math2.sqrt(dof) * jStat2.betafn(0.5, dof / 2)) * Math2.pow(1 + x2 * x2 / dof, -((dof + 1) / 2));
          },
          cdf: function cdf(x2, dof) {
            var dof2 = dof / 2;
            return jStat2.ibeta((x2 + Math2.sqrt(x2 * x2 + dof)) / (2 * Math2.sqrt(x2 * x2 + dof)), dof2, dof2);
          },
          inv: function(p2, dof) {
            var x2 = jStat2.ibetainv(2 * Math2.min(p2, 1 - p2), 0.5 * dof, 0.5);
            x2 = Math2.sqrt(dof * (1 - x2) / x2);
            return p2 > 0.5 ? x2 : -x2;
          },
          mean: function mean(dof) {
            return dof > 1 ? 0 : void 0;
          },
          median: function median() {
            return 0;
          },
          mode: function mode() {
            return 0;
          },
          sample: function sample(dof) {
            return jStat2.randn() * Math2.sqrt(dof / (2 * jStat2.randg(dof / 2)));
          },
          variance: function variance(dof) {
            return dof > 2 ? dof / (dof - 2) : dof > 1 ? Infinity : void 0;
          }
        });
        jStat2.extend(jStat2.weibull, {
          pdf: function pdf(x2, scale, shape) {
            if (x2 < 0 || scale < 0 || shape < 0)
              return 0;
            return shape / scale * Math2.pow(x2 / scale, shape - 1) * Math2.exp(-Math2.pow(x2 / scale, shape));
          },
          cdf: function cdf(x2, scale, shape) {
            return x2 < 0 ? 0 : 1 - Math2.exp(-Math2.pow(x2 / scale, shape));
          },
          inv: function(p2, scale, shape) {
            return scale * Math2.pow(-Math2.log(1 - p2), 1 / shape);
          },
          mean: function(scale, shape) {
            return scale * jStat2.gammafn(1 + 1 / shape);
          },
          median: function median(scale, shape) {
            return scale * Math2.pow(Math2.log(2), 1 / shape);
          },
          mode: function mode(scale, shape) {
            if (shape <= 1)
              return 0;
            return scale * Math2.pow((shape - 1) / shape, 1 / shape);
          },
          sample: function sample(scale, shape) {
            return scale * Math2.pow(-Math2.log(jStat2._random_fn()), 1 / shape);
          },
          variance: function variance(scale, shape) {
            return scale * scale * jStat2.gammafn(1 + 2 / shape) - Math2.pow(jStat2.weibull.mean(scale, shape), 2);
          }
        });
        jStat2.extend(jStat2.uniform, {
          pdf: function pdf(x2, a2, b2) {
            return x2 < a2 || x2 > b2 ? 0 : 1 / (b2 - a2);
          },
          cdf: function cdf(x2, a2, b2) {
            if (x2 < a2)
              return 0;
            else if (x2 < b2)
              return (x2 - a2) / (b2 - a2);
            return 1;
          },
          inv: function(p2, a2, b2) {
            return a2 + p2 * (b2 - a2);
          },
          mean: function mean(a2, b2) {
            return 0.5 * (a2 + b2);
          },
          median: function median(a2, b2) {
            return jStat2.mean(a2, b2);
          },
          mode: function mode() {
            throw new Error("mode is not yet implemented");
          },
          sample: function sample(a2, b2) {
            return a2 / 2 + b2 / 2 + (b2 / 2 - a2 / 2) * (2 * jStat2._random_fn() - 1);
          },
          variance: function variance(a2, b2) {
            return Math2.pow(b2 - a2, 2) / 12;
          }
        });
        function betinc(x2, a2, b2, eps) {
          var a0 = 0;
          var b0 = 1;
          var a1 = 1;
          var b1 = 1;
          var m9 = 0;
          var a22 = 0;
          var c9;
          while (Math2.abs((a1 - a22) / a1) > eps) {
            a22 = a1;
            c9 = -(a2 + m9) * (a2 + b2 + m9) * x2 / (a2 + 2 * m9) / (a2 + 2 * m9 + 1);
            a0 = a1 + c9 * a0;
            b0 = b1 + c9 * b0;
            m9 = m9 + 1;
            c9 = m9 * (b2 - m9) * x2 / (a2 + 2 * m9 - 1) / (a2 + 2 * m9);
            a1 = a0 + c9 * a1;
            b1 = b0 + c9 * b1;
            a0 = a0 / b1;
            b0 = b0 / b1;
            a1 = a1 / b1;
            b1 = 1;
          }
          return a1 / a2;
        }
        jStat2.extend(jStat2.binomial, {
          pdf: function pdf(k2, n2, p2) {
            return p2 === 0 || p2 === 1 ? n2 * p2 === k2 ? 1 : 0 : jStat2.combination(n2, k2) * Math2.pow(p2, k2) * Math2.pow(1 - p2, n2 - k2);
          },
          cdf: function cdf(x2, n2, p2) {
            var betacdf;
            var eps = 1e-10;
            if (x2 < 0)
              return 0;
            if (x2 >= n2)
              return 1;
            if (p2 < 0 || p2 > 1 || n2 <= 0)
              return NaN;
            x2 = Math2.floor(x2);
            var z2 = p2;
            var a2 = x2 + 1;
            var b2 = n2 - x2;
            var s2 = a2 + b2;
            var bt = Math2.exp(jStat2.gammaln(s2) - jStat2.gammaln(b2) - jStat2.gammaln(a2) + a2 * Math2.log(z2) + b2 * Math2.log(1 - z2));
            if (z2 < (a2 + 1) / (s2 + 2))
              betacdf = bt * betinc(z2, a2, b2, eps);
            else
              betacdf = 1 - bt * betinc(1 - z2, b2, a2, eps);
            return Math2.round((1 - betacdf) * (1 / eps)) / (1 / eps);
          }
        });
        jStat2.extend(jStat2.negbin, {
          pdf: function pdf(k2, r2, p2) {
            if (k2 !== k2 >>> 0)
              return false;
            if (k2 < 0)
              return 0;
            return jStat2.combination(k2 + r2 - 1, r2 - 1) * Math2.pow(1 - p2, k2) * Math2.pow(p2, r2);
          },
          cdf: function cdf(x2, r2, p2) {
            var sum = 0, k2 = 0;
            if (x2 < 0) return 0;
            for (; k2 <= x2; k2++) {
              sum += jStat2.negbin.pdf(k2, r2, p2);
            }
            return sum;
          }
        });
        jStat2.extend(jStat2.hypgeom, {
          pdf: function pdf(k2, N2, m2, n2) {
            if (k2 !== k2 | 0) {
              return false;
            } else if (k2 < 0 || k2 < m2 - (N2 - n2)) {
              return 0;
            } else if (k2 > n2 || k2 > m2) {
              return 0;
            } else if (m2 * 2 > N2) {
              if (n2 * 2 > N2) {
                return jStat2.hypgeom.pdf(N2 - m2 - n2 + k2, N2, N2 - m2, N2 - n2);
              } else {
                return jStat2.hypgeom.pdf(n2 - k2, N2, N2 - m2, n2);
              }
            } else if (n2 * 2 > N2) {
              return jStat2.hypgeom.pdf(m2 - k2, N2, m2, N2 - n2);
            } else if (m2 < n2) {
              return jStat2.hypgeom.pdf(k2, N2, n2, m2);
            } else {
              var scaledPDF = 1;
              var samplesDone = 0;
              for (var i2 = 0; i2 < k2; i2++) {
                while (scaledPDF > 1 && samplesDone < n2) {
                  scaledPDF *= 1 - m2 / (N2 - samplesDone);
                  samplesDone++;
                }
                scaledPDF *= (n2 - i2) * (m2 - i2) / ((i2 + 1) * (N2 - m2 - n2 + i2 + 1));
              }
              for (; samplesDone < n2; samplesDone++) {
                scaledPDF *= 1 - m2 / (N2 - samplesDone);
              }
              return Math2.min(1, Math2.max(0, scaledPDF));
            }
          },
          cdf: function cdf(x2, N2, m2, n2) {
            if (x2 < 0 || x2 < m2 - (N2 - n2)) {
              return 0;
            } else if (x2 >= n2 || x2 >= m2) {
              return 1;
            } else if (m2 * 2 > N2) {
              if (n2 * 2 > N2) {
                return jStat2.hypgeom.cdf(N2 - m2 - n2 + x2, N2, N2 - m2, N2 - n2);
              } else {
                return 1 - jStat2.hypgeom.cdf(n2 - x2 - 1, N2, N2 - m2, n2);
              }
            } else if (n2 * 2 > N2) {
              return 1 - jStat2.hypgeom.cdf(m2 - x2 - 1, N2, m2, N2 - n2);
            } else if (m2 < n2) {
              return jStat2.hypgeom.cdf(x2, N2, n2, m2);
            } else {
              var scaledCDF = 1;
              var scaledPDF = 1;
              var samplesDone = 0;
              for (var i2 = 0; i2 < x2; i2++) {
                while (scaledCDF > 1 && samplesDone < n2) {
                  var factor = 1 - m2 / (N2 - samplesDone);
                  scaledPDF *= factor;
                  scaledCDF *= factor;
                  samplesDone++;
                }
                scaledPDF *= (n2 - i2) * (m2 - i2) / ((i2 + 1) * (N2 - m2 - n2 + i2 + 1));
                scaledCDF += scaledPDF;
              }
              for (; samplesDone < n2; samplesDone++) {
                scaledCDF *= 1 - m2 / (N2 - samplesDone);
              }
              return Math2.min(1, Math2.max(0, scaledCDF));
            }
          }
        });
        jStat2.extend(jStat2.poisson, {
          pdf: function pdf(k2, l2) {
            if (l2 < 0 || k2 % 1 !== 0 || k2 < 0) {
              return 0;
            }
            return Math2.pow(l2, k2) * Math2.exp(-l2) / jStat2.factorial(k2);
          },
          cdf: function cdf(x2, l2) {
            var sumarr = [], k2 = 0;
            if (x2 < 0) return 0;
            for (; k2 <= x2; k2++) {
              sumarr.push(jStat2.poisson.pdf(k2, l2));
            }
            return jStat2.sum(sumarr);
          },
          mean: function(l2) {
            return l2;
          },
          variance: function(l2) {
            return l2;
          },
          sampleSmall: function sampleSmall(l2) {
            var p2 = 1, k2 = 0, L2 = Math2.exp(-l2);
            do {
              k2++;
              p2 *= jStat2._random_fn();
            } while (p2 > L2);
            return k2 - 1;
          },
          sampleLarge: function sampleLarge(l2) {
            var lam = l2;
            var k2;
            var U2, V2, slam, loglam, a2, b2, invalpha, vr, us;
            slam = Math2.sqrt(lam);
            loglam = Math2.log(lam);
            b2 = 0.931 + 2.53 * slam;
            a2 = -0.059 + 0.02483 * b2;
            invalpha = 1.1239 + 1.1328 / (b2 - 3.4);
            vr = 0.9277 - 3.6224 / (b2 - 2);
            while (1) {
              U2 = Math2.random() - 0.5;
              V2 = Math2.random();
              us = 0.5 - Math2.abs(U2);
              k2 = Math2.floor((2 * a2 / us + b2) * U2 + lam + 0.43);
              if (us >= 0.07 && V2 <= vr) {
                return k2;
              }
              if (k2 < 0 || us < 0.013 && V2 > us) {
                continue;
              }
              if (Math2.log(V2) + Math2.log(invalpha) - Math2.log(a2 / (us * us) + b2) <= -lam + k2 * loglam - jStat2.loggam(k2 + 1)) {
                return k2;
              }
            }
          },
          sample: function sample(l2) {
            if (l2 < 10)
              return this.sampleSmall(l2);
            else
              return this.sampleLarge(l2);
          }
        });
        jStat2.extend(jStat2.triangular, {
          pdf: function pdf(x2, a2, b2, c2) {
            if (b2 <= a2 || c2 < a2 || c2 > b2) {
              return NaN;
            } else {
              if (x2 < a2 || x2 > b2) {
                return 0;
              } else if (x2 < c2) {
                return 2 * (x2 - a2) / ((b2 - a2) * (c2 - a2));
              } else if (x2 === c2) {
                return 2 / (b2 - a2);
              } else {
                return 2 * (b2 - x2) / ((b2 - a2) * (b2 - c2));
              }
            }
          },
          cdf: function cdf(x2, a2, b2, c2) {
            if (b2 <= a2 || c2 < a2 || c2 > b2)
              return NaN;
            if (x2 <= a2)
              return 0;
            else if (x2 >= b2)
              return 1;
            if (x2 <= c2)
              return Math2.pow(x2 - a2, 2) / ((b2 - a2) * (c2 - a2));
            else
              return 1 - Math2.pow(b2 - x2, 2) / ((b2 - a2) * (b2 - c2));
          },
          inv: function inv(p2, a2, b2, c2) {
            if (b2 <= a2 || c2 < a2 || c2 > b2) {
              return NaN;
            } else {
              if (p2 <= (c2 - a2) / (b2 - a2)) {
                return a2 + (b2 - a2) * Math2.sqrt(p2 * ((c2 - a2) / (b2 - a2)));
              } else {
                return a2 + (b2 - a2) * (1 - Math2.sqrt((1 - p2) * (1 - (c2 - a2) / (b2 - a2))));
              }
            }
          },
          mean: function mean(a2, b2, c2) {
            return (a2 + b2 + c2) / 3;
          },
          median: function median(a2, b2, c2) {
            if (c2 <= (a2 + b2) / 2) {
              return b2 - Math2.sqrt((b2 - a2) * (b2 - c2)) / Math2.sqrt(2);
            } else if (c2 > (a2 + b2) / 2) {
              return a2 + Math2.sqrt((b2 - a2) * (c2 - a2)) / Math2.sqrt(2);
            }
          },
          mode: function mode(a2, b2, c2) {
            return c2;
          },
          sample: function sample(a2, b2, c2) {
            var u2 = jStat2._random_fn();
            if (u2 < (c2 - a2) / (b2 - a2))
              return a2 + Math2.sqrt(u2 * (b2 - a2) * (c2 - a2));
            return b2 - Math2.sqrt((1 - u2) * (b2 - a2) * (b2 - c2));
          },
          variance: function variance(a2, b2, c2) {
            return (a2 * a2 + b2 * b2 + c2 * c2 - a2 * b2 - a2 * c2 - b2 * c2) / 18;
          }
        });
        jStat2.extend(jStat2.arcsine, {
          pdf: function pdf(x2, a2, b2) {
            if (b2 <= a2) return NaN;
            return x2 <= a2 || x2 >= b2 ? 0 : 2 / Math2.PI * Math2.pow(Math2.pow(b2 - a2, 2) - Math2.pow(2 * x2 - a2 - b2, 2), -0.5);
          },
          cdf: function cdf(x2, a2, b2) {
            if (x2 < a2)
              return 0;
            else if (x2 < b2)
              return 2 / Math2.PI * Math2.asin(Math2.sqrt((x2 - a2) / (b2 - a2)));
            return 1;
          },
          inv: function(p2, a2, b2) {
            return a2 + (0.5 - 0.5 * Math2.cos(Math2.PI * p2)) * (b2 - a2);
          },
          mean: function mean(a2, b2) {
            if (b2 <= a2) return NaN;
            return (a2 + b2) / 2;
          },
          median: function median(a2, b2) {
            if (b2 <= a2) return NaN;
            return (a2 + b2) / 2;
          },
          mode: function mode() {
            throw new Error("mode is not yet implemented");
          },
          sample: function sample(a2, b2) {
            return (a2 + b2) / 2 + (b2 - a2) / 2 * Math2.sin(2 * Math2.PI * jStat2.uniform.sample(0, 1));
          },
          variance: function variance(a2, b2) {
            if (b2 <= a2) return NaN;
            return Math2.pow(b2 - a2, 2) / 8;
          }
        });
        function laplaceSign(x2) {
          return x2 / Math2.abs(x2);
        }
        jStat2.extend(jStat2.laplace, {
          pdf: function pdf(x2, mu, b2) {
            return b2 <= 0 ? 0 : Math2.exp(-Math2.abs(x2 - mu) / b2) / (2 * b2);
          },
          cdf: function cdf(x2, mu, b2) {
            if (b2 <= 0) {
              return 0;
            }
            if (x2 < mu) {
              return 0.5 * Math2.exp((x2 - mu) / b2);
            } else {
              return 1 - 0.5 * Math2.exp(-(x2 - mu) / b2);
            }
          },
          mean: function(mu) {
            return mu;
          },
          median: function(mu) {
            return mu;
          },
          mode: function(mu) {
            return mu;
          },
          variance: function(mu, b2) {
            return 2 * b2 * b2;
          },
          sample: function sample(mu, b2) {
            var u2 = jStat2._random_fn() - 0.5;
            return mu - b2 * laplaceSign(u2) * Math2.log(1 - 2 * Math2.abs(u2));
          }
        });
        function tukeyWprob(w2, rr, cc2) {
          var nleg = 12;
          var ihalf = 6;
          var C1 = -30;
          var C2 = -50;
          var C3 = 60;
          var bb2 = 8;
          var wlar = 3;
          var wincr1 = 2;
          var wincr2 = 3;
          var xleg = [
            0.9815606342467192,
            0.9041172563704749,
            0.7699026741943047,
            0.5873179542866175,
            0.3678314989981802,
            0.1252334085114689
          ];
          var aleg = [
            0.04717533638651183,
            0.10693932599531843,
            0.16007832854334622,
            0.20316742672306592,
            0.2334925365383548,
            0.24914704581340277
          ];
          var qsqz = w2 * 0.5;
          if (qsqz >= bb2)
            return 1;
          var pr_w = 2 * jStat2.normal.cdf(qsqz, 0, 1, 1, 0) - 1;
          if (pr_w >= Math2.exp(C2 / cc2))
            pr_w = Math2.pow(pr_w, cc2);
          else
            pr_w = 0;
          var wincr;
          if (w2 > wlar)
            wincr = wincr1;
          else
            wincr = wincr2;
          var blb = qsqz;
          var binc = (bb2 - qsqz) / wincr;
          var bub = blb + binc;
          var einsum = 0;
          var cc1 = cc2 - 1;
          for (var wi2 = 1; wi2 <= wincr; wi2++) {
            var elsum = 0;
            var a2 = 0.5 * (bub + blb);
            var b2 = 0.5 * (bub - blb);
            for (var jj2 = 1; jj2 <= nleg; jj2++) {
              var j2, xx;
              if (ihalf < jj2) {
                j2 = nleg - jj2 + 1;
                xx = xleg[j2 - 1];
              } else {
                j2 = jj2;
                xx = -xleg[j2 - 1];
              }
              var c2 = b2 * xx;
              var ac2 = a2 + c2;
              var qexpo = ac2 * ac2;
              if (qexpo > C3)
                break;
              var pplus = 2 * jStat2.normal.cdf(ac2, 0, 1, 1, 0);
              var pminus = 2 * jStat2.normal.cdf(ac2, w2, 1, 1, 0);
              var rinsum = pplus * 0.5 - pminus * 0.5;
              if (rinsum >= Math2.exp(C1 / cc1)) {
                rinsum = aleg[j2 - 1] * Math2.exp(-(0.5 * qexpo)) * Math2.pow(rinsum, cc1);
                elsum += rinsum;
              }
            }
            elsum *= 2 * b2 * cc2 / Math2.sqrt(2 * Math2.PI);
            einsum += elsum;
            blb = bub;
            bub += binc;
          }
          pr_w += einsum;
          if (pr_w <= Math2.exp(C1 / rr))
            return 0;
          pr_w = Math2.pow(pr_w, rr);
          if (pr_w >= 1)
            return 1;
          return pr_w;
        }
        function tukeyQinv(p2, c2, v2) {
          var p0 = 0.322232421088;
          var q0 = 0.099348462606;
          var p1 = -1;
          var q1 = 0.588581570495;
          var p22 = -0.342242088547;
          var q2 = 0.531103462366;
          var p3 = -0.204231210125;
          var q3 = 0.10353775285;
          var p4 = -453642210148e-16;
          var q4 = 0.0038560700634;
          var c1 = 0.8832;
          var c22 = 0.2368;
          var c4 = 1.208;
          var c5 = 1.4142;
          var vmax = 120;
          var ps = 0.5 - 0.5 * p2;
          var yi2 = Math2.sqrt(Math2.log(1 / (ps * ps)));
          var t2 = yi2 + ((((yi2 * p4 + p3) * yi2 + p22) * yi2 + p1) * yi2 + p0) / ((((yi2 * q4 + q3) * yi2 + q2) * yi2 + q1) * yi2 + q0);
          if (v2 < vmax) t2 += (t2 * t2 * t2 + t2) / v2 / 4;
          var q5 = c1 - c22 * t2;
          if (v2 < vmax) q5 += -1.214 / v2 + c4 * t2 / v2;
          return t2 * (q5 * Math2.log(c2 - 1) + c5);
        }
        jStat2.extend(jStat2.tukey, {
          cdf: function cdf(q2, nmeans, df2) {
            var rr = 1;
            var cc2 = nmeans;
            var nlegq = 16;
            var ihalfq = 8;
            var eps1 = -30;
            var eps2 = 1e-14;
            var dhaf = 100;
            var dquar = 800;
            var deigh = 5e3;
            var dlarg = 25e3;
            var ulen1 = 1;
            var ulen2 = 0.5;
            var ulen3 = 0.25;
            var ulen4 = 0.125;
            var xlegq = [
              0.9894009349916499,
              0.9445750230732326,
              0.8656312023878318,
              0.755404408355003,
              0.6178762444026438,
              0.45801677765722737,
              0.2816035507792589,
              0.09501250983763744
            ];
            var alegq = [
              0.027152459411754096,
              0.062253523938647894,
              0.09515851168249279,
              0.12462897125553388,
              0.14959598881657674,
              0.16915651939500254,
              0.18260341504492358,
              0.1894506104550685
            ];
            if (q2 <= 0)
              return 0;
            if (df2 < 2 || rr < 1 || cc2 < 2) return NaN;
            if (!Number.isFinite(q2))
              return 1;
            if (df2 > dlarg)
              return tukeyWprob(q2, rr, cc2);
            var f2 = df2 * 0.5;
            var f2lf = f2 * Math2.log(df2) - df2 * Math2.log(2) - jStat2.gammaln(f2);
            var f21 = f2 - 1;
            var ff4 = df2 * 0.25;
            var ulen;
            if (df2 <= dhaf) ulen = ulen1;
            else if (df2 <= dquar) ulen = ulen2;
            else if (df2 <= deigh) ulen = ulen3;
            else ulen = ulen4;
            f2lf += Math2.log(ulen);
            var ans = 0;
            for (var i2 = 1; i2 <= 50; i2++) {
              var otsum = 0;
              var twa1 = (2 * i2 - 1) * ulen;
              for (var jj2 = 1; jj2 <= nlegq; jj2++) {
                var j2, t1;
                if (ihalfq < jj2) {
                  j2 = jj2 - ihalfq - 1;
                  t1 = f2lf + f21 * Math2.log(twa1 + xlegq[j2] * ulen) - (xlegq[j2] * ulen + twa1) * ff4;
                } else {
                  j2 = jj2 - 1;
                  t1 = f2lf + f21 * Math2.log(twa1 - xlegq[j2] * ulen) + (xlegq[j2] * ulen - twa1) * ff4;
                }
                var qsqz;
                if (t1 >= eps1) {
                  if (ihalfq < jj2) {
                    qsqz = q2 * Math2.sqrt((xlegq[j2] * ulen + twa1) * 0.5);
                  } else {
                    qsqz = q2 * Math2.sqrt((-(xlegq[j2] * ulen) + twa1) * 0.5);
                  }
                  var wprb = tukeyWprob(qsqz, rr, cc2);
                  var rotsum = wprb * alegq[j2] * Math2.exp(t1);
                  otsum += rotsum;
                }
              }
              if (i2 * ulen >= 1 && otsum <= eps2)
                break;
              ans += otsum;
            }
            if (otsum > eps2) {
              throw new Error("tukey.cdf failed to converge");
            }
            if (ans > 1)
              ans = 1;
            return ans;
          },
          inv: function(p2, nmeans, df2) {
            var rr = 1;
            var cc2 = nmeans;
            var eps = 1e-4;
            var maxiter = 50;
            if (df2 < 2 || rr < 1 || cc2 < 2) return NaN;
            if (p2 < 0 || p2 > 1) return NaN;
            if (p2 === 0) return 0;
            if (p2 === 1) return Infinity;
            var x0 = tukeyQinv(p2, cc2, df2);
            var valx0 = jStat2.tukey.cdf(x0, nmeans, df2) - p2;
            var x1;
            if (valx0 > 0)
              x1 = Math2.max(0, x0 - 1);
            else
              x1 = x0 + 1;
            var valx1 = jStat2.tukey.cdf(x1, nmeans, df2) - p2;
            var ans;
            for (var iter = 1; iter < maxiter; iter++) {
              ans = x1 - valx1 * (x1 - x0) / (valx1 - valx0);
              valx0 = valx1;
              x0 = x1;
              if (ans < 0) {
                ans = 0;
                valx1 = -p2;
              }
              valx1 = jStat2.tukey.cdf(ans, nmeans, df2) - p2;
              x1 = ans;
              var xabs = Math2.abs(x1 - x0);
              if (xabs < eps)
                return ans;
            }
            throw new Error("tukey.inv failed to converge");
          }
        });
      })(jStat, Math);
      (function(jStat2, Math2) {
        var push = Array.prototype.push;
        var isArray = jStat2.utils.isArray;
        function isUsable(arg) {
          return isArray(arg) || arg instanceof jStat2;
        }
        jStat2.extend({
          // add a vector/matrix to a vector/matrix or scalar
          add: function add(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.map(arr, function(value, row, col) {
                return value + arg[row][col];
              });
            }
            return jStat2.map(arr, function(value) {
              return value + arg;
            });
          },
          // subtract a vector or scalar from the vector
          subtract: function subtract(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.map(arr, function(value, row, col) {
                return value - arg[row][col] || 0;
              });
            }
            return jStat2.map(arr, function(value) {
              return value - arg;
            });
          },
          // matrix division
          divide: function divide(arr, arg) {
            if (isUsable(arg)) {
              if (!isUsable(arg[0])) arg = [arg];
              return jStat2.multiply(arr, jStat2.inv(arg));
            }
            return jStat2.map(arr, function(value) {
              return value / arg;
            });
          },
          // matrix multiplication
          multiply: function multiply(arr, arg) {
            var row, col, nrescols, sum, nrow, ncol, res, rescols;
            if (arr.length === void 0 && arg.length === void 0) {
              return arr * arg;
            }
            nrow = arr.length, ncol = arr[0].length, res = jStat2.zeros(nrow, nrescols = isUsable(arg) ? arg[0].length : ncol), rescols = 0;
            if (isUsable(arg)) {
              for (; rescols < nrescols; rescols++) {
                for (row = 0; row < nrow; row++) {
                  sum = 0;
                  for (col = 0; col < ncol; col++)
                    sum += arr[row][col] * arg[col][rescols];
                  res[row][rescols] = sum;
                }
              }
              return nrow === 1 && rescols === 1 ? res[0][0] : res;
            }
            return jStat2.map(arr, function(value) {
              return value * arg;
            });
          },
          // outer([1,2,3],[4,5,6])
          // ===
          // [[1],[2],[3]] times [[4,5,6]]
          // ->
          // [[4,5,6],[8,10,12],[12,15,18]]
          outer: function outer(A2, B2) {
            return jStat2.multiply(A2.map(function(t2) {
              return [t2];
            }), [B2]);
          },
          // Returns the dot product of two matricies
          dot: function dot(arr, arg) {
            if (!isUsable(arr[0])) arr = [arr];
            if (!isUsable(arg[0])) arg = [arg];
            var left = arr[0].length === 1 && arr.length !== 1 ? jStat2.transpose(arr) : arr, right = arg[0].length === 1 && arg.length !== 1 ? jStat2.transpose(arg) : arg, res = [], row = 0, nrow = left.length, ncol = left[0].length, sum, col;
            for (; row < nrow; row++) {
              res[row] = [];
              sum = 0;
              for (col = 0; col < ncol; col++)
                sum += left[row][col] * right[row][col];
              res[row] = sum;
            }
            return res.length === 1 ? res[0] : res;
          },
          // raise every element by a scalar
          pow: function pow(arr, arg) {
            return jStat2.map(arr, function(value) {
              return Math2.pow(value, arg);
            });
          },
          // exponentiate every element
          exp: function exp(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.exp(value);
            });
          },
          // generate the natural log of every element
          log: function exp(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.log(value);
            });
          },
          // generate the absolute values of the vector
          abs: function abs(arr) {
            return jStat2.map(arr, function(value) {
              return Math2.abs(value);
            });
          },
          // computes the p-norm of the vector
          // In the case that a matrix is passed, uses the first row as the vector
          norm: function norm(arr, p2) {
            var nnorm = 0, i2 = 0;
            if (isNaN(p2)) p2 = 2;
            if (isUsable(arr[0])) arr = arr[0];
            for (; i2 < arr.length; i2++) {
              nnorm += Math2.pow(Math2.abs(arr[i2]), p2);
            }
            return Math2.pow(nnorm, 1 / p2);
          },
          // computes the angle between two vectors in rads
          // In case a matrix is passed, this uses the first row as the vector
          angle: function angle(arr, arg) {
            return Math2.acos(jStat2.dot(arr, arg) / (jStat2.norm(arr) * jStat2.norm(arg)));
          },
          // augment one matrix by another
          // Note: this function returns a matrix, not a jStat object
          aug: function aug(a2, b2) {
            var newarr = [];
            var i2;
            for (i2 = 0; i2 < a2.length; i2++) {
              newarr.push(a2[i2].slice());
            }
            for (i2 = 0; i2 < newarr.length; i2++) {
              push.apply(newarr[i2], b2[i2]);
            }
            return newarr;
          },
          // The inv() function calculates the inverse of a matrix
          // Create the inverse by augmenting the matrix by the identity matrix of the
          // appropriate size, and then use G-J elimination on the augmented matrix.
          inv: function inv(a2) {
            var rows = a2.length;
            var cols = a2[0].length;
            var b2 = jStat2.identity(rows, cols);
            var c2 = jStat2.gauss_jordan(a2, b2);
            var result = [];
            var i2 = 0;
            var j2;
            for (; i2 < rows; i2++) {
              result[i2] = [];
              for (j2 = cols; j2 < c2[0].length; j2++)
                result[i2][j2 - cols] = c2[i2][j2];
            }
            return result;
          },
          // calculate the determinant of a matrix
          det: function det(a2) {
            if (a2.length === 2) {
              return a2[0][0] * a2[1][1] - a2[0][1] * a2[1][0];
            }
            var determinant = 0;
            for (var i2 = 0; i2 < a2.length; i2++) {
              var submatrix = [];
              for (var row = 1; row < a2.length; row++) {
                submatrix[row - 1] = [];
                for (var col = 0; col < a2.length; col++) {
                  if (col < i2) {
                    submatrix[row - 1][col] = a2[row][col];
                  } else if (col > i2) {
                    submatrix[row - 1][col - 1] = a2[row][col];
                  }
                }
              }
              var sign = i2 % 2 ? -1 : 1;
              determinant += det(submatrix) * a2[0][i2] * sign;
            }
            return determinant;
          },
          gauss_elimination: function gauss_elimination(a2, b2) {
            var i2 = 0, j2 = 0, n2 = a2.length, m2 = a2[0].length, factor = 1, sum = 0, x2 = [], maug, pivot, temp, k2;
            a2 = jStat2.aug(a2, b2);
            maug = a2[0].length;
            for (i2 = 0; i2 < n2; i2++) {
              pivot = a2[i2][i2];
              j2 = i2;
              for (k2 = i2 + 1; k2 < m2; k2++) {
                if (pivot < Math2.abs(a2[k2][i2])) {
                  pivot = a2[k2][i2];
                  j2 = k2;
                }
              }
              if (j2 != i2) {
                for (k2 = 0; k2 < maug; k2++) {
                  temp = a2[i2][k2];
                  a2[i2][k2] = a2[j2][k2];
                  a2[j2][k2] = temp;
                }
              }
              for (j2 = i2 + 1; j2 < n2; j2++) {
                factor = a2[j2][i2] / a2[i2][i2];
                for (k2 = i2; k2 < maug; k2++) {
                  a2[j2][k2] = a2[j2][k2] - factor * a2[i2][k2];
                }
              }
            }
            for (i2 = n2 - 1; i2 >= 0; i2--) {
              sum = 0;
              for (j2 = i2 + 1; j2 <= n2 - 1; j2++) {
                sum = sum + x2[j2] * a2[i2][j2];
              }
              x2[i2] = (a2[i2][maug - 1] - sum) / a2[i2][i2];
            }
            return x2;
          },
          gauss_jordan: function gauss_jordan(a2, b2) {
            var m2 = jStat2.aug(a2, b2);
            var h2 = m2.length;
            var w2 = m2[0].length;
            var c2 = 0;
            var x2, y2, y22;
            for (y2 = 0; y2 < h2; y2++) {
              var maxrow = y2;
              for (y22 = y2 + 1; y22 < h2; y22++) {
                if (Math2.abs(m2[y22][y2]) > Math2.abs(m2[maxrow][y2]))
                  maxrow = y22;
              }
              var tmp = m2[y2];
              m2[y2] = m2[maxrow];
              m2[maxrow] = tmp;
              for (y22 = y2 + 1; y22 < h2; y22++) {
                c2 = m2[y22][y2] / m2[y2][y2];
                for (x2 = y2; x2 < w2; x2++) {
                  m2[y22][x2] -= m2[y2][x2] * c2;
                }
              }
            }
            for (y2 = h2 - 1; y2 >= 0; y2--) {
              c2 = m2[y2][y2];
              for (y22 = 0; y22 < y2; y22++) {
                for (x2 = w2 - 1; x2 > y2 - 1; x2--) {
                  m2[y22][x2] -= m2[y2][x2] * m2[y22][y2] / c2;
                }
              }
              m2[y2][y2] /= c2;
              for (x2 = h2; x2 < w2; x2++) {
                m2[y2][x2] /= c2;
              }
            }
            return m2;
          },
          // solve equation
          // Ax=b
          // A is upper triangular matrix
          // A=[[1,2,3],[0,4,5],[0,6,7]]
          // b=[1,2,3]
          // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]
          // if you use matrix style
          // A=[[1,2,3],[0,4,5],[0,6,7]]
          // b=[[1],[2],[3]]
          // will return [[2.666],[0.1666],[1.666]]
          triaUpSolve: function triaUpSolve(A2, b2) {
            var size2 = A2[0].length;
            var x2 = jStat2.zeros(1, size2)[0];
            var parts;
            var matrix_mode = false;
            if (b2[0].length != void 0) {
              b2 = b2.map(function(i2) {
                return i2[0];
              });
              matrix_mode = true;
            }
            jStat2.arange(size2 - 1, -1, -1).forEach(function(i2) {
              parts = jStat2.arange(i2 + 1, size2).map(function(j2) {
                return x2[j2] * A2[i2][j2];
              });
              x2[i2] = (b2[i2] - jStat2.sum(parts)) / A2[i2][i2];
            });
            if (matrix_mode)
              return x2.map(function(i2) {
                return [i2];
              });
            return x2;
          },
          triaLowSolve: function triaLowSolve(A2, b2) {
            var size2 = A2[0].length;
            var x2 = jStat2.zeros(1, size2)[0];
            var parts;
            var matrix_mode = false;
            if (b2[0].length != void 0) {
              b2 = b2.map(function(i2) {
                return i2[0];
              });
              matrix_mode = true;
            }
            jStat2.arange(size2).forEach(function(i2) {
              parts = jStat2.arange(i2).map(function(j2) {
                return A2[i2][j2] * x2[j2];
              });
              x2[i2] = (b2[i2] - jStat2.sum(parts)) / A2[i2][i2];
            });
            if (matrix_mode)
              return x2.map(function(i2) {
                return [i2];
              });
            return x2;
          },
          // A -> [L,U]
          // A=LU
          // L is lower triangular matrix
          // U is upper triangular matrix
          lu: function lu(A2) {
            var size2 = A2.length;
            var L2 = jStat2.identity(size2);
            var R2 = jStat2.zeros(A2.length, A2[0].length);
            var parts;
            jStat2.arange(size2).forEach(function(t2) {
              R2[0][t2] = A2[0][t2];
            });
            jStat2.arange(1, size2).forEach(function(l2) {
              jStat2.arange(l2).forEach(function(i2) {
                parts = jStat2.arange(i2).map(function(jj2) {
                  return L2[l2][jj2] * R2[jj2][i2];
                });
                L2[l2][i2] = (A2[l2][i2] - jStat2.sum(parts)) / R2[i2][i2];
              });
              jStat2.arange(l2, size2).forEach(function(j2) {
                parts = jStat2.arange(l2).map(function(jj2) {
                  return L2[l2][jj2] * R2[jj2][j2];
                });
                R2[l2][j2] = A2[parts.length][j2] - jStat2.sum(parts);
              });
            });
            return [L2, R2];
          },
          // A -> T
          // A=TT'
          // T is lower triangular matrix
          cholesky: function cholesky(A2) {
            var size2 = A2.length;
            var T2 = jStat2.zeros(A2.length, A2[0].length);
            var parts;
            jStat2.arange(size2).forEach(function(i2) {
              parts = jStat2.arange(i2).map(function(t2) {
                return Math2.pow(T2[i2][t2], 2);
              });
              T2[i2][i2] = Math2.sqrt(A2[i2][i2] - jStat2.sum(parts));
              jStat2.arange(i2 + 1, size2).forEach(function(j2) {
                parts = jStat2.arange(i2).map(function(t2) {
                  return T2[i2][t2] * T2[j2][t2];
                });
                T2[j2][i2] = (A2[i2][j2] - jStat2.sum(parts)) / T2[i2][i2];
              });
            });
            return T2;
          },
          gauss_jacobi: function gauss_jacobi(a2, b2, x2, r2) {
            var i2 = 0;
            var j2 = 0;
            var n2 = a2.length;
            var l2 = [];
            var u2 = [];
            var d2 = [];
            var xv, c2, h2, xk2;
            for (; i2 < n2; i2++) {
              l2[i2] = [];
              u2[i2] = [];
              d2[i2] = [];
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 > j2) {
                  l2[i2][j2] = a2[i2][j2];
                  u2[i2][j2] = d2[i2][j2] = 0;
                } else if (i2 < j2) {
                  u2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = d2[i2][j2] = 0;
                } else {
                  d2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = u2[i2][j2] = 0;
                }
              }
            }
            h2 = jStat2.multiply(jStat2.multiply(jStat2.inv(d2), jStat2.add(l2, u2)), -1);
            c2 = jStat2.multiply(jStat2.inv(d2), b2);
            xv = x2;
            xk2 = jStat2.add(jStat2.multiply(h2, x2), c2);
            i2 = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk2, xv))) > r2) {
              xv = xk2;
              xk2 = jStat2.add(jStat2.multiply(h2, xv), c2);
              i2++;
            }
            return xk2;
          },
          gauss_seidel: function gauss_seidel(a2, b2, x2, r2) {
            var i2 = 0;
            var n2 = a2.length;
            var l2 = [];
            var u2 = [];
            var d2 = [];
            var j2, xv, c2, h2, xk2;
            for (; i2 < n2; i2++) {
              l2[i2] = [];
              u2[i2] = [];
              d2[i2] = [];
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 > j2) {
                  l2[i2][j2] = a2[i2][j2];
                  u2[i2][j2] = d2[i2][j2] = 0;
                } else if (i2 < j2) {
                  u2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = d2[i2][j2] = 0;
                } else {
                  d2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = u2[i2][j2] = 0;
                }
              }
            }
            h2 = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(d2, l2)), u2), -1);
            c2 = jStat2.multiply(jStat2.inv(jStat2.add(d2, l2)), b2);
            xv = x2;
            xk2 = jStat2.add(jStat2.multiply(h2, x2), c2);
            i2 = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk2, xv))) > r2) {
              xv = xk2;
              xk2 = jStat2.add(jStat2.multiply(h2, xv), c2);
              i2 = i2 + 1;
            }
            return xk2;
          },
          SOR: function SOR(a2, b2, x2, r2, w2) {
            var i2 = 0;
            var n2 = a2.length;
            var l2 = [];
            var u2 = [];
            var d2 = [];
            var j2, xv, c2, h2, xk2;
            for (; i2 < n2; i2++) {
              l2[i2] = [];
              u2[i2] = [];
              d2[i2] = [];
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 > j2) {
                  l2[i2][j2] = a2[i2][j2];
                  u2[i2][j2] = d2[i2][j2] = 0;
                } else if (i2 < j2) {
                  u2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = d2[i2][j2] = 0;
                } else {
                  d2[i2][j2] = a2[i2][j2];
                  l2[i2][j2] = u2[i2][j2] = 0;
                }
              }
            }
            h2 = jStat2.multiply(
              jStat2.inv(jStat2.add(d2, jStat2.multiply(l2, w2))),
              jStat2.subtract(
                jStat2.multiply(d2, 1 - w2),
                jStat2.multiply(u2, w2)
              )
            );
            c2 = jStat2.multiply(jStat2.multiply(jStat2.inv(jStat2.add(
              d2,
              jStat2.multiply(l2, w2)
            )), b2), w2);
            xv = x2;
            xk2 = jStat2.add(jStat2.multiply(h2, x2), c2);
            i2 = 2;
            while (Math2.abs(jStat2.norm(jStat2.subtract(xk2, xv))) > r2) {
              xv = xk2;
              xk2 = jStat2.add(jStat2.multiply(h2, xv), c2);
              i2++;
            }
            return xk2;
          },
          householder: function householder(a2) {
            var m2 = a2.length;
            var n2 = a2[0].length;
            var i2 = 0;
            var w2 = [];
            var p2 = [];
            var alpha, r2, k2, j2, factor;
            for (; i2 < m2 - 1; i2++) {
              alpha = 0;
              for (j2 = i2 + 1; j2 < n2; j2++)
                alpha += a2[j2][i2] * a2[j2][i2];
              factor = a2[i2 + 1][i2] > 0 ? -1 : 1;
              alpha = factor * Math2.sqrt(alpha);
              r2 = Math2.sqrt((alpha * alpha - a2[i2 + 1][i2] * alpha) / 2);
              w2 = jStat2.zeros(m2, 1);
              w2[i2 + 1][0] = (a2[i2 + 1][i2] - alpha) / (2 * r2);
              for (k2 = i2 + 2; k2 < m2; k2++) w2[k2][0] = a2[k2][i2] / (2 * r2);
              p2 = jStat2.subtract(
                jStat2.identity(m2, n2),
                jStat2.multiply(jStat2.multiply(w2, jStat2.transpose(w2)), 2)
              );
              a2 = jStat2.multiply(p2, jStat2.multiply(a2, p2));
            }
            return a2;
          },
          // A -> [Q,R]
          // Q is orthogonal matrix
          // R is upper triangular
          QR: function() {
            var sum = jStat2.sum;
            var range = jStat2.arange;
            function qr2(x2) {
              var n2 = x2.length;
              var p2 = x2[0].length;
              var r2 = jStat2.zeros(p2, p2);
              x2 = jStat2.copy(x2);
              var i2, j2, k2;
              for (j2 = 0; j2 < p2; j2++) {
                r2[j2][j2] = Math2.sqrt(sum(range(n2).map(function(i3) {
                  return x2[i3][j2] * x2[i3][j2];
                })));
                for (i2 = 0; i2 < n2; i2++) {
                  x2[i2][j2] = x2[i2][j2] / r2[j2][j2];
                }
                for (k2 = j2 + 1; k2 < p2; k2++) {
                  r2[j2][k2] = sum(range(n2).map(function(i3) {
                    return x2[i3][j2] * x2[i3][k2];
                  }));
                  for (i2 = 0; i2 < n2; i2++) {
                    x2[i2][k2] = x2[i2][k2] - x2[i2][j2] * r2[j2][k2];
                  }
                }
              }
              return [x2, r2];
            }
            return qr2;
          }(),
          lstsq: /* @__PURE__ */ function() {
            function R_I(A2) {
              A2 = jStat2.copy(A2);
              var size2 = A2.length;
              var I2 = jStat2.identity(size2);
              jStat2.arange(size2 - 1, -1, -1).forEach(function(i2) {
                jStat2.sliceAssign(
                  I2,
                  { row: i2 },
                  jStat2.divide(jStat2.slice(I2, { row: i2 }), A2[i2][i2])
                );
                jStat2.sliceAssign(
                  A2,
                  { row: i2 },
                  jStat2.divide(jStat2.slice(A2, { row: i2 }), A2[i2][i2])
                );
                jStat2.arange(i2).forEach(function(j2) {
                  var c2 = jStat2.multiply(A2[j2][i2], -1);
                  var Aj2 = jStat2.slice(A2, { row: j2 });
                  var cAi = jStat2.multiply(jStat2.slice(A2, { row: i2 }), c2);
                  jStat2.sliceAssign(A2, { row: j2 }, jStat2.add(Aj2, cAi));
                  var Ij2 = jStat2.slice(I2, { row: j2 });
                  var cIi = jStat2.multiply(jStat2.slice(I2, { row: i2 }), c2);
                  jStat2.sliceAssign(I2, { row: j2 }, jStat2.add(Ij2, cIi));
                });
              });
              return I2;
            }
            function qr_solve(A2, b2) {
              var array_mode = false;
              if (b2[0].length === void 0) {
                b2 = b2.map(function(x3) {
                  return [x3];
                });
                array_mode = true;
              }
              var QR = jStat2.QR(A2);
              var Q2 = QR[0];
              var R2 = QR[1];
              var attrs = A2[0].length;
              var Q1 = jStat2.slice(Q2, { col: { end: attrs } });
              var R1 = jStat2.slice(R2, { row: { end: attrs } });
              var RI = R_I(R1);
              var Q22 = jStat2.transpose(Q1);
              if (Q22[0].length === void 0) {
                Q22 = [Q22];
              }
              var x2 = jStat2.multiply(jStat2.multiply(RI, Q22), b2);
              if (x2.length === void 0) {
                x2 = [[x2]];
              }
              if (array_mode)
                return x2.map(function(i2) {
                  return i2[0];
                });
              return x2;
            }
            return qr_solve;
          }(),
          jacobi: function jacobi(a2) {
            var condition = 1;
            var n2 = a2.length;
            var e = jStat2.identity(n2, n2);
            var ev = [];
            var b2, i2, j2, p2, q2, maxim, theta, s2;
            while (condition === 1) {
              maxim = a2[0][1];
              p2 = 0;
              q2 = 1;
              for (i2 = 0; i2 < n2; i2++) {
                for (j2 = 0; j2 < n2; j2++) {
                  if (i2 != j2) {
                    if (maxim < Math2.abs(a2[i2][j2])) {
                      maxim = Math2.abs(a2[i2][j2]);
                      p2 = i2;
                      q2 = j2;
                    }
                  }
                }
              }
              if (a2[p2][p2] === a2[q2][q2])
                theta = a2[p2][q2] > 0 ? Math2.PI / 4 : -Math2.PI / 4;
              else
                theta = Math2.atan(2 * a2[p2][q2] / (a2[p2][p2] - a2[q2][q2])) / 2;
              s2 = jStat2.identity(n2, n2);
              s2[p2][p2] = Math2.cos(theta);
              s2[p2][q2] = -Math2.sin(theta);
              s2[q2][p2] = Math2.sin(theta);
              s2[q2][q2] = Math2.cos(theta);
              e = jStat2.multiply(e, s2);
              b2 = jStat2.multiply(jStat2.multiply(jStat2.inv(s2), a2), s2);
              a2 = b2;
              condition = 0;
              for (i2 = 1; i2 < n2; i2++) {
                for (j2 = 1; j2 < n2; j2++) {
                  if (i2 != j2 && Math2.abs(a2[i2][j2]) > 1e-3) {
                    condition = 1;
                  }
                }
              }
            }
            for (i2 = 0; i2 < n2; i2++) ev.push(a2[i2][i2]);
            return [e, ev];
          },
          rungekutta: function rungekutta(f2, h2, p2, t_j, u_j, order) {
            var k1, k2, u_j1, k3, k4;
            if (order === 2) {
              while (t_j <= p2) {
                k1 = h2 * f2(t_j, u_j);
                k2 = h2 * f2(t_j + h2, u_j + k1);
                u_j1 = u_j + (k1 + k2) / 2;
                u_j = u_j1;
                t_j = t_j + h2;
              }
            }
            if (order === 4) {
              while (t_j <= p2) {
                k1 = h2 * f2(t_j, u_j);
                k2 = h2 * f2(t_j + h2 / 2, u_j + k1 / 2);
                k3 = h2 * f2(t_j + h2 / 2, u_j + k2 / 2);
                k4 = h2 * f2(t_j + h2, u_j + k3);
                u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
                u_j = u_j1;
                t_j = t_j + h2;
              }
            }
            return u_j;
          },
          romberg: function romberg(f2, a2, b2, order) {
            var i2 = 0;
            var h2 = (b2 - a2) / 2;
            var x2 = [];
            var h1 = [];
            var g2 = [];
            var m2, a1, j2, k2, I2;
            while (i2 < order / 2) {
              I2 = f2(a2);
              for (j2 = a2, k2 = 0; j2 <= b2; j2 = j2 + h2, k2++) x2[k2] = j2;
              m2 = x2.length;
              for (j2 = 1; j2 < m2 - 1; j2++) {
                I2 += (j2 % 2 !== 0 ? 4 : 2) * f2(x2[j2]);
              }
              I2 = h2 / 3 * (I2 + f2(b2));
              g2[i2] = I2;
              h2 /= 2;
              i2++;
            }
            a1 = g2.length;
            m2 = 1;
            while (a1 !== 1) {
              for (j2 = 0; j2 < a1 - 1; j2++)
                h1[j2] = (Math2.pow(4, m2) * g2[j2 + 1] - g2[j2]) / (Math2.pow(4, m2) - 1);
              a1 = h1.length;
              g2 = h1;
              h1 = [];
              m2++;
            }
            return g2;
          },
          richardson: function richardson(X2, f2, x2, h2) {
            function pos(X3, x3) {
              var i3 = 0;
              var n2 = X3.length;
              var p2;
              for (; i3 < n2; i3++)
                if (X3[i3] === x3) p2 = i3;
              return p2;
            }
            var h_min = Math2.abs(x2 - X2[pos(X2, x2) + 1]);
            var i2 = 0;
            var g2 = [];
            var h1 = [];
            var y1, y2, m2, a2, j2;
            while (h2 >= h_min) {
              y1 = pos(X2, x2 + h2);
              y2 = pos(X2, x2);
              g2[i2] = (f2[y1] - 2 * f2[y2] + f2[2 * y2 - y1]) / (h2 * h2);
              h2 /= 2;
              i2++;
            }
            a2 = g2.length;
            m2 = 1;
            while (a2 != 1) {
              for (j2 = 0; j2 < a2 - 1; j2++)
                h1[j2] = (Math2.pow(4, m2) * g2[j2 + 1] - g2[j2]) / (Math2.pow(4, m2) - 1);
              a2 = h1.length;
              g2 = h1;
              h1 = [];
              m2++;
            }
            return g2;
          },
          simpson: function simpson(f2, a2, b2, n2) {
            var h2 = (b2 - a2) / n2;
            var I2 = f2(a2);
            var x2 = [];
            var j2 = a2;
            var k2 = 0;
            var i2 = 1;
            var m2;
            for (; j2 <= b2; j2 = j2 + h2, k2++)
              x2[k2] = j2;
            m2 = x2.length;
            for (; i2 < m2 - 1; i2++) {
              I2 += (i2 % 2 !== 0 ? 4 : 2) * f2(x2[i2]);
            }
            return h2 / 3 * (I2 + f2(b2));
          },
          hermite: function hermite(X2, F2, dF, value) {
            var n2 = X2.length;
            var p2 = 0;
            var i2 = 0;
            var l2 = [];
            var dl2 = [];
            var A2 = [];
            var B2 = [];
            var j2;
            for (; i2 < n2; i2++) {
              l2[i2] = 1;
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 != j2) l2[i2] *= (value - X2[j2]) / (X2[i2] - X2[j2]);
              }
              dl2[i2] = 0;
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 != j2) dl2[i2] += 1 / (X2[i2] - X2[j2]);
              }
              A2[i2] = (1 - 2 * (value - X2[i2]) * dl2[i2]) * (l2[i2] * l2[i2]);
              B2[i2] = (value - X2[i2]) * (l2[i2] * l2[i2]);
              p2 += A2[i2] * F2[i2] + B2[i2] * dF[i2];
            }
            return p2;
          },
          lagrange: function lagrange(X2, F2, value) {
            var p2 = 0;
            var i2 = 0;
            var j2, l2;
            var n2 = X2.length;
            for (; i2 < n2; i2++) {
              l2 = F2[i2];
              for (j2 = 0; j2 < n2; j2++) {
                if (i2 != j2) l2 *= (value - X2[j2]) / (X2[i2] - X2[j2]);
              }
              p2 += l2;
            }
            return p2;
          },
          cubic_spline: function cubic_spline(X2, F2, value) {
            var n2 = X2.length;
            var i2 = 0, j2;
            var A2 = [];
            var B2 = [];
            var alpha = [];
            var c2 = [];
            var h2 = [];
            var b2 = [];
            var d2 = [];
            for (; i2 < n2 - 1; i2++)
              h2[i2] = X2[i2 + 1] - X2[i2];
            alpha[0] = 0;
            for (i2 = 1; i2 < n2 - 1; i2++) {
              alpha[i2] = 3 / h2[i2] * (F2[i2 + 1] - F2[i2]) - 3 / h2[i2 - 1] * (F2[i2] - F2[i2 - 1]);
            }
            for (i2 = 1; i2 < n2 - 1; i2++) {
              A2[i2] = [];
              B2[i2] = [];
              A2[i2][i2 - 1] = h2[i2 - 1];
              A2[i2][i2] = 2 * (h2[i2 - 1] + h2[i2]);
              A2[i2][i2 + 1] = h2[i2];
              B2[i2][0] = alpha[i2];
            }
            c2 = jStat2.multiply(jStat2.inv(A2), B2);
            for (j2 = 0; j2 < n2 - 1; j2++) {
              b2[j2] = (F2[j2 + 1] - F2[j2]) / h2[j2] - h2[j2] * (c2[j2 + 1][0] + 2 * c2[j2][0]) / 3;
              d2[j2] = (c2[j2 + 1][0] - c2[j2][0]) / (3 * h2[j2]);
            }
            for (j2 = 0; j2 < n2; j2++) {
              if (X2[j2] > value) break;
            }
            j2 -= 1;
            return F2[j2] + (value - X2[j2]) * b2[j2] + jStat2.sq(value - X2[j2]) * c2[j2] + (value - X2[j2]) * jStat2.sq(value - X2[j2]) * d2[j2];
          },
          gauss_quadrature: function gauss_quadrature() {
            throw new Error("gauss_quadrature not yet implemented");
          },
          PCA: function PCA(X2) {
            var m2 = X2.length;
            var n2 = X2[0].length;
            var i2 = 0;
            var j2, temp1;
            var u2 = [];
            var D2 = [];
            var result = [];
            var temp2 = [];
            var Y2 = [];
            var Bt = [];
            var B2 = [];
            var C2 = [];
            var V2 = [];
            var Vt = [];
            for (i2 = 0; i2 < m2; i2++) {
              u2[i2] = jStat2.sum(X2[i2]) / n2;
            }
            for (i2 = 0; i2 < n2; i2++) {
              B2[i2] = [];
              for (j2 = 0; j2 < m2; j2++) {
                B2[i2][j2] = X2[j2][i2] - u2[j2];
              }
            }
            B2 = jStat2.transpose(B2);
            for (i2 = 0; i2 < m2; i2++) {
              C2[i2] = [];
              for (j2 = 0; j2 < m2; j2++) {
                C2[i2][j2] = jStat2.dot([B2[i2]], [B2[j2]]) / (n2 - 1);
              }
            }
            result = jStat2.jacobi(C2);
            V2 = result[0];
            D2 = result[1];
            Vt = jStat2.transpose(V2);
            for (i2 = 0; i2 < D2.length; i2++) {
              for (j2 = i2; j2 < D2.length; j2++) {
                if (D2[i2] < D2[j2]) {
                  temp1 = D2[i2];
                  D2[i2] = D2[j2];
                  D2[j2] = temp1;
                  temp2 = Vt[i2];
                  Vt[i2] = Vt[j2];
                  Vt[j2] = temp2;
                }
              }
            }
            Bt = jStat2.transpose(B2);
            for (i2 = 0; i2 < m2; i2++) {
              Y2[i2] = [];
              for (j2 = 0; j2 < Bt.length; j2++) {
                Y2[i2][j2] = jStat2.dot([Vt[i2]], [Bt[j2]]);
              }
            }
            return [X2, D2, Vt, Y2];
          }
        });
        (function(funcs) {
          for (var i2 = 0; i2 < funcs.length; i2++) (function(passfunc) {
            jStat2.fn[passfunc] = function(arg, func2) {
              var tmpthis = this;
              if (func2) {
                setTimeout(function() {
                  func2.call(tmpthis, jStat2.fn[passfunc].call(tmpthis, arg));
                }, 15);
                return this;
              }
              if (typeof jStat2[passfunc](this, arg) === "number")
                return jStat2[passfunc](this, arg);
              else
                return jStat2(jStat2[passfunc](this, arg));
            };
          })(funcs[i2]);
        })("add divide multiply subtract dot pow exp log abs norm angle".split(" "));
      })(jStat, Math);
      (function(jStat2, Math2) {
        var slice = [].slice;
        var isNumber = jStat2.utils.isNumber;
        var isArray = jStat2.utils.isArray;
        jStat2.extend({
          // 2 different parameter lists:
          // (value, mean, sd)
          // (value, array, flag)
          zscore: function zscore() {
            var args = slice.call(arguments);
            if (isNumber(args[1])) {
              return (args[0] - args[1]) / args[2];
            }
            return (args[0] - jStat2.mean(args[1])) / jStat2.stdev(args[1], args[2]);
          },
          // 3 different paramter lists:
          // (value, mean, sd, sides)
          // (zscore, sides)
          // (value, array, sides, flag)
          ztest: function ztest() {
            var args = slice.call(arguments);
            var z2;
            if (isArray(args[1])) {
              z2 = jStat2.zscore(args[0], args[1], args[3]);
              return args[2] === 1 ? jStat2.normal.cdf(-Math2.abs(z2), 0, 1) : jStat2.normal.cdf(-Math2.abs(z2), 0, 1) * 2;
            } else {
              if (args.length > 2) {
                z2 = jStat2.zscore(args[0], args[1], args[2]);
                return args[3] === 1 ? jStat2.normal.cdf(-Math2.abs(z2), 0, 1) : jStat2.normal.cdf(-Math2.abs(z2), 0, 1) * 2;
              } else {
                z2 = args[0];
                return args[1] === 1 ? jStat2.normal.cdf(-Math2.abs(z2), 0, 1) : jStat2.normal.cdf(-Math2.abs(z2), 0, 1) * 2;
              }
            }
          }
        });
        jStat2.extend(jStat2.fn, {
          zscore: function zscore(value, flag) {
            return (value - this.mean()) / this.stdev(flag);
          },
          ztest: function ztest(value, sides, flag) {
            var zscore = Math2.abs(this.zscore(value, flag));
            return sides === 1 ? jStat2.normal.cdf(-zscore, 0, 1) : jStat2.normal.cdf(-zscore, 0, 1) * 2;
          }
        });
        jStat2.extend({
          // 2 parameter lists
          // (value, mean, sd, n)
          // (value, array)
          tscore: function tscore() {
            var args = slice.call(arguments);
            return args.length === 4 ? (args[0] - args[1]) / (args[2] / Math2.sqrt(args[3])) : (args[0] - jStat2.mean(args[1])) / (jStat2.stdev(args[1], true) / Math2.sqrt(args[1].length));
          },
          // 3 different paramter lists:
          // (value, mean, sd, n, sides)
          // (tscore, n, sides)
          // (value, array, sides)
          ttest: function ttest() {
            var args = slice.call(arguments);
            var tscore;
            if (args.length === 5) {
              tscore = Math2.abs(jStat2.tscore(args[0], args[1], args[2], args[3]));
              return args[4] === 1 ? jStat2.studentt.cdf(-tscore, args[3] - 1) : jStat2.studentt.cdf(-tscore, args[3] - 1) * 2;
            }
            if (isNumber(args[1])) {
              tscore = Math2.abs(args[0]);
              return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1] - 1) : jStat2.studentt.cdf(-tscore, args[1] - 1) * 2;
            }
            tscore = Math2.abs(jStat2.tscore(args[0], args[1]));
            return args[2] == 1 ? jStat2.studentt.cdf(-tscore, args[1].length - 1) : jStat2.studentt.cdf(-tscore, args[1].length - 1) * 2;
          }
        });
        jStat2.extend(jStat2.fn, {
          tscore: function tscore(value) {
            return (value - this.mean()) / (this.stdev(true) / Math2.sqrt(this.cols()));
          },
          ttest: function ttest(value, sides) {
            return sides === 1 ? 1 - jStat2.studentt.cdf(Math2.abs(this.tscore(value)), this.cols() - 1) : jStat2.studentt.cdf(-Math2.abs(this.tscore(value)), this.cols() - 1) * 2;
          }
        });
        jStat2.extend({
          // Paramter list is as follows:
          // (array1, array2, array3, ...)
          // or it is an array of arrays
          // array of arrays conversion
          anovafscore: function anovafscore() {
            var args = slice.call(arguments), expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i2, j2;
            if (args.length === 1) {
              tmpargs = new Array(args[0].length);
              for (i2 = 0; i2 < args[0].length; i2++) {
                tmpargs[i2] = args[0][i2];
              }
              args = tmpargs;
            }
            sample = new Array();
            for (i2 = 0; i2 < args.length; i2++) {
              sample = sample.concat(args[i2]);
            }
            sampMean = jStat2.mean(sample);
            expVar = 0;
            for (i2 = 0; i2 < args.length; i2++) {
              expVar = expVar + args[i2].length * Math2.pow(jStat2.mean(args[i2]) - sampMean, 2);
            }
            expVar /= args.length - 1;
            unexpVar = 0;
            for (i2 = 0; i2 < args.length; i2++) {
              sampSampMean = jStat2.mean(args[i2]);
              for (j2 = 0; j2 < args[i2].length; j2++) {
                unexpVar += Math2.pow(args[i2][j2] - sampSampMean, 2);
              }
            }
            unexpVar /= sample.length - args.length;
            return expVar / unexpVar;
          },
          // 2 different paramter setups
          // (array1, array2, array3, ...)
          // (anovafscore, df1, df2)
          anovaftest: function anovaftest() {
            var args = slice.call(arguments), df1, df2, n2, i2;
            if (isNumber(args[0])) {
              return 1 - jStat2.centralF.cdf(args[0], args[1], args[2]);
            }
            var anovafscore = jStat2.anovafscore(args);
            df1 = args.length - 1;
            n2 = 0;
            for (i2 = 0; i2 < args.length; i2++) {
              n2 = n2 + args[i2].length;
            }
            df2 = n2 - df1 - 1;
            return 1 - jStat2.centralF.cdf(anovafscore, df1, df2);
          },
          ftest: function ftest(fscore, df1, df2) {
            return 1 - jStat2.centralF.cdf(fscore, df1, df2);
          }
        });
        jStat2.extend(jStat2.fn, {
          anovafscore: function anovafscore() {
            return jStat2.anovafscore(this.toArray());
          },
          anovaftes: function anovaftes() {
            var n2 = 0;
            var i2;
            for (i2 = 0; i2 < this.length; i2++) {
              n2 = n2 + this[i2].length;
            }
            return jStat2.ftest(this.anovafscore(), this.length - 1, n2 - this.length);
          }
        });
        jStat2.extend({
          // 2 parameter lists
          // (mean1, mean2, n1, n2, sd)
          // (array1, array2, sd)
          qscore: function qscore() {
            var args = slice.call(arguments);
            var mean1, mean2, n1, n2, sd2;
            if (isNumber(args[0])) {
              mean1 = args[0];
              mean2 = args[1];
              n1 = args[2];
              n2 = args[3];
              sd2 = args[4];
            } else {
              mean1 = jStat2.mean(args[0]);
              mean2 = jStat2.mean(args[1]);
              n1 = args[0].length;
              n2 = args[1].length;
              sd2 = args[2];
            }
            return Math2.abs(mean1 - mean2) / (sd2 * Math2.sqrt((1 / n1 + 1 / n2) / 2));
          },
          // 3 different parameter lists:
          // (qscore, n, k)
          // (mean1, mean2, n1, n2, sd, n, k)
          // (array1, array2, sd, n, k)
          qtest: function qtest() {
            var args = slice.call(arguments);
            var qscore;
            if (args.length === 3) {
              qscore = args[0];
              args = args.slice(1);
            } else if (args.length === 7) {
              qscore = jStat2.qscore(args[0], args[1], args[2], args[3], args[4]);
              args = args.slice(5);
            } else {
              qscore = jStat2.qscore(args[0], args[1], args[2]);
              args = args.slice(3);
            }
            var n2 = args[0];
            var k2 = args[1];
            return 1 - jStat2.tukey.cdf(qscore, k2, n2 - k2);
          },
          tukeyhsd: function tukeyhsd(arrays) {
            var sd2 = jStat2.pooledstdev(arrays);
            var means = arrays.map(function(arr) {
              return jStat2.mean(arr);
            });
            var n2 = arrays.reduce(function(n3, arr) {
              return n3 + arr.length;
            }, 0);
            var results = [];
            for (var i2 = 0; i2 < arrays.length; ++i2) {
              for (var j2 = i2 + 1; j2 < arrays.length; ++j2) {
                var p2 = jStat2.qtest(means[i2], means[j2], arrays[i2].length, arrays[j2].length, sd2, n2, arrays.length);
                results.push([[i2, j2], p2]);
              }
            }
            return results;
          }
        });
        jStat2.extend({
          // 2 different parameter setups
          // (value, alpha, sd, n)
          // (value, alpha, array)
          normalci: function normalci() {
            var args = slice.call(arguments), ans = new Array(2), change;
            if (args.length === 4) {
              change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * args[2] / Math2.sqrt(args[3]));
            } else {
              change = Math2.abs(jStat2.normal.inv(args[1] / 2, 0, 1) * jStat2.stdev(args[2]) / Math2.sqrt(args[2].length));
            }
            ans[0] = args[0] - change;
            ans[1] = args[0] + change;
            return ans;
          },
          // 2 different parameter setups
          // (value, alpha, sd, n)
          // (value, alpha, array)
          tci: function tci() {
            var args = slice.call(arguments), ans = new Array(2), change;
            if (args.length === 4) {
              change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[3] - 1) * args[2] / Math2.sqrt(args[3]));
            } else {
              change = Math2.abs(jStat2.studentt.inv(args[1] / 2, args[2].length - 1) * jStat2.stdev(args[2], true) / Math2.sqrt(args[2].length));
            }
            ans[0] = args[0] - change;
            ans[1] = args[0] + change;
            return ans;
          },
          significant: function significant(pvalue, alpha) {
            return pvalue < alpha;
          }
        });
        jStat2.extend(jStat2.fn, {
          normalci: function normalci(value, alpha) {
            return jStat2.normalci(value, alpha, this.toArray());
          },
          tci: function tci(value, alpha) {
            return jStat2.tci(value, alpha, this.toArray());
          }
        });
        function differenceOfProportions(p1, n1, p2, n2) {
          if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
            throw new Error("Proportions should be greater than 0 and less than 1");
          }
          var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
          var se2 = Math2.sqrt(pooled * (1 - pooled) * (1 / n1 + 1 / n2));
          return (p1 - p2) / se2;
        }
        jStat2.extend(jStat2.fn, {
          oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
            var z2 = differenceOfProportions(p1, n1, p2, n2);
            return jStat2.ztest(z2, 1);
          },
          twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
            var z2 = differenceOfProportions(p1, n1, p2, n2);
            return jStat2.ztest(z2, 2);
          }
        });
      })(jStat, Math);
      jStat.models = /* @__PURE__ */ function() {
        function sub_regress(exog) {
          var var_count = exog[0].length;
          var modelList = jStat.arange(var_count).map(function(endog_index) {
            var exog_index = jStat.arange(var_count).filter(function(i2) {
              return i2 !== endog_index;
            });
            return ols(
              jStat.col(exog, endog_index).map(function(x2) {
                return x2[0];
              }),
              jStat.col(exog, exog_index)
            );
          });
          return modelList;
        }
        function ols(endog, exog) {
          var nobs = endog.length;
          var df_model = exog[0].length - 1;
          var df_resid = nobs - df_model - 1;
          var coef = jStat.lstsq(exog, endog);
          var predict = jStat.multiply(exog, coef.map(function(x2) {
            return [x2];
          })).map(function(p2) {
            return p2[0];
          });
          var resid = jStat.subtract(endog, predict);
          var ybar = jStat.mean(endog);
          var SSE = jStat.sum(predict.map(function(f2) {
            return Math.pow(f2 - ybar, 2);
          }));
          var SSR = jStat.sum(endog.map(function(y2, i2) {
            return Math.pow(y2 - predict[i2], 2);
          }));
          var SST = SSE + SSR;
          var R2 = SSE / SST;
          return {
            exog,
            endog,
            nobs,
            df_model,
            df_resid,
            coef,
            predict,
            resid,
            ybar,
            SST,
            SSE,
            SSR,
            R2
          };
        }
        function t_test(model) {
          var subModelList = sub_regress(model.exog);
          var sigmaHat = Math.sqrt(model.SSR / model.df_resid);
          var seBetaHat = subModelList.map(function(mod) {
            var SST = mod.SST;
            var R2 = mod.R2;
            return sigmaHat / Math.sqrt(SST * (1 - R2));
          });
          var tStatistic = model.coef.map(function(coef, i2) {
            return (coef - 0) / seBetaHat[i2];
          });
          var pValue = tStatistic.map(function(t2) {
            var leftppf = jStat.studentt.cdf(t2, model.df_resid);
            return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;
          });
          var c2 = jStat.studentt.inv(0.975, model.df_resid);
          var interval95 = model.coef.map(function(coef, i2) {
            var d2 = c2 * seBetaHat[i2];
            return [coef - d2, coef + d2];
          });
          return {
            se: seBetaHat,
            t: tStatistic,
            p: pValue,
            sigmaHat,
            interval95
          };
        }
        function F_test(model) {
          var F_statistic = model.R2 / model.df_model / ((1 - model.R2) / model.df_resid);
          var fcdf = function(x2, n1, n2) {
            return jStat.beta.cdf(x2 / (n2 / n1 + x2), n1 / 2, n2 / 2);
          };
          var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);
          return { F_statistic, pvalue };
        }
        function ols_wrap(endog, exog) {
          var model = ols(endog, exog);
          var ttest = t_test(model);
          var ftest = F_test(model);
          var adjust_R2 = 1 - (1 - model.R2) * ((model.nobs - 1) / model.df_resid);
          model.t = ttest;
          model.f = ftest;
          model.adjust_R2 = adjust_R2;
          return model;
        }
        return { ols: ols_wrap };
      }();
      jStat.extend({
        buildxmatrix: function buildxmatrix() {
          var matrixRows = new Array(arguments.length);
          for (var i2 = 0; i2 < arguments.length; i2++) {
            var array = [1];
            matrixRows[i2] = array.concat(arguments[i2]);
          }
          return jStat(matrixRows);
        },
        builddxmatrix: function builddxmatrix() {
          var matrixRows = new Array(arguments[0].length);
          for (var i2 = 0; i2 < arguments[0].length; i2++) {
            var array = [1];
            matrixRows[i2] = array.concat(arguments[0][i2]);
          }
          return jStat(matrixRows);
        },
        buildjxmatrix: function buildjxmatrix(jMat) {
          var pass = new Array(jMat.length);
          for (var i2 = 0; i2 < jMat.length; i2++) {
            pass[i2] = jMat[i2];
          }
          return jStat.builddxmatrix(pass);
        },
        buildymatrix: function buildymatrix(array) {
          return jStat(array).transpose();
        },
        buildjymatrix: function buildjymatrix(jMat) {
          return jMat.transpose();
        },
        matrixmult: function matrixmult(A2, B2) {
          var i2, j2, k2, result, sum;
          if (A2.cols() == B2.rows()) {
            if (B2.rows() > 1) {
              result = [];
              for (i2 = 0; i2 < A2.rows(); i2++) {
                result[i2] = [];
                for (j2 = 0; j2 < B2.cols(); j2++) {
                  sum = 0;
                  for (k2 = 0; k2 < A2.cols(); k2++) {
                    sum += A2.toArray()[i2][k2] * B2.toArray()[k2][j2];
                  }
                  result[i2][j2] = sum;
                }
              }
              return jStat(result);
            }
            result = [];
            for (i2 = 0; i2 < A2.rows(); i2++) {
              result[i2] = [];
              for (j2 = 0; j2 < B2.cols(); j2++) {
                sum = 0;
                for (k2 = 0; k2 < A2.cols(); k2++) {
                  sum += A2.toArray()[i2][k2] * B2.toArray()[j2];
                }
                result[i2][j2] = sum;
              }
            }
            return jStat(result);
          }
        },
        //regress and regresst to be fixed
        regress: function regress(jMatX, jMatY) {
          var innerinv = jStat.xtranspxinv(jMatX);
          var xtransp = jMatX.transpose();
          var next = jStat.matrixmult(jStat(innerinv), xtransp);
          return jStat.matrixmult(next, jMatY);
        },
        regresst: function regresst(jMatX, jMatY, sides) {
          var beta = jStat.regress(jMatX, jMatY);
          var compile = {};
          compile.anova = {};
          var jMatYBar = jStat.jMatYBar(jMatX, beta);
          compile.yBar = jMatYBar;
          var yAverage = jMatY.mean();
          compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);
          compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);
          compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);
          compile.anova.sse = jStat.sse(jMatY, jMatYBar);
          compile.anova.mse = compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);
          compile.anova.sst = jStat.sst(jMatY, yAverage);
          compile.anova.mst = compile.anova.sst / (jMatY.length - 1);
          compile.anova.r2 = 1 - compile.anova.sse / compile.anova.sst;
          if (compile.anova.r2 < 0) compile.anova.r2 = 0;
          compile.anova.fratio = compile.anova.msr / compile.anova.mse;
          compile.anova.pvalue = jStat.anovaftest(
            compile.anova.fratio,
            jMatX[0].length - 1,
            jMatY.length - (jMatX[0].length - 1) - 1
          );
          compile.anova.rmse = Math.sqrt(compile.anova.mse);
          compile.anova.r2adj = 1 - compile.anova.mse / compile.anova.mst;
          if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;
          compile.stats = new Array(jMatX[0].length);
          var covar = jStat.xtranspxinv(jMatX);
          var sds, ts, ps;
          for (var i2 = 0; i2 < beta.length; i2++) {
            sds = Math.sqrt(compile.anova.mse * Math.abs(covar[i2][i2]));
            ts = Math.abs(beta[i2] / sds);
            ps = jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);
            compile.stats[i2] = [beta[i2], sds, ts, ps];
          }
          compile.regress = beta;
          return compile;
        },
        xtranspx: function xtranspx(jMatX) {
          return jStat.matrixmult(jMatX.transpose(), jMatX);
        },
        xtranspxinv: function xtranspxinv(jMatX) {
          var inner = jStat.matrixmult(jMatX.transpose(), jMatX);
          var innerinv = jStat.inv(inner);
          return innerinv;
        },
        jMatYBar: function jMatYBar(jMatX, beta) {
          var yBar = jStat.matrixmult(jMatX, beta);
          return new jStat(yBar);
        },
        residuals: function residuals(jMatY, jMatYBar) {
          return jStat.matrixsubtract(jMatY, jMatYBar);
        },
        ssr: function ssr(jMatYBar, yAverage) {
          var ssr2 = 0;
          for (var i2 = 0; i2 < jMatYBar.length; i2++) {
            ssr2 += Math.pow(jMatYBar[i2] - yAverage, 2);
          }
          return ssr2;
        },
        sse: function sse(jMatY, jMatYBar) {
          var sse2 = 0;
          for (var i2 = 0; i2 < jMatY.length; i2++) {
            sse2 += Math.pow(jMatY[i2] - jMatYBar[i2], 2);
          }
          return sse2;
        },
        sst: function sst(jMatY, yAverage) {
          var sst2 = 0;
          for (var i2 = 0; i2 < jMatY.length; i2++) {
            sst2 += Math.pow(jMatY[i2] - yAverage, 2);
          }
          return sst2;
        },
        matrixsubtract: function matrixsubtract(A2, B2) {
          var ans = new Array(A2.length);
          for (var i2 = 0; i2 < A2.length; i2++) {
            ans[i2] = new Array(A2[i2].length);
            for (var j2 = 0; j2 < A2[i2].length; j2++) {
              ans[i2][j2] = A2[i2][j2] - B2[i2][j2];
            }
          }
          return jStat(ans);
        }
      });
      jStat.jStat = jStat;
      return jStat;
    });
  })(jstat);
  var jstatExports = jstat.exports;
  var criteriaEval = {};
  var defaultOperator = "=";
  var validSymbols = [">", ">=", "<", "<=", "=", "<>"];
  var TOKEN_TYPE_OPERATOR = "operator";
  var TOKEN_TYPE_LITERAL = "literal";
  var SUPPORTED_TOKENS = [TOKEN_TYPE_OPERATOR, TOKEN_TYPE_LITERAL];
  criteriaEval.TOKEN_TYPE_OPERATOR = TOKEN_TYPE_OPERATOR;
  criteriaEval.TOKEN_TYPE_LITERAL = TOKEN_TYPE_LITERAL;
  function createToken(value, type) {
    if (SUPPORTED_TOKENS.indexOf(type) === -1) {
      throw new Error("Unsupported token type: " + type);
    }
    return {
      value,
      type
    };
  }
  function castValueToCorrectType(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (/^\d+(\.\d+)?$/.test(value)) {
      value = value.indexOf(".") === -1 ? parseInt(value, 10) : parseFloat(value);
    }
    return value;
  }
  function tokenizeExpression(expression) {
    var expressionLength = expression.length;
    var tokens = [];
    var cursorIndex = 0;
    var processedValue = "";
    var processedSymbol = "";
    while (cursorIndex < expressionLength) {
      var char = expression.charAt(cursorIndex);
      switch (char) {
        case ">":
        case "<":
        case "=":
          processedSymbol = processedSymbol + char;
          if (processedValue.length > 0) {
            tokens.push(processedValue);
            processedValue = "";
          }
          break;
        default:
          if (processedSymbol.length > 0) {
            tokens.push(processedSymbol);
            processedSymbol = "";
          }
          processedValue = processedValue + char;
          break;
      }
      cursorIndex++;
    }
    if (processedValue.length > 0) {
      tokens.push(processedValue);
    }
    if (processedSymbol.length > 0) {
      tokens.push(processedSymbol);
    }
    return tokens;
  }
  function analyzeTokens(tokens) {
    var literalValue = "";
    var analyzedTokens = [];
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (i2 === 0 && validSymbols.indexOf(token) >= 0) {
        analyzedTokens.push(createToken(token, TOKEN_TYPE_OPERATOR));
      } else {
        literalValue += token;
      }
    }
    if (literalValue.length > 0) {
      analyzedTokens.push(createToken(castValueToCorrectType(literalValue), TOKEN_TYPE_LITERAL));
    }
    if (analyzedTokens.length > 0 && analyzedTokens[0].type !== TOKEN_TYPE_OPERATOR) {
      analyzedTokens.unshift(createToken(defaultOperator, TOKEN_TYPE_OPERATOR));
    }
    return analyzedTokens;
  }
  function computeExpression(tokens) {
    var values = [];
    var operator;
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      switch (token.type) {
        case TOKEN_TYPE_OPERATOR:
          operator = token.value;
          break;
        case TOKEN_TYPE_LITERAL:
          values.push(token.value);
          break;
      }
    }
    return evaluate(values, operator);
  }
  function evaluate(values, operator) {
    var result = false;
    switch (operator) {
      case ">":
        result = values[0] > values[1];
        break;
      case ">=":
        result = values[0] >= values[1];
        break;
      case "<":
        result = values[0] < values[1];
        break;
      case "<=":
        result = values[0] <= values[1];
        break;
      case "=":
        result = values[0] == values[1];
        break;
      case "<>":
        result = values[0] != values[1];
        break;
    }
    return result;
  }
  criteriaEval.parse = function(expression) {
    return analyzeTokens(tokenizeExpression(expression));
  };
  criteriaEval.createToken = createToken;
  criteriaEval.compute = computeExpression;
  var miscellaneous = {};
  var utils$1 = common;
  var error$2 = error$3;
  miscellaneous.UNIQUE = function() {
    var result = [];
    for (var i2 = 0; i2 < arguments.length; ++i2) {
      var hasElement = false;
      var element = arguments[i2];
      for (var j2 = 0; j2 < result.length; ++j2) {
        hasElement = result[j2] === element;
        if (hasElement) {
          break;
        }
      }
      if (!hasElement) {
        result.push(element);
      }
    }
    return result;
  };
  miscellaneous.FLATTEN = utils$1.flatten;
  miscellaneous.ARGS2ARRAY = function() {
    return Array.prototype.slice.call(arguments, 0);
  };
  miscellaneous.REFERENCE = function(context, reference) {
    if (!arguments.length) {
      return error$2.error;
    }
    try {
      var path = reference.split(".");
      var result = context;
      for (var i2 = 0; i2 < path.length; ++i2) {
        var step = path[i2];
        if (step[step.length - 1] === "]") {
          var opening = step.indexOf("[");
          var index2 = step.substring(opening + 1, step.length - 1);
          result = result[step.substring(0, opening)][index2];
        } else {
          result = result[step];
        }
      }
      return result;
    } catch (error2) {
    }
  };
  miscellaneous.JOIN = function(array, separator) {
    return array.join(separator);
  };
  miscellaneous.NUMBERS = function() {
    var possibleNumbers = utils$1.flatten(arguments);
    return possibleNumbers.filter(function(el2) {
      return typeof el2 === "number";
    });
  };
  var hasRequiredStatistical;
  function requireStatistical() {
    if (hasRequiredStatistical) return statistical$1;
    hasRequiredStatistical = 1;
    (function(exports$1) {
      var mathTrig2 = requireMathTrig();
      var text$1 = text;
      var jStat = jstatExports;
      var utils2 = common;
      var evalExpression = criteriaEval;
      var error2 = error$3;
      var misc = miscellaneous;
      var SQRT2PI = 2.5066282746310002;
      exports$1.AVEDEV = function() {
        var flatArguments = utils2.flatten(arguments);
        var flatArgumentsDefined = flatArguments.filter(utils2.isDefined);
        if (flatArgumentsDefined.length === 0) {
          return error2.num;
        }
        var range = utils2.parseNumberArray(flatArgumentsDefined);
        if (range instanceof Error) {
          return range;
        }
        return jStat.sum(jStat(range).subtract(jStat.mean(range)).abs()[0]) / range.length;
      };
      exports$1.AVERAGE = function() {
        var flatArguments = utils2.flatten(arguments);
        var flatArgumentsDefined = flatArguments.filter(utils2.isDefined);
        if (flatArgumentsDefined.length === 0) {
          return error2.div0;
        }
        var someError = utils2.anyError.apply(void 0, flatArgumentsDefined);
        if (someError) {
          return someError;
        }
        var range = utils2.numbers(flatArgumentsDefined);
        var n2 = range.length;
        var sum = 0;
        var count = 0;
        var result;
        for (var i2 = 0; i2 < n2; i2++) {
          sum += range[i2];
          count += 1;
        }
        result = sum / count;
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.AVERAGEA = function() {
        var flatArguments = utils2.flatten(arguments);
        var flatArgumentsDefined = flatArguments.filter(utils2.isDefined);
        if (flatArgumentsDefined.length === 0) {
          return error2.div0;
        }
        var someError = utils2.anyError.apply(void 0, flatArgumentsDefined);
        if (someError) {
          return someError;
        }
        var range = flatArgumentsDefined;
        var n2 = range.length;
        var sum = 0;
        var count = 0;
        var result;
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range[i2];
          if (typeof el2 === "number") {
            sum += el2;
          }
          if (el2 === true) {
            sum++;
          }
          if (el2 !== null) {
            count++;
          }
        }
        result = sum / count;
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.AVERAGEIF = function(range, criteria, average_range) {
        if (arguments.length <= 1) {
          return error2.na;
        }
        average_range = average_range || range;
        var flatAverageRange = utils2.flatten(average_range);
        var flatAverageRangeDefined = flatAverageRange.filter(utils2.isDefined);
        average_range = utils2.parseNumberArray(flatAverageRangeDefined);
        range = utils2.flatten(range);
        if (average_range instanceof Error) {
          return average_range;
        }
        var average_count = 0;
        var result = 0;
        var isWildcard = criteria === void 0 || criteria === "*";
        var tokenizedCriteria = isWildcard ? null : evalExpression.parse(criteria + "");
        for (var i2 = 0; i2 < range.length; i2++) {
          var value = range[i2];
          if (isWildcard) {
            result += average_range[i2];
            average_count++;
          } else {
            var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
            if (evalExpression.compute(tokens)) {
              result += average_range[i2];
              average_count++;
            }
          }
        }
        return result / average_count;
      };
      exports$1.AVERAGEIFS = function() {
        var args = utils2.argsToArray(arguments);
        var criteriaLength = (args.length - 1) / 2;
        var range = utils2.flatten(args[0]);
        var count = 0;
        var result = 0;
        for (var i2 = 0; i2 < range.length; i2++) {
          var isMeetCondition = false;
          for (var j2 = 0; j2 < criteriaLength; j2++) {
            var value = args[2 * j2 + 1][i2];
            var criteria = args[2 * j2 + 2];
            var isWildcard = criteria === void 0 || criteria === "*";
            var computedResult = false;
            if (isWildcard) {
              computedResult = true;
            } else {
              var tokenizedCriteria = evalExpression.parse(criteria + "");
              var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
              computedResult = evalExpression.compute(tokens);
            }
            if (!computedResult) {
              isMeetCondition = false;
              break;
            }
            isMeetCondition = true;
          }
          if (isMeetCondition) {
            result += range[i2];
            count++;
          }
        }
        var average = result / count;
        if (isNaN(average)) {
          return 0;
        } else {
          return average;
        }
      };
      exports$1.BETA = {};
      exports$1.BETA.DIST = function(x2, alpha, beta, cumulative, A2, B2) {
        if (arguments.length < 4) {
          return error2.value;
        }
        A2 = A2 === void 0 ? 0 : A2;
        B2 = B2 === void 0 ? 1 : B2;
        x2 = utils2.parseNumber(x2);
        alpha = utils2.parseNumber(alpha);
        beta = utils2.parseNumber(beta);
        A2 = utils2.parseNumber(A2);
        B2 = utils2.parseNumber(B2);
        if (utils2.anyIsError(x2, alpha, beta, A2, B2)) {
          return error2.value;
        }
        x2 = (x2 - A2) / (B2 - A2);
        return cumulative ? jStat.beta.cdf(x2, alpha, beta) : jStat.beta.pdf(x2, alpha, beta);
      };
      exports$1.BETA.INV = function(probability, alpha, beta, A2, B2) {
        A2 = A2 === void 0 ? 0 : A2;
        B2 = B2 === void 0 ? 1 : B2;
        probability = utils2.parseNumber(probability);
        alpha = utils2.parseNumber(alpha);
        beta = utils2.parseNumber(beta);
        A2 = utils2.parseNumber(A2);
        B2 = utils2.parseNumber(B2);
        if (utils2.anyIsError(probability, alpha, beta, A2, B2)) {
          return error2.value;
        }
        return jStat.beta.inv(probability, alpha, beta) * (B2 - A2) + A2;
      };
      exports$1.BINOM = {};
      exports$1.BINOM.DIST = function(successes, trials, probability, cumulative) {
        successes = utils2.parseNumber(successes);
        trials = utils2.parseNumber(trials);
        probability = utils2.parseNumber(probability);
        cumulative = utils2.parseNumber(cumulative);
        if (utils2.anyIsError(successes, trials, probability, cumulative)) {
          return error2.value;
        }
        return cumulative ? jStat.binomial.cdf(successes, trials, probability) : jStat.binomial.pdf(successes, trials, probability);
      };
      exports$1.BINOM.DIST.RANGE = function(trials, probability, successes, successes2) {
        successes2 = successes2 === void 0 ? successes : successes2;
        trials = utils2.parseNumber(trials);
        probability = utils2.parseNumber(probability);
        successes = utils2.parseNumber(successes);
        successes2 = utils2.parseNumber(successes2);
        if (utils2.anyIsError(trials, probability, successes, successes2)) {
          return error2.value;
        }
        var result = 0;
        for (var i2 = successes; i2 <= successes2; i2++) {
          result += mathTrig2.COMBIN(trials, i2) * Math.pow(probability, i2) * Math.pow(1 - probability, trials - i2);
        }
        return result;
      };
      exports$1.BINOM.INV = function(trials, probability, alpha) {
        trials = utils2.parseNumber(trials);
        probability = utils2.parseNumber(probability);
        alpha = utils2.parseNumber(alpha);
        if (utils2.anyIsError(trials, probability, alpha)) {
          return error2.value;
        }
        var x2 = 0;
        while (x2 <= trials) {
          if (jStat.binomial.cdf(x2, trials, probability) >= alpha) {
            return x2;
          }
          x2++;
        }
      };
      exports$1.CHISQ = {};
      exports$1.CHISQ.DIST = function(x2, k2, cumulative) {
        x2 = utils2.parseNumber(x2);
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(x2, k2)) {
          return error2.value;
        }
        return cumulative ? jStat.chisquare.cdf(x2, k2) : jStat.chisquare.pdf(x2, k2);
      };
      exports$1.CHISQ.DIST.RT = function(x2, k2) {
        if (!x2 | !k2) {
          return error2.na;
        }
        if (x2 < 1 || k2 > Math.pow(10, 10)) {
          return error2.num;
        }
        if (typeof x2 !== "number" || typeof k2 !== "number") {
          return error2.value;
        }
        return 1 - jStat.chisquare.cdf(x2, k2);
      };
      exports$1.CHISQ.INV = function(probability, k2) {
        probability = utils2.parseNumber(probability);
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(probability, k2)) {
          return error2.value;
        }
        return jStat.chisquare.inv(probability, k2);
      };
      exports$1.CHISQ.INV.RT = function(p2, k2) {
        if (!p2 | !k2) {
          return error2.na;
        }
        if (p2 < 0 || p2 > 1 || k2 < 1 || k2 > Math.pow(10, 10)) {
          return error2.num;
        }
        if (typeof p2 !== "number" || typeof k2 !== "number") {
          return error2.value;
        }
        return jStat.chisquare.inv(1 - p2, k2);
      };
      exports$1.CHISQ.TEST = function(observed, expected) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (!(observed instanceof Array) || !(expected instanceof Array)) {
          return error2.value;
        }
        if (observed.length !== expected.length) {
          return error2.value;
        }
        if (observed[0] && expected[0] && observed[0].length !== expected[0].length) {
          return error2.value;
        }
        var row = observed.length;
        var tmp, i2, j2;
        for (i2 = 0; i2 < row; i2++) {
          if (!(observed[i2] instanceof Array)) {
            tmp = observed[i2];
            observed[i2] = [];
            observed[i2].push(tmp);
          }
          if (!(expected[i2] instanceof Array)) {
            tmp = expected[i2];
            expected[i2] = [];
            expected[i2].push(tmp);
          }
        }
        var col = observed[0].length;
        var dof = col === 1 ? row - 1 : (row - 1) * (col - 1);
        var xsqr = 0;
        var Pi2 = Math.PI;
        for (i2 = 0; i2 < row; i2++) {
          for (j2 = 0; j2 < col; j2++) {
            xsqr += Math.pow(observed[i2][j2] - expected[i2][j2], 2) / expected[i2][j2];
          }
        }
        function ChiSq(xsqr2, dof2) {
          var p2 = Math.exp(-0.5 * xsqr2);
          if (dof2 % 2 === 1) {
            p2 = p2 * Math.sqrt(2 * xsqr2 / Pi2);
          }
          var k2 = dof2;
          while (k2 >= 2) {
            p2 = p2 * xsqr2 / k2;
            k2 = k2 - 2;
          }
          var t2 = p2;
          var a2 = dof2;
          while (t2 > 1e-10 * p2) {
            a2 = a2 + 2;
            t2 = t2 * xsqr2 / a2;
            p2 = p2 + t2;
          }
          return 1 - p2;
        }
        return Math.round(ChiSq(xsqr, dof) * 1e6) / 1e6;
      };
      exports$1.COLUMN = function(matrix, index2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (index2 < 0) {
          return error2.num;
        }
        if (!(matrix instanceof Array) || typeof index2 !== "number") {
          return error2.value;
        }
        if (matrix.length === 0) {
          return void 0;
        }
        return jStat.col(matrix, index2);
      };
      exports$1.COLUMNS = function(matrix) {
        if (arguments.length !== 1) {
          return error2.na;
        }
        if (!(matrix instanceof Array)) {
          return error2.value;
        }
        if (matrix.length === 0) {
          return 0;
        }
        return jStat.cols(matrix);
      };
      exports$1.CONFIDENCE = {};
      exports$1.CONFIDENCE.NORM = function(alpha, sd2, n2) {
        alpha = utils2.parseNumber(alpha);
        sd2 = utils2.parseNumber(sd2);
        n2 = utils2.parseNumber(n2);
        if (utils2.anyIsError(alpha, sd2, n2)) {
          return error2.value;
        }
        return jStat.normalci(1, alpha, sd2, n2)[1] - 1;
      };
      exports$1.CONFIDENCE.T = function(alpha, sd2, n2) {
        alpha = utils2.parseNumber(alpha);
        sd2 = utils2.parseNumber(sd2);
        n2 = utils2.parseNumber(n2);
        if (utils2.anyIsError(alpha, sd2, n2)) {
          return error2.value;
        }
        return jStat.tci(1, alpha, sd2, n2)[1] - 1;
      };
      exports$1.CORREL = function(array1, array2) {
        array1 = utils2.parseNumberArray(utils2.flatten(array1));
        array2 = utils2.parseNumberArray(utils2.flatten(array2));
        if (utils2.anyIsError(array1, array2)) {
          return error2.value;
        }
        return jStat.corrcoeff(array1, array2);
      };
      exports$1.COUNT = function() {
        var flatArguments = utils2.flatten(arguments);
        return utils2.numbers(flatArguments).length;
      };
      exports$1.COUNTA = function() {
        var flatArguments = utils2.flatten(arguments);
        return flatArguments.length - exports$1.COUNTBLANK(flatArguments);
      };
      exports$1.COUNTIN = function(range, value) {
        var result = 0;
        range = utils2.flatten(range);
        for (var i2 = 0; i2 < range.length; i2++) {
          if (range[i2] === value) {
            result++;
          }
        }
        return result;
      };
      exports$1.COUNTBLANK = function() {
        var range = utils2.flatten(arguments);
        var blanks = 0;
        var element;
        for (var i2 = 0; i2 < range.length; i2++) {
          element = range[i2];
          if (element === void 0 || element === null || element === "") {
            blanks++;
          }
        }
        return blanks;
      };
      exports$1.COUNTIF = function(range, criteria) {
        range = utils2.flatten(range);
        var isWildcard = criteria === void 0 || criteria === "*";
        if (isWildcard) {
          return range.length;
        }
        var matches = 0;
        var tokenizedCriteria = evalExpression.parse(criteria + "");
        for (var i2 = 0; i2 < range.length; i2++) {
          var value = range[i2];
          var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
          if (evalExpression.compute(tokens)) {
            matches++;
          }
        }
        return matches;
      };
      exports$1.COUNTIFS = function() {
        var args = utils2.argsToArray(arguments);
        var results = new Array(utils2.flatten(args[0]).length);
        for (var i2 = 0; i2 < results.length; i2++) {
          results[i2] = true;
        }
        for (i2 = 0; i2 < args.length; i2 += 2) {
          var range = utils2.flatten(args[i2]);
          var criteria = args[i2 + 1];
          var isWildcard = criteria === void 0 || criteria === "*";
          if (!isWildcard) {
            var tokenizedCriteria = evalExpression.parse(criteria + "");
            for (var j2 = 0; j2 < range.length; j2++) {
              var value = range[j2];
              var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
              results[j2] = results[j2] && evalExpression.compute(tokens);
            }
          }
        }
        var result = 0;
        for (i2 = 0; i2 < results.length; i2++) {
          if (results[i2]) {
            result++;
          }
        }
        return result;
      };
      exports$1.COUNTUNIQUE = function() {
        return misc.UNIQUE.apply(null, utils2.flatten(arguments)).length;
      };
      exports$1.COVARIANCE = {};
      exports$1.COVARIANCE.P = function(array1, array2) {
        array1 = utils2.parseNumberArray(utils2.flatten(array1));
        array2 = utils2.parseNumberArray(utils2.flatten(array2));
        if (utils2.anyIsError(array1, array2)) {
          return error2.value;
        }
        var mean1 = jStat.mean(array1);
        var mean2 = jStat.mean(array2);
        var result = 0;
        var n2 = array1.length;
        for (var i2 = 0; i2 < n2; i2++) {
          result += (array1[i2] - mean1) * (array2[i2] - mean2);
        }
        return result / n2;
      };
      exports$1.COVARIANCE.S = function(array1, array2) {
        array1 = utils2.parseNumberArray(utils2.flatten(array1));
        array2 = utils2.parseNumberArray(utils2.flatten(array2));
        if (utils2.anyIsError(array1, array2)) {
          return error2.value;
        }
        return jStat.covariance(array1, array2);
      };
      exports$1.DEVSQ = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var mean = jStat.mean(range);
        var result = 0;
        for (var i2 = 0; i2 < range.length; i2++) {
          result += Math.pow(range[i2] - mean, 2);
        }
        return result;
      };
      exports$1.EXPON = {};
      exports$1.EXPON.DIST = function(x2, lambda, cumulative) {
        x2 = utils2.parseNumber(x2);
        lambda = utils2.parseNumber(lambda);
        if (utils2.anyIsError(x2, lambda)) {
          return error2.value;
        }
        return cumulative ? jStat.exponential.cdf(x2, lambda) : jStat.exponential.pdf(x2, lambda);
      };
      exports$1.F = {};
      exports$1.F.DIST = function(x2, d1, d2, cumulative) {
        x2 = utils2.parseNumber(x2);
        d1 = utils2.parseNumber(d1);
        d2 = utils2.parseNumber(d2);
        if (utils2.anyIsError(x2, d1, d2)) {
          return error2.value;
        }
        return cumulative ? jStat.centralF.cdf(x2, d1, d2) : jStat.centralF.pdf(x2, d1, d2);
      };
      exports$1.F.DIST.RT = function(x2, d1, d2) {
        if (arguments.length !== 3) {
          return error2.na;
        }
        if (x2 < 0 || d1 < 1 || d2 < 1) {
          return error2.num;
        }
        if (typeof x2 !== "number" || typeof d1 !== "number" || typeof d2 !== "number") {
          return error2.value;
        }
        return 1 - jStat.centralF.cdf(x2, d1, d2);
      };
      exports$1.F.INV = function(probability, d1, d2) {
        probability = utils2.parseNumber(probability);
        d1 = utils2.parseNumber(d1);
        d2 = utils2.parseNumber(d2);
        if (utils2.anyIsError(probability, d1, d2)) {
          return error2.value;
        }
        if (probability <= 0 || probability > 1) {
          return error2.num;
        }
        return jStat.centralF.inv(probability, d1, d2);
      };
      exports$1.F.INV.RT = function(p2, d1, d2) {
        if (arguments.length !== 3) {
          return error2.na;
        }
        if (p2 < 0 || p2 > 1 || d1 < 1 || d1 > Math.pow(10, 10) || d2 < 1 || d2 > Math.pow(10, 10)) {
          return error2.num;
        }
        if (typeof p2 !== "number" || typeof d1 !== "number" || typeof d2 !== "number") {
          return error2.value;
        }
        return jStat.centralF.inv(1 - p2, d1, d2);
      };
      exports$1.F.TEST = function(array1, array2) {
        if (!array1 || !array2) {
          return error2.na;
        }
        if (!(array1 instanceof Array) || !(array2 instanceof Array)) {
          return error2.na;
        }
        if (array1.length < 2 || array2.length < 2) {
          return error2.div0;
        }
        var sumOfSquares = function(values, x12) {
          var sum = 0;
          for (var i2 = 0; i2 < values.length; i2++) {
            sum += Math.pow(values[i2] - x12, 2);
          }
          return sum;
        };
        var x1 = mathTrig2.SUM(array1) / array1.length;
        var x2 = mathTrig2.SUM(array2) / array2.length;
        var sum1 = sumOfSquares(array1, x1) / (array1.length - 1);
        var sum2 = sumOfSquares(array2, x2) / (array2.length - 1);
        return sum1 / sum2;
      };
      exports$1.FISHER = function(x2) {
        x2 = utils2.parseNumber(x2);
        if (x2 instanceof Error) {
          return x2;
        }
        return Math.log((1 + x2) / (1 - x2)) / 2;
      };
      exports$1.FISHERINV = function(y2) {
        y2 = utils2.parseNumber(y2);
        if (y2 instanceof Error) {
          return y2;
        }
        var e2y = Math.exp(2 * y2);
        return (e2y - 1) / (e2y + 1);
      };
      exports$1.FORECAST = function(x2, data_y, data_x) {
        x2 = utils2.parseNumber(x2);
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(x2, data_y, data_x)) {
          return error2.value;
        }
        var xmean = jStat.mean(data_x);
        var ymean = jStat.mean(data_y);
        var n2 = data_x.length;
        var num = 0;
        var den = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          num += (data_x[i2] - xmean) * (data_y[i2] - ymean);
          den += Math.pow(data_x[i2] - xmean, 2);
        }
        var b2 = num / den;
        var a2 = ymean - b2 * xmean;
        return a2 + b2 * x2;
      };
      exports$1.FREQUENCY = function(data, bins) {
        data = utils2.parseNumberArray(utils2.flatten(data));
        bins = utils2.parseNumberArray(utils2.flatten(bins));
        if (utils2.anyIsError(data, bins)) {
          return error2.value;
        }
        var n2 = data.length;
        var b2 = bins.length;
        var r2 = [];
        for (var i2 = 0; i2 <= b2; i2++) {
          r2[i2] = 0;
          for (var j2 = 0; j2 < n2; j2++) {
            if (i2 === 0) {
              if (data[j2] <= bins[0]) {
                r2[0] += 1;
              }
            } else if (i2 < b2) {
              if (data[j2] > bins[i2 - 1] && data[j2] <= bins[i2]) {
                r2[i2] += 1;
              }
            } else if (i2 === b2) {
              if (data[j2] > bins[b2 - 1]) {
                r2[b2] += 1;
              }
            }
          }
        }
        return r2;
      };
      exports$1.GAMMA = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.num;
        }
        if (parseInt(number, 10) === number && number < 0) {
          return error2.num;
        }
        return jStat.gammafn(number);
      };
      exports$1.GAMMA.DIST = function(value, alpha, beta, cumulative) {
        if (arguments.length !== 4) {
          return error2.na;
        }
        if (value < 0 || alpha <= 0 || beta <= 0) {
          return error2.value;
        }
        if (typeof value !== "number" || typeof alpha !== "number" || typeof beta !== "number") {
          return error2.value;
        }
        return cumulative ? jStat.gamma.cdf(value, alpha, beta, true) : jStat.gamma.pdf(value, alpha, beta, false);
      };
      exports$1.GAMMA.INV = function(probability, alpha, beta) {
        if (arguments.length !== 3) {
          return error2.na;
        }
        if (probability < 0 || probability > 1 || alpha <= 0 || beta <= 0) {
          return error2.num;
        }
        if (typeof probability !== "number" || typeof alpha !== "number" || typeof beta !== "number") {
          return error2.value;
        }
        return jStat.gamma.inv(probability, alpha, beta);
      };
      exports$1.GAMMALN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return jStat.gammaln(number);
      };
      exports$1.GAMMALN.PRECISE = function(x2) {
        if (arguments.length !== 1) {
          return error2.na;
        }
        if (x2 <= 0) {
          return error2.num;
        }
        if (typeof x2 !== "number") {
          return error2.value;
        }
        return jStat.gammaln(x2);
      };
      exports$1.GAUSS = function(z2) {
        z2 = utils2.parseNumber(z2);
        if (z2 instanceof Error) {
          return z2;
        }
        return jStat.normal.cdf(z2, 0, 1) - 0.5;
      };
      exports$1.GEOMEAN = function() {
        var args = utils2.parseNumberArray(utils2.flatten(arguments));
        if (args instanceof Error) {
          return args;
        }
        return jStat.geomean(args);
      };
      exports$1.GROWTH = function(known_y, known_x, new_x, use_const) {
        known_y = utils2.parseNumberArray(known_y);
        if (known_y instanceof Error) {
          return known_y;
        }
        var i2;
        if (known_x === void 0) {
          known_x = [];
          for (i2 = 1; i2 <= known_y.length; i2++) {
            known_x.push(i2);
          }
        }
        if (new_x === void 0) {
          new_x = [];
          for (i2 = 1; i2 <= known_y.length; i2++) {
            new_x.push(i2);
          }
        }
        known_x = utils2.parseNumberArray(known_x);
        new_x = utils2.parseNumberArray(new_x);
        if (utils2.anyIsError(known_x, new_x)) {
          return error2.value;
        }
        if (use_const === void 0) {
          use_const = true;
        }
        var n2 = known_y.length;
        var avg_x = 0;
        var avg_y = 0;
        var avg_xy = 0;
        var avg_xx = 0;
        for (i2 = 0; i2 < n2; i2++) {
          var x2 = known_x[i2];
          var y2 = Math.log(known_y[i2]);
          avg_x += x2;
          avg_y += y2;
          avg_xy += x2 * y2;
          avg_xx += x2 * x2;
        }
        avg_x /= n2;
        avg_y /= n2;
        avg_xy /= n2;
        avg_xx /= n2;
        var beta;
        var alpha;
        if (use_const) {
          beta = (avg_xy - avg_x * avg_y) / (avg_xx - avg_x * avg_x);
          alpha = avg_y - beta * avg_x;
        } else {
          beta = avg_xy / avg_xx;
          alpha = 0;
        }
        var new_y = [];
        for (i2 = 0; i2 < new_x.length; i2++) {
          new_y.push(Math.exp(alpha + beta * new_x[i2]));
        }
        return new_y;
      };
      exports$1.HARMEAN = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var n2 = range.length;
        var den = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          den += 1 / range[i2];
        }
        return n2 / den;
      };
      exports$1.HYPGEOM = {};
      exports$1.HYPGEOM.DIST = function(x2, n2, M2, N2, cumulative) {
        x2 = utils2.parseNumber(x2);
        n2 = utils2.parseNumber(n2);
        M2 = utils2.parseNumber(M2);
        N2 = utils2.parseNumber(N2);
        if (utils2.anyIsError(x2, n2, M2, N2)) {
          return error2.value;
        }
        function pdf(x3, n3, M3, N3) {
          return mathTrig2.COMBIN(M3, x3) * mathTrig2.COMBIN(N3 - M3, n3 - x3) / mathTrig2.COMBIN(N3, n3);
        }
        function cdf(x3, n3, M3, N3) {
          var result = 0;
          for (var i2 = 0; i2 <= x3; i2++) {
            result += pdf(i2, n3, M3, N3);
          }
          return result;
        }
        return cumulative ? cdf(x2, n2, M2, N2) : pdf(x2, n2, M2, N2);
      };
      exports$1.INTERCEPT = function(known_y, known_x) {
        known_y = utils2.parseNumberArray(known_y);
        known_x = utils2.parseNumberArray(known_x);
        if (utils2.anyIsError(known_y, known_x)) {
          return error2.value;
        }
        if (known_y.length !== known_x.length) {
          return error2.na;
        }
        return exports$1.FORECAST(0, known_y, known_x);
      };
      exports$1.KURT = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var mean = jStat.mean(range);
        var n2 = range.length;
        var sigma = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range[i2] - mean, 4);
        }
        sigma = sigma / Math.pow(jStat.stdev(range, true), 4);
        return n2 * (n2 + 1) / ((n2 - 1) * (n2 - 2) * (n2 - 3)) * sigma - 3 * (n2 - 1) * (n2 - 1) / ((n2 - 2) * (n2 - 3));
      };
      exports$1.LARGE = function(range, k2) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(range, k2)) {
          return range;
        }
        if (k2 < 0 || range.length < k2) {
          return error2.value;
        }
        return range.sort(function(a2, b2) {
          return b2 - a2;
        })[k2 - 1];
      };
      exports$1.LINEST = function(data_y, data_x) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(data_y, data_x)) {
          return error2.value;
        }
        var ymean = jStat.mean(data_y);
        var xmean = jStat.mean(data_x);
        var n2 = data_x.length;
        var num = 0;
        var den = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          num += (data_x[i2] - xmean) * (data_y[i2] - ymean);
          den += Math.pow(data_x[i2] - xmean, 2);
        }
        var m2 = num / den;
        var b2 = ymean - m2 * xmean;
        return [m2, b2];
      };
      exports$1.LOGEST = function(data_y, data_x) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(data_y, data_x)) {
          return error2.value;
        }
        for (var i2 = 0; i2 < data_y.length; i2++) {
          data_y[i2] = Math.log(data_y[i2]);
        }
        var result = exports$1.LINEST(data_y, data_x);
        result[0] = Math.round(Math.exp(result[0]) * 1e6) / 1e6;
        result[1] = Math.round(Math.exp(result[1]) * 1e6) / 1e6;
        return result;
      };
      exports$1.LOGNORM = {};
      exports$1.LOGNORM.DIST = function(x2, mean, sd2, cumulative) {
        x2 = utils2.parseNumber(x2);
        mean = utils2.parseNumber(mean);
        sd2 = utils2.parseNumber(sd2);
        if (utils2.anyIsError(x2, mean, sd2)) {
          return error2.value;
        }
        return cumulative ? jStat.lognormal.cdf(x2, mean, sd2) : jStat.lognormal.pdf(x2, mean, sd2);
      };
      exports$1.LOGNORM.INV = function(probability, mean, sd2) {
        probability = utils2.parseNumber(probability);
        mean = utils2.parseNumber(mean);
        sd2 = utils2.parseNumber(sd2);
        if (utils2.anyIsError(probability, mean, sd2)) {
          return error2.value;
        }
        return jStat.lognormal.inv(probability, mean, sd2);
      };
      exports$1.MAX = function() {
        var flatArguments = utils2.flatten(arguments);
        var someError = utils2.anyError.apply(void 0, flatArguments);
        if (someError) {
          return someError;
        }
        var range = utils2.numbers(flatArguments);
        return range.length === 0 ? 0 : Math.max.apply(Math, range);
      };
      exports$1.MAXA = function() {
        var flatArguments = utils2.flatten(arguments);
        var someError = utils2.anyError.apply(void 0, flatArguments);
        if (someError) {
          return someError;
        }
        var range = utils2.arrayValuesToNumbers(flatArguments);
        range = range.map(function(value) {
          return value === void 0 || value === null ? 0 : value;
        });
        return range.length === 0 ? 0 : Math.max.apply(Math, range);
      };
      exports$1.MEDIAN = function() {
        var flatArguments = utils2.flatten(arguments);
        var someError = utils2.anyError.apply(void 0, flatArguments);
        if (someError) {
          return someError;
        }
        var range = utils2.arrayValuesToNumbers(flatArguments);
        var result = jStat.median(range);
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.MIN = function() {
        var flatArguments = utils2.flatten(arguments);
        var someError = utils2.anyError.apply(void 0, flatArguments);
        if (someError) {
          return someError;
        }
        var range = utils2.numbers(flatArguments);
        return range.length === 0 ? 0 : Math.min.apply(Math, range);
      };
      exports$1.MINA = function() {
        var flatArguments = utils2.flatten(arguments);
        var someError = utils2.anyError.apply(void 0, flatArguments);
        if (someError) {
          return someError;
        }
        var range = utils2.arrayValuesToNumbers(flatArguments);
        range = range.map(function(value) {
          return value === void 0 || value === null ? 0 : value;
        });
        return range.length === 0 ? 0 : Math.min.apply(Math, range);
      };
      exports$1.MODE = {};
      exports$1.MODE.MULT = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var n2 = range.length;
        var count = {};
        var maxItems = [];
        var max = 0;
        var currentItem;
        for (var i2 = 0; i2 < n2; i2++) {
          currentItem = range[i2];
          count[currentItem] = count[currentItem] ? count[currentItem] + 1 : 1;
          if (count[currentItem] > max) {
            max = count[currentItem];
            maxItems = [];
          }
          if (count[currentItem] === max) {
            maxItems[maxItems.length] = currentItem;
          }
        }
        return maxItems;
      };
      exports$1.MODE.SNGL = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        return exports$1.MODE.MULT(range).sort(function(a2, b2) {
          return a2 - b2;
        })[0];
      };
      exports$1.NEGBINOM = {};
      exports$1.NEGBINOM.DIST = function(k2, r2, p2, cumulative) {
        k2 = utils2.parseNumber(k2);
        r2 = utils2.parseNumber(r2);
        p2 = utils2.parseNumber(p2);
        if (utils2.anyIsError(k2, r2, p2)) {
          return error2.value;
        }
        return cumulative ? jStat.negbin.cdf(k2, r2, p2) : jStat.negbin.pdf(k2, r2, p2);
      };
      exports$1.NORM = {};
      exports$1.NORM.DIST = function(x2, mean, sd2, cumulative) {
        x2 = utils2.parseNumber(x2);
        mean = utils2.parseNumber(mean);
        sd2 = utils2.parseNumber(sd2);
        if (utils2.anyIsError(x2, mean, sd2)) {
          return error2.value;
        }
        if (sd2 <= 0) {
          return error2.num;
        }
        return cumulative ? jStat.normal.cdf(x2, mean, sd2) : jStat.normal.pdf(x2, mean, sd2);
      };
      exports$1.NORM.INV = function(probability, mean, sd2) {
        probability = utils2.parseNumber(probability);
        mean = utils2.parseNumber(mean);
        sd2 = utils2.parseNumber(sd2);
        if (utils2.anyIsError(probability, mean, sd2)) {
          return error2.value;
        }
        return jStat.normal.inv(probability, mean, sd2);
      };
      exports$1.NORM.S = {};
      exports$1.NORM.S.DIST = function(z2, cumulative) {
        z2 = utils2.parseNumber(z2);
        if (z2 instanceof Error) {
          return error2.value;
        }
        return cumulative ? jStat.normal.cdf(z2, 0, 1) : jStat.normal.pdf(z2, 0, 1);
      };
      exports$1.NORM.S.INV = function(probability) {
        probability = utils2.parseNumber(probability);
        if (probability instanceof Error) {
          return error2.value;
        }
        return jStat.normal.inv(probability, 0, 1);
      };
      exports$1.PEARSON = function(data_x, data_y) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(data_y, data_x)) {
          return error2.value;
        }
        var xmean = jStat.mean(data_x);
        var ymean = jStat.mean(data_y);
        var n2 = data_x.length;
        var num = 0;
        var den1 = 0;
        var den2 = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          num += (data_x[i2] - xmean) * (data_y[i2] - ymean);
          den1 += Math.pow(data_x[i2] - xmean, 2);
          den2 += Math.pow(data_y[i2] - ymean, 2);
        }
        return num / Math.sqrt(den1 * den2);
      };
      exports$1.PERCENTILE = {};
      exports$1.PERCENTILE.EXC = function(array, k2) {
        array = utils2.parseNumberArray(utils2.flatten(array));
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(array, k2)) {
          return error2.value;
        }
        array = array.sort(function(a2, b2) {
          {
            return a2 - b2;
          }
        });
        var n2 = array.length;
        if (k2 < 1 / (n2 + 1) || k2 > 1 - 1 / (n2 + 1)) {
          return error2.num;
        }
        var l2 = k2 * (n2 + 1) - 1;
        var fl2 = Math.floor(l2);
        return utils2.cleanFloat(l2 === fl2 ? array[l2] : array[fl2] + (l2 - fl2) * (array[fl2 + 1] - array[fl2]));
      };
      exports$1.PERCENTILE.INC = function(array, k2) {
        array = utils2.parseNumberArray(utils2.flatten(array));
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(array, k2)) {
          return error2.value;
        }
        array = array.sort(function(a2, b2) {
          return a2 - b2;
        });
        var n2 = array.length;
        var l2 = k2 * (n2 - 1);
        var fl2 = Math.floor(l2);
        return utils2.cleanFloat(l2 === fl2 ? array[l2] : array[fl2] + (l2 - fl2) * (array[fl2 + 1] - array[fl2]));
      };
      exports$1.PERCENTRANK = {};
      exports$1.PERCENTRANK.EXC = function(array, x2, significance) {
        significance = significance === void 0 ? 3 : significance;
        array = utils2.parseNumberArray(utils2.flatten(array));
        x2 = utils2.parseNumber(x2);
        significance = utils2.parseNumber(significance);
        if (utils2.anyIsError(array, x2, significance)) {
          return error2.value;
        }
        array = array.sort(function(a2, b2) {
          return a2 - b2;
        });
        var uniques = misc.UNIQUE.apply(null, array);
        var n2 = array.length;
        var m2 = uniques.length;
        var power = Math.pow(10, significance);
        var result = 0;
        var match = false;
        var i2 = 0;
        while (!match && i2 < m2) {
          if (x2 === uniques[i2]) {
            result = (array.indexOf(uniques[i2]) + 1) / (n2 + 1);
            match = true;
          } else if (x2 >= uniques[i2] && (x2 < uniques[i2 + 1] || i2 === m2 - 1)) {
            result = (array.indexOf(uniques[i2]) + 1 + (x2 - uniques[i2]) / (uniques[i2 + 1] - uniques[i2])) / (n2 + 1);
            match = true;
          }
          i2++;
        }
        return Math.floor(result * power) / power;
      };
      exports$1.PERCENTRANK.INC = function(array, x2, significance) {
        significance = significance === void 0 ? 3 : significance;
        array = utils2.parseNumberArray(utils2.flatten(array));
        x2 = utils2.parseNumber(x2);
        significance = utils2.parseNumber(significance);
        if (utils2.anyIsError(array, x2, significance)) {
          return error2.value;
        }
        array = array.sort(function(a2, b2) {
          return a2 - b2;
        });
        var uniques = misc.UNIQUE.apply(null, array);
        var n2 = array.length;
        var m2 = uniques.length;
        var power = Math.pow(10, significance);
        var result = 0;
        var match = false;
        var i2 = 0;
        while (!match && i2 < m2) {
          if (x2 === uniques[i2]) {
            result = array.indexOf(uniques[i2]) / (n2 - 1);
            match = true;
          } else if (x2 >= uniques[i2] && (x2 < uniques[i2 + 1] || i2 === m2 - 1)) {
            result = (array.indexOf(uniques[i2]) + (x2 - uniques[i2]) / (uniques[i2 + 1] - uniques[i2])) / (n2 - 1);
            match = true;
          }
          i2++;
        }
        return Math.floor(result * power) / power;
      };
      exports$1.PERMUT = function(number, number_chosen) {
        number = utils2.parseNumber(number);
        number_chosen = utils2.parseNumber(number_chosen);
        if (utils2.anyIsError(number, number_chosen)) {
          return error2.value;
        }
        return mathTrig2.FACT(number) / mathTrig2.FACT(number - number_chosen);
      };
      exports$1.PERMUTATIONA = function(number, number_chosen) {
        number = utils2.parseNumber(number);
        number_chosen = utils2.parseNumber(number_chosen);
        if (utils2.anyIsError(number, number_chosen)) {
          return error2.value;
        }
        return Math.pow(number, number_chosen);
      };
      exports$1.PHI = function(x2) {
        x2 = utils2.parseNumber(x2);
        if (x2 instanceof Error) {
          return error2.value;
        }
        return Math.exp(-0.5 * x2 * x2) / SQRT2PI;
      };
      exports$1.POISSON = {};
      exports$1.POISSON.DIST = function(x2, mean, cumulative) {
        x2 = utils2.parseNumber(x2);
        mean = utils2.parseNumber(mean);
        if (utils2.anyIsError(x2, mean)) {
          return error2.value;
        }
        return cumulative ? jStat.poisson.cdf(x2, mean) : jStat.poisson.pdf(x2, mean);
      };
      exports$1.PROB = function(range, probability, lower, upper) {
        if (lower === void 0) {
          return 0;
        }
        upper = upper === void 0 ? lower : upper;
        range = utils2.parseNumberArray(utils2.flatten(range));
        probability = utils2.parseNumberArray(utils2.flatten(probability));
        lower = utils2.parseNumber(lower);
        upper = utils2.parseNumber(upper);
        if (utils2.anyIsError(range, probability, lower, upper)) {
          return error2.value;
        }
        if (lower === upper) {
          return range.indexOf(lower) >= 0 ? probability[range.indexOf(lower)] : 0;
        }
        var sorted = range.sort(function(a2, b2) {
          return a2 - b2;
        });
        var n2 = sorted.length;
        var result = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          if (sorted[i2] >= lower && sorted[i2] <= upper) {
            result += probability[range.indexOf(sorted[i2])];
          }
        }
        return result;
      };
      exports$1.QUARTILE = {};
      exports$1.QUARTILE.EXC = function(range, quart) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        quart = utils2.parseNumber(quart);
        if (utils2.anyIsError(range, quart)) {
          return error2.value;
        }
        switch (quart) {
          case 1:
            return exports$1.PERCENTILE.EXC(range, 0.25);
          case 2:
            return exports$1.PERCENTILE.EXC(range, 0.5);
          case 3:
            return exports$1.PERCENTILE.EXC(range, 0.75);
          default:
            return error2.num;
        }
      };
      exports$1.QUARTILE.INC = function(range, quart) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        quart = utils2.parseNumber(quart);
        if (utils2.anyIsError(range, quart)) {
          return error2.value;
        }
        switch (quart) {
          case 1:
            return exports$1.PERCENTILE.INC(range, 0.25);
          case 2:
            return exports$1.PERCENTILE.INC(range, 0.5);
          case 3:
            return exports$1.PERCENTILE.INC(range, 0.75);
          default:
            return error2.num;
        }
      };
      exports$1.RANK = {};
      exports$1.RANK.AVG = function(number, range, order) {
        number = utils2.parseNumber(number);
        range = utils2.parseNumberArray(utils2.flatten(range));
        if (utils2.anyIsError(number, range)) {
          return error2.value;
        }
        range = utils2.flatten(range);
        order = order || false;
        var sort = order ? function(a2, b2) {
          return a2 - b2;
        } : function(a2, b2) {
          return b2 - a2;
        };
        range = range.sort(sort);
        var length = range.length;
        var count = 0;
        for (var i2 = 0; i2 < length; i2++) {
          if (range[i2] === number) {
            count++;
          }
        }
        return count > 1 ? (2 * range.indexOf(number) + count + 1) / 2 : range.indexOf(number) + 1;
      };
      exports$1.RANK.EQ = function(number, range, order) {
        number = utils2.parseNumber(number);
        range = utils2.parseNumberArray(utils2.flatten(range));
        if (utils2.anyIsError(number, range)) {
          return error2.value;
        }
        order = order || false;
        var sort = order ? function(a2, b2) {
          return a2 - b2;
        } : function(a2, b2) {
          return b2 - a2;
        };
        range = range.sort(sort);
        return range.indexOf(number) + 1;
      };
      exports$1.ROW = function(matrix, index2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (index2 < 0) {
          return error2.num;
        }
        if (!(matrix instanceof Array) || typeof index2 !== "number") {
          return error2.value;
        }
        if (matrix.length === 0) {
          return void 0;
        }
        return jStat.row(matrix, index2);
      };
      exports$1.ROWS = function(matrix) {
        if (arguments.length !== 1) {
          return error2.na;
        }
        if (!(matrix instanceof Array)) {
          return error2.value;
        }
        if (matrix.length === 0) {
          return 0;
        }
        return jStat.rows(matrix);
      };
      exports$1.RSQ = function(data_x, data_y) {
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        if (utils2.anyIsError(data_x, data_y)) {
          return error2.value;
        }
        return Math.pow(exports$1.PEARSON(data_x, data_y), 2);
      };
      exports$1.SKEW = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var mean = jStat.mean(range);
        var n2 = range.length;
        var sigma = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range[i2] - mean, 3);
        }
        return n2 * sigma / ((n2 - 1) * (n2 - 2) * Math.pow(jStat.stdev(range, true), 3));
      };
      exports$1.SKEW.P = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var mean = jStat.mean(range);
        var n2 = range.length;
        var m2 = 0;
        var m3 = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          m3 += Math.pow(range[i2] - mean, 3);
          m2 += Math.pow(range[i2] - mean, 2);
        }
        m3 = m3 / n2;
        m2 = m2 / n2;
        return m3 / Math.pow(m2, 3 / 2);
      };
      exports$1.SLOPE = function(data_y, data_x) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(data_y, data_x)) {
          return error2.value;
        }
        var xmean = jStat.mean(data_x);
        var ymean = jStat.mean(data_y);
        var n2 = data_x.length;
        var num = 0;
        var den = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          num += (data_x[i2] - xmean) * (data_y[i2] - ymean);
          den += Math.pow(data_x[i2] - xmean, 2);
        }
        return num / den;
      };
      exports$1.SMALL = function(range, k2) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        k2 = utils2.parseNumber(k2);
        if (utils2.anyIsError(range, k2)) {
          return range;
        }
        return range.sort(function(a2, b2) {
          return a2 - b2;
        })[k2 - 1];
      };
      exports$1.STANDARDIZE = function(x2, mean, sd2) {
        x2 = utils2.parseNumber(x2);
        mean = utils2.parseNumber(mean);
        sd2 = utils2.parseNumber(sd2);
        if (utils2.anyIsError(x2, mean, sd2)) {
          return error2.value;
        }
        return (x2 - mean) / sd2;
      };
      exports$1.STDEV = {};
      exports$1.STDEV.P = function() {
        var v2 = exports$1.VAR.P.apply(this, arguments);
        var result = Math.sqrt(v2);
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.STDEV.S = function() {
        var v2 = exports$1.VAR.S.apply(this, arguments);
        var result = Math.sqrt(v2);
        return result;
      };
      exports$1.STDEVA = function() {
        var v2 = exports$1.VARA.apply(this, arguments);
        var result = Math.sqrt(v2);
        return result;
      };
      exports$1.STDEVPA = function() {
        var v2 = exports$1.VARPA.apply(this, arguments);
        var result = Math.sqrt(v2);
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.STEYX = function(data_y, data_x) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        if (utils2.anyIsError(data_y, data_x)) {
          return error2.value;
        }
        var xmean = jStat.mean(data_x);
        var ymean = jStat.mean(data_y);
        var n2 = data_x.length;
        var lft = 0;
        var num = 0;
        var den = 0;
        for (var i2 = 0; i2 < n2; i2++) {
          lft += Math.pow(data_y[i2] - ymean, 2);
          num += (data_x[i2] - xmean) * (data_y[i2] - ymean);
          den += Math.pow(data_x[i2] - xmean, 2);
        }
        return Math.sqrt((lft - num * num / den) / (n2 - 2));
      };
      exports$1.TRANSPOSE = function(matrix) {
        if (!matrix) {
          return error2.na;
        }
        return jStat.transpose(matrix);
      };
      exports$1.T = text$1.T;
      exports$1.T.DIST = function(x2, df2, tails) {
        if (tails !== 1 && tails !== 2) {
          return error2.num;
        }
        return tails === 1 ? exports$1.T.DIST.RT(x2, df2) : exports$1.T.DIST["2T"](x2, df2);
      };
      exports$1.T.DIST["2T"] = function(x2, df2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (x2 < 0 || df2 < 1) {
          return error2.num;
        }
        if (typeof x2 !== "number" || typeof df2 !== "number") {
          return error2.value;
        }
        return (1 - jStat.studentt.cdf(x2, df2)) * 2;
      };
      exports$1.T.DIST.RT = function(x2, df2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (x2 < 0 || df2 < 1) {
          return error2.num;
        }
        if (typeof x2 !== "number" || typeof df2 !== "number") {
          return error2.value;
        }
        return 1 - jStat.studentt.cdf(x2, df2);
      };
      exports$1.T.INV = function(probability, df2) {
        probability = utils2.parseNumber(probability);
        df2 = utils2.parseNumber(df2);
        if (utils2.anyIsError(probability, df2)) {
          return error2.value;
        }
        return jStat.studentt.inv(probability, df2);
      };
      exports$1.T.INV["2T"] = function(probability, df2) {
        probability = utils2.parseNumber(probability);
        df2 = utils2.parseNumber(df2);
        if (probability <= 0 || probability > 1 || df2 < 1) {
          return error2.num;
        }
        if (utils2.anyIsError(probability, df2)) {
          return error2.value;
        }
        return Math.abs(jStat.studentt.inv(probability / 2, df2));
      };
      exports$1.T.TEST = function(data_x, data_y) {
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        if (utils2.anyIsError(data_x, data_y)) {
          return error2.value;
        }
        var mean_x = jStat.mean(data_x);
        var mean_y = jStat.mean(data_y);
        var s_x = 0;
        var s_y = 0;
        var i2;
        for (i2 = 0; i2 < data_x.length; i2++) {
          s_x += Math.pow(data_x[i2] - mean_x, 2);
        }
        for (i2 = 0; i2 < data_y.length; i2++) {
          s_y += Math.pow(data_y[i2] - mean_y, 2);
        }
        s_x = s_x / (data_x.length - 1);
        s_y = s_y / (data_y.length - 1);
        var t2 = Math.abs(mean_x - mean_y) / Math.sqrt(s_x / data_x.length + s_y / data_y.length);
        return exports$1.T.DIST["2T"](t2, data_x.length + data_y.length - 2);
      };
      exports$1.TREND = function(data_y, data_x, new_data_x) {
        data_y = utils2.parseNumberArray(utils2.flatten(data_y));
        data_x = utils2.parseNumberArray(utils2.flatten(data_x));
        new_data_x = utils2.parseNumberArray(utils2.flatten(new_data_x));
        if (utils2.anyIsError(data_y, data_x, new_data_x)) {
          return error2.value;
        }
        var linest = exports$1.LINEST(data_y, data_x);
        var m2 = linest[0];
        var b2 = linest[1];
        var result = [];
        new_data_x.forEach(function(x2) {
          result.push(m2 * x2 + b2);
        });
        return result;
      };
      exports$1.TRIMMEAN = function(range, percent) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        percent = utils2.parseNumber(percent);
        if (utils2.anyIsError(range, percent)) {
          return error2.value;
        }
        var trim = mathTrig2.FLOOR(range.length * percent, 2) / 2;
        return jStat.mean(utils2.initial(utils2.rest(range.sort(function(a2, b2) {
          return a2 - b2;
        }), trim), trim));
      };
      exports$1.VAR = {};
      exports$1.VAR.P = function() {
        var range = utils2.numbers(utils2.flatten(arguments));
        var n2 = range.length;
        var sigma = 0;
        var mean = exports$1.AVERAGE(range);
        var result;
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range[i2] - mean, 2);
        }
        result = sigma / n2;
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.VAR.S = function() {
        var range = utils2.numbers(utils2.flatten(arguments));
        var n2 = range.length;
        var sigma = 0;
        var mean = exports$1.AVERAGE(range);
        for (var i2 = 0; i2 < n2; i2++) {
          sigma += Math.pow(range[i2] - mean, 2);
        }
        return sigma / (n2 - 1);
      };
      exports$1.VARA = function() {
        var range = utils2.flatten(arguments);
        var n2 = range.length;
        var sigma = 0;
        var count = 0;
        var mean = exports$1.AVERAGEA(range);
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range[i2];
          if (typeof el2 === "number") {
            sigma += Math.pow(el2 - mean, 2);
          } else if (el2 === true) {
            sigma += Math.pow(1 - mean, 2);
          } else {
            sigma += Math.pow(0 - mean, 2);
          }
          if (el2 !== null) {
            count++;
          }
        }
        return sigma / (count - 1);
      };
      exports$1.VARPA = function() {
        var range = utils2.flatten(arguments);
        var n2 = range.length;
        var sigma = 0;
        var count = 0;
        var mean = exports$1.AVERAGEA(range);
        var result;
        for (var i2 = 0; i2 < n2; i2++) {
          var el2 = range[i2];
          if (typeof el2 === "number") {
            sigma += Math.pow(el2 - mean, 2);
          } else if (el2 === true) {
            sigma += Math.pow(1 - mean, 2);
          } else {
            sigma += Math.pow(0 - mean, 2);
          }
          if (el2 !== null) {
            count++;
          }
        }
        result = sigma / count;
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.WEIBULL = {};
      exports$1.WEIBULL.DIST = function(x2, alpha, beta, cumulative) {
        x2 = utils2.parseNumber(x2);
        alpha = utils2.parseNumber(alpha);
        beta = utils2.parseNumber(beta);
        if (utils2.anyIsError(x2, alpha, beta)) {
          return error2.value;
        }
        return cumulative ? 1 - Math.exp(-Math.pow(x2 / beta, alpha)) : Math.pow(x2, alpha - 1) * Math.exp(-Math.pow(x2 / beta, alpha)) * alpha / Math.pow(beta, alpha);
      };
      exports$1.Z = {};
      exports$1.Z.TEST = function(range, x2, sd2) {
        range = utils2.parseNumberArray(utils2.flatten(range));
        x2 = utils2.parseNumber(x2);
        if (utils2.anyIsError(range, x2)) {
          return error2.value;
        }
        sd2 = sd2 || exports$1.STDEV.S(range);
        var n2 = range.length;
        return 1 - exports$1.NORM.S.DIST((exports$1.AVERAGE(range) - x2) / (sd2 / Math.sqrt(n2)), true);
      };
    })(statistical$1);
    return statistical$1;
  }
  var information$1 = {};
  (function(exports$1) {
    var error2 = error$3;
    exports$1.CELL = function() {
      throw new Error("CELL is not implemented");
    };
    exports$1.ERROR = {};
    exports$1.ERROR.TYPE = function(error_val) {
      switch (error_val) {
        case error2.nil:
          return 1;
        case error2.div0:
          return 2;
        case error2.value:
          return 3;
        case error2.ref:
          return 4;
        case error2.name:
          return 5;
        case error2.num:
          return 6;
        case error2.na:
          return 7;
        case error2.data:
          return 8;
      }
      return error2.na;
    };
    exports$1.INFO = function() {
      throw new Error("INFO is not implemented");
    };
    exports$1.ISBLANK = function(value) {
      return value === null;
    };
    exports$1.ISBINARY = function(number) {
      return /^[01]{1,10}$/.test(number);
    };
    exports$1.ISERR = function(value) {
      return [error2.value, error2.ref, error2.div0, error2.num, error2.name, error2.nil].indexOf(value) >= 0 || typeof value === "number" && (isNaN(value) || !isFinite(value));
    };
    exports$1.ISERROR = function(value) {
      return exports$1.ISERR(value) || value === error2.na;
    };
    exports$1.ISEVEN = function(number) {
      return Math.floor(Math.abs(number)) & 1 ? false : true;
    };
    exports$1.ISFORMULA = function() {
      throw new Error("ISFORMULA is not implemented");
    };
    exports$1.ISLOGICAL = function(value) {
      return value === true || value === false;
    };
    exports$1.ISNA = function(value) {
      return value === error2.na;
    };
    exports$1.ISNONTEXT = function(value) {
      return typeof value !== "string";
    };
    exports$1.ISNUMBER = function(value) {
      return typeof value === "number" && !isNaN(value) && isFinite(value);
    };
    exports$1.ISODD = function(number) {
      return Math.floor(Math.abs(number)) & 1 ? true : false;
    };
    exports$1.ISREF = function() {
      throw new Error("ISREF is not implemented");
    };
    exports$1.ISTEXT = function(value) {
      return typeof value === "string";
    };
    exports$1.N = function(value) {
      if (this.ISNUMBER(value)) {
        return value;
      }
      if (value instanceof Date) {
        return value.getTime();
      }
      if (value === true) {
        return 1;
      }
      if (value === false) {
        return 0;
      }
      if (this.ISERROR(value)) {
        return value;
      }
      return 0;
    };
    exports$1.NA = function() {
      return error2.na;
    };
    exports$1.SHEET = function() {
      throw new Error("SHEET is not implemented");
    };
    exports$1.SHEETS = function() {
      throw new Error("SHEETS is not implemented");
    };
    exports$1.TYPE = function(value) {
      if (this.ISNUMBER(value)) {
        return 1;
      }
      if (this.ISTEXT(value)) {
        return 2;
      }
      if (this.ISLOGICAL(value)) {
        return 4;
      }
      if (this.ISERROR(value)) {
        return 16;
      }
      if (Array.isArray(value)) {
        return 64;
      }
    };
  })(information$1);
  var hasRequiredMathTrig;
  function requireMathTrig() {
    if (hasRequiredMathTrig) return mathTrig$1;
    hasRequiredMathTrig = 1;
    (function(exports$1) {
      var utils2 = common;
      var error2 = error$3;
      var statistical2 = requireStatistical();
      var information2 = information$1;
      var evalExpression = criteriaEval;
      exports$1.ABS = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.abs(number);
        return result;
      };
      exports$1.ACOS = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.acos(number);
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.ACOSH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.log(number + Math.sqrt(number * number - 1));
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.ACOT = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.atan(1 / number);
        return result;
      };
      exports$1.ACOTH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = 0.5 * Math.log((number + 1) / (number - 1));
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.AGGREGATE = function(function_num, options, ref1, ref2) {
        function_num = utils2.parseNumber(function_num);
        options = utils2.parseNumber(function_num);
        if (utils2.anyIsError(function_num, options)) {
          return error2.value;
        }
        switch (function_num) {
          case 1:
            return statistical2.AVERAGE(ref1);
          case 2:
            return statistical2.COUNT(ref1);
          case 3:
            return statistical2.COUNTA(ref1);
          case 4:
            return statistical2.MAX(ref1);
          case 5:
            return statistical2.MIN(ref1);
          case 6:
            return exports$1.PRODUCT(ref1);
          case 7:
            return statistical2.STDEV.S(ref1);
          case 8:
            return statistical2.STDEV.P(ref1);
          case 9:
            return exports$1.SUM(ref1);
          case 10:
            return statistical2.VAR.S(ref1);
          case 11:
            return statistical2.VAR.P(ref1);
          case 12:
            return statistical2.MEDIAN(ref1);
          case 13:
            return statistical2.MODE.SNGL(ref1);
          case 14:
            return statistical2.LARGE(ref1, ref2);
          case 15:
            return statistical2.SMALL(ref1, ref2);
          case 16:
            return statistical2.PERCENTILE.INC(ref1, ref2);
          case 17:
            return statistical2.QUARTILE.INC(ref1, ref2);
          case 18:
            return statistical2.PERCENTILE.EXC(ref1, ref2);
          case 19:
            return statistical2.QUARTILE.EXC(ref1, ref2);
        }
      };
      exports$1.ARABIC = function(text2) {
        if (text2 === void 0 || text2 === null) {
          return 0;
        }
        if (text2 instanceof Error) {
          return text2;
        }
        if (!/^M*(?:D?C{0,3}|C[MD])(?:L?X{0,3}|X[CL])(?:V?I{0,3}|I[XV])$/.test(text2)) {
          return error2.value;
        }
        var r2 = 0;
        text2.replace(/[MDLV]|C[MD]?|X[CL]?|I[XV]?/g, function(i2) {
          r2 += {
            M: 1e3,
            CM: 900,
            D: 500,
            CD: 400,
            C: 100,
            XC: 90,
            L: 50,
            XL: 40,
            X: 10,
            IX: 9,
            V: 5,
            IV: 4,
            I: 1
          }[i2];
        });
        return r2;
      };
      exports$1.ASIN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.asin(number);
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.ASINH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.log(number + Math.sqrt(number * number + 1));
      };
      exports$1.ATAN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.atan(number);
      };
      exports$1.ATAN2 = function(number_x, number_y) {
        number_x = utils2.parseNumber(number_x);
        number_y = utils2.parseNumber(number_y);
        var anyError = utils2.anyError(number_x, number_y);
        if (anyError) {
          return anyError;
        }
        return Math.atan2(number_x, number_y);
      };
      exports$1.ATANH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var result = Math.log((1 + number) / (1 - number)) / 2;
        if (isNaN(result)) {
          result = error2.num;
        }
        return result;
      };
      exports$1.BASE = function(number, radix, min_length) {
        number = utils2.parseNumber(number);
        radix = utils2.parseNumber(radix);
        min_length = utils2.parseNumber(min_length);
        var anyError = utils2.anyError(number, radix, min_length);
        if (anyError) {
          return anyError;
        }
        if (radix === 0) {
          return error2.num;
        }
        var result = number.toString(radix);
        return new Array(Math.max(min_length + 1 - result.length, 0)).join("0") + result;
      };
      exports$1.CEILING = function(number, significance, mode) {
        number = utils2.parseNumber(number);
        significance = utils2.parseNumber(significance);
        mode = utils2.parseNumber(mode);
        var anyError = utils2.anyError(number, significance, mode);
        if (anyError) {
          return anyError;
        }
        if (significance === 0) {
          return 0;
        }
        significance = Math.abs(significance);
        var precision = -Math.floor(Math.log(significance) / Math.log(10));
        if (number >= 0) {
          return exports$1.ROUND(Math.ceil(number / significance) * significance, precision);
        } else {
          if (mode === 0) {
            return -exports$1.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
          } else {
            return -exports$1.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
          }
        }
      };
      exports$1.CEILING.MATH = exports$1.CEILING;
      exports$1.CEILING.PRECISE = exports$1.CEILING;
      exports$1.COMBIN = function(number, number_chosen) {
        number = utils2.parseNumber(number);
        number_chosen = utils2.parseNumber(number_chosen);
        var anyError = utils2.anyError(number, number_chosen);
        if (anyError) {
          return anyError;
        }
        if (number < number_chosen) {
          return error2.num;
        }
        return exports$1.FACT(number) / (exports$1.FACT(number_chosen) * exports$1.FACT(number - number_chosen));
      };
      exports$1.COMBINA = function(number, number_chosen) {
        number = utils2.parseNumber(number);
        number_chosen = utils2.parseNumber(number_chosen);
        var anyError = utils2.anyError(number, number_chosen);
        if (anyError) {
          return anyError;
        }
        if (number < number_chosen) {
          return error2.num;
        }
        return number === 0 && number_chosen === 0 ? 1 : exports$1.COMBIN(number + number_chosen - 1, number - 1);
      };
      exports$1.COS = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.cos(number);
      };
      exports$1.COSH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return (Math.exp(number) + Math.exp(-number)) / 2;
      };
      exports$1.COT = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.div0;
        }
        return 1 / Math.tan(number);
      };
      exports$1.COTH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.div0;
        }
        var e2 = Math.exp(2 * number);
        return (e2 + 1) / (e2 - 1);
      };
      exports$1.CSC = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.div0;
        }
        return 1 / Math.sin(number);
      };
      exports$1.CSCH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.div0;
        }
        return 2 / (Math.exp(number) - Math.exp(-number));
      };
      exports$1.DECIMAL = function(number, radix) {
        if (arguments.length < 1) {
          return error2.value;
        }
        number = utils2.parseNumber(number);
        radix = utils2.parseNumber(radix);
        var anyError = utils2.anyError(number, radix);
        if (anyError) {
          return anyError;
        }
        if (radix === 0) {
          return error2.num;
        }
        return parseInt(number, radix);
      };
      exports$1.DEGREES = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return number * 180 / Math.PI;
      };
      exports$1.EVEN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return exports$1.CEILING(number, -2, -1);
      };
      exports$1.EXP = function(number) {
        if (arguments.length < 1) {
          return error2.na;
        }
        if (arguments.length > 1) {
          return error2.error;
        }
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        number = Math.exp(number);
        return number;
      };
      var MEMOIZED_FACT = [];
      exports$1.FACT = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var n2 = Math.floor(number);
        if (n2 === 0 || n2 === 1) {
          return 1;
        } else if (MEMOIZED_FACT[n2] > 0) {
          return MEMOIZED_FACT[n2];
        } else {
          MEMOIZED_FACT[n2] = exports$1.FACT(n2 - 1) * n2;
          return MEMOIZED_FACT[n2];
        }
      };
      exports$1.FACTDOUBLE = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var n2 = Math.floor(number);
        if (n2 <= 0) {
          return 1;
        } else {
          return n2 * exports$1.FACTDOUBLE(n2 - 2);
        }
      };
      exports$1.FLOOR = function(number, significance) {
        number = utils2.parseNumber(number);
        significance = utils2.parseNumber(significance);
        var anyError = utils2.anyError(number, significance);
        if (anyError) {
          return anyError;
        }
        if (significance === 0) {
          return 0;
        }
        if (!(number >= 0 && significance > 0) && !(number <= 0 && significance < 0)) {
          return error2.num;
        }
        significance = Math.abs(significance);
        var precision = -Math.floor(Math.log(significance) / Math.log(10));
        if (number >= 0) {
          return exports$1.ROUND(Math.floor(number / significance) * significance, precision);
        } else {
          return -exports$1.ROUND(Math.ceil(Math.abs(number) / significance), precision);
        }
      };
      exports$1.FLOOR.MATH = function(number, significance, mode) {
        if (significance instanceof Error) {
          return significance;
        }
        significance = significance === void 0 ? 0 : significance;
        number = utils2.parseNumber(number);
        significance = utils2.parseNumber(significance);
        mode = utils2.parseNumber(mode);
        var anyError = utils2.anyError(number, significance, mode);
        if (anyError) {
          return anyError;
        }
        if (significance === 0) {
          return 0;
        }
        significance = significance ? Math.abs(significance) : 1;
        var precision = -Math.floor(Math.log(significance) / Math.log(10));
        if (number >= 0) {
          return exports$1.ROUND(Math.floor(number / significance) * significance, precision);
        } else if (mode === 0 || mode === void 0) {
          return -exports$1.ROUND(Math.ceil(Math.abs(number) / significance) * significance, precision);
        }
        return -exports$1.ROUND(Math.floor(Math.abs(number) / significance) * significance, precision);
      };
      exports$1.FLOOR.PRECISE = exports$1.FLOOR.MATH;
      exports$1.GCD = function() {
        var range = utils2.parseNumberArray(utils2.flatten(arguments));
        if (range instanceof Error) {
          return range;
        }
        var n2 = range.length;
        var r0 = range[0];
        var x2 = r0 < 0 ? -r0 : r0;
        for (var i2 = 1; i2 < n2; i2++) {
          var ri2 = range[i2];
          var y2 = ri2 < 0 ? -ri2 : ri2;
          while (x2 && y2) {
            if (x2 > y2) {
              x2 %= y2;
            } else {
              y2 %= x2;
            }
          }
          x2 += y2;
        }
        return x2;
      };
      exports$1.INT = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.floor(number);
      };
      exports$1.ISO = {
        CEILING: exports$1.CEILING
      };
      exports$1.LCM = function() {
        var o2 = utils2.parseNumberArray(utils2.flatten(arguments));
        if (o2 instanceof Error) {
          return o2;
        }
        for (var i2, j2, n2, d2, r2 = 1; (n2 = o2.pop()) !== void 0; ) {
          if (n2 === 0) {
            return 0;
          }
          while (n2 > 1) {
            if (n2 % 2) {
              for (i2 = 3, j2 = Math.floor(Math.sqrt(n2)); i2 <= j2 && n2 % i2; i2 += 2) {
              }
              d2 = i2 <= j2 ? i2 : n2;
            } else {
              d2 = 2;
            }
            for (n2 /= d2, r2 *= d2, i2 = o2.length; i2; o2[--i2] % d2 === 0 && (o2[i2] /= d2) === 1 && o2.splice(i2, 1)) {
            }
          }
        }
        return r2;
      };
      exports$1.LN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.num;
        }
        return Math.log(number);
      };
      exports$1.LN10 = function() {
        return Math.log(10);
      };
      exports$1.LN2 = function() {
        return Math.log(2);
      };
      exports$1.LOG10E = function() {
        return Math.LOG10E;
      };
      exports$1.LOG2E = function() {
        return Math.LOG2E;
      };
      exports$1.LOG = function(number, base) {
        number = utils2.parseNumber(number);
        base = utils2.parseNumber(base);
        var anyError = utils2.anyError(number, base);
        if (anyError) {
          return anyError;
        }
        if (number === 0 || base === 0) {
          return error2.num;
        }
        return Math.log(number) / Math.log(base);
      };
      exports$1.LOG10 = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number === 0) {
          return error2.num;
        }
        return Math.log(number) / Math.log(10);
      };
      exports$1.MOD = function(dividend, divisor) {
        dividend = utils2.parseNumber(dividend);
        divisor = utils2.parseNumber(divisor);
        var anyError = utils2.anyError(dividend, divisor);
        if (anyError) {
          return anyError;
        }
        if (divisor === 0) {
          return error2.div0;
        }
        var modulus = Math.abs(dividend % divisor);
        modulus = dividend < 0 ? divisor - modulus : modulus;
        return divisor > 0 ? modulus : -modulus;
      };
      exports$1.MROUND = function(number, multiple) {
        number = utils2.parseNumber(number);
        multiple = utils2.parseNumber(multiple);
        var anyError = utils2.anyError(number, multiple);
        if (anyError) {
          return anyError;
        }
        if (number * multiple === 0) {
          return 0;
        }
        if (number * multiple < 0) {
          return error2.num;
        }
        return Math.round(number / multiple) * multiple;
      };
      exports$1.MULTINOMIAL = function() {
        var args = utils2.parseNumberArray(utils2.flatten(arguments));
        if (args instanceof Error) {
          return args;
        }
        var sum = 0;
        var divisor = 1;
        for (var i2 = 0; i2 < args.length; i2++) {
          sum += args[i2];
          divisor *= exports$1.FACT(args[i2]);
        }
        return exports$1.FACT(sum) / divisor;
      };
      exports$1.ODD = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var temp = Math.ceil(Math.abs(number));
        temp = temp & 1 ? temp : temp + 1;
        return number >= 0 ? temp : -temp;
      };
      exports$1.PI = function() {
        return Math.PI;
      };
      exports$1.E = function() {
        return Math.E;
      };
      exports$1.POWER = function(number, power) {
        number = utils2.parseNumber(number);
        power = utils2.parseNumber(power);
        var anyError = utils2.anyError(number, power);
        if (anyError) {
          return anyError;
        }
        if (number === 0 && power === 0) {
          return error2.num;
        }
        var result = Math.pow(number, power);
        if (isNaN(result)) {
          return error2.num;
        }
        return result;
      };
      exports$1.PRODUCT = function() {
        var flatArguments = utils2.flatten(arguments);
        var flatArgumentsDefined = flatArguments.filter(function(arg) {
          return arg !== void 0 && arg !== null;
        });
        if (flatArgumentsDefined.length === 0) {
          return 0;
        }
        var args = utils2.parseNumberArray(flatArgumentsDefined);
        if (args instanceof Error) {
          return args;
        }
        var result = 1;
        for (var i2 = 0; i2 < args.length; i2++) {
          result *= args[i2];
        }
        return result;
      };
      exports$1.QUOTIENT = function(numerator, denominator) {
        numerator = utils2.parseNumber(numerator);
        denominator = utils2.parseNumber(denominator);
        var anyError = utils2.anyError(numerator, denominator);
        if (anyError) {
          return anyError;
        }
        return parseInt(numerator / denominator, 10);
      };
      exports$1.RADIANS = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return number * Math.PI / 180;
      };
      exports$1.RAND = function() {
        return Math.random();
      };
      exports$1.RANDBETWEEN = function(bottom, top) {
        bottom = utils2.parseNumber(bottom);
        top = utils2.parseNumber(top);
        var anyError = utils2.anyError(bottom, top);
        if (anyError) {
          return anyError;
        }
        return bottom + Math.ceil((top - bottom + 1) * Math.random()) - 1;
      };
      exports$1.ROMAN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var digits = String(number).split("");
        var key = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM", "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC", "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
        var roman = "";
        var i2 = 3;
        while (i2--) {
          roman = (key[+digits.pop() + i2 * 10] || "") + roman;
        }
        return new Array(+digits.join("") + 1).join("M") + roman;
      };
      exports$1.ROUND = function(number, digits) {
        number = utils2.parseNumber(number);
        digits = utils2.parseNumber(digits);
        var anyError = utils2.anyError(number, digits);
        if (anyError) {
          return anyError;
        }
        return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports$1.ROUNDDOWN = function(number, digits) {
        number = utils2.parseNumber(number);
        digits = utils2.parseNumber(digits);
        var anyError = utils2.anyError(number, digits);
        if (anyError) {
          return anyError;
        }
        var sign = number > 0 ? 1 : -1;
        return sign * Math.floor(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports$1.ROUNDUP = function(number, digits) {
        number = utils2.parseNumber(number);
        digits = utils2.parseNumber(digits);
        var anyError = utils2.anyError(number, digits);
        if (anyError) {
          return anyError;
        }
        var sign = number > 0 ? 1 : -1;
        return sign * Math.ceil(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
      exports$1.SEC = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return 1 / Math.cos(number);
      };
      exports$1.SECH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return 2 / (Math.exp(number) + Math.exp(-number));
      };
      exports$1.SERIESSUM = function(x2, n2, m2, coefficients) {
        x2 = utils2.parseNumber(x2);
        n2 = utils2.parseNumber(n2);
        m2 = utils2.parseNumber(m2);
        coefficients = utils2.parseNumberArray(coefficients);
        if (utils2.anyIsError(x2, n2, m2, coefficients)) {
          return error2.value;
        }
        var result = coefficients[0] * Math.pow(x2, n2);
        for (var i2 = 1; i2 < coefficients.length; i2++) {
          result += coefficients[i2] * Math.pow(x2, n2 + i2 * m2);
        }
        return result;
      };
      exports$1.SIGN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number < 0) {
          return -1;
        } else if (number === 0) {
          return 0;
        } else {
          return 1;
        }
      };
      exports$1.SIN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.sin(number);
      };
      exports$1.SINH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return (Math.exp(number) - Math.exp(-number)) / 2;
      };
      exports$1.SQRT = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        if (number < 0) {
          return error2.num;
        }
        return Math.sqrt(number);
      };
      exports$1.SQRTPI = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.sqrt(number * Math.PI);
      };
      exports$1.SQRT1_2 = function() {
        return 1 / Math.sqrt(2);
      };
      exports$1.SQRT2 = function() {
        return Math.sqrt(2);
      };
      exports$1.SUBTOTAL = function(function_code, ref1) {
        function_code = utils2.parseNumber(function_code);
        if (function_code instanceof Error) {
          return function_code;
        }
        switch (function_code) {
          case 1:
            return statistical2.AVERAGE(ref1);
          case 2:
            return statistical2.COUNT(ref1);
          case 3:
            return statistical2.COUNTA(ref1);
          case 4:
            return statistical2.MAX(ref1);
          case 5:
            return statistical2.MIN(ref1);
          case 6:
            return exports$1.PRODUCT(ref1);
          case 7:
            return statistical2.STDEV.S(ref1);
          case 8:
            return statistical2.STDEV.P(ref1);
          case 9:
            return exports$1.SUM(ref1);
          case 10:
            return statistical2.VAR.S(ref1);
          case 11:
            return statistical2.VAR.P(ref1);
          case 101:
            return statistical2.AVERAGE(ref1);
          case 102:
            return statistical2.COUNT(ref1);
          case 103:
            return statistical2.COUNTA(ref1);
          case 104:
            return statistical2.MAX(ref1);
          case 105:
            return statistical2.MIN(ref1);
          case 106:
            return exports$1.PRODUCT(ref1);
          case 107:
            return statistical2.STDEV.S(ref1);
          case 108:
            return statistical2.STDEV.P(ref1);
          case 109:
            return exports$1.SUM(ref1);
          case 110:
            return statistical2.VAR.S(ref1);
          case 111:
            return statistical2.VAR.P(ref1);
        }
      };
      exports$1.ADD = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        num1 = utils2.parseNumber(num1);
        num2 = utils2.parseNumber(num2);
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 + num2;
      };
      exports$1.MINUS = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        num1 = utils2.parseNumber(num1);
        num2 = utils2.parseNumber(num2);
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 - num2;
      };
      exports$1.DIVIDE = function(dividend, divisor) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        dividend = utils2.parseNumber(dividend);
        divisor = utils2.parseNumber(divisor);
        var anyError = utils2.anyError(dividend, divisor);
        if (anyError) {
          return anyError;
        }
        if (divisor === 0) {
          return error2.div0;
        }
        return dividend / divisor;
      };
      exports$1.MULTIPLY = function(factor1, factor2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        factor1 = utils2.parseNumber(factor1);
        factor2 = utils2.parseNumber(factor2);
        var anyError = utils2.anyError(factor1, factor2);
        if (anyError) {
          return anyError;
        }
        return factor1 * factor2;
      };
      exports$1.GT = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (num1 instanceof Error) {
          return num1;
        }
        if (num2 instanceof Error) {
          return num2;
        }
        if (utils2.anyIsString(num1, num2)) {
          num1 = utils2.parseString(num1);
          num2 = utils2.parseString(num2);
        } else {
          num1 = utils2.parseNumber(num1);
          num2 = utils2.parseNumber(num2);
        }
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 > num2;
      };
      exports$1.GTE = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (utils2.anyIsString(num1, num2)) {
          num1 = utils2.parseString(num1);
          num2 = utils2.parseString(num2);
        } else {
          num1 = utils2.parseNumber(num1);
          num2 = utils2.parseNumber(num2);
        }
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 >= num2;
      };
      exports$1.LT = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (utils2.anyIsString(num1, num2)) {
          num1 = utils2.parseString(num1);
          num2 = utils2.parseString(num2);
        } else {
          num1 = utils2.parseNumber(num1);
          num2 = utils2.parseNumber(num2);
        }
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 < num2;
      };
      exports$1.LTE = function(num1, num2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (utils2.anyIsString(num1, num2)) {
          num1 = utils2.parseString(num1);
          num2 = utils2.parseString(num2);
        } else {
          num1 = utils2.parseNumber(num1);
          num2 = utils2.parseNumber(num2);
        }
        var anyError = utils2.anyError(num1, num2);
        if (anyError) {
          return anyError;
        }
        return num1 <= num2;
      };
      exports$1.EQ = function(value1, value2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (value1 instanceof Error) {
          return value1;
        }
        if (value2 instanceof Error) {
          return value2;
        }
        if (value1 === null) {
          value1 = void 0;
        }
        if (value2 === null) {
          value2 = void 0;
        }
        return value1 === value2;
      };
      exports$1.NE = function(value1, value2) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        if (value1 instanceof Error) {
          return value1;
        }
        if (value2 instanceof Error) {
          return value2;
        }
        if (value1 === null) {
          value1 = void 0;
        }
        if (value2 === null) {
          value2 = void 0;
        }
        return value1 !== value2;
      };
      exports$1.POW = function(base, exponent) {
        if (arguments.length !== 2) {
          return error2.na;
        }
        return exports$1.POWER(base, exponent);
      };
      exports$1.SUM = function() {
        var result = 0;
        utils2.arrayEach(utils2.argsToArray(arguments), function(value) {
          if (result instanceof Error) {
            return false;
          } else if (value instanceof Error) {
            result = value;
          } else if (typeof value === "number") {
            result += value;
          } else if (typeof value === "string") {
            var parsed = parseFloat(value);
            !isNaN(parsed) && (result += parsed);
          } else if (Array.isArray(value)) {
            var inner_result = exports$1.SUM.apply(null, value);
            if (inner_result instanceof Error) {
              result = inner_result;
            } else {
              result += inner_result;
            }
          }
        });
        return result;
      };
      exports$1.SUMIF = function(range, criteria, sumRange) {
        range = utils2.flatten(range);
        if (sumRange) {
          sumRange = utils2.flatten(sumRange);
        } else {
          sumRange = range;
        }
        if (range instanceof Error) {
          return range;
        }
        if (criteria === void 0 || criteria === null || criteria instanceof Error) {
          return 0;
        }
        var result = 0;
        var isWildcard = criteria === "*";
        var tokenizedCriteria = isWildcard ? null : evalExpression.parse(criteria + "");
        for (var i2 = 0; i2 < range.length; i2++) {
          var value = range[i2];
          var sumValue = sumRange[i2];
          if (isWildcard) {
            result += value;
          } else {
            var tokens = [evalExpression.createToken(value, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
            result += evalExpression.compute(tokens) ? sumValue : 0;
          }
        }
        return result;
      };
      exports$1.SUMIFS = function() {
        var args = utils2.argsToArray(arguments);
        var range = utils2.parseNumberArray(utils2.flatten(args.shift()));
        if (range instanceof Error) {
          return range;
        }
        var criterias = args;
        var criteriaLength = criterias.length / 2;
        for (var i2 = 0; i2 < criteriaLength; i2++) {
          criterias[i2 * 2] = utils2.flatten(criterias[i2 * 2]);
        }
        var result = 0;
        for (var i2 = 0; i2 < range.length; i2++) {
          var isMeetCondition = false;
          for (var j2 = 0; j2 < criteriaLength; j2++) {
            var valueToTest = criterias[j2 * 2][i2];
            var criteria = criterias[j2 * 2 + 1];
            var isWildcard = criteria === void 0 || criteria === "*";
            var computedResult = false;
            if (isWildcard) {
              computedResult = true;
            } else {
              var tokenizedCriteria = evalExpression.parse(criteria + "");
              var tokens = [evalExpression.createToken(valueToTest, evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
              computedResult = evalExpression.compute(tokens);
            }
            if (!computedResult) {
              isMeetCondition = false;
              break;
            }
            isMeetCondition = true;
          }
          if (isMeetCondition) {
            result += range[i2];
          }
        }
        return result;
      };
      exports$1.SUMPRODUCT = function() {
        if (!arguments || arguments.length === 0) {
          return error2.value;
        }
        var arrays = arguments.length + 1;
        var result = 0;
        var product;
        var k2;
        var _i;
        var _ij;
        for (var i2 = 0; i2 < arguments[0].length; i2++) {
          if (!(arguments[0][i2] instanceof Array)) {
            product = 1;
            for (k2 = 1; k2 < arrays; k2++) {
              var _i_arg = arguments[k2 - 1][i2];
              if (_i_arg instanceof Error) {
                return _i_arg;
              }
              _i = utils2.parseNumber(_i_arg);
              if (_i instanceof Error) {
                return _i;
              }
              product *= _i;
            }
            result += product;
          } else {
            for (var j2 = 0; j2 < arguments[0][i2].length; j2++) {
              product = 1;
              for (k2 = 1; k2 < arrays; k2++) {
                var _ij_arg = arguments[k2 - 1][i2][j2];
                if (_ij_arg instanceof Error) {
                  return _ij_arg;
                }
                _ij = utils2.parseNumber(_ij_arg);
                if (_ij instanceof Error) {
                  return _ij;
                }
                product *= _ij;
              }
              result += product;
            }
          }
        }
        return result;
      };
      exports$1.SUMSQ = function() {
        var numbers = utils2.parseNumberArray(utils2.flatten(arguments));
        if (numbers instanceof Error) {
          return numbers;
        }
        var result = 0;
        var length = numbers.length;
        for (var i2 = 0; i2 < length; i2++) {
          result += information2.ISNUMBER(numbers[i2]) ? numbers[i2] * numbers[i2] : 0;
        }
        return result;
      };
      exports$1.SUMX2MY2 = function(array_x, array_y) {
        array_x = utils2.parseNumberArray(utils2.flatten(array_x));
        array_y = utils2.parseNumberArray(utils2.flatten(array_y));
        if (utils2.anyIsError(array_x, array_y)) {
          return error2.value;
        }
        var result = 0;
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result += array_x[i2] * array_x[i2] - array_y[i2] * array_y[i2];
        }
        return result;
      };
      exports$1.SUMX2PY2 = function(array_x, array_y) {
        array_x = utils2.parseNumberArray(utils2.flatten(array_x));
        array_y = utils2.parseNumberArray(utils2.flatten(array_y));
        if (utils2.anyIsError(array_x, array_y)) {
          return error2.value;
        }
        var result = 0;
        array_x = utils2.parseNumberArray(utils2.flatten(array_x));
        array_y = utils2.parseNumberArray(utils2.flatten(array_y));
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result += array_x[i2] * array_x[i2] + array_y[i2] * array_y[i2];
        }
        return result;
      };
      exports$1.SUMXMY2 = function(array_x, array_y) {
        array_x = utils2.parseNumberArray(utils2.flatten(array_x));
        array_y = utils2.parseNumberArray(utils2.flatten(array_y));
        if (utils2.anyIsError(array_x, array_y)) {
          return error2.value;
        }
        var result = 0;
        array_x = utils2.flatten(array_x);
        array_y = utils2.flatten(array_y);
        for (var i2 = 0; i2 < array_x.length; i2++) {
          result += Math.pow(array_x[i2] - array_y[i2], 2);
        }
        return result;
      };
      exports$1.TAN = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        return Math.tan(number);
      };
      exports$1.TANH = function(number) {
        number = utils2.parseNumber(number);
        if (number instanceof Error) {
          return number;
        }
        var e2 = Math.exp(2 * number);
        return (e2 - 1) / (e2 + 1);
      };
      exports$1.TRUNC = function(number, digits) {
        number = utils2.parseNumber(number);
        digits = utils2.parseNumber(digits);
        var anyError = utils2.anyError(number, digits);
        if (anyError) {
          return anyError;
        }
        var sign = number > 0 ? 1 : -1;
        return sign * Math.floor(Math.abs(number) * Math.pow(10, digits)) / Math.pow(10, digits);
      };
    })(mathTrig$1);
    return mathTrig$1;
  }
  var engineering$1 = {};
  var bessel = {};
  (function(exports$1) {
    (function(factory) {
      if (typeof DO_NOT_EXPORT_BESSEL === "undefined") {
        {
          factory(exports$1);
        }
      } else {
        factory({});
      }
    })(function(BESSEL) {
      BESSEL.version = "1.0.2";
      var M2 = Math;
      function _horner(arr, v2) {
        for (var i2 = 0, z2 = 0; i2 < arr.length; ++i2) z2 = v2 * z2 + arr[i2];
        return z2;
      }
      function _bessel_iter(x2, n2, f0, f1, sign) {
        if (n2 === 0) return f0;
        if (n2 === 1) return f1;
        var tdx = 2 / x2, f2 = f1;
        for (var o2 = 1; o2 < n2; ++o2) {
          f2 = f1 * o2 * tdx + sign * f0;
          f0 = f1;
          f1 = f2;
        }
        return f2;
      }
      function _bessel_wrap(bessel0, bessel1, name, nonzero, sign) {
        return function bessel2(x2, n2) {
          if (nonzero) {
            if (x2 === 0) return nonzero == 1 ? -Infinity : Infinity;
            else if (x2 < 0) return NaN;
          }
          if (n2 === 0) return bessel0(x2);
          if (n2 === 1) return bessel1(x2);
          if (n2 < 0) return NaN;
          n2 |= 0;
          var b0 = bessel0(x2), b1 = bessel1(x2);
          return _bessel_iter(x2, n2, b0, b1, sign);
        };
      }
      var besselj = function() {
        var W2 = 0.636619772;
        var b0_a1a = [57568490574, -13362590354, 6516196407e-1, -1121442418e-2, 77392.33017, -184.9052456].reverse();
        var b0_a2a = [57568490411, 1029532985, 9494680718e-3, 59272.64853, 267.8532712, 1].reverse();
        var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
        var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934935152e-16].reverse();
        function bessel0(x2) {
          var a2 = 0, a1 = 0, a22 = 0, y2 = x2 * x2;
          if (x2 < 8) {
            a1 = _horner(b0_a1a, y2);
            a22 = _horner(b0_a2a, y2);
            a2 = a1 / a22;
          } else {
            var xx = x2 - 0.785398164;
            y2 = 64 / y2;
            a1 = _horner(b0_a1b, y2);
            a22 = _horner(b0_a2b, y2);
            a2 = M2.sqrt(W2 / x2) * (M2.cos(xx) * a1 - M2.sin(xx) * a22 * 8 / x2);
          }
          return a2;
        }
        var b1_a1a = [72362614232, -7895059235, 2423968531e-1, -2972611439e-3, 15704.4826, -30.16036606].reverse();
        var b1_a2a = [144725228442, 2300535178, 1858330474e-2, 99447.43394, 376.9991397, 1].reverse();
        var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
        var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
        function bessel1(x2) {
          var a2 = 0, a1 = 0, a22 = 0, y2 = x2 * x2, xx = M2.abs(x2) - 2.356194491;
          if (Math.abs(x2) < 8) {
            a1 = x2 * _horner(b1_a1a, y2);
            a22 = _horner(b1_a2a, y2);
            a2 = a1 / a22;
          } else {
            y2 = 64 / y2;
            a1 = _horner(b1_a1b, y2);
            a22 = _horner(b1_a2b, y2);
            a2 = M2.sqrt(W2 / M2.abs(x2)) * (M2.cos(xx) * a1 - M2.sin(xx) * a22 * 8 / M2.abs(x2));
            if (x2 < 0) a2 = -a2;
          }
          return a2;
        }
        return function besselj2(x2, n2) {
          n2 = Math.round(n2);
          if (!isFinite(x2)) return isNaN(x2) ? x2 : 0;
          if (n2 < 0) return (n2 % 2 ? -1 : 1) * besselj2(x2, -n2);
          if (x2 < 0) return (n2 % 2 ? -1 : 1) * besselj2(-x2, n2);
          if (n2 === 0) return bessel0(x2);
          if (n2 === 1) return bessel1(x2);
          if (x2 === 0) return 0;
          var ret = 0;
          if (x2 > n2) {
            ret = _bessel_iter(x2, n2, bessel0(x2), bessel1(x2), -1);
          } else {
            var m2 = 2 * M2.floor((n2 + M2.floor(M2.sqrt(40 * n2))) / 2);
            var jsum = false;
            var bjp = 0, sum = 0;
            var bj2 = 1, bjm = 0;
            var tox = 2 / x2;
            for (var j2 = m2; j2 > 0; j2--) {
              bjm = j2 * tox * bj2 - bjp;
              bjp = bj2;
              bj2 = bjm;
              if (M2.abs(bj2) > 1e10) {
                bj2 *= 1e-10;
                bjp *= 1e-10;
                ret *= 1e-10;
                sum *= 1e-10;
              }
              if (jsum) sum += bj2;
              jsum = !jsum;
              if (j2 == n2) ret = bjp;
            }
            sum = 2 * sum - bj2;
            ret /= sum;
          }
          return ret;
        };
      }();
      var bessely = function() {
        var W2 = 0.636619772;
        var b0_a1a = [-2957821389, 7062834065, -5123598036e-1, 1087988129e-2, -86327.92757, 228.4622733].reverse();
        var b0_a2a = [40076544269, 7452499648e-1, 7189466438e-3, 47447.2647, 226.1030244, 1].reverse();
        var b0_a1b = [1, -0.001098628627, 2734510407e-14, -2073370639e-15, 2093887211e-16].reverse();
        var b0_a2b = [-0.01562499995, 1430488765e-13, -6911147651e-15, 7621095161e-16, -934945152e-16].reverse();
        function bessel0(x2) {
          var a2 = 0, a1 = 0, a22 = 0, y2 = x2 * x2, xx = x2 - 0.785398164;
          if (x2 < 8) {
            a1 = _horner(b0_a1a, y2);
            a22 = _horner(b0_a2a, y2);
            a2 = a1 / a22 + W2 * besselj(x2, 0) * M2.log(x2);
          } else {
            y2 = 64 / y2;
            a1 = _horner(b0_a1b, y2);
            a22 = _horner(b0_a2b, y2);
            a2 = M2.sqrt(W2 / x2) * (M2.sin(xx) * a1 + M2.cos(xx) * a22 * 8 / x2);
          }
          return a2;
        }
        var b1_a1a = [-4900604943e3, 127527439e4, -51534381390, 7349264551e-1, -4237922726e-3, 8511.937935].reverse();
        var b1_a2a = [249958057e5, 424441966400, 3733650367, 2245904002e-2, 102042.605, 354.9632885, 1].reverse();
        var b1_a1b = [1, 183105e-8, -3516396496e-14, 2457520174e-15, -240337019e-15].reverse();
        var b1_a2b = [0.04687499995, -2002690873e-13, 8449199096e-15, -88228987e-14, 105787412e-15].reverse();
        function bessel1(x2) {
          var a2 = 0, a1 = 0, a22 = 0, y2 = x2 * x2, xx = x2 - 2.356194491;
          if (x2 < 8) {
            a1 = x2 * _horner(b1_a1a, y2);
            a22 = _horner(b1_a2a, y2);
            a2 = a1 / a22 + W2 * (besselj(x2, 1) * M2.log(x2) - 1 / x2);
          } else {
            y2 = 64 / y2;
            a1 = _horner(b1_a1b, y2);
            a22 = _horner(b1_a2b, y2);
            a2 = M2.sqrt(W2 / x2) * (M2.sin(xx) * a1 + M2.cos(xx) * a22 * 8 / x2);
          }
          return a2;
        }
        return _bessel_wrap(bessel0, bessel1, "BESSELY", 1, -1);
      }();
      var besseli = function() {
        var b0_a = [1, 3.5156229, 3.0899424, 1.2067492, 0.2659732, 0.0360768, 45813e-7].reverse();
        var b0_b = [0.39894228, 0.01328592, 225319e-8, -157565e-8, 916281e-8, -0.02057706, 0.02635537, -0.01647633, 392377e-8].reverse();
        function bessel0(x2) {
          if (x2 <= 3.75) return _horner(b0_a, x2 * x2 / (3.75 * 3.75));
          return M2.exp(M2.abs(x2)) / M2.sqrt(M2.abs(x2)) * _horner(b0_b, 3.75 / M2.abs(x2));
        }
        var b1_a = [0.5, 0.87890594, 0.51498869, 0.15084934, 0.02658733, 301532e-8, 32411e-8].reverse();
        var b1_b = [0.39894228, -0.03988024, -362018e-8, 163801e-8, -0.01031555, 0.02282967, -0.02895312, 0.01787654, -420059e-8].reverse();
        function bessel1(x2) {
          if (x2 < 3.75) return x2 * _horner(b1_a, x2 * x2 / (3.75 * 3.75));
          return (x2 < 0 ? -1 : 1) * M2.exp(M2.abs(x2)) / M2.sqrt(M2.abs(x2)) * _horner(b1_b, 3.75 / M2.abs(x2));
        }
        return function besseli2(x2, n2) {
          n2 = Math.round(n2);
          if (n2 === 0) return bessel0(x2);
          if (n2 === 1) return bessel1(x2);
          if (n2 < 0) return NaN;
          if (M2.abs(x2) === 0) return 0;
          if (x2 == Infinity) return Infinity;
          var ret = 0, j2, tox = 2 / M2.abs(x2), bip = 0, bi2 = 1, bim = 0;
          var m2 = 2 * M2.round((n2 + M2.round(M2.sqrt(40 * n2))) / 2);
          for (j2 = m2; j2 > 0; j2--) {
            bim = j2 * tox * bi2 + bip;
            bip = bi2;
            bi2 = bim;
            if (M2.abs(bi2) > 1e10) {
              bi2 *= 1e-10;
              bip *= 1e-10;
              ret *= 1e-10;
            }
            if (j2 == n2) ret = bip;
          }
          ret *= besseli2(x2, 0) / bi2;
          return x2 < 0 && n2 % 2 ? -ret : ret;
        };
      }();
      var besselk = function() {
        var b0_a = [-0.57721566, 0.4227842, 0.23069756, 0.0348859, 262698e-8, 1075e-7, 74e-7].reverse();
        var b0_b = [1.25331414, -0.07832358, 0.02189568, -0.01062446, 587872e-8, -25154e-7, 53208e-8].reverse();
        function bessel0(x2) {
          if (x2 <= 2) return -M2.log(x2 / 2) * besseli(x2, 0) + _horner(b0_a, x2 * x2 / 4);
          return M2.exp(-x2) / M2.sqrt(x2) * _horner(b0_b, 2 / x2);
        }
        var b1_a = [1, 0.15443144, -0.67278579, -0.18156897, -0.01919402, -110404e-8, -4686e-8].reverse();
        var b1_b = [1.25331414, 0.23498619, -0.0365562, 0.01504268, -780353e-8, 325614e-8, -68245e-8].reverse();
        function bessel1(x2) {
          if (x2 <= 2) return M2.log(x2 / 2) * besseli(x2, 1) + 1 / x2 * _horner(b1_a, x2 * x2 / 4);
          return M2.exp(-x2) / M2.sqrt(x2) * _horner(b1_b, 2 / x2);
        }
        return _bessel_wrap(bessel0, bessel1, "BESSELK", 2, 1);
      }();
      BESSEL.besselj = besselj;
      BESSEL.bessely = bessely;
      BESSEL.besseli = besseli;
      BESSEL.besselk = besselk;
    });
  })(bessel);
  (function(exports$1) {
    var error2 = error$3;
    var jStat = jstatExports;
    var text$1 = text;
    var utils2 = common;
    var bessel$1 = bessel;
    function isValidBinaryNumber(number) {
      return /^[01]{1,10}$/.test(number);
    }
    exports$1.BESSELI = function(x2, n2) {
      x2 = utils2.parseNumber(x2);
      n2 = utils2.parseNumber(n2);
      if (utils2.anyIsError(x2, n2)) {
        return error2.value;
      }
      return bessel$1.besseli(x2, n2);
    };
    exports$1.BESSELJ = function(x2, n2) {
      x2 = utils2.parseNumber(x2);
      n2 = utils2.parseNumber(n2);
      if (utils2.anyIsError(x2, n2)) {
        return error2.value;
      }
      return bessel$1.besselj(x2, n2);
    };
    exports$1.BESSELK = function(x2, n2) {
      x2 = utils2.parseNumber(x2);
      n2 = utils2.parseNumber(n2);
      if (utils2.anyIsError(x2, n2)) {
        return error2.value;
      }
      return bessel$1.besselk(x2, n2);
    };
    exports$1.BESSELY = function(x2, n2) {
      x2 = utils2.parseNumber(x2);
      n2 = utils2.parseNumber(n2);
      if (utils2.anyIsError(x2, n2)) {
        return error2.value;
      }
      return bessel$1.bessely(x2, n2);
    };
    exports$1.BIN2DEC = function(number) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var result = parseInt(number, 2);
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return parseInt(stringified.substring(1), 2) - 512;
      } else {
        return result;
      }
    };
    exports$1.BIN2HEX = function(number, places) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return (1099511627264 + parseInt(stringified.substring(1), 2)).toString(16);
      }
      var result = parseInt(number, 2).toString(16);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.BIN2OCT = function(number, places) {
      if (!isValidBinaryNumber(number)) {
        return error2.num;
      }
      var stringified = number.toString();
      if (stringified.length === 10 && stringified.substring(0, 1) === "1") {
        return (1073741312 + parseInt(stringified.substring(1), 2)).toString(8);
      }
      var result = parseInt(number, 2).toString(8);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.BITAND = function(number1, number2) {
      number1 = utils2.parseNumber(number1);
      number2 = utils2.parseNumber(number2);
      if (utils2.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 & number2;
    };
    exports$1.BITLSHIFT = function(number, shift) {
      number = utils2.parseNumber(number);
      shift = utils2.parseNumber(shift);
      if (utils2.anyIsError(number, shift)) {
        return error2.value;
      }
      if (number < 0) {
        return error2.num;
      }
      if (Math.floor(number) !== number) {
        return error2.num;
      }
      if (number > 281474976710655) {
        return error2.num;
      }
      if (Math.abs(shift) > 53) {
        return error2.num;
      }
      return shift >= 0 ? number << shift : number >> -shift;
    };
    exports$1.BITOR = function(number1, number2) {
      number1 = utils2.parseNumber(number1);
      number2 = utils2.parseNumber(number2);
      if (utils2.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 | number2;
    };
    exports$1.BITRSHIFT = function(number, shift) {
      number = utils2.parseNumber(number);
      shift = utils2.parseNumber(shift);
      if (utils2.anyIsError(number, shift)) {
        return error2.value;
      }
      if (number < 0) {
        return error2.num;
      }
      if (Math.floor(number) !== number) {
        return error2.num;
      }
      if (number > 281474976710655) {
        return error2.num;
      }
      if (Math.abs(shift) > 53) {
        return error2.num;
      }
      return shift >= 0 ? number >> shift : number << -shift;
    };
    exports$1.BITXOR = function(number1, number2) {
      number1 = utils2.parseNumber(number1);
      number2 = utils2.parseNumber(number2);
      if (utils2.anyIsError(number1, number2)) {
        return error2.value;
      }
      if (number1 < 0 || number2 < 0) {
        return error2.num;
      }
      if (Math.floor(number1) !== number1 || Math.floor(number2) !== number2) {
        return error2.num;
      }
      if (number1 > 281474976710655 || number2 > 281474976710655) {
        return error2.num;
      }
      return number1 ^ number2;
    };
    exports$1.COMPLEX = function(real, imaginary, suffix) {
      real = utils2.parseNumber(real);
      imaginary = utils2.parseNumber(imaginary);
      if (utils2.anyIsError(real, imaginary)) {
        return real;
      }
      suffix = suffix === void 0 ? "i" : suffix;
      if (suffix !== "i" && suffix !== "j") {
        return error2.value;
      }
      if (real === 0 && imaginary === 0) {
        return 0;
      } else if (real === 0) {
        return imaginary === 1 ? suffix : imaginary.toString() + suffix;
      } else if (imaginary === 0) {
        return real.toString();
      } else {
        var sign = imaginary > 0 ? "+" : "";
        return real.toString() + sign + (imaginary === 1 ? suffix : imaginary.toString() + suffix);
      }
    };
    exports$1.CONVERT = function(number, from_unit, to_unit) {
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      var units = [
        ["a.u. of action", "?", null, "action", false, false, 105457168181818e-48],
        ["a.u. of charge", "e", null, "electric_charge", false, false, 160217653141414e-33],
        ["a.u. of energy", "Eh", null, "energy", false, false, 435974417757576e-32],
        ["a.u. of length", "a?", null, "length", false, false, 529177210818182e-25],
        ["a.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
        ["a.u. of time", "?/Eh", null, "time", false, false, 241888432650516e-31],
        ["admiralty knot", "admkn", null, "speed", false, true, 0.514773333],
        ["ampere", "A", null, "electric_current", true, false, 1],
        ["ampere per meter", "A/m", null, "magnetic_field_intensity", true, false, 1],
        ["ångström", "Å", ["ang"], "length", false, true, 1e-10],
        ["are", "ar", null, "area", false, true, 100],
        ["astronomical unit", "ua", null, "length", false, false, 149597870691667e-25],
        ["bar", "bar", null, "pressure", false, false, 1e5],
        ["barn", "b", null, "area", false, false, 1e-28],
        ["becquerel", "Bq", null, "radioactivity", true, false, 1],
        ["bit", "bit", ["b"], "information", false, true, 1],
        ["btu", "BTU", ["btu"], "energy", false, true, 1055.05585262],
        ["byte", "byte", null, "information", false, true, 8],
        ["candela", "cd", null, "luminous_intensity", true, false, 1],
        ["candela per square metre", "cd/m?", null, "luminance", true, false, 1],
        ["coulomb", "C", null, "electric_charge", true, false, 1],
        ["cubic ångström", "ang3", ["ang^3"], "volume", false, true, 1e-30],
        ["cubic foot", "ft3", ["ft^3"], "volume", false, true, 0.028316846592],
        ["cubic inch", "in3", ["in^3"], "volume", false, true, 16387064e-12],
        ["cubic light-year", "ly3", ["ly^3"], "volume", false, true, 846786664623715e-61],
        ["cubic metre", "m?", null, "volume", true, true, 1],
        ["cubic mile", "mi3", ["mi^3"], "volume", false, true, 416818182544058e-5],
        ["cubic nautical mile", "Nmi3", ["Nmi^3"], "volume", false, true, 6352182208],
        ["cubic Pica", "Pica3", ["Picapt3", "Pica^3", "Picapt^3"], "volume", false, true, 758660370370369e-22],
        ["cubic yard", "yd3", ["yd^3"], "volume", false, true, 0.764554857984],
        ["cup", "cup", null, "volume", false, true, 2365882365e-13],
        ["dalton", "Da", ["u"], "mass", false, false, 166053886282828e-41],
        ["day", "d", ["day"], "time", false, true, 86400],
        ["degree", "°", null, "angle", false, false, 0.0174532925199433],
        ["degrees Rankine", "Rank", null, "temperature", false, true, 0.555555555555556],
        ["dyne", "dyn", ["dy"], "force", false, true, 1e-5],
        ["electronvolt", "eV", ["ev"], "energy", false, true, 1.60217656514141],
        ["ell", "ell", null, "length", false, true, 1.143],
        ["erg", "erg", ["e"], "energy", false, true, 1e-7],
        ["farad", "F", null, "electric_capacitance", true, false, 1],
        ["fluid ounce", "oz", null, "volume", false, true, 295735295625e-16],
        ["foot", "ft", null, "length", false, true, 0.3048],
        ["foot-pound", "flb", null, "energy", false, true, 1.3558179483314],
        ["gal", "Gal", null, "acceleration", false, false, 0.01],
        ["gallon", "gal", null, "volume", false, true, 0.003785411784],
        ["gauss", "G", ["ga"], "magnetic_flux_density", false, true, 1],
        ["grain", "grain", null, "mass", false, true, 647989e-10],
        ["gram", "g", null, "mass", false, true, 1e-3],
        ["gray", "Gy", null, "absorbed_dose", true, false, 1],
        ["gross registered ton", "GRT", ["regton"], "volume", false, true, 2.8316846592],
        ["hectare", "ha", null, "area", false, true, 1e4],
        ["henry", "H", null, "inductance", true, false, 1],
        ["hertz", "Hz", null, "frequency", true, false, 1],
        ["horsepower", "HP", ["h"], "power", false, true, 745.69987158227],
        ["horsepower-hour", "HPh", ["hh", "hph"], "energy", false, true, 2684519538e-3],
        ["hour", "h", ["hr"], "time", false, true, 3600],
        ["imperial gallon (U.K.)", "uk_gal", null, "volume", false, true, 454609e-8],
        ["imperial hundredweight", "lcwt", ["uk_cwt", "hweight"], "mass", false, true, 50.802345],
        ["imperial quart (U.K)", "uk_qt", null, "volume", false, true, 0.0011365225],
        ["imperial ton", "brton", ["uk_ton", "LTON"], "mass", false, true, 1016.046909],
        ["inch", "in", null, "length", false, true, 0.0254],
        ["international acre", "uk_acre", null, "area", false, true, 4046.8564224],
        ["IT calorie", "cal", null, "energy", false, true, 4.1868],
        ["joule", "J", null, "energy", true, true, 1],
        ["katal", "kat", null, "catalytic_activity", true, false, 1],
        ["kelvin", "K", ["kel"], "temperature", true, true, 1],
        ["kilogram", "kg", null, "mass", true, true, 1],
        ["knot", "kn", null, "speed", false, true, 0.514444444444444],
        ["light-year", "ly", null, "length", false, true, 9460730472580800],
        ["litre", "L", ["l", "lt"], "volume", false, true, 1e-3],
        ["lumen", "lm", null, "luminous_flux", true, false, 1],
        ["lux", "lx", null, "illuminance", true, false, 1],
        ["maxwell", "Mx", null, "magnetic_flux", false, false, 1e-18],
        ["measurement ton", "MTON", null, "volume", false, true, 1.13267386368],
        ["meter per hour", "m/h", ["m/hr"], "speed", false, true, 27777777777778e-17],
        ["meter per second", "m/s", ["m/sec"], "speed", true, true, 1],
        ["meter per second squared", "m?s??", null, "acceleration", true, false, 1],
        ["parsec", "pc", ["parsec"], "length", false, true, 30856775814671900],
        ["meter squared per second", "m?/s", null, "kinematic_viscosity", true, false, 1],
        ["metre", "m", null, "length", true, true, 1],
        ["miles per hour", "mph", null, "speed", false, true, 0.44704],
        ["millimetre of mercury", "mmHg", null, "pressure", false, false, 133.322],
        ["minute", "?", null, "angle", false, false, 290888208665722e-18],
        ["minute", "min", ["mn"], "time", false, true, 60],
        ["modern teaspoon", "tspm", null, "volume", false, true, 5e-6],
        ["mole", "mol", null, "amount_of_substance", true, false, 1],
        ["morgen", "Morgen", null, "area", false, true, 2500],
        ["n.u. of action", "?", null, "action", false, false, 105457168181818e-48],
        ["n.u. of mass", "m?", null, "mass", false, false, 910938261616162e-45],
        ["n.u. of speed", "c?", null, "speed", false, false, 299792458],
        ["n.u. of time", "?/(me?c??)", null, "time", false, false, 128808866778687e-35],
        ["nautical mile", "M", ["Nmi"], "length", false, true, 1852],
        ["newton", "N", null, "force", true, true, 1],
        ["œrsted", "Oe ", null, "magnetic_field_intensity", false, false, 79.5774715459477],
        ["ohm", "Ω", null, "electric_resistance", true, false, 1],
        ["ounce mass", "ozm", null, "mass", false, true, 0.028349523125],
        ["pascal", "Pa", null, "pressure", true, false, 1],
        ["pascal second", "Pa?s", null, "dynamic_viscosity", true, false, 1],
        ["pferdestärke", "PS", null, "power", false, true, 735.49875],
        ["phot", "ph", null, "illuminance", false, false, 1e-4],
        ["pica (1/6 inch)", "pica", null, "length", false, true, 35277777777778e-17],
        ["pica (1/72 inch)", "Pica", ["Picapt"], "length", false, true, 0.00423333333333333],
        ["poise", "P", null, "dynamic_viscosity", false, false, 0.1],
        ["pond", "pond", null, "force", false, true, 980665e-8],
        ["pound force", "lbf", null, "force", false, true, 4.4482216152605],
        ["pound mass", "lbm", null, "mass", false, true, 0.45359237],
        ["quart", "qt", null, "volume", false, true, 946352946e-12],
        ["radian", "rad", null, "angle", true, false, 1],
        ["second", "?", null, "angle", false, false, 484813681109536e-20],
        ["second", "s", ["sec"], "time", true, true, 1],
        ["short hundredweight", "cwt", ["shweight"], "mass", false, true, 45.359237],
        ["siemens", "S", null, "electrical_conductance", true, false, 1],
        ["sievert", "Sv", null, "equivalent_dose", true, false, 1],
        ["slug", "sg", null, "mass", false, true, 14.59390294],
        ["square ångström", "ang2", ["ang^2"], "area", false, true, 1e-20],
        ["square foot", "ft2", ["ft^2"], "area", false, true, 0.09290304],
        ["square inch", "in2", ["in^2"], "area", false, true, 64516e-8],
        ["square light-year", "ly2", ["ly^2"], "area", false, true, 895054210748189e17],
        ["square meter", "m?", null, "area", true, true, 1],
        ["square mile", "mi2", ["mi^2"], "area", false, true, 2589988110336e-6],
        ["square nautical mile", "Nmi2", ["Nmi^2"], "area", false, true, 3429904],
        ["square Pica", "Pica2", ["Picapt2", "Pica^2", "Picapt^2"], "area", false, true, 1792111111111e-17],
        ["square yard", "yd2", ["yd^2"], "area", false, true, 0.83612736],
        ["statute mile", "mi", null, "length", false, true, 1609.344],
        ["steradian", "sr", null, "solid_angle", true, false, 1],
        ["stilb", "sb", null, "luminance", false, false, 1e-4],
        ["stokes", "St", null, "kinematic_viscosity", false, false, 1e-4],
        ["stone", "stone", null, "mass", false, true, 6.35029318],
        ["tablespoon", "tbs", null, "volume", false, true, 147868e-10],
        ["teaspoon", "tsp", null, "volume", false, true, 492892e-11],
        ["tesla", "T", null, "magnetic_flux_density", true, true, 1],
        ["thermodynamic calorie", "c", null, "energy", false, true, 4.184],
        ["ton", "ton", null, "mass", false, true, 907.18474],
        ["tonne", "t", null, "mass", false, false, 1e3],
        ["U.K. pint", "uk_pt", null, "volume", false, true, 56826125e-11],
        ["U.S. bushel", "bushel", null, "volume", false, true, 0.03523907],
        ["U.S. oil barrel", "barrel", null, "volume", false, true, 0.158987295],
        ["U.S. pint", "pt", ["us_pt"], "volume", false, true, 473176473e-12],
        ["U.S. survey mile", "survey_mi", null, "length", false, true, 1609.347219],
        ["U.S. survey/statute acre", "us_acre", null, "area", false, true, 4046.87261],
        ["volt", "V", null, "voltage", true, false, 1],
        ["watt", "W", null, "power", true, true, 1],
        ["watt-hour", "Wh", ["wh"], "energy", false, true, 3600],
        ["weber", "Wb", null, "magnetic_flux", true, false, 1],
        ["yard", "yd", null, "length", false, true, 0.9144],
        ["year", "yr", null, "time", false, true, 31557600]
      ];
      var binary_prefixes = {
        Yi: ["yobi", 80, 12089258196146292e8, "Yi", "yotta"],
        Zi: ["zebi", 70, 11805916207174113e5, "Zi", "zetta"],
        Ei: ["exbi", 60, 1152921504606847e3, "Ei", "exa"],
        Pi: ["pebi", 50, 1125899906842624, "Pi", "peta"],
        Ti: ["tebi", 40, 1099511627776, "Ti", "tera"],
        Gi: ["gibi", 30, 1073741824, "Gi", "giga"],
        Mi: ["mebi", 20, 1048576, "Mi", "mega"],
        ki: ["kibi", 10, 1024, "ki", "kilo"]
      };
      var unit_prefixes = {
        Y: ["yotta", 1e24, "Y"],
        Z: ["zetta", 1e21, "Z"],
        E: ["exa", 1e18, "E"],
        P: ["peta", 1e15, "P"],
        T: ["tera", 1e12, "T"],
        G: ["giga", 1e9, "G"],
        M: ["mega", 1e6, "M"],
        k: ["kilo", 1e3, "k"],
        h: ["hecto", 100, "h"],
        e: ["dekao", 10, "e"],
        d: ["deci", 0.1, "d"],
        c: ["centi", 0.01, "c"],
        m: ["milli", 1e-3, "m"],
        u: ["micro", 1e-6, "u"],
        n: ["nano", 1e-9, "n"],
        p: ["pico", 1e-12, "p"],
        f: ["femto", 1e-15, "f"],
        a: ["atto", 1e-18, "a"],
        z: ["zepto", 1e-21, "z"],
        y: ["yocto", 1e-24, "y"]
      };
      var from = null;
      var to = null;
      var base_from_unit = from_unit;
      var base_to_unit = to_unit;
      var from_multiplier = 1;
      var to_multiplier = 1;
      var alt;
      for (var i2 = 0; i2 < units.length; i2++) {
        alt = units[i2][2] === null ? [] : units[i2][2];
        if (units[i2][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
          from = units[i2];
        }
        if (units[i2][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
          to = units[i2];
        }
      }
      if (from === null) {
        var from_binary_prefix = binary_prefixes[from_unit.substring(0, 2)];
        var from_unit_prefix = unit_prefixes[from_unit.substring(0, 1)];
        if (from_unit.substring(0, 2) === "da") {
          from_unit_prefix = ["dekao", 10, "da"];
        }
        if (from_binary_prefix) {
          from_multiplier = from_binary_prefix[2];
          base_from_unit = from_unit.substring(2);
        } else if (from_unit_prefix) {
          from_multiplier = from_unit_prefix[1];
          base_from_unit = from_unit.substring(from_unit_prefix[2].length);
        }
        for (var j2 = 0; j2 < units.length; j2++) {
          alt = units[j2][2] === null ? [] : units[j2][2];
          if (units[j2][1] === base_from_unit || alt.indexOf(base_from_unit) >= 0) {
            from = units[j2];
          }
        }
      }
      if (to === null) {
        var to_binary_prefix = binary_prefixes[to_unit.substring(0, 2)];
        var to_unit_prefix = unit_prefixes[to_unit.substring(0, 1)];
        if (to_unit.substring(0, 2) === "da") {
          to_unit_prefix = ["dekao", 10, "da"];
        }
        if (to_binary_prefix) {
          to_multiplier = to_binary_prefix[2];
          base_to_unit = to_unit.substring(2);
        } else if (to_unit_prefix) {
          to_multiplier = to_unit_prefix[1];
          base_to_unit = to_unit.substring(to_unit_prefix[2].length);
        }
        for (var k2 = 0; k2 < units.length; k2++) {
          alt = units[k2][2] === null ? [] : units[k2][2];
          if (units[k2][1] === base_to_unit || alt.indexOf(base_to_unit) >= 0) {
            to = units[k2];
          }
        }
      }
      if (from === null || to === null) {
        return error2.na;
      }
      if (from[3] !== to[3]) {
        return error2.na;
      }
      return number * from[6] * from_multiplier / (to[6] * to_multiplier);
    };
    exports$1.DEC2BIN = function(number, places) {
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,3}$/.test(number) || number < -512 || number > 511) {
        return error2.num;
      }
      if (number < 0) {
        return "1" + text$1.REPT("0", 9 - (512 + number).toString(2).length) + (512 + number).toString(2);
      }
      var result = parseInt(number, 10).toString(2);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.DEC2HEX = function(number, places) {
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,12}$/.test(number) || number < -549755813888 || number > 549755813887) {
        return error2.num;
      }
      if (number < 0) {
        return (1099511627776 + number).toString(16);
      }
      var result = parseInt(number, 10).toString(16);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.DEC2OCT = function(number, places) {
      number = utils2.parseNumber(number);
      if (number instanceof Error) {
        return number;
      }
      if (!/^-?[0-9]{1,9}$/.test(number) || number < -536870912 || number > 536870911) {
        return error2.num;
      }
      if (number < 0) {
        return (1073741824 + number).toString(8);
      }
      var result = parseInt(number, 10).toString(8);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.DELTA = function(number1, number2) {
      number2 = number2 === void 0 ? 0 : number2;
      number1 = utils2.parseNumber(number1);
      number2 = utils2.parseNumber(number2);
      if (utils2.anyIsError(number1, number2)) {
        return error2.value;
      }
      return number1 === number2 ? 1 : 0;
    };
    exports$1.ERF = function(lower_bound, upper_bound) {
      upper_bound = upper_bound === void 0 ? 0 : upper_bound;
      lower_bound = utils2.parseNumber(lower_bound);
      upper_bound = utils2.parseNumber(upper_bound);
      if (utils2.anyIsError(lower_bound, upper_bound)) {
        return error2.value;
      }
      return jStat.erf(lower_bound);
    };
    exports$1.ERF.PRECISE = function() {
      throw new Error("ERF.PRECISE is not implemented");
    };
    exports$1.ERFC = function(x2) {
      if (isNaN(x2)) {
        return error2.value;
      }
      return jStat.erfc(x2);
    };
    exports$1.ERFC.PRECISE = function() {
      throw new Error("ERFC.PRECISE is not implemented");
    };
    exports$1.GESTEP = function(number, step) {
      step = step || 0;
      number = utils2.parseNumber(number);
      if (utils2.anyIsError(step, number)) {
        return number;
      }
      return number >= step ? 1 : 0;
    };
    exports$1.HEX2BIN = function(number, places) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var negative = number.length === 10 && number.substring(0, 1).toLowerCase() === "f" ? true : false;
      var decimal = negative ? parseInt(number, 16) - 1099511627776 : parseInt(number, 16);
      if (decimal < -512 || decimal > 511) {
        return error2.num;
      }
      if (negative) {
        return "1" + text$1.REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
      }
      var result = decimal.toString(2);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.HEX2DEC = function(number) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 16);
      return decimal >= 549755813888 ? decimal - 1099511627776 : decimal;
    };
    exports$1.HEX2OCT = function(number, places) {
      if (!/^[0-9A-Fa-f]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 16);
      if (decimal > 536870911 && decimal < 1098974756864) {
        return error2.num;
      }
      if (decimal >= 1098974756864) {
        return (decimal - 1098437885952).toString(8);
      }
      var result = decimal.toString(8);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.IMABS = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      return Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
    };
    exports$1.IMAGINARY = function(inumber) {
      if (inumber === void 0 || inumber === true || inumber === false) {
        return error2.value;
      }
      if (inumber === 0 || inumber === "0") {
        return 0;
      }
      if (["i", "j"].indexOf(inumber) >= 0) {
        return 1;
      }
      inumber = inumber + "";
      inumber = inumber.replace("+i", "+1i").replace("-i", "-1i").replace("+j", "+1j").replace("-j", "-1j");
      var plus = inumber.indexOf("+");
      var minus = inumber.indexOf("-");
      if (plus === 0) {
        plus = inumber.indexOf("+", 1);
      }
      if (minus === 0) {
        minus = inumber.indexOf("-", 1);
      }
      var last = inumber.substring(inumber.length - 1, inumber.length);
      var unit = last === "i" || last === "j";
      if (plus >= 0 || minus >= 0) {
        if (!unit) {
          return error2.num;
        }
        if (plus >= 0) {
          return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(plus + 1, inumber.length - 1));
        } else {
          return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error2.num : -Number(inumber.substring(minus + 1, inumber.length - 1));
        }
      } else {
        if (unit) {
          return isNaN(inumber.substring(0, inumber.length - 1)) ? error2.num : inumber.substring(0, inumber.length - 1);
        } else {
          return isNaN(inumber) ? error2.num : 0;
        }
      }
    };
    exports$1.IMARGUMENT = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      if (x2 === 0 && y2 === 0) {
        return error2.div0;
      }
      if (x2 === 0 && y2 > 0) {
        return Math.PI / 2;
      }
      if (x2 === 0 && y2 < 0) {
        return -Math.PI / 2;
      }
      if (y2 === 0 && x2 > 0) {
        return 0;
      }
      if (y2 === 0 && x2 < 0) {
        return -Math.PI;
      }
      if (x2 > 0) {
        return Math.atan(y2 / x2);
      } else if (x2 < 0 && y2 >= 0) {
        return Math.atan(y2 / x2) + Math.PI;
      } else {
        return Math.atan(y2 / x2) - Math.PI;
      }
    };
    exports$1.IMCONJUGATE = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return y2 !== 0 ? exports$1.COMPLEX(x2, -y2, unit) : inumber;
    };
    exports$1.IMCOS = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.cos(x2) * (Math.exp(y2) + Math.exp(-y2)) / 2, -Math.sin(x2) * (Math.exp(y2) - Math.exp(-y2)) / 2, unit);
    };
    exports$1.IMCOSH = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.cos(y2) * (Math.exp(x2) + Math.exp(-x2)) / 2, Math.sin(y2) * (Math.exp(x2) - Math.exp(-x2)) / 2, unit);
    };
    exports$1.IMCOT = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      return exports$1.IMDIV(exports$1.IMCOS(inumber), exports$1.IMSIN(inumber));
    };
    exports$1.IMDIV = function(inumber1, inumber2) {
      var a2 = exports$1.IMREAL(inumber1);
      var b2 = exports$1.IMAGINARY(inumber1);
      var c2 = exports$1.IMREAL(inumber2);
      var d2 = exports$1.IMAGINARY(inumber2);
      if (utils2.anyIsError(a2, b2, c2, d2)) {
        return error2.value;
      }
      var unit1 = inumber1.substring(inumber1.length - 1);
      var unit2 = inumber2.substring(inumber2.length - 1);
      var unit = "i";
      if (unit1 === "j") {
        unit = "j";
      } else if (unit2 === "j") {
        unit = "j";
      }
      if (c2 === 0 && d2 === 0) {
        return error2.num;
      }
      var den = c2 * c2 + d2 * d2;
      return exports$1.COMPLEX((a2 * c2 + b2 * d2) / den, (b2 * c2 - a2 * d2) / den, unit);
    };
    exports$1.IMEXP = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var e = Math.exp(x2);
      return exports$1.COMPLEX(e * Math.cos(y2), e * Math.sin(y2), unit);
    };
    exports$1.IMLN = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)), Math.atan(y2 / x2), unit);
    };
    exports$1.IMLOG10 = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)) / Math.log(10), Math.atan(y2 / x2) / Math.log(10), unit);
    };
    exports$1.IMLOG2 = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.log(Math.sqrt(x2 * x2 + y2 * y2)) / Math.log(2), Math.atan(y2 / x2) / Math.log(2), unit);
    };
    exports$1.IMPOWER = function(inumber, number) {
      number = utils2.parseNumber(number);
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(number, x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var p2 = Math.pow(exports$1.IMABS(inumber), number);
      var t2 = exports$1.IMARGUMENT(inumber);
      return exports$1.COMPLEX(p2 * Math.cos(number * t2), p2 * Math.sin(number * t2), unit);
    };
    exports$1.IMPRODUCT = function() {
      var result = arguments[0];
      if (!arguments.length) {
        return error2.value;
      }
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var a2 = exports$1.IMREAL(result);
        var b2 = exports$1.IMAGINARY(result);
        var c2 = exports$1.IMREAL(arguments[i2]);
        var d2 = exports$1.IMAGINARY(arguments[i2]);
        if (utils2.anyIsError(a2, b2, c2, d2)) {
          return error2.value;
        }
        result = exports$1.COMPLEX(a2 * c2 - b2 * d2, a2 * d2 + b2 * c2);
      }
      return result;
    };
    exports$1.IMREAL = function(inumber) {
      if (inumber === void 0 || inumber === true || inumber === false) {
        return error2.value;
      }
      if (inumber === 0 || inumber === "0") {
        return 0;
      }
      if (["i", "+i", "1i", "+1i", "-i", "-1i", "j", "+j", "1j", "+1j", "-j", "-1j"].indexOf(inumber) >= 0) {
        return 0;
      }
      inumber = inumber + "";
      var plus = inumber.indexOf("+");
      var minus = inumber.indexOf("-");
      if (plus === 0) {
        plus = inumber.indexOf("+", 1);
      }
      if (minus === 0) {
        minus = inumber.indexOf("-", 1);
      }
      var last = inumber.substring(inumber.length - 1, inumber.length);
      var unit = last === "i" || last === "j";
      if (plus >= 0 || minus >= 0) {
        if (!unit) {
          return error2.num;
        }
        if (plus >= 0) {
          return isNaN(inumber.substring(0, plus)) || isNaN(inumber.substring(plus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(0, plus));
        } else {
          return isNaN(inumber.substring(0, minus)) || isNaN(inumber.substring(minus + 1, inumber.length - 1)) ? error2.num : Number(inumber.substring(0, minus));
        }
      } else {
        if (unit) {
          return isNaN(inumber.substring(0, inumber.length - 1)) ? error2.num : 0;
        } else {
          return isNaN(inumber) ? error2.num : inumber;
        }
      }
    };
    exports$1.IMSEC = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      return exports$1.IMDIV("1", exports$1.IMCOS(inumber));
    };
    exports$1.IMSECH = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      return exports$1.IMDIV("1", exports$1.IMCOSH(inumber));
    };
    exports$1.IMSIN = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.sin(x2) * (Math.exp(y2) + Math.exp(-y2)) / 2, Math.cos(x2) * (Math.exp(y2) - Math.exp(-y2)) / 2, unit);
    };
    exports$1.IMSINH = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      return exports$1.COMPLEX(Math.cos(y2) * (Math.exp(x2) - Math.exp(-x2)) / 2, Math.sin(y2) * (Math.exp(x2) + Math.exp(-x2)) / 2, unit);
    };
    exports$1.IMSQRT = function(inumber) {
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      var unit = inumber.substring(inumber.length - 1);
      unit = unit === "i" || unit === "j" ? unit : "i";
      var s2 = Math.sqrt(exports$1.IMABS(inumber));
      var t2 = exports$1.IMARGUMENT(inumber);
      return exports$1.COMPLEX(s2 * Math.cos(t2 / 2), s2 * Math.sin(t2 / 2), unit);
    };
    exports$1.IMCSC = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.num;
      }
      return exports$1.IMDIV("1", exports$1.IMSIN(inumber));
    };
    exports$1.IMCSCH = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.num;
      }
      return exports$1.IMDIV("1", exports$1.IMSINH(inumber));
    };
    exports$1.IMSUB = function(inumber1, inumber2) {
      var a2 = this.IMREAL(inumber1);
      var b2 = this.IMAGINARY(inumber1);
      var c2 = this.IMREAL(inumber2);
      var d2 = this.IMAGINARY(inumber2);
      if (utils2.anyIsError(a2, b2, c2, d2)) {
        return error2.value;
      }
      var unit1 = inumber1.substring(inumber1.length - 1);
      var unit2 = inumber2.substring(inumber2.length - 1);
      var unit = "i";
      if (unit1 === "j") {
        unit = "j";
      } else if (unit2 === "j") {
        unit = "j";
      }
      return this.COMPLEX(a2 - c2, b2 - d2, unit);
    };
    exports$1.IMSUM = function() {
      if (!arguments.length) {
        return error2.value;
      }
      var args = utils2.flatten(arguments);
      var result = args[0];
      for (var i2 = 1; i2 < args.length; i2++) {
        var a2 = this.IMREAL(result);
        var b2 = this.IMAGINARY(result);
        var c2 = this.IMREAL(args[i2]);
        var d2 = this.IMAGINARY(args[i2]);
        if (utils2.anyIsError(a2, b2, c2, d2)) {
          return error2.value;
        }
        result = this.COMPLEX(a2 + c2, b2 + d2);
      }
      return result;
    };
    exports$1.IMTAN = function(inumber) {
      if (inumber === true || inumber === false) {
        return error2.value;
      }
      var x2 = exports$1.IMREAL(inumber);
      var y2 = exports$1.IMAGINARY(inumber);
      if (utils2.anyIsError(x2, y2)) {
        return error2.value;
      }
      return this.IMDIV(this.IMSIN(inumber), this.IMCOS(inumber));
    };
    exports$1.OCT2BIN = function(number, places) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var negative = number.length === 10 && number.substring(0, 1) === "7" ? true : false;
      var decimal = negative ? parseInt(number, 8) - 1073741824 : parseInt(number, 8);
      if (decimal < -512 || decimal > 511) {
        return error2.num;
      }
      if (negative) {
        return "1" + text$1.REPT("0", 9 - (512 + decimal).toString(2).length) + (512 + decimal).toString(2);
      }
      var result = decimal.toString(2);
      if (typeof places === "undefined") {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
    exports$1.OCT2DEC = function(number) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 8);
      return decimal >= 536870912 ? decimal - 1073741824 : decimal;
    };
    exports$1.OCT2HEX = function(number, places) {
      if (!/^[0-7]{1,10}$/.test(number)) {
        return error2.num;
      }
      var decimal = parseInt(number, 8);
      if (decimal >= 536870912) {
        return "ff" + (decimal + 3221225472).toString(16);
      }
      var result = decimal.toString(16);
      if (places === void 0) {
        return result;
      } else {
        if (isNaN(places)) {
          return error2.value;
        }
        if (places < 0) {
          return error2.num;
        }
        places = Math.floor(places);
        return places >= result.length ? text$1.REPT("0", places - result.length) + result : error2.num;
      }
    };
  })(engineering$1);
  var dateTime$1 = {};
  (function(exports$1) {
    var error2 = error$3;
    var utils2 = common;
    var d1900 = new Date(Date.UTC(1900, 0, 1));
    var WEEK_STARTS = [
      void 0,
      0,
      1,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      1,
      2,
      3,
      4,
      5,
      6,
      0
    ];
    var WEEK_TYPES = [
      [],
      [1, 2, 3, 4, 5, 6, 7],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 0, 1, 2, 3, 4, 5],
      [],
      [],
      [],
      [],
      [],
      [],
      [],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 7, 1, 2, 3, 4, 5],
      [5, 6, 7, 1, 2, 3, 4],
      [4, 5, 6, 7, 1, 2, 3],
      [3, 4, 5, 6, 7, 1, 2],
      [2, 3, 4, 5, 6, 7, 1],
      [1, 2, 3, 4, 5, 6, 7]
    ];
    var WEEKEND_TYPES = [
      [],
      [6, 0],
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 4],
      [4, 5],
      [5, 6],
      void 0,
      void 0,
      void 0,
      [0, 0],
      [1, 1],
      [2, 2],
      [3, 3],
      [4, 4],
      [5, 5],
      [6, 6]
    ];
    exports$1.DATE = function(year, month, day) {
      var result;
      year = utils2.parseNumber(year);
      month = utils2.parseNumber(month);
      day = utils2.parseNumber(day);
      if (utils2.anyIsError(year, month, day)) {
        result = error2.value;
      } else {
        result = new Date(year, month - 1, day);
        if (result.getFullYear() < 0) {
          result = error2.num;
        }
      }
      return result;
    };
    exports$1.DATEDIF = function(start_date, end_date, unit) {
      unit = unit.toUpperCase();
      start_date = utils2.parseDate(start_date);
      end_date = utils2.parseDate(end_date);
      var start_date_year = start_date.getFullYear();
      var start_date_month = start_date.getMonth();
      var start_date_day = start_date.getDate();
      var end_date_year = end_date.getFullYear();
      var end_date_month = end_date.getMonth();
      var end_date_day = end_date.getDate();
      var result;
      switch (unit) {
        case "Y":
          result = Math.floor(exports$1.YEARFRAC(start_date, end_date));
          break;
        case "D":
          result = exports$1.DAYS(end_date, start_date);
          break;
        case "M":
          result = end_date_month - start_date_month + 12 * (end_date_year - start_date_year);
          if (end_date_day < start_date_day) {
            result--;
          }
          break;
        case "MD":
          if (start_date_day <= end_date_day) {
            result = end_date_day - start_date_day;
          } else {
            if (end_date_month === 0) {
              start_date.setFullYear(end_date_year - 1);
              start_date.setMonth(12);
            } else {
              start_date.setFullYear(end_date_year);
              start_date.setMonth(end_date_month - 1);
            }
            result = exports$1.DAYS(end_date, start_date);
          }
          break;
        case "YM":
          result = end_date_month - start_date_month + 12 * (end_date_year - start_date_year);
          if (end_date_day < start_date_day) {
            result--;
          }
          result = result % 12;
          break;
        case "YD":
          if (end_date_month > start_date_month || end_date_month === start_date_month && end_date_day < start_date_day) {
            start_date.setFullYear(end_date_year);
          } else {
            start_date.setFullYear(end_date_year - 1);
          }
          result = exports$1.DAYS(end_date, start_date);
          break;
      }
      return result;
    };
    exports$1.DATEVALUE = function(date_text) {
      if (typeof date_text !== "string") {
        return error2.value;
      }
      var date = Date.parse(date_text);
      if (isNaN(date)) {
        return error2.value;
      }
      return new Date(date_text);
    };
    exports$1.DAY = function(serial_number) {
      var date = utils2.parseDate(serial_number);
      if (date instanceof Error) {
        return date;
      }
      return date.getDate();
    };
    function startOfDay(date) {
      var newDate = new Date(date);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    }
    exports$1.DAYS = function(end_date, start_date) {
      end_date = utils2.parseDate(end_date);
      start_date = utils2.parseDate(start_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      if (start_date instanceof Error) {
        return start_date;
      }
      return serial(startOfDay(end_date)) - serial(startOfDay(start_date));
    };
    exports$1.DAYS360 = function(start_date, end_date, method) {
      method = utils2.parseBool(method || "false");
      start_date = utils2.parseDate(start_date);
      end_date = utils2.parseDate(end_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (end_date instanceof Error) {
        return end_date;
      }
      if (method instanceof Error) {
        return method;
      }
      var sm = start_date.getMonth();
      var em = end_date.getMonth();
      var sd2, ed2;
      if (method) {
        sd2 = start_date.getDate() === 31 ? 30 : start_date.getDate();
        ed2 = end_date.getDate() === 31 ? 30 : end_date.getDate();
      } else {
        var smd = new Date(start_date.getFullYear(), sm + 1, 0).getDate();
        var emd = new Date(end_date.getFullYear(), em + 1, 0).getDate();
        sd2 = start_date.getDate() === smd ? 30 : start_date.getDate();
        if (end_date.getDate() === emd) {
          if (sd2 < 30) {
            em++;
            ed2 = 1;
          } else {
            ed2 = 30;
          }
        } else {
          ed2 = end_date.getDate();
        }
      }
      return 360 * (end_date.getFullYear() - start_date.getFullYear()) + 30 * (em - sm) + (ed2 - sd2);
    };
    exports$1.EDATE = function(start_date, months) {
      start_date = utils2.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (isNaN(months)) {
        return error2.value;
      }
      months = parseInt(months, 10);
      start_date.setMonth(start_date.getMonth() + months);
      return start_date;
    };
    exports$1.EOMONTH = function(start_date, months) {
      start_date = utils2.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      if (isNaN(months)) {
        return error2.value;
      }
      months = parseInt(months, 10);
      return new Date(start_date.getFullYear(), start_date.getMonth() + months + 1, 0);
    };
    exports$1.HOUR = function(serial_number) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getHours();
    };
    exports$1.INTERVAL = function(second) {
      if (typeof second !== "number" && typeof second !== "string") {
        return error2.value;
      } else {
        second = parseInt(second, 10);
      }
      var year = Math.floor(second / 94608e4);
      second = second % 94608e4;
      var month = Math.floor(second / 2592e3);
      second = second % 2592e3;
      var day = Math.floor(second / 86400);
      second = second % 86400;
      var hour = Math.floor(second / 3600);
      second = second % 3600;
      var min = Math.floor(second / 60);
      second = second % 60;
      var sec = second;
      year = year > 0 ? year + "Y" : "";
      month = month > 0 ? month + "M" : "";
      day = day > 0 ? day + "D" : "";
      hour = hour > 0 ? hour + "H" : "";
      min = min > 0 ? min + "M" : "";
      sec = sec > 0 ? sec + "S" : "";
      return "P" + year + month + day + "T" + hour + min + sec;
    };
    exports$1.ISOWEEKNUM = function(date) {
      date = utils2.parseDate(date);
      if (date instanceof Error) {
        return date;
      }
      date = startOfDay(date);
      date.setDate(date.getDate() + 4 - (date.getDay() || 7));
      var yearStart = new Date(date.getFullYear(), 0, 1);
      return Math.ceil(((date - yearStart) / 864e5 + 1) / 7);
    };
    exports$1.MINUTE = function(serial_number) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getMinutes();
    };
    exports$1.MONTH = function(serial_number) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getMonth() + 1;
    };
    exports$1.NETWORKDAYS = function(start_date, end_date, holidays) {
      return this.NETWORKDAYS.INTL(start_date, end_date, 1, holidays);
    };
    exports$1.NETWORKDAYS.INTL = function(start_date, end_date, weekend, holidays) {
      start_date = utils2.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      end_date = utils2.parseDate(end_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      var isMask = false;
      var maskDays = [];
      var maskIndex = [1, 2, 3, 4, 5, 6, 0];
      var maskRegex = new RegExp("^[0|1]{7}$");
      if (weekend === void 0) {
        weekend = WEEKEND_TYPES[1];
      } else if (typeof weekend === "string" && maskRegex.test(weekend)) {
        isMask = true;
        weekend = weekend.split("");
        for (i2 = 0; i2 < weekend.length; i2++) {
          if (weekend[i2] === "1") {
            maskDays.push(maskIndex[i2]);
          }
        }
      } else {
        weekend = WEEKEND_TYPES[weekend];
      }
      if (!(weekend instanceof Array)) {
        return error2.value;
      }
      if (holidays === void 0) {
        holidays = [];
      } else if (!(holidays instanceof Array)) {
        holidays = [holidays];
      }
      for (var i2 = 0; i2 < holidays.length; i2++) {
        var h2 = utils2.parseDate(holidays[i2]);
        if (h2 instanceof Error) {
          return h2;
        }
        holidays[i2] = h2;
      }
      var days = Math.round((end_date - start_date) / (1e3 * 60 * 60 * 24)) + 1;
      var total = days;
      var day = start_date;
      for (i2 = 0; i2 < days; i2++) {
        var d2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() > 0 ? day.getUTCDay() : day.getDay();
        var dec = isMask ? maskDays.includes(d2) : d2 === weekend[0] || d2 === weekend[1];
        for (var j2 = 0; j2 < holidays.length; j2++) {
          var holiday = holidays[j2];
          if (holiday.getDate() === day.getDate() && holiday.getMonth() === day.getMonth() && holiday.getFullYear() === day.getFullYear()) {
            dec = true;
            break;
          }
        }
        if (dec) {
          total--;
        }
        day.setDate(day.getDate() + 1);
      }
      return total;
    };
    exports$1.NOW = function() {
      return /* @__PURE__ */ new Date();
    };
    exports$1.SECOND = function(serial_number) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getSeconds();
    };
    exports$1.TIME = function(hour, minute, second) {
      hour = utils2.parseNumber(hour);
      minute = utils2.parseNumber(minute);
      second = utils2.parseNumber(second);
      if (utils2.anyIsError(hour, minute, second)) {
        return error2.value;
      }
      if (hour < 0 || minute < 0 || second < 0) {
        return error2.num;
      }
      return (3600 * hour + 60 * minute + second) / 86400;
    };
    exports$1.TIMEVALUE = function(time_text) {
      time_text = utils2.parseDate(time_text);
      if (time_text instanceof Error) {
        return time_text;
      }
      return (3600 * time_text.getHours() + 60 * time_text.getMinutes() + time_text.getSeconds()) / 86400;
    };
    exports$1.TODAY = function() {
      return startOfDay(/* @__PURE__ */ new Date());
    };
    exports$1.WEEKDAY = function(serial_number, return_type) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      if (return_type === void 0) {
        return_type = 1;
      }
      var day = serial_number.getDay();
      return WEEK_TYPES[return_type][day];
    };
    exports$1.WEEKNUM = function(serial_number, return_type) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      if (return_type === void 0) {
        return_type = 1;
      }
      if (return_type === 21) {
        return this.ISOWEEKNUM(serial_number);
      }
      var week_start = WEEK_STARTS[return_type];
      var jan = new Date(serial_number.getFullYear(), 0, 1);
      var inc = jan.getDay() < week_start ? 1 : 0;
      jan -= Math.abs(jan.getDay() - week_start) * 24 * 60 * 60 * 1e3;
      return Math.floor((serial_number - jan) / (1e3 * 60 * 60 * 24) / 7 + 1) + inc;
    };
    exports$1.WORKDAY = function(start_date, days, holidays) {
      return this.WORKDAY.INTL(start_date, days, 1, holidays);
    };
    exports$1.WORKDAY.INTL = function(start_date, days, weekend, holidays) {
      start_date = utils2.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      days = utils2.parseNumber(days);
      if (days instanceof Error) {
        return days;
      }
      if (days < 0) {
        return error2.num;
      }
      if (weekend === void 0) {
        weekend = WEEKEND_TYPES[1];
      } else {
        weekend = WEEKEND_TYPES[weekend];
      }
      if (!(weekend instanceof Array)) {
        return error2.value;
      }
      if (holidays === void 0) {
        holidays = [];
      } else if (!(holidays instanceof Array)) {
        holidays = [holidays];
      }
      for (var i2 = 0; i2 < holidays.length; i2++) {
        var h2 = utils2.parseDate(holidays[i2]);
        if (h2 instanceof Error) {
          return h2;
        }
        holidays[i2] = h2;
      }
      var d2 = 0;
      while (d2 < days) {
        start_date.setDate(start_date.getDate() + 1);
        var day = start_date.getDay();
        if (day === weekend[0] || day === weekend[1]) {
          continue;
        }
        for (var j2 = 0; j2 < holidays.length; j2++) {
          var holiday = holidays[j2];
          if (holiday.getDate() === start_date.getDate() && holiday.getMonth() === start_date.getMonth() && holiday.getFullYear() === start_date.getFullYear()) {
            d2--;
            break;
          }
        }
        d2++;
      }
      return start_date;
    };
    exports$1.YEAR = function(serial_number) {
      serial_number = utils2.parseDate(serial_number);
      if (serial_number instanceof Error) {
        return serial_number;
      }
      return serial_number.getFullYear();
    };
    function isLeapYear(year) {
      return new Date(year, 1, 29).getMonth() === 1;
    }
    function daysBetween(start_date, end_date) {
      return Math.ceil((end_date - start_date) / 1e3 / 60 / 60 / 24);
    }
    exports$1.YEARFRAC = function(start_date, end_date, basis) {
      start_date = utils2.parseDate(start_date);
      if (start_date instanceof Error) {
        return start_date;
      }
      end_date = utils2.parseDate(end_date);
      if (end_date instanceof Error) {
        return end_date;
      }
      basis = basis || 0;
      var sd2 = start_date.getDate();
      var sm = start_date.getMonth() + 1;
      var sy = start_date.getFullYear();
      var ed2 = end_date.getDate();
      var em = end_date.getMonth() + 1;
      var ey = end_date.getFullYear();
      switch (basis) {
        case 0:
          if (sd2 === 31 && ed2 === 31) {
            sd2 = 30;
            ed2 = 30;
          } else if (sd2 === 31) {
            sd2 = 30;
          } else if (sd2 === 30 && ed2 === 31) {
            ed2 = 30;
          }
          return (ed2 + em * 30 + ey * 360 - (sd2 + sm * 30 + sy * 360)) / 360;
        case 1:
          var feb29Between = function(date1, date2) {
            var year1 = date1.getFullYear();
            var mar1year1 = new Date(year1, 2, 1);
            if (isLeapYear(year1) && date1 < mar1year1 && date2 >= mar1year1) {
              return true;
            }
            var year2 = date2.getFullYear();
            var mar1year2 = new Date(year2, 2, 1);
            return isLeapYear(year2) && date2 >= mar1year2 && date1 < mar1year2;
          };
          var ylength = 365;
          if (sy === ey || sy + 1 === ey && (sm > em || sm === em && sd2 >= ed2)) {
            if (sy === ey && isLeapYear(sy) || feb29Between(start_date, end_date) || em === 1 && ed2 === 29) {
              ylength = 366;
            }
            return daysBetween(start_date, end_date) / ylength;
          }
          var years = ey - sy + 1;
          var days = (new Date(ey + 1, 0, 1) - new Date(sy, 0, 1)) / 1e3 / 60 / 60 / 24;
          var average = days / years;
          return daysBetween(start_date, end_date) / average;
        case 2:
          return daysBetween(start_date, end_date) / 360;
        case 3:
          return daysBetween(start_date, end_date) / 365;
        case 4:
          return (ed2 + em * 30 + ey * 360 - (sd2 + sm * 30 + sy * 360)) / 360;
      }
    };
    function serial(date) {
      var addOn = date > -22038912e5 ? 2 : 1;
      return Math.ceil((date - d1900) / 864e5) + addOn;
    }
  })(dateTime$1);
  var mathTrig = requireMathTrig();
  var statistical = requireStatistical();
  var engineering = engineering$1;
  var dateTime = dateTime$1;
  function set(fn2, root) {
    if (root) {
      for (var i2 in root) {
        fn2[i2] = root[i2];
      }
    }
    return fn2;
  }
  compatibility.BETADIST = statistical.BETA.DIST;
  compatibility.BETAINV = statistical.BETA.INV;
  compatibility.BINOMDIST = statistical.BINOM.DIST;
  compatibility.CEILING = compatibility.ISOCEILING = set(mathTrig.CEILING.MATH, mathTrig.CEILING);
  compatibility.CEILINGMATH = mathTrig.CEILING.MATH;
  compatibility.CEILINGPRECISE = mathTrig.CEILING.PRECISE;
  compatibility.CHIDIST = statistical.CHISQ.DIST;
  compatibility.CHIDISTRT = statistical.CHISQ.DIST.RT;
  compatibility.CHIINV = statistical.CHISQ.INV;
  compatibility.CHIINVRT = statistical.CHISQ.INV.RT;
  compatibility.CHITEST = statistical.CHISQ.TEST;
  compatibility.CONFIDENCE = set(statistical.CONFIDENCE.NORM, statistical.CONFIDENCE);
  compatibility.COVAR = statistical.COVARIANCE.P;
  compatibility.COVARIANCEP = statistical.COVARIANCE.P;
  compatibility.COVARIANCES = statistical.COVARIANCE.S;
  compatibility.CRITBINOM = statistical.BINOM.INV;
  compatibility.EXPONDIST = statistical.EXPON.DIST;
  compatibility.ERFCPRECISE = engineering.ERFC.PRECISE;
  compatibility.ERFPRECISE = engineering.ERF.PRECISE;
  compatibility.FDIST = statistical.F.DIST;
  compatibility.FDISTRT = statistical.F.DIST.RT;
  compatibility.FINVRT = statistical.F.INV.RT;
  compatibility.FINV = statistical.F.INV;
  compatibility.FLOOR = set(mathTrig.FLOOR.MATH, mathTrig.FLOOR);
  compatibility.FLOORMATH = mathTrig.FLOOR.MATH;
  compatibility.FLOORPRECISE = mathTrig.FLOOR.PRECISE;
  compatibility.FTEST = statistical.F.TEST;
  compatibility.GAMMADIST = statistical.GAMMA.DIST;
  compatibility.GAMMAINV = statistical.GAMMA.INV;
  compatibility.GAMMALNPRECISE = statistical.GAMMALN.PRECISE;
  compatibility.HYPGEOMDIST = statistical.HYPGEOM.DIST;
  compatibility.LOGINV = statistical.LOGNORM.INV;
  compatibility.LOGNORMINV = statistical.LOGNORM.INV;
  compatibility.LOGNORMDIST = statistical.LOGNORM.DIST;
  compatibility.MODE = set(statistical.MODE.SNGL, statistical.MODE);
  compatibility.MODEMULT = statistical.MODE.MULT;
  compatibility.MODESNGL = statistical.MODE.SNGL;
  compatibility.NEGBINOMDIST = statistical.NEGBINOM.DIST;
  compatibility.NETWORKDAYSINTL = dateTime.NETWORKDAYS.INTL;
  compatibility.NORMDIST = statistical.NORM.DIST;
  compatibility.NORMINV = statistical.NORM.INV;
  compatibility.NORMSDIST = statistical.NORM.S.DIST;
  compatibility.NORMSINV = statistical.NORM.S.INV;
  compatibility.PERCENTILE = set(statistical.PERCENTILE.EXC, statistical.PERCENTILE);
  compatibility.PERCENTILEEXC = statistical.PERCENTILE.EXC;
  compatibility.PERCENTILEINC = statistical.PERCENTILE.INC;
  compatibility.PERCENTRANK = set(statistical.PERCENTRANK.INC, statistical.PERCENTRANK);
  compatibility.PERCENTRANKEXC = statistical.PERCENTRANK.EXC;
  compatibility.PERCENTRANKINC = statistical.PERCENTRANK.INC;
  compatibility.POISSON = set(statistical.POISSON.DIST, statistical.POISSON);
  compatibility.POISSONDIST = statistical.POISSON.DIST;
  compatibility.QUARTILE = set(statistical.QUARTILE.INC, statistical.QUARTILE);
  compatibility.QUARTILEEXC = statistical.QUARTILE.EXC;
  compatibility.QUARTILEINC = statistical.QUARTILE.INC;
  compatibility.RANK = set(statistical.RANK.EQ, statistical.RANK);
  compatibility.RANKAVG = statistical.RANK.AVG;
  compatibility.RANKEQ = statistical.RANK.EQ;
  compatibility.SKEWP = statistical.SKEW.P;
  compatibility.STDEV = set(statistical.STDEV.S, statistical.STDEV);
  compatibility.STDEVP = statistical.STDEV.P;
  compatibility.STDEVS = statistical.STDEV.S;
  compatibility.TDIST = statistical.T.DIST;
  compatibility.TDISTRT = statistical.T.DIST.RT;
  compatibility.TINV = statistical.T.INV;
  compatibility.TTEST = statistical.T.TEST;
  compatibility.VAR = set(statistical.VAR.S, statistical.VAR);
  compatibility.VARP = statistical.VAR.P;
  compatibility.VARS = statistical.VAR.S;
  compatibility.WEIBULL = set(statistical.WEIBULL.DIST, statistical.WEIBULL);
  compatibility.WEIBULLDIST = statistical.WEIBULL.DIST;
  compatibility.WORKDAYINTL = dateTime.WORKDAY.INTL;
  compatibility.ZTEST = statistical.Z.TEST;
  var database = {};
  (function(exports$1) {
    var error2 = error$3;
    var stats = requireStatistical();
    var maths = requireMathTrig();
    var utils2 = common;
    var evalExpression = criteriaEval;
    function compact(array) {
      var result = [];
      utils2.arrayEach(array, function(value) {
        if (value) {
          result.push(value);
        }
      });
      return result;
    }
    exports$1.FINDFIELD = function(database2, title) {
      var index2 = null;
      utils2.arrayEach(database2, function(value, i2) {
        if (value[0] === title) {
          index2 = i2;
          return false;
        }
      });
      if (index2 == null) {
        return error2.value;
      }
      return index2;
    };
    function findResultIndex(database2, criterias) {
      var matches = {};
      for (var i2 = 1; i2 < database2[0].length; ++i2) {
        matches[i2] = true;
      }
      var maxCriteriaLength = criterias[0].length;
      for (i2 = 1; i2 < criterias.length; ++i2) {
        if (criterias[i2].length > maxCriteriaLength) {
          maxCriteriaLength = criterias[i2].length;
        }
      }
      for (var k2 = 1; k2 < database2.length; ++k2) {
        for (var l2 = 1; l2 < database2[k2].length; ++l2) {
          var currentCriteriaResult = false;
          var hasMatchingCriteria = false;
          for (var j2 = 0; j2 < criterias.length; ++j2) {
            var criteria = criterias[j2];
            if (criteria.length < maxCriteriaLength) {
              continue;
            }
            var criteriaField = criteria[0];
            if (database2[k2][0] !== criteriaField) {
              continue;
            }
            hasMatchingCriteria = true;
            for (var p2 = 1; p2 < criteria.length; ++p2) {
              if (!currentCriteriaResult) {
                var isWildcard = criteria[p2] === void 0 || criteria[p2] === "*";
                if (isWildcard) {
                  currentCriteriaResult = true;
                } else {
                  var tokenizedCriteria = evalExpression.parse(criteria[p2] + "");
                  var tokens = [evalExpression.createToken(database2[k2][l2], evalExpression.TOKEN_TYPE_LITERAL)].concat(tokenizedCriteria);
                  currentCriteriaResult = evalExpression.compute(tokens);
                }
              }
            }
          }
          if (hasMatchingCriteria) {
            matches[l2] = matches[l2] && currentCriteriaResult;
          }
        }
      }
      var result = [];
      for (var n2 = 0; n2 < database2[0].length; ++n2) {
        if (matches[n2]) {
          result.push(n2 - 1);
        }
      }
      return result;
    }
    exports$1.DAVERAGE = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var sum = 0;
      utils2.arrayEach(resultIndexes, function(value) {
        sum += targetFields[value];
      });
      return resultIndexes.length === 0 ? error2.div0 : sum / resultIndexes.length;
    };
    exports$1.DCOUNT = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.COUNT(targetValues);
    };
    exports$1.DCOUNTA = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.COUNTA(targetValues);
    };
    exports$1.DGET = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      if (resultIndexes.length === 0) {
        return error2.value;
      }
      if (resultIndexes.length > 1) {
        return error2.num;
      }
      return targetFields[resultIndexes[0]];
    };
    exports$1.DMAX = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var maxValue = targetFields[resultIndexes[0]];
      utils2.arrayEach(resultIndexes, function(value) {
        if (maxValue < targetFields[value]) {
          maxValue = targetFields[value];
        }
      });
      return maxValue;
    };
    exports$1.DMIN = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var minValue = targetFields[resultIndexes[0]];
      utils2.arrayEach(resultIndexes, function(value) {
        if (minValue > targetFields[value]) {
          minValue = targetFields[value];
        }
      });
      return minValue;
    };
    exports$1.DPRODUCT = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      var result = 1;
      utils2.arrayEach(targetValues, function(value) {
        result *= value;
      });
      return result;
    };
    exports$1.DSTDEV = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      return stats.STDEV.S(targetValues);
    };
    exports$1.DSTDEVP = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      targetValues = compact(targetValues);
      return stats.STDEV.P(targetValues);
    };
    exports$1.DSUM = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return maths.SUM(targetValues);
    };
    exports$1.DVAR = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.VAR.S(targetValues);
    };
    exports$1.DVARP = function(database2, field, criteria) {
      if (isNaN(field) && typeof field !== "string") {
        return error2.value;
      }
      var resultIndexes = findResultIndex(database2, criteria);
      var targetFields = [];
      if (typeof field === "string") {
        var index2 = exports$1.FINDFIELD(database2, field);
        targetFields = utils2.rest(database2[index2]);
      } else {
        targetFields = utils2.rest(database2[field]);
      }
      var targetValues = [];
      utils2.arrayEach(resultIndexes, function(value) {
        targetValues.push(targetFields[value]);
      });
      return stats.VAR.P(targetValues);
    };
  })(database);
  var logical = {};
  var error$1 = error$3;
  var utils = common;
  var information = information$1;
  logical.AND = function() {
    var args = utils.flatten(arguments);
    var result = error$1.value;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (args[i2] instanceof Error) {
        return args[i2];
      }
      if (args[i2] === void 0 || args[i2] === null || typeof args[i2] === "string") {
        continue;
      }
      if (result === error$1.value) {
        result = true;
      }
      if (!args[i2]) {
        result = false;
      }
    }
    return result;
  };
  logical.CHOOSE = function() {
    if (arguments.length < 2) {
      return error$1.na;
    }
    var index2 = arguments[0];
    if (index2 < 1 || index2 > 254) {
      return error$1.value;
    }
    if (arguments.length < index2 + 1) {
      return error$1.value;
    }
    return arguments[index2];
  };
  logical.FALSE = function() {
    return false;
  };
  logical.IF = function(test, then_value, otherwise_value) {
    if (test instanceof Error) {
      return test;
    }
    then_value = arguments.length >= 2 ? then_value : true;
    if (then_value === void 0 || then_value === null) {
      then_value = 0;
    }
    otherwise_value = arguments.length === 3 ? otherwise_value : false;
    if (otherwise_value === void 0 || otherwise_value === null) {
      otherwise_value = 0;
    }
    return test ? then_value : otherwise_value;
  };
  logical.IFS = function() {
    for (var i2 = 0; i2 < arguments.length / 2; i2++) {
      if (arguments[i2 * 2]) {
        return arguments[i2 * 2 + 1];
      }
    }
    return error$1.na;
  };
  logical.IFERROR = function(value, valueIfError) {
    if (information.ISERROR(value)) {
      return valueIfError;
    }
    return value;
  };
  logical.IFNA = function(value, value_if_na) {
    return value === error$1.na ? value_if_na : value;
  };
  logical.NOT = function(logical2) {
    if (typeof logical2 === "string") {
      return error$1.value;
    }
    if (logical2 instanceof Error) {
      return logical2;
    }
    return !logical2;
  };
  logical.OR = function() {
    var args = utils.flatten(arguments);
    var result = error$1.value;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (args[i2] instanceof Error) {
        return args[i2];
      }
      if (args[i2] === void 0 || args[i2] === null || typeof args[i2] === "string") {
        continue;
      }
      if (result === error$1.value) {
        result = false;
      }
      if (args[i2]) {
        result = true;
      }
    }
    return result;
  };
  logical.TRUE = function() {
    return true;
  };
  logical.XOR = function() {
    var args = utils.flatten(arguments);
    var result = error$1.value;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (args[i2] instanceof Error) {
        return args[i2];
      }
      if (args[i2] === void 0 || args[i2] === null || typeof args[i2] === "string") {
        continue;
      }
      if (result === error$1.value) {
        result = 0;
      }
      if (args[i2]) {
        result++;
      }
    }
    if (result === error$1.value) {
      return result;
    }
    return Math.floor(Math.abs(result)) & 1 ? true : false;
  };
  logical.SWITCH = function() {
    var result;
    if (arguments.length > 0) {
      var targetValue = arguments[0];
      var argc = arguments.length - 1;
      var switchCount = Math.floor(argc / 2);
      var switchSatisfied = false;
      var hasDefaultClause = argc % 2 !== 0;
      var defaultClause = argc % 2 === 0 ? null : arguments[arguments.length - 1];
      if (switchCount) {
        for (var index2 = 0; index2 < switchCount; index2++) {
          if (targetValue === arguments[index2 * 2 + 1]) {
            result = arguments[index2 * 2 + 2];
            switchSatisfied = true;
            break;
          }
        }
      }
      if (!switchSatisfied) {
        result = hasDefaultClause ? defaultClause : error$1.na;
      }
    } else {
      result = error$1.value;
    }
    return result;
  };
  var financial = {};
  (function(exports$1) {
    var error2 = error$3;
    var dateTime2 = dateTime$1;
    var utils2 = common;
    function validDate(d2) {
      return d2 && d2.getTime && !isNaN(d2.getTime());
    }
    function ensureDate(d2) {
      return d2 instanceof Date ? d2 : new Date(d2);
    }
    exports$1.ACCRINT = function(issue, first, settlement, rate, par, frequency, basis) {
      issue = ensureDate(issue);
      first = ensureDate(first);
      settlement = ensureDate(settlement);
      if (!validDate(issue) || !validDate(first) || !validDate(settlement)) {
        return error2.value;
      }
      if (rate <= 0 || par <= 0) {
        return error2.num;
      }
      if ([1, 2, 4].indexOf(frequency) === -1) {
        return error2.num;
      }
      if ([0, 1, 2, 3, 4].indexOf(basis) === -1) {
        return error2.num;
      }
      if (settlement <= issue) {
        return error2.num;
      }
      par = par || 0;
      basis = basis || 0;
      return par * rate * dateTime2.YEARFRAC(issue, settlement, basis);
    };
    exports$1.ACCRINTM = function() {
      throw new Error("ACCRINTM is not implemented");
    };
    exports$1.AMORDEGRC = function() {
      throw new Error("AMORDEGRC is not implemented");
    };
    exports$1.AMORLINC = function() {
      throw new Error("AMORLINC is not implemented");
    };
    exports$1.COUPDAYBS = function() {
      throw new Error("COUPDAYBS is not implemented");
    };
    exports$1.COUPDAYS = function() {
      throw new Error("COUPDAYS is not implemented");
    };
    exports$1.COUPDAYSNC = function() {
      throw new Error("COUPDAYSNC is not implemented");
    };
    exports$1.COUPNCD = function() {
      throw new Error("COUPNCD is not implemented");
    };
    exports$1.COUPNUM = function() {
      throw new Error("COUPNUM is not implemented");
    };
    exports$1.COUPPCD = function() {
      throw new Error("COUPPCD is not implemented");
    };
    exports$1.CUMIPMT = function(rate, periods, value, start, end, type) {
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      value = utils2.parseNumber(value);
      if (utils2.anyIsError(rate, periods, value)) {
        return error2.value;
      }
      if (rate <= 0 || periods <= 0 || value <= 0) {
        return error2.num;
      }
      if (start < 1 || end < 1 || start > end) {
        return error2.num;
      }
      if (type !== 0 && type !== 1) {
        return error2.num;
      }
      var payment = exports$1.PMT(rate, periods, value, 0, type);
      var interest = 0;
      if (start === 1) {
        if (type === 0) {
          interest = -value;
        }
        start++;
      }
      for (var i2 = start; i2 <= end; i2++) {
        if (type === 1) {
          interest += exports$1.FV(rate, i2 - 2, payment, value, 1) - payment;
        } else {
          interest += exports$1.FV(rate, i2 - 1, payment, value, 0);
        }
      }
      interest *= rate;
      return interest;
    };
    exports$1.CUMPRINC = function(rate, periods, value, start, end, type) {
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      value = utils2.parseNumber(value);
      if (utils2.anyIsError(rate, periods, value)) {
        return error2.value;
      }
      if (rate <= 0 || periods <= 0 || value <= 0) {
        return error2.num;
      }
      if (start < 1 || end < 1 || start > end) {
        return error2.num;
      }
      if (type !== 0 && type !== 1) {
        return error2.num;
      }
      var payment = exports$1.PMT(rate, periods, value, 0, type);
      var principal = 0;
      if (start === 1) {
        if (type === 0) {
          principal = payment + value * rate;
        } else {
          principal = payment;
        }
        start++;
      }
      for (var i2 = start; i2 <= end; i2++) {
        if (type > 0) {
          principal += payment - (exports$1.FV(rate, i2 - 2, payment, value, 1) - payment) * rate;
        } else {
          principal += payment - exports$1.FV(rate, i2 - 1, payment, value, 0) * rate;
        }
      }
      return principal;
    };
    exports$1.DB = function(cost, salvage, life, period, month) {
      month = month === void 0 ? 12 : month;
      cost = utils2.parseNumber(cost);
      salvage = utils2.parseNumber(salvage);
      life = utils2.parseNumber(life);
      period = utils2.parseNumber(period);
      month = utils2.parseNumber(month);
      if (utils2.anyIsError(cost, salvage, life, period, month)) {
        return error2.value;
      }
      if (cost < 0 || salvage < 0 || life < 0 || period < 0) {
        return error2.num;
      }
      if ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].indexOf(month) === -1) {
        return error2.num;
      }
      if (period > life) {
        return error2.num;
      }
      if (salvage >= cost) {
        return 0;
      }
      var rate = (1 - Math.pow(salvage / cost, 1 / life)).toFixed(3);
      var initial = cost * rate * month / 12;
      var total = initial;
      var current = 0;
      var ceiling = period === life ? life - 1 : period;
      for (var i2 = 2; i2 <= ceiling; i2++) {
        current = (cost - total) * rate;
        total += current;
      }
      if (period === 1) {
        return initial;
      } else if (period === life) {
        return (cost - total) * rate;
      } else {
        return current;
      }
    };
    exports$1.DDB = function(cost, salvage, life, period, factor) {
      factor = factor === void 0 ? 2 : factor;
      cost = utils2.parseNumber(cost);
      salvage = utils2.parseNumber(salvage);
      life = utils2.parseNumber(life);
      period = utils2.parseNumber(period);
      factor = utils2.parseNumber(factor);
      if (utils2.anyIsError(cost, salvage, life, period, factor)) {
        return error2.value;
      }
      if (cost < 0 || salvage < 0 || life < 0 || period < 0 || factor <= 0) {
        return error2.num;
      }
      if (period > life) {
        return error2.num;
      }
      if (salvage >= cost) {
        return 0;
      }
      var total = 0;
      var current = 0;
      for (var i2 = 1; i2 <= period; i2++) {
        current = Math.min((cost - total) * (factor / life), cost - salvage - total);
        total += current;
      }
      return current;
    };
    exports$1.DISC = function() {
      throw new Error("DISC is not implemented");
    };
    exports$1.DOLLARDE = function(dollar, fraction) {
      dollar = utils2.parseNumber(dollar);
      fraction = utils2.parseNumber(fraction);
      if (utils2.anyIsError(dollar, fraction)) {
        return error2.value;
      }
      if (fraction < 0) {
        return error2.num;
      }
      if (fraction >= 0 && fraction < 1) {
        return error2.div0;
      }
      fraction = parseInt(fraction, 10);
      var result = parseInt(dollar, 10);
      result += dollar % 1 * Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN10)) / fraction;
      var power = Math.pow(10, Math.ceil(Math.log(fraction) / Math.LN2) + 1);
      result = Math.round(result * power) / power;
      return result;
    };
    exports$1.DOLLARFR = function(dollar, fraction) {
      dollar = utils2.parseNumber(dollar);
      fraction = utils2.parseNumber(fraction);
      if (utils2.anyIsError(dollar, fraction)) {
        return error2.value;
      }
      if (fraction < 0) {
        return error2.num;
      }
      if (fraction >= 0 && fraction < 1) {
        return error2.div0;
      }
      fraction = parseInt(fraction, 10);
      var result = parseInt(dollar, 10);
      result += dollar % 1 * Math.pow(10, -Math.ceil(Math.log(fraction) / Math.LN10)) * fraction;
      return result;
    };
    exports$1.DURATION = function() {
      throw new Error("DURATION is not implemented");
    };
    exports$1.EFFECT = function(rate, periods) {
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      if (utils2.anyIsError(rate, periods)) {
        return error2.value;
      }
      if (rate <= 0 || periods < 1) {
        return error2.num;
      }
      periods = parseInt(periods, 10);
      return Math.pow(1 + rate / periods, periods) - 1;
    };
    exports$1.FV = function(rate, periods, payment, value, type) {
      value = value || 0;
      type = type || 0;
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      payment = utils2.parseNumber(payment);
      value = utils2.parseNumber(value);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, periods, payment, value, type)) {
        return error2.value;
      }
      var result;
      if (rate === 0) {
        result = value + payment * periods;
      } else {
        var term = Math.pow(1 + rate, periods);
        if (type === 1) {
          result = value * term + payment * (1 + rate) * (term - 1) / rate;
        } else {
          result = value * term + payment * (term - 1) / rate;
        }
      }
      return -result;
    };
    exports$1.FVSCHEDULE = function(principal, schedule) {
      principal = utils2.parseNumber(principal);
      schedule = utils2.parseNumberArray(utils2.flatten(schedule));
      if (utils2.anyIsError(principal, schedule)) {
        return error2.value;
      }
      var n2 = schedule.length;
      var future = principal;
      for (var i2 = 0; i2 < n2; i2++) {
        future *= 1 + schedule[i2];
      }
      return future;
    };
    exports$1.INTRATE = function() {
      throw new Error("INTRATE is not implemented");
    };
    exports$1.IPMT = function(rate, period, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils2.parseNumber(rate);
      period = utils2.parseNumber(period);
      periods = utils2.parseNumber(periods);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, period, periods, present, future, type)) {
        return error2.value;
      }
      var payment = exports$1.PMT(rate, periods, present, future, type);
      var interest;
      if (period === 1) {
        if (type === 1) {
          interest = 0;
        } else {
          interest = -present;
        }
      } else {
        if (type === 1) {
          interest = exports$1.FV(rate, period - 2, payment, present, 1) - payment;
        } else {
          interest = exports$1.FV(rate, period - 1, payment, present, 0);
        }
      }
      return interest * rate;
    };
    exports$1.IRR = function(values, guess) {
      guess = guess || 0;
      values = utils2.parseNumberArray(utils2.flatten(values));
      guess = utils2.parseNumber(guess);
      if (utils2.anyIsError(values, guess)) {
        return error2.value;
      }
      var irrResult = function(values2, dates2, rate) {
        var r2 = rate + 1;
        var result = values2[0];
        for (var i3 = 1; i3 < values2.length; i3++) {
          result += values2[i3] / Math.pow(r2, (dates2[i3] - dates2[0]) / 365);
        }
        return result;
      };
      var irrResultDeriv = function(values2, dates2, rate) {
        var r2 = rate + 1;
        var result = 0;
        for (var i3 = 1; i3 < values2.length; i3++) {
          var frac = (dates2[i3] - dates2[0]) / 365;
          result -= frac * values2[i3] / Math.pow(r2, frac + 1);
        }
        return result;
      };
      var dates = [];
      var positive = false;
      var negative = false;
      for (var i2 = 0; i2 < values.length; i2++) {
        dates[i2] = i2 === 0 ? 0 : dates[i2 - 1] + 365;
        if (values[i2] > 0) {
          positive = true;
        }
        if (values[i2] < 0) {
          negative = true;
        }
      }
      if (!positive || !negative) {
        return error2.num;
      }
      guess = guess === void 0 ? 0.1 : guess;
      var resultRate = guess;
      var epsMax = 1e-10;
      var newRate, epsRate, resultValue;
      var contLoop = true;
      do {
        resultValue = irrResult(values, dates, resultRate);
        newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
        epsRate = Math.abs(newRate - resultRate);
        resultRate = newRate;
        contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
      } while (contLoop);
      return resultRate;
    };
    exports$1.ISPMT = function(rate, period, periods, value) {
      rate = utils2.parseNumber(rate);
      period = utils2.parseNumber(period);
      periods = utils2.parseNumber(periods);
      value = utils2.parseNumber(value);
      if (utils2.anyIsError(rate, period, periods, value)) {
        return error2.value;
      }
      return value * rate * (period / periods - 1);
    };
    exports$1.MDURATION = function() {
      throw new Error("MDURATION is not implemented");
    };
    exports$1.MIRR = function(values, finance_rate, reinvest_rate) {
      values = utils2.parseNumberArray(utils2.flatten(values));
      finance_rate = utils2.parseNumber(finance_rate);
      reinvest_rate = utils2.parseNumber(reinvest_rate);
      if (utils2.anyIsError(values, finance_rate, reinvest_rate)) {
        return error2.value;
      }
      var n2 = values.length;
      var payments = [];
      var incomes = [];
      for (var i2 = 0; i2 < n2; i2++) {
        if (values[i2] < 0) {
          payments.push(values[i2]);
        } else {
          incomes.push(values[i2]);
        }
      }
      var num = -exports$1.NPV(reinvest_rate, incomes) * Math.pow(1 + reinvest_rate, n2 - 1);
      var den = exports$1.NPV(finance_rate, payments) * (1 + finance_rate);
      return Math.pow(num / den, 1 / (n2 - 1)) - 1;
    };
    exports$1.NOMINAL = function(rate, periods) {
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      if (utils2.anyIsError(rate, periods)) {
        return error2.value;
      }
      if (rate <= 0 || periods < 1) {
        return error2.num;
      }
      periods = parseInt(periods, 10);
      return (Math.pow(rate + 1, 1 / periods) - 1) * periods;
    };
    exports$1.NPER = function(rate, payment, present, future, type) {
      type = type === void 0 ? 0 : type;
      future = future === void 0 ? 0 : future;
      rate = utils2.parseNumber(rate);
      payment = utils2.parseNumber(payment);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, payment, present, future, type)) {
        return error2.value;
      }
      if (rate === 0) {
        return -(present + future) / payment;
      } else {
        var num = payment * (1 + rate * type) - future * rate;
        var den = present * rate + payment * (1 + rate * type);
        return Math.log(num / den) / Math.log(1 + rate);
      }
    };
    exports$1.NPV = function() {
      var args = utils2.parseNumberArray(utils2.flatten(arguments));
      if (args instanceof Error) {
        return args;
      }
      var rate = args[0];
      var value = 0;
      for (var j2 = 1; j2 < args.length; j2++) {
        value += args[j2] / Math.pow(1 + rate, j2);
      }
      return value;
    };
    exports$1.ODDFPRICE = function() {
      throw new Error("ODDFPRICE is not implemented");
    };
    exports$1.ODDFYIELD = function() {
      throw new Error("ODDFYIELD is not implemented");
    };
    exports$1.ODDLPRICE = function() {
      throw new Error("ODDLPRICE is not implemented");
    };
    exports$1.ODDLYIELD = function() {
      throw new Error("ODDLYIELD is not implemented");
    };
    exports$1.PDURATION = function(rate, present, future) {
      rate = utils2.parseNumber(rate);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      if (utils2.anyIsError(rate, present, future)) {
        return error2.value;
      }
      if (rate <= 0) {
        return error2.num;
      }
      return (Math.log(future) - Math.log(present)) / Math.log(1 + rate);
    };
    exports$1.PMT = function(rate, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, periods, present, future, type)) {
        return error2.value;
      }
      var result;
      if (rate === 0) {
        result = (present + future) / periods;
      } else {
        var term = Math.pow(1 + rate, periods);
        if (type === 1) {
          result = (future * rate / (term - 1) + present * rate / (1 - 1 / term)) / (1 + rate);
        } else {
          result = future * rate / (term - 1) + present * rate / (1 - 1 / term);
        }
      }
      return -result;
    };
    exports$1.PPMT = function(rate, period, periods, present, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, periods, present, future, type)) {
        return error2.value;
      }
      return exports$1.PMT(rate, periods, present, future, type) - exports$1.IPMT(rate, period, periods, present, future, type);
    };
    exports$1.PRICE = function() {
      throw new Error("PRICE is not implemented");
    };
    exports$1.PRICEDISC = function() {
      throw new Error("PRICEDISC is not implemented");
    };
    exports$1.PRICEMAT = function() {
      throw new Error("PRICEMAT is not implemented");
    };
    exports$1.PV = function(rate, periods, payment, future, type) {
      future = future || 0;
      type = type || 0;
      rate = utils2.parseNumber(rate);
      periods = utils2.parseNumber(periods);
      payment = utils2.parseNumber(payment);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      if (utils2.anyIsError(rate, periods, payment, future, type)) {
        return error2.value;
      }
      if (rate === 0) {
        return -payment * periods - future;
      } else {
        return ((1 - Math.pow(1 + rate, periods)) / rate * payment * (1 + rate * type) - future) / Math.pow(1 + rate, periods);
      }
    };
    exports$1.RATE = function(periods, payment, present, future, type, guess) {
      guess = guess === void 0 ? 0.01 : guess;
      future = future === void 0 ? 0 : future;
      type = type === void 0 ? 0 : type;
      periods = utils2.parseNumber(periods);
      payment = utils2.parseNumber(payment);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      type = utils2.parseNumber(type);
      guess = utils2.parseNumber(guess);
      if (utils2.anyIsError(periods, payment, present, future, type, guess)) {
        return error2.value;
      }
      var epsMax = 1e-10;
      var iterMax = 20;
      var rate = guess;
      type = type ? 1 : 0;
      for (var i2 = 0; i2 < iterMax; i2++) {
        if (rate <= -1) {
          return error2.num;
        }
        var y2, f2;
        if (Math.abs(rate) < epsMax) {
          y2 = present * (1 + periods * rate) + payment * (1 + rate * type) * periods + future;
        } else {
          f2 = Math.pow(1 + rate, periods);
          y2 = present * f2 + payment * (1 / rate + type) * (f2 - 1) + future;
        }
        if (Math.abs(y2) < epsMax) {
          return rate;
        }
        var dy;
        if (Math.abs(rate) < epsMax) {
          dy = present * periods + payment * type * periods;
        } else {
          f2 = Math.pow(1 + rate, periods);
          var df2 = periods * Math.pow(1 + rate, periods - 1);
          dy = present * df2 + payment * (1 / rate + type) * df2 + payment * (-1 / (rate * rate)) * (f2 - 1);
        }
        rate -= y2 / dy;
      }
      return rate;
    };
    exports$1.RECEIVED = function() {
      throw new Error("RECEIVED is not implemented");
    };
    exports$1.RRI = function(periods, present, future) {
      periods = utils2.parseNumber(periods);
      present = utils2.parseNumber(present);
      future = utils2.parseNumber(future);
      if (utils2.anyIsError(periods, present, future)) {
        return error2.value;
      }
      if (periods === 0 || present === 0) {
        return error2.num;
      }
      return Math.pow(future / present, 1 / periods) - 1;
    };
    exports$1.SLN = function(cost, salvage, life) {
      cost = utils2.parseNumber(cost);
      salvage = utils2.parseNumber(salvage);
      life = utils2.parseNumber(life);
      if (utils2.anyIsError(cost, salvage, life)) {
        return error2.value;
      }
      if (life === 0) {
        return error2.num;
      }
      return (cost - salvage) / life;
    };
    exports$1.SYD = function(cost, salvage, life, period) {
      cost = utils2.parseNumber(cost);
      salvage = utils2.parseNumber(salvage);
      life = utils2.parseNumber(life);
      period = utils2.parseNumber(period);
      if (utils2.anyIsError(cost, salvage, life, period)) {
        return error2.value;
      }
      if (life === 0) {
        return error2.num;
      }
      if (period < 1 || period > life) {
        return error2.num;
      }
      period = parseInt(period, 10);
      return (cost - salvage) * (life - period + 1) * 2 / (life * (life + 1));
    };
    exports$1.TBILLEQ = function(settlement, maturity, discount) {
      settlement = utils2.parseDate(settlement);
      maturity = utils2.parseDate(maturity);
      discount = utils2.parseNumber(discount);
      if (utils2.anyIsError(settlement, maturity, discount)) {
        return error2.value;
      }
      if (discount <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return 365 * discount / (360 - discount * dateTime2.DAYS360(settlement, maturity, false));
    };
    exports$1.TBILLPRICE = function(settlement, maturity, discount) {
      settlement = utils2.parseDate(settlement);
      maturity = utils2.parseDate(maturity);
      discount = utils2.parseNumber(discount);
      if (utils2.anyIsError(settlement, maturity, discount)) {
        return error2.value;
      }
      if (discount <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return 100 * (1 - discount * dateTime2.DAYS360(settlement, maturity, false) / 360);
    };
    exports$1.TBILLYIELD = function(settlement, maturity, price) {
      settlement = utils2.parseDate(settlement);
      maturity = utils2.parseDate(maturity);
      price = utils2.parseNumber(price);
      if (utils2.anyIsError(settlement, maturity, price)) {
        return error2.value;
      }
      if (price <= 0) {
        return error2.num;
      }
      if (settlement > maturity) {
        return error2.num;
      }
      if (maturity - settlement > 365 * 24 * 60 * 60 * 1e3) {
        return error2.num;
      }
      return (100 - price) * 360 / (price * dateTime2.DAYS360(settlement, maturity, false));
    };
    exports$1.VDB = function() {
      throw new Error("VDB is not implemented");
    };
    exports$1.XIRR = function(values, dates, guess) {
      values = utils2.parseNumberArray(utils2.flatten(values));
      dates = utils2.parseDateArray(utils2.flatten(dates));
      guess = utils2.parseNumber(guess);
      if (utils2.anyIsError(values, dates, guess)) {
        return error2.value;
      }
      var irrResult = function(values2, dates2, rate) {
        var r2 = rate + 1;
        var result = values2[0];
        for (var i3 = 1; i3 < values2.length; i3++) {
          result += values2[i3] / Math.pow(r2, dateTime2.DAYS(dates2[i3], dates2[0]) / 365);
        }
        return result;
      };
      var irrResultDeriv = function(values2, dates2, rate) {
        var r2 = rate + 1;
        var result = 0;
        for (var i3 = 1; i3 < values2.length; i3++) {
          var frac = dateTime2.DAYS(dates2[i3], dates2[0]) / 365;
          result -= frac * values2[i3] / Math.pow(r2, frac + 1);
        }
        return result;
      };
      var positive = false;
      var negative = false;
      for (var i2 = 0; i2 < values.length; i2++) {
        if (values[i2] > 0) {
          positive = true;
        }
        if (values[i2] < 0) {
          negative = true;
        }
      }
      if (!positive || !negative) {
        return error2.num;
      }
      guess = guess || 0.1;
      var resultRate = guess;
      var epsMax = 1e-10;
      var newRate, epsRate, resultValue;
      var contLoop = true;
      do {
        resultValue = irrResult(values, dates, resultRate);
        newRate = resultRate - resultValue / irrResultDeriv(values, dates, resultRate);
        epsRate = Math.abs(newRate - resultRate);
        resultRate = newRate;
        contLoop = epsRate > epsMax && Math.abs(resultValue) > epsMax;
      } while (contLoop);
      return resultRate;
    };
    exports$1.XNPV = function(rate, values, dates) {
      rate = utils2.parseNumber(rate);
      values = utils2.parseNumberArray(utils2.flatten(values));
      dates = utils2.parseDateArray(utils2.flatten(dates));
      if (utils2.anyIsError(rate, values, dates)) {
        return error2.value;
      }
      var result = 0;
      for (var i2 = 0; i2 < values.length; i2++) {
        result += values[i2] / Math.pow(1 + rate, dateTime2.DAYS(dates[i2], dates[0]) / 365);
      }
      return result;
    };
    exports$1.YIELD = function() {
      throw new Error("YIELD is not implemented");
    };
    exports$1.YIELDDISC = function() {
      throw new Error("YIELDDISC is not implemented");
    };
    exports$1.YIELDMAT = function() {
      throw new Error("YIELDMAT is not implemented");
    };
  })(financial);
  var lookupReference = {};
  (function(exports$1) {
    var error2 = error$3;
    var utils2 = common;
    exports$1.MATCH = function(lookupValue, lookupArray, matchType) {
      if (!lookupValue && !lookupArray) {
        return error2.na;
      }
      if (arguments.length === 2) {
        matchType = 1;
      }
      if (!(lookupArray instanceof Array)) {
        return error2.na;
      }
      lookupArray = utils2.flatten(lookupArray);
      if (matchType !== -1 && matchType !== 0 && matchType !== 1) {
        return error2.na;
      }
      var index2;
      var indexValue;
      for (var idx = 0; idx < lookupArray.length; idx++) {
        if (matchType === 1) {
          if (lookupArray[idx] === lookupValue) {
            return idx + 1;
          } else if (lookupArray[idx] < lookupValue) {
            if (!indexValue) {
              index2 = idx + 1;
              indexValue = lookupArray[idx];
            } else if (lookupArray[idx] > indexValue) {
              index2 = idx + 1;
              indexValue = lookupArray[idx];
            }
          }
        } else if (matchType === 0) {
          if (typeof lookupValue === "string") {
            lookupValue = lookupValue.replace(/\?/g, ".");
            if (lookupArray[idx].toLowerCase().match(lookupValue.toLowerCase())) {
              return idx + 1;
            }
          } else {
            if (lookupArray[idx] === lookupValue) {
              return idx + 1;
            }
          }
        } else if (matchType === -1) {
          if (lookupArray[idx] === lookupValue) {
            return idx + 1;
          } else if (lookupArray[idx] > lookupValue) {
            if (!indexValue) {
              index2 = idx + 1;
              indexValue = lookupArray[idx];
            } else if (lookupArray[idx] < indexValue) {
              index2 = idx + 1;
              indexValue = lookupArray[idx];
            }
          }
        }
      }
      return index2 ? index2 : error2.na;
    };
    exports$1.VLOOKUP = function(needle, table, index2, rangeLookup) {
      if (!table || !index2) {
        return error2.na;
      }
      rangeLookup = !(rangeLookup === 0 || rangeLookup === false);
      var result = error2.na;
      var isNumberLookup = typeof needle === "number";
      var exactMatchOnly = false;
      for (var i2 = 0; i2 < table.length; i2++) {
        var row = table[i2];
        if (row[0] === needle) {
          result = index2 < row.length + 1 ? row[index2 - 1] : error2.ref;
          break;
        } else if (!exactMatchOnly && (isNumberLookup && rangeLookup && row[0] <= needle || rangeLookup && typeof row[0] === "string" && row[0].localeCompare(needle) < 0)) {
          result = index2 < row.length + 1 ? row[index2 - 1] : error2.ref;
        }
        if (isNumberLookup && row[0] > needle) {
          exactMatchOnly = true;
        }
      }
      return result;
    };
    exports$1.HLOOKUP = function(needle, table, index2, rangeLookup) {
      return exports$1.VLOOKUP(needle, utils2.transpose(table), index2, rangeLookup);
    };
    exports$1.LOOKUP = function(searchCriterion, array, resultArray) {
      array = utils2.flatten(array);
      resultArray = utils2.flatten(resultArray);
      var isNumberLookup = typeof searchCriterion === "number";
      var result = error2.na;
      for (var i2 = 0; i2 < array.length; i2++) {
        if (array[i2] === searchCriterion) {
          return resultArray[i2];
        } else if (isNumberLookup && array[i2] <= searchCriterion || typeof array[i2] === "string" && array[i2].localeCompare(searchCriterion) < 0) {
          result = resultArray[i2];
        } else if (isNumberLookup && array[i2] > searchCriterion) {
          return result;
        }
      }
      return result;
    };
    exports$1.INDEX = function(cellRange, rowNumber, columnNumber) {
      var someError = utils2.anyError(cellRange, rowNumber, columnNumber);
      if (someError) {
        return someError;
      }
      if (!Array.isArray(cellRange)) {
        return error2.value;
      }
      var isOneDimensionRange = cellRange.length > 0 && !Array.isArray(cellRange[0]);
      if (isOneDimensionRange && !columnNumber) {
        columnNumber = rowNumber;
        rowNumber = 1;
      } else {
        columnNumber = columnNumber ? columnNumber : 1;
        rowNumber = rowNumber ? rowNumber : 1;
      }
      if (columnNumber < 0 || rowNumber < 0) {
        return error2.value;
      }
      if (isOneDimensionRange && rowNumber === 1 && columnNumber <= cellRange.length) {
        return cellRange[columnNumber - 1];
      } else if (rowNumber <= cellRange.length && columnNumber <= cellRange[rowNumber - 1].length) {
        return cellRange[rowNumber - 1][columnNumber - 1];
      }
      return error2.ref;
    };
  })(lookupReference);
  (function(exports$1) {
    var categories = [
      compatibility,
      database,
      engineering$1,
      logical,
      requireMathTrig(),
      text,
      dateTime$1,
      financial,
      information$1,
      lookupReference,
      requireStatistical(),
      miscellaneous
    ];
    for (var c2 in categories) {
      var category = categories[c2];
      for (var f2 in category) {
        exports$1[f2] = exports$1[f2] || category[f2];
      }
    }
    exports$1.utils = {
      errors: error$3
    };
  })(formulajs$1);
  const index$1 = /* @__PURE__ */ getDefaultExportFromCjs(formulajs$1);
  const formulajs = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: index$1
  }, [formulajs$1]);
  var SUPPORTED_FORMULAS = Object.keys(formulajs);
  var SYMBOL$8 = SUPPORTED_FORMULAS;
  function func$8(symbol) {
    return function __formulaFunction() {
      symbol = symbol.toUpperCase();
      var symbolParts = symbol.split(".");
      var foundFormula = false;
      var result;
      if (symbolParts.length === 1) {
        if (formulajs[symbolParts[0]]) {
          foundFormula = true;
          result = formulajs[symbolParts[0]].apply(formulajs, arguments);
        }
      } else {
        var length = symbolParts.length;
        var index2 = 0;
        var nestedFormula = formulajs;
        while (index2 < length) {
          nestedFormula = nestedFormula[symbolParts[index2]];
          index2++;
          if (!nestedFormula) {
            nestedFormula = null;
            break;
          }
        }
        if (nestedFormula) {
          foundFormula = true;
          result = nestedFormula.apply(void 0, arguments);
        }
      }
      if (!foundFormula) {
        throw Error(ERROR_NAME);
      }
      return result;
    };
  }
  func$8.isFactory = true;
  func$8.SYMBOL = SYMBOL$8;
  var SYMBOL$7 = ">";
  function func$7(exp1, exp2) {
    return exp1 > exp2;
  }
  func$7.SYMBOL = SYMBOL$7;
  var SYMBOL$6 = ">=";
  function func$6(exp1, exp2) {
    return exp1 >= exp2;
  }
  func$6.SYMBOL = SYMBOL$6;
  var SYMBOL$5 = "<";
  function func$5(exp1, exp2) {
    return exp1 < exp2;
  }
  func$5.SYMBOL = SYMBOL$5;
  var SYMBOL$4 = "<=";
  function func$4(exp1, exp2) {
    return exp1 <= exp2;
  }
  func$4.SYMBOL = SYMBOL$4;
  var SYMBOL$3 = "-";
  function func$3(first) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    var result = rest.reduce(function(acc, value) {
      return acc - toNumber(value);
    }, toNumber(first));
    if (isNaN(result)) {
      throw Error(ERROR_VALUE);
    }
    return result;
  }
  func$3.SYMBOL = SYMBOL$3;
  var SYMBOL$2 = "*";
  function func$2(first) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    var result = rest.reduce(function(acc, value) {
      return acc * toNumber(value);
    }, toNumber(first));
    if (isNaN(result)) {
      throw Error(ERROR_VALUE);
    }
    return result;
  }
  func$2.SYMBOL = SYMBOL$2;
  var SYMBOL$1 = "<>";
  function func$1(exp1, exp2) {
    return exp1 !== exp2;
  }
  func$1.SYMBOL = SYMBOL$1;
  var SYMBOL = "^";
  function func(exp1, exp2) {
    var result = Math.pow(toNumber(exp1), toNumber(exp2));
    if (isNaN(result)) {
      throw Error(ERROR_VALUE);
    }
    return result;
  }
  func.SYMBOL = SYMBOL;
  function _toConsumableArray$2(arr) {
    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$2();
  }
  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$4(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray$4(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$4(o2, minLen);
  }
  function _iterableToArray$2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$2(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
  }
  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  var availableOperators = /* @__PURE__ */ Object.create(null);
  function evaluateByOperator(operator) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    operator = operator.toUpperCase();
    if (!availableOperators[operator]) {
      throw Error(ERROR_NAME);
    }
    return availableOperators[operator].apply(availableOperators, _toConsumableArray$2(params));
  }
  function registerOperation(symbol, func2) {
    if (!Array.isArray(symbol)) {
      symbol = [symbol.toUpperCase()];
    }
    symbol.forEach(function(s2) {
      if (func2.isFactory) {
        availableOperators[s2] = func2(s2);
      } else {
        availableOperators[s2] = func2;
      }
    });
  }
  registerOperation(func$c.SYMBOL, func$c);
  registerOperation(func$b.SYMBOL, func$b);
  registerOperation(func$a.SYMBOL, func$a);
  registerOperation(func$9.SYMBOL, func$9);
  registerOperation(func.SYMBOL, func);
  registerOperation(func$8.SYMBOL, func$8);
  registerOperation(func$7.SYMBOL, func$7);
  registerOperation(func$6.SYMBOL, func$6);
  registerOperation(func$5.SYMBOL, func$5);
  registerOperation(func$4.SYMBOL, func$4);
  registerOperation(func$2.SYMBOL, func$2);
  registerOperation(func$1.SYMBOL, func$1);
  registerOperation(func$3.SYMBOL, func$3);
  var simpleSheetName$2 = "[A-Za-z0-9_À-ʯ]+";
  var quotedSheetName$2 = "'(?:(?!').|'')*'";
  var sheetNameRegexp$2 = "(?:".concat(simpleSheetName$2, "|").concat(quotedSheetName$2, ")!");
  var ABSOLUTE_CELL = new RegExp("^(?:".concat(sheetNameRegexp$2, ")?(?:[$][A-Za-z]+[$][0-9]+)"));
  var MIXED_CELL_COL = new RegExp("^(?:".concat(sheetNameRegexp$2, ")?(?:[$][A-Za-z]+[0-9]*)"));
  var MIXED_CELL_ROW = new RegExp("^(?:".concat(sheetNameRegexp$2, ")?(?:[A-Za-z]*[$][0-9]+)"));
  var RELATIVE_CELL = new RegExp("^(?:".concat(sheetNameRegexp$2, ")?(?:(?:[A-Za-z]+[0-9]*)|(?:[A-Za-z]*[0-9]+))(?!\\d)(?!\\.)"));
  var NUMONLY = /^(?:[0-9]+$)/;
  var stackCache;
  var o$1 = function o2(k2, v2, _o, l2) {
    for (_o = _o || {}, l2 = k2.length; l2--; _o[k2[l2]] = v2) {
    }
    return _o;
  }, $V0 = [1, 5], $V1 = [1, 8], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 9], $V5 = [1, 14], $V6 = [1, 15], $V7 = [1, 16], $V8 = [1, 12], $V9 = [1, 13], $Va = [1, 17], $Vb = [1, 19], $Vc = [1, 20], $Vd = [1, 21], $Ve = [1, 22], $Vf = [1, 23], $Vg = [1, 24], $Vh = [1, 25], $Vi = [1, 26], $Vj = [1, 27], $Vk = [1, 28], $Vl = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30], $Vm = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 32], $Vn = [5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 34], $Vo = [5, 10, 11, 13, 14, 15, 16, 17, 29, 30], $Vp = [5, 10, 13, 14, 15, 16, 29, 30], $Vq = [5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 29, 30], $Vr = [13, 29, 30];
  var parser = {
    trace: function trace() {
    },
    yy: {},
    symbols_: {
      error: 2,
      expressions: 3,
      expression: 4,
      EOF: 5,
      variableSequence: 6,
      number: 7,
      STRING: 8,
      "&": 9,
      "=": 10,
      "+": 11,
      "(": 12,
      ")": 13,
      "<": 14,
      ">": 15,
      NOT: 16,
      "-": 17,
      "*": 18,
      "/": 19,
      "^": 20,
      FUNCTION: 21,
      expseq: 22,
      cell: 23,
      ABSOLUTE_CELL: 24,
      RELATIVE_CELL: 25,
      MIXED_CELL: 26,
      ":": 27,
      ARRAY: 28,
      ";": 29,
      ",": 30,
      VARIABLE: 31,
      DECIMAL: 32,
      NUMBER: 33,
      "%": 34,
      ERROR: 35,
      $accept: 0,
      $end: 1
    },
    terminals_: {
      5: "EOF",
      8: "STRING",
      9: "&",
      10: "=",
      11: "+",
      12: "(",
      13: ")",
      14: "<",
      15: ">",
      16: "NOT",
      17: "-",
      18: "*",
      19: "/",
      20: "^",
      21: "FUNCTION",
      24: "ABSOLUTE_CELL",
      25: "RELATIVE_CELL",
      26: "MIXED_CELL",
      27: ":",
      28: "ARRAY",
      29: ";",
      30: ",",
      31: "VARIABLE",
      32: "DECIMAL",
      33: "NUMBER",
      34: "%",
      35: "ERROR"
    },
    productions_: [0, [3, 2], [4, 1], [4, 1], [4, 1], [4, 3], [4, 3], [4, 3], [4, 3], [4, 4], [4, 4], [4, 4], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 3], [4, 2], [4, 2], [4, 3], [4, 4], [4, 1], [4, 1], [4, 2], [23, 1], [23, 1], [23, 1], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [23, 3], [22, 1], [22, 1], [22, 3], [22, 3], [6, 1], [6, 3], [7, 1], [7, 3], [7, 2], [2, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
        case 2:
          this.$ = yy.callVariable($$[$0][0]);
          break;
        case 3:
          this.$ = yy.toNumber($$[$0]);
          break;
        case 4:
          this.$ = yy.trimEdges($$[$0]);
          break;
        case 5:
          this.$ = yy.evaluateByOperator("&", [$$[$0 - 2], $$[$0]]);
          break;
        case 6:
          this.$ = yy.evaluateByOperator("=", [$$[$0 - 2], $$[$0]]);
          break;
        case 7:
          this.$ = yy.evaluateByOperator("+", [$$[$0 - 2], $$[$0]]);
          break;
        case 8:
          this.$ = $$[$0 - 1];
          break;
        case 9:
          this.$ = yy.evaluateByOperator("<=", [$$[$0 - 3], $$[$0]]);
          break;
        case 10:
          this.$ = yy.evaluateByOperator(">=", [$$[$0 - 3], $$[$0]]);
          break;
        case 11:
          this.$ = yy.evaluateByOperator("<>", [$$[$0 - 3], $$[$0]]);
          break;
        case 12:
          this.$ = yy.evaluateByOperator("NOT", [$$[$0 - 2], $$[$0]]);
          break;
        case 13:
          this.$ = yy.evaluateByOperator(">", [$$[$0 - 2], $$[$0]]);
          break;
        case 14:
          this.$ = yy.evaluateByOperator("<", [$$[$0 - 2], $$[$0]]);
          break;
        case 15:
          this.$ = yy.evaluateByOperator("-", [$$[$0 - 2], $$[$0]]);
          break;
        case 16:
          this.$ = yy.evaluateByOperator("*", [$$[$0 - 2], $$[$0]]);
          break;
        case 17:
          this.$ = yy.evaluateByOperator("/", [$$[$0 - 2], $$[$0]]);
          break;
        case 18:
          this.$ = yy.evaluateByOperator("^", [$$[$0 - 2], $$[$0]]);
          break;
        case 19:
          var n1 = yy.invertNumber($$[$0]);
          this.$ = n1;
          if (isNaN(this.$)) {
            this.$ = 0;
          }
          break;
        case 20:
          var n1 = yy.toNumber($$[$0]);
          this.$ = n1;
          if (isNaN(this.$)) {
            this.$ = 0;
          }
          break;
        case 21:
          this.$ = yy.callFunction($$[$0 - 2]);
          break;
        case 22:
          this.$ = yy.callFunction($$[$0 - 3], $$[$0 - 1]);
          break;
        case 26:
        case 27:
        case 28:
          this.$ = yy.cellValue($$[$0]);
          break;
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
          this.$ = yy.rangeValue($$[$0 - 2], $$[$0]);
          break;
        case 38:
        case 42:
          this.$ = [$$[$0]];
          break;
        case 39:
          this.$ = yy.trimEdges(yytext).split(",");
          break;
        case 40:
        case 41:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 43:
          this.$ = Array.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]];
          this.$.push($$[$0]);
          break;
        case 44:
          this.$ = $$[$0];
          break;
        case 45:
          this.$ = ($$[$0 - 2] + "." + $$[$0]) * 1;
          break;
        case 46:
          this.$ = $$[$0 - 1] * 0.01;
          break;
        case 47:
          this.$ = yy.throwError($$[$0]);
          break;
      }
    },
    table: [{
      2: 11,
      3: 1,
      4: 2,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      1: [3]
    }, {
      5: [1, 18],
      9: $Vb,
      10: $Vc,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }, o$1($Vl, [2, 2], {
      32: [1, 29]
    }), o$1($Vl, [2, 3], {
      34: [1, 30]
    }), o$1($Vl, [2, 4]), {
      2: 11,
      4: 31,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 32,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 33,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      12: [1, 34]
    }, o$1($Vl, [2, 23]), o$1($Vl, [2, 24], {
      2: 35,
      35: $Va
    }), o$1($Vm, [2, 42]), o$1($Vn, [2, 44], {
      32: [1, 36]
    }), o$1($Vl, [2, 26], {
      27: [1, 37]
    }), o$1($Vl, [2, 27], {
      27: [1, 38]
    }), o$1($Vl, [2, 28], {
      27: [1, 39]
    }), o$1([5, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 35], [2, 47]), {
      1: [2, 1]
    }, {
      2: 11,
      4: 40,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 41,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 42,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 45,
      6: 3,
      7: 4,
      8: $V0,
      10: [1, 43],
      11: $V1,
      12: $V2,
      15: [1, 44],
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 47,
      6: 3,
      7: 4,
      8: $V0,
      10: [1, 46],
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 48,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 49,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 50,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 51,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 52,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      31: [1, 53]
    }, o$1($Vn, [2, 46]), {
      9: $Vb,
      10: $Vc,
      11: $Vd,
      13: [1, 54],
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }, o$1($Vo, [2, 19], {
      9: $Vb,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vo, [2, 20], {
      9: $Vb,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), {
      2: 11,
      4: 57,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      13: [1, 55],
      17: $V3,
      21: $V4,
      22: 56,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      28: [1, 58],
      31: $V8,
      33: $V9,
      35: $Va
    }, o$1($Vl, [2, 25]), {
      33: [1, 59]
    }, {
      24: [1, 60],
      25: [1, 61],
      26: [1, 62]
    }, {
      24: [1, 63],
      25: [1, 64],
      26: [1, 65]
    }, {
      24: [1, 66],
      25: [1, 67],
      26: [1, 68]
    }, o$1($Vl, [2, 5]), o$1([5, 10, 13, 29, 30], [2, 6], {
      9: $Vb,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vo, [2, 7], {
      9: $Vb,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), {
      2: 11,
      4: 69,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 70,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, o$1($Vp, [2, 14], {
      9: $Vb,
      11: $Vd,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), {
      2: 11,
      4: 71,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, o$1($Vp, [2, 13], {
      9: $Vb,
      11: $Vd,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1([5, 10, 13, 16, 29, 30], [2, 12], {
      9: $Vb,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vo, [2, 15], {
      9: $Vb,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vq, [2, 16], {
      9: $Vb,
      20: $Vk
    }), o$1($Vq, [2, 17], {
      9: $Vb,
      20: $Vk
    }), o$1([5, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30], [2, 18], {
      9: $Vb
    }), o$1($Vm, [2, 43]), o$1($Vl, [2, 8]), o$1($Vl, [2, 21]), {
      13: [1, 72],
      29: [1, 73],
      30: [1, 74]
    }, o$1($Vr, [2, 38], {
      9: $Vb,
      10: $Vc,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vr, [2, 39]), o$1($Vn, [2, 45]), o$1($Vl, [2, 29]), o$1($Vl, [2, 30]), o$1($Vl, [2, 31]), o$1($Vl, [2, 32]), o$1($Vl, [2, 33]), o$1($Vl, [2, 34]), o$1($Vl, [2, 35]), o$1($Vl, [2, 36]), o$1($Vl, [2, 37]), o$1($Vp, [2, 9], {
      9: $Vb,
      11: $Vd,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vp, [2, 11], {
      9: $Vb,
      11: $Vd,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vp, [2, 10], {
      9: $Vb,
      11: $Vd,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vl, [2, 22]), {
      2: 11,
      4: 75,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, {
      2: 11,
      4: 76,
      6: 3,
      7: 4,
      8: $V0,
      11: $V1,
      12: $V2,
      17: $V3,
      21: $V4,
      23: 10,
      24: $V5,
      25: $V6,
      26: $V7,
      31: $V8,
      33: $V9,
      35: $Va
    }, o$1($Vr, [2, 40], {
      9: $Vb,
      10: $Vc,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    }), o$1($Vr, [2, 41], {
      9: $Vb,
      10: $Vc,
      11: $Vd,
      14: $Ve,
      15: $Vf,
      16: $Vg,
      17: $Vh,
      18: $Vi,
      19: $Vj,
      20: $Vk
    })],
    defaultActions: {
      18: [2, 1]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error2 = new Error(str);
        error2.hash = hash;
        throw error2;
      }
    },
    parse: function parse(input) {
      var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n2) {
        stack.length = stack.length - 2 * n2;
        vstack.length = vstack.length - n2;
        lstack.length = lstack.length - n2;
      }
      var lex = function lex2() {
        var token;
        token = lexer2.lex() || EOF;
        if (typeof token !== "number") {
          token = self2.symbols_[token] || token;
        }
        return token;
      };
      var symbol, preErrorSymbol, state, action, r2, yyval = {}, p2, len, newState, expected;
      while (true) {
        stackCache = stack;
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == "undefined") {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var locateNearestErrorRecoveryRule = function locateNearestErrorRecoveryRule2(state2) {
            var stack_probe = stack.length - 1;
            var depth = 0;
            for (; ; ) {
              if (TERROR.toString() in table[state2]) {
                return depth;
              }
              if (state2 === 0 || stack_probe < 2) {
                return false;
              }
              stack_probe -= 2;
              state2 = stack[stack_probe];
              ++depth;
            }
          };
          var error_rule_depth;
          var errStr = "";
          if (!recovering) {
            error_rule_depth = locateNearestErrorRecoveryRule(state);
            expected = [];
            for (p2 in table[state]) {
              if (this.terminals_[p2] && p2 > TERROR) {
                expected.push("'" + this.terminals_[p2] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected,
              recoverable: error_rule_depth !== false
            });
          } else if (preErrorSymbol !== EOF) {
            error_rule_depth = locateNearestErrorRecoveryRule(state);
          }
          if (recovering == 3) {
            if (symbol === EOF || preErrorSymbol === EOF) {
              throw new Error(errStr || "Parsing halted while starting to recover from another error.");
            }
            yyleng = lexer2.yyleng;
            yytext = lexer2.yytext;
            yylineno = lexer2.yylineno;
            yyloc = lexer2.yylloc;
            symbol = lex();
          }
          if (error_rule_depth === false) {
            throw new Error(errStr || "Parsing halted. No suitable error recovery rule available.");
          }
          popStack(error_rule_depth);
          preErrorSymbol = symbol == TERROR ? null : symbol;
          symbol = TERROR;
          state = stack[stack.length - 1];
          action = table[state] && table[state][TERROR];
          recovering = 3;
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r2 = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r2 !== "undefined") {
              return r2;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = /* @__PURE__ */ function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function input() {
        var ch2 = this._input[0];
        this.yytext += ch2;
        this.yyleng++;
        this.offset++;
        this.match += ch2;
        this.matched += ch2;
        var lines = ch2.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch2;
      },
      // unshifts one char (or a string) into the input
      unput: function unput(ch2) {
        var len = ch2.length;
        var lines = ch2.split(/(?:\r\n?|\n)/g);
        this._input = ch2 + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r2 = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function more() {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function reject() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function less(n2) {
        this.unput(this.match.slice(n2));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function pastInput() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function upcomingInput() {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function showPosition() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function test_match(match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      // return next match in input
      next: function next() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i2 = 0; i2 < rules.length; i2++) {
          tempMatch = this._input.match(this.rules[rules[i2]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i2;
            var stackLen = stackCache.length;
            if (rules[i2] === 8 && match[0].match(NUMONLY) && !(match.input.slice(match[0].length)[0] === ":" || stackLen > 3 && stackCache[stackLen - 4] === 25 && stackCache[stackLen - 2] === 27)) {
              match = false;
              continue;
            }
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i2]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index2]);
          if (token !== false) {
            return token;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r2 = this.next();
        if (r2) {
          return r2;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n2 = this.conditionStack.length - 1;
        if (n2 > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n2) {
        n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
        if (n2 >= 0) {
          return this.conditionStack[n2];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 8;
          case 2:
            return 8;
          case 3:
            return 21;
          case 4:
            return 35;
          case 5:
            return 24;
          case 6:
            return 26;
          case 7:
            return 26;
          case 8:
            return 25;
          case 9:
            return 21;
          case 10:
            return 31;
          case 11:
            return 31;
          case 12:
            return 33;
          case 13:
            return 28;
          case 14:
            return 9;
          case 15:
            return " ";
          case 16:
            return 32;
          case 17:
            return 27;
          case 18:
            return 29;
          case 19:
            return 30;
          case 20:
            return 18;
          case 21:
            return 19;
          case 22:
            return 17;
          case 23:
            return 11;
          case 24:
            return 20;
          case 25:
            return 12;
          case 26:
            return 13;
          case 27:
            return 15;
          case 28:
            return 14;
          case 29:
            return 16;
          case 30:
            return '"';
          case 31:
            return "'";
          case 32:
            return "!";
          case 33:
            return 10;
          case 34:
            return 34;
          case 35:
            return "#";
          case 36:
            return 5;
        }
      },
      rules: [/^(?:\s+)/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*'[^'!])/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9\.]+(?=[(]))/, /^(?:#[A-Z0-9\/]+(!|\?)?)/, ABSOLUTE_CELL, MIXED_CELL_COL, MIXED_CELL_ROW, RELATIVE_CELL, /^(?:[A-Za-z\.]+(?=[(]))/, /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/, /^(?:[A-Za-z_]+)/, /^(?:[0-9]+)/, /^(?:\[(.*)?\])/, /^(?:&)/, /^(?: )/, /^(?:[.])/, /^(?::)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\/)/, /^(?:-)/, /^(?:\+)/, /^(?:\^)/, /^(?:\()/, /^(?:\))/, /^(?:>)/, /^(?:<)/, /^(?:NOT\b)/, /^(?:")/, /^(?:')/, /^(?:!)/, /^(?:=)/, /^(?:%)/, /^(?:[#])/, /^(?:$)/],
      conditions: {
        INITIAL: {
          rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
          inclusive: true
        }
      }
    };
    return lexer2;
  }();
  parser.lexer = lexer;
  function Parser$1() {
    this.yy = {};
  }
  Parser$1.prototype = parser;
  parser.Parser = Parser$1;
  function trimEdges(string) {
    var margin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    string = string.substring(margin, string.length - margin);
    return string;
  }
  function _slicedToArray$3(arr, i2) {
    return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i2) || _unsupportedIterableToArray$3(arr, i2) || _nonIterableRest$3();
  }
  function _nonIterableRest$3() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$3(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray$3(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$3(o2, minLen);
  }
  function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit$3(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$3(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function rowLabelToIndex(label) {
    var result = parseInt(label, 10);
    if (isNaN(result)) {
      result = -1;
    } else {
      result = Math.max(result - 1, -1);
    }
    return result;
  }
  function rowIndexToLabel(row) {
    var result = "";
    if (row >= 0) {
      result = "".concat(row + 1);
    }
    return result;
  }
  var COLUMN_LABEL_BASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var COLUMN_LABEL_BASE_LENGTH = COLUMN_LABEL_BASE.length;
  function columnLabelToIndex(label) {
    var result = 0;
    if (typeof label === "string") {
      label = label.toUpperCase();
      for (var i2 = 0, j2 = label.length - 1; i2 < label.length; i2 += 1, j2 -= 1) {
        result += Math.pow(COLUMN_LABEL_BASE_LENGTH, j2) * (COLUMN_LABEL_BASE.indexOf(label[i2]) + 1);
      }
    }
    --result;
    return result;
  }
  function columnIndexToLabel(column) {
    var result = "";
    while (column >= 0) {
      result = String.fromCharCode(column % COLUMN_LABEL_BASE_LENGTH + 97) + result;
      column = Math.floor(column / COLUMN_LABEL_BASE_LENGTH) - 1;
    }
    return result.toUpperCase();
  }
  var simpleSheetName$1 = "[A-Za-z0-9_À-ʯ]+";
  var quotedSheetName$1 = "'(?:(?!').|'')*'";
  var sheetNameRegexp$1 = "(".concat(simpleSheetName$1, "|").concat(quotedSheetName$1, ")!");
  var LABEL_EXTRACT_REGEXP$1 = new RegExp("^(?:".concat(sheetNameRegexp$1, ")?([$])?([A-Za-z]*)([$])?([0-9]*)$"));
  function extractLabel(label) {
    if (typeof label !== "string" || !LABEL_EXTRACT_REGEXP$1.test(label)) {
      return [];
    }
    var _label$toUpperCase$ma = label.toUpperCase().match(LABEL_EXTRACT_REGEXP$1), _label$toUpperCase$ma2 = _slicedToArray$3(_label$toUpperCase$ma, 6), sheetNameStr = _label$toUpperCase$ma2[1], columnAbs = _label$toUpperCase$ma2[2], column = _label$toUpperCase$ma2[3], rowAbs = _label$toUpperCase$ma2[4], row = _label$toUpperCase$ma2[5];
    if (column == null && row == null) return [];
    var sheetName = sheetNameStr == null ? null : label.slice(0, sheetNameStr.length).replace(/^'|'$/g, "").replace(/''/g, "'");
    return [{
      index: rowLabelToIndex(row),
      label: row,
      isAbsolute: rowAbs === "$"
    }, {
      index: columnLabelToIndex(column),
      label: column,
      isAbsolute: columnAbs === "$"
    }, sheetName];
  }
  function toLabel(row, column) {
    var rowLabel = (row.isAbsolute ? "$" : "") + rowIndexToLabel(row.index);
    var columnLabel = (column.isAbsolute ? "$" : "") + columnIndexToLabel(column.index);
    return columnLabel + rowLabel;
  }
  function _typeof$1(obj) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$1(obj);
  }
  function _slicedToArray$2(arr, i2) {
    return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i2) || _unsupportedIterableToArray$2(arr, i2) || _nonIterableRest$2();
  }
  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$2(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray$2(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$2(o2, minLen);
  }
  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
      arr2[i2] = arr[i2];
    }
    return arr2;
  }
  function _iterableToArrayLimit$2(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$2(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$1(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
    Object.defineProperty(subClass, "prototype", { writable: false });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o2, p2) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
      o3.__proto__ = p3;
      return o3;
    };
    return _setPrototypeOf(o2, p2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _getPrototypeOf(o2) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
      return o3.__proto__ || Object.getPrototypeOf(o3);
    };
    return _getPrototypeOf(o2);
  }
  var Parser = /* @__PURE__ */ function(_Emitter) {
    _inherits(Parser2, _Emitter);
    var _super = _createSuper(Parser2);
    function Parser2() {
      var _this;
      _classCallCheck$1(this, Parser2);
      _this = _super.call(this);
      _this.parser = new Parser$1();
      _this.parser.yy = {
        toNumber,
        trimEdges,
        invertNumber,
        throwError: function throwError(errorName) {
          return _this._throwError(errorName);
        },
        callVariable: function callVariable(variable) {
          return _this._callVariable(variable);
        },
        evaluateByOperator,
        callFunction: function callFunction(name, params) {
          return _this._callFunction(name, params);
        },
        cellValue: function cellValue(value) {
          return _this._callCellValue(value);
        },
        rangeValue: function rangeValue(start, end) {
          return _this._callRangeValue(start, end);
        }
      };
      _this.variables = /* @__PURE__ */ Object.create(null);
      _this.functions = /* @__PURE__ */ Object.create(null);
      _this.options = /* @__PURE__ */ Object.create(null);
      _this.setVariable("TRUE", true).setVariable("FALSE", false).setVariable("NULL", null);
      return _this;
    }
    _createClass$1(Parser2, [{
      key: "parse",
      value: function parse(expression, options) {
        var result = null;
        var error2 = null;
        this.options = options;
        try {
          if (expression === "") {
            result = "";
          } else {
            result = this.parser.parse(expression);
          }
        } catch (ex) {
          var message = error$4(ex.message);
          if (message) {
            error2 = message;
          } else {
            error2 = error$4(ERROR);
          }
        }
        if (result instanceof Error) {
          error2 = error$4(result.message) || error$4(ERROR);
          result = null;
        }
        return {
          error: error2,
          result
        };
      }
      /**
       * Set predefined variable name which can be visible while parsing formula expression.
       *
       * @param {String} name Variable name.
       * @param {*} value Variable value.
       * @returns {Parser}
       */
    }, {
      key: "setVariable",
      value: function setVariable(name, value) {
        this.variables[name] = value;
        return this;
      }
      /**
       * Get variable name.
       *
       * @param {String} name Variable name.
       * @returns {*}
       */
    }, {
      key: "getVariable",
      value: function getVariable(name) {
        return this.variables[name];
      }
      /**
       * Retrieve variable value by its name.
       *
       * @param name Variable name.
       * @returns {*}
       * @private
       */
    }, {
      key: "_callVariable",
      value: function _callVariable(name) {
        var value = this.getVariable(name);
        this.emit("callVariable", name, function(newValue) {
          if (newValue !== void 0) {
            value = newValue;
          }
        });
        if (value === void 0) {
          throw Error(ERROR_NAME);
        }
        return value;
      }
      /**
       * Set custom function which can be visible while parsing formula expression.
       *
       * @param {String} name Custom function name.
       * @param {Function} fn Custom function.
       * @returns {Parser}
       */
    }, {
      key: "setFunction",
      value: function setFunction(name, fn2) {
        this.functions[name] = fn2;
        return this;
      }
      /**
       * Get custom function.
       *
       * @param {String} name Custom function name.
       * @returns {*}
       */
    }, {
      key: "getFunction",
      value: function getFunction(name) {
        return this.functions[name];
      }
      /**
       * Call function with provided params.
       *
       * @param name Function name.
       * @param params Function params.
       * @returns {*}
       * @private
       */
    }, {
      key: "_callFunction",
      value: function _callFunction(name) {
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var fn2 = this.getFunction(name);
        var value;
        if (fn2) {
          value = fn2(params);
        }
        this.emit("callFunction", name, params, function(newValue) {
          if (newValue !== void 0) {
            value = newValue;
          }
        });
        return value === void 0 ? evaluateByOperator(name, params) : value;
      }
      /**
       * Retrieve value by its label (`B3`, `B$3`, `B$3`, `$B$3`).
       *
       * @param {String} label Coordinates.
       * @returns {*}
       * @private
       */
    }, {
      key: "_callCellValue",
      value: function _callCellValue(label) {
        var _extractLabel = extractLabel(label), _extractLabel2 = _slicedToArray$2(_extractLabel, 3), row = _extractLabel2[0], column = _extractLabel2[1], sheetName = _extractLabel2[2];
        if ((column === null || column === void 0 ? void 0 : column.index) === -1) {
          if (row.isAbsolute || column.isAbsolute) {
            throw Error(ERROR_NAME);
          }
          return row.index + 1;
        } else if ((row === null || row === void 0 ? void 0 : row.index) === -1) {
          throw Error(ERROR_NAME);
        }
        var value = void 0;
        this.emit("callCellValue", {
          label,
          row,
          column,
          sheetName
        }, this.options, function(_value) {
          value = _value;
        });
        return value;
      }
      /**
       * Retrieve value by its label (`B3:A1`, `B$3:A1`, `B$3:$A1`, `$B$3:A$1`).
       *
       * @param {String} startLabel Coordinates of the first cell.
       * @param {String} endLabel Coordinates of the last cell.
       * @returns {Array} Returns an array of mixed values.
       * @private
       */
    }, {
      key: "_callRangeValue",
      value: function _callRangeValue(startLabel, endLabel) {
        var _extractLabel3 = extractLabel(startLabel), _extractLabel4 = _slicedToArray$2(_extractLabel3, 3), startRow = _extractLabel4[0], startColumn = _extractLabel4[1], startSheetName = _extractLabel4[2];
        var _extractLabel5 = extractLabel(endLabel), _extractLabel6 = _slicedToArray$2(_extractLabel5, 3), endRow = _extractLabel6[0], endColumn = _extractLabel6[1], endSheetName = _extractLabel6[2];
        if (endSheetName != null && startSheetName != endSheetName) {
          throw Error(ERROR_VALUE);
        }
        var startCell = {};
        var endCell = {};
        startCell.sheetName = startSheetName;
        if (startRow.index <= endRow.index) {
          startCell.row = startRow;
          endCell.row = endRow;
        } else {
          startCell.row = endRow;
          endCell.row = startRow;
        }
        if (startColumn.index <= endColumn.index) {
          startCell.column = startColumn;
          endCell.column = endColumn;
        } else {
          startCell.column = endColumn;
          endCell.column = startColumn;
        }
        startCell.label = toLabel(startCell.row, startCell.column);
        endCell.label = toLabel(endCell.row, endCell.column);
        var value = [];
        this.emit("callRangeValue", startCell, endCell, this.options, function() {
          var _value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          value = _value;
        });
        return value;
      }
      /**
       * Try to throw error by its name.
       *
       * @param {String} errorName Error name.
       * @returns {String}
       * @private
       */
    }, {
      key: "_throwError",
      value: function _throwError(errorName) {
        if (isValidStrict(errorName)) {
          throw Error(errorName);
        }
        throw Error(ERROR);
      }
    }]);
    return Parser2;
  }(Emitter);
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  function validate(uuid) {
    return typeof uuid === "string" && REGEX.test(uuid);
  }
  var byteToHex = [];
  for (var i$2 = 0; i$2 < 256; ++i$2) {
    byteToHex.push((i$2 + 256).toString(16).substr(1));
  }
  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!validate(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    return stringify(rnds);
  }
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i2 = 0; i2 < props.length; i2++) {
      var descriptor = props[i2];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _slicedToArray$1(arr, i2) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i2) || _unsupportedIterableToArray$1(arr, i2) || _nonIterableRest$1();
  }
  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
  }
  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit$1(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray$1(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray$1(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray$1(o2, minLen);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
    return arr2;
  }
  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var en$1 = {
    generalDialog: {
      partiallyError: "Cannot perform this operation on partially merged cells",
      readOnlyError: "Cannot perform this operation in read-only mode",
      dataNullError: "Cannot perform this operation on data that does not exist",
      noSeletionError: "The selection operation has not been performed yet",
      cannotSelectMultiple: "Cannot select multiple selections"
    },
    functionlist: [{
      n: "SUMIF",
      t: 0,
      d: "Returns a conditional sum across a range.",
      a: "A conditional sum across a range.",
      m: [2, 3],
      p: [{
        name: "range",
        detail: "The range which is tested against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sum_range",
        detail: "The range to be summed, if different from `range`.",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TAN",
      t: 0,
      d: "Returns the tangent of an angle provided in radians.",
      a: "Tangent of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the tangent of, in radians.",
        example: "45*PI()/180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TANH",
      t: 0,
      d: "Returns the hyperbolic tangent of any real number.",
      a: "Hyperbolic tangent of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic tangent of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CEILING",
      t: 0,
      d: "Rounds a number up to the nearest integer multiple of specified significance `factor`.",
      a: "Rounds number up to nearest multiple of a factor.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round up to the nearest integer multiple of `factor`.",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN",
      t: 0,
      d: "Returns the inverse tangent of a value, in radians.",
      a: "Inverse tangent of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse tangent.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ASINH",
      t: 0,
      d: "Returns the inverse hyperbolic sine of a number.",
      a: "Inverse hyperbolic sine of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic sine.",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ABS",
      t: 0,
      d: "Returns the absolute value of a number.",
      a: "Absolute value of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number of which to return the absolute value.",
        example: "-2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOS",
      t: 0,
      d: "Returns the inverse cosine of a value, in radians.",
      a: "Inverse cosine of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse cosine. Must be between `-1` and `1`, inclusive.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOSH",
      t: 0,
      d: "Returns the inverse hyperbolic cosine of a number.",
      a: "Inverse hyperbolic cosine of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic cosine. Must be greater than or equal to `1`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTINOMIAL",
      t: 0,
      d: "Returns the factorial of the sum of values divided by the product of the values' factorials.",
      a: "Multinomial distribution function.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "ATANH",
      t: 0,
      d: "Returns the inverse hyperbolic tangent of a number.",
      a: "Inverse hyperbolic tangent of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic tangent. Must be between -1 and 1, exclusive.",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN2",
      t: 0,
      d: "Returns the angle between the x-axis and a line segment from the origin (0,0) to specified coordinate pair (`x`,`y`), in radians.",
      a: "Arctangent of a value.",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The x coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "y",
        detail: "The y coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTBLANK",
      t: 1,
      d: "Returns the number of empty values in a list of values and ranges.",
      a: "Number of empty values.",
      m: [1, 1],
      p: [{
        name: "value1",
        detail: "The first value or range in which to count the number of blanks.",
        example: "A2:C100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "COSH",
      t: 0,
      d: "Returns the hyperbolic cosine of any real number.",
      a: "Hyperbolic cosine of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic cosine of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INT",
      t: 0,
      d: "Rounds a number down to the nearest integer that is less than or equal to it.",
      a: "Rounds number down to nearest integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round down to the nearest integer.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISEVEN",
      t: 0,
      d: "Checks whether the provided value is even.",
      a: "Whether the provided value is even.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as even.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISODD",
      t: 0,
      d: "Checks whether the provided value is odd.",
      a: "Whether the provided value is odd.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as odd.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LCM",
      t: 0,
      d: "Returns the least common multiple of one or more integers.",
      a: "Least common multiple of one or more integers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range whose factors to consider in a calculation to find the least common multiple.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges whose factors to consider to find the least common multiple.",
        example: "3",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LN",
      t: 0,
      d: "Returns the logarithm of a number, base e (Euler's number).",
      a: "The logarithm of a number, base e (euler's number).",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm, base e.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG",
      t: 0,
      d: "Returns the logarithm of a number with respect to a base.",
      a: "The logarithm of a number with respect to a base.",
      m: [1, 2],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm.",
        example: "128",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "base",
        detail: "The base to use for calculation of the logarithm.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG10",
      t: 0,
      d: "Returns the logarithm of a number, base 10.",
      a: "The logarithm of a number, base 10.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm, base 10.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MOD",
      t: 0,
      d: "Returns the result of the modulo operator, the remainder after a division operation.",
      a: "Modulo (remainder) operator.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided to find the remainder.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MROUND",
      t: 0,
      d: "Rounds one number to the nearest integer multiple of another.",
      a: "Rounds a number to the nearest integer multiple.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The number to round to the nearest integer multiple of another.",
        example: "21",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ODD",
      t: 0,
      d: "Rounds a number up to the nearest odd integer.",
      a: "Rounds a number up to the nearest odd integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round to the next greatest odd number.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMSQ",
      t: 0,
      d: "Returns the sum of the squares of a series of numbers and/or cells.",
      a: "Sum of squares.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first number or range whose squares to add together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional numbers or ranges whose squares to add to the square(s) of `value1`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMBIN",
      t: 0,
      d: "Returns the number of ways to choose some number of objects from a pool of a given size of objects.",
      a: "Number of combinations from a set of objects.",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "The size of the pool of objects to choose from.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "The number of objects to choose.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUM",
      t: 0,
      d: "Returns the sum of a series of numbers and/or cells.",
      a: "Sum of a series of numbers and/or cells.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first number or range to add together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional numbers or ranges to add to `value1`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SUBTOTAL",
      t: 0,
      d: "Returns a subtotal for a vertical range of cells using a specified aggregation function.",
      a: "Subtotal for a range using a specific function.",
      m: [2, 256],
      p: [{
        name: "function_code",
        detail: "The function to use in subtotal aggregation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "range1",
        detail: "The first range over which to calculate a subtotal.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "range2",
        detail: "Additional ranges over which to calculate subtotals.",
        example: "B2:B8",
        require: "o",
        repeat: "y",
        type: "range"
      }]
    }, {
      n: "ASIN",
      t: 0,
      d: "Returns the inverse sine of a value, in radians.",
      a: "Inverse sine of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse sine. Must be between `-1` and `1`, inclusive.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTIF",
      t: 1,
      d: "Returns a conditional count across a range.",
      a: "A conditional count across a range.",
      m: [2, 2],
      p: [{
        name: "range",
        detail: "The range that is tested against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RADIANS",
      t: 0,
      d: "Converts an angle value in degrees to radians.",
      a: "Converts an angle value in degrees to radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to convert from degrees to radians.",
        example: "180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RAND",
      t: 0,
      d: "Returns a random number between 0 inclusive and 1 exclusive.",
      a: "A random number between 0 inclusive and 1 exclusive.",
      m: [0, 0],
      p: []
    }, {
      n: "COUNTUNIQUE",
      t: 0,
      d: "Counts the number of unique values in a list of specified values and ranges.",
      a: "Counts number of unique values in a range.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider for uniqueness.",
        example: "A1:C100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider for uniqueness.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DEGREES",
      t: 0,
      d: "Converts an angle value in radians to degrees.",
      a: "Converts an angle value in radians to degrees.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to convert from radians to degrees.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ERFC",
      t: 9,
      d: "Returns the complementary Gauss error function of a value.",
      a: "Complementary gauss error function of a value.",
      m: [1, 1],
      p: [{
        name: "z",
        detail: "The number for which to calculate the complementary Gauss error function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVEN",
      t: 0,
      d: "Rounds a number up to the nearest even integer.",
      a: "Rounds a number up to the nearest even integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round to the next greatest even number.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EXP",
      t: 0,
      d: "Returns Euler's number, e (~2.718) raised to a power.",
      a: "Euler's number, e (~2.718) raised to a power.",
      m: [1, 1],
      p: [{
        name: "exponent",
        detail: "The exponent to raise e to.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACT",
      t: 0,
      d: "Returns the factorial of a number.",
      a: "Factorial of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number or reference to a number whose factorial will be calculated and returned.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACTDOUBLE",
      t: 0,
      d: 'Returns the "double factorial" of a number.',
      a: '"double factorial" of a number.',
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number or reference to a number whose double factorial will be calculated and returned.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PI",
      t: 0,
      d: "Returns the value of Pi to 14 decimal places.",
      a: "The number pi.",
      m: [0, 0],
      p: []
    }, {
      n: "FLOOR",
      t: 0,
      d: "Rounds a number down to the nearest integer multiple of specified significance `factor`.",
      a: "Rounds number down to nearest multiple of a factor.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round down to the nearest integer multiple of `factor`.",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GCD",
      t: 0,
      d: "Returns the greatest common divisor of one or more integers.",
      a: "Greatest common divisor of one or more integers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range whose factors to consider in a calculation to find the greatest common divisor.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges whose factors to consider to find the greatest common divisor.",
        example: "96",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANDBETWEEN",
      t: 0,
      d: "Returns a uniformly random integer between two values, inclusive.",
      a: "Random integer between two values, inclusive.",
      m: [2, 2],
      p: [{
        name: "low",
        detail: "The low end of the random range.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "high",
        detail: "The high end of the random range.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUND",
      t: 0,
      d: "Rounds a number to a certain number of decimal places according to standard rules.",
      a: "Rounds a number according to standard rules.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDDOWN",
      t: 0,
      d: "Rounds a number to a certain number of decimal places, always rounding down to the next valid increment.",
      a: "Rounds down a number.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places, always rounding down.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDUP",
      t: 0,
      d: "Rounds a number to a certain number of decimal places, always rounding up to the next valid increment.",
      a: "Rounds up a number.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places, always rounding up.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SERIESSUM",
      t: 0,
      d: "Given parameters `x`, `n`, `m`, and `a`, returns the power series sum a",
      a: "Sum of a power series.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the power series. Varies depending on the type of approximation, may be angle, exponent, or some other value.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "The initial power to which to raise `x` in the power series.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "m",
        detail: "The additive increment by which to increase `x`.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "a",
        detail: "The array or range containing the coefficients of the power series.",
        example: "{FACT(0)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIGN",
      t: 0,
      d: "Given an input number, returns `-1` if it is negative, `1` if positive, and `0` if it is zero.",
      a: "Sign of a provided number (+/-/0).",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value whose sign will be evaluated.",
        example: "-42",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIN",
      t: 0,
      d: "Returns the sine of an angle provided in radians.",
      a: "Sine of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the sine of, in radians.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SINH",
      t: 0,
      d: "Returns the hyperbolic sine of any real number.",
      a: "Hyperbolic sine of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic sine of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRT",
      t: 0,
      d: "Returns the positive square root of a positive number.",
      a: "Positive square root of a positive number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number for which to calculate the positive square root.",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRTPI",
      t: 0,
      d: "Returns the positive square root of the product of Pi and the given positive number.",
      a: "Square root of the product of pi and number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number which will be multiplied by Pi and have the product's square root returned",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GAMMALN",
      t: 1,
      d: "Returns the logarithm of a specified Gamma function, base e (Euler's number).",
      a: "Logarithm of gamma function.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The input to the Gamma function. The natural logarithm of Gamma(`value`) will be returned.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COS",
      t: 0,
      d: "Returns the cosine of an angle provided in radians.",
      a: "Cosine of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the cosine of, in radians.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRUNC",
      t: 0,
      d: "Truncates a number to a certain number of significant digits by omitting less significant digits.",
      a: "Truncates a number.",
      m: [1, 2],
      p: [{
        name: "value",
        detail: "The value to be truncated.",
        example: "3.141592654",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of significant digits to the right of the decimal point to retain.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUOTIENT",
      t: 0,
      d: "Returns one number divided by another.",
      a: "One number divided by another.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POWER",
      t: 0,
      d: "Returns a number raised to a power.",
      a: "A number raised to a power.",
      m: [2, 2],
      p: [{
        name: "base",
        detail: "The number to raise to the `exponent` power.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "exponent",
        detail: "The exponent to raise `base` to.",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMIFS",
      t: 0,
      d: "Returns the sum of a range depending on multiple criteria.",
      a: "Sums a range depending on multiple criteria.",
      m: [3, 257],
      p: [{
        name: "sum_range",
        detail: "The range to sum.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criteria_range1",
        detail: "The range to check against criterion1.",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to criteria_range1.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " C1:C10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTIFS",
      t: 1,
      d: "Returns the count of a range depending on multiple criteria.",
      a: "Count values depending on multiple criteria.",
      m: [2, 256],
      p: [{
        name: "criteria_range1",
        detail: "The range to check against `criterion1`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to `criteria_range1`.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " B1:B10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PRODUCT",
      t: 0,
      d: "Returns the result of multiplying a series of numbers together.",
      a: "Result of multiplying a series of numbers together.",
      m: [1, 255],
      p: [{
        name: "factor1",
        detail: "The first number or range to calculate for the product.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor2",
        detail: "More numbers or ranges to calculate for the product.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HARMEAN",
      t: 1,
      d: "Calculates the harmonic mean of a dataset.",
      a: "The harmonic mean of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HYPGEOMDIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of successes in a certain number of tries given a population of a certain size containing a certain number of successes, without replacement of draws.",
      a: "Hypergeometric distribution probability.",
      m: [5, 5],
      p: [{
        name: "num_successes",
        detail: "The desired number of successes.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_draws",
        detail: "The number of permitted draws.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "successes_in_pop",
        detail: "The total number of successes in the population.",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pop_size",
        detail: "The total size of the population",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf cumulative is TRUE(), HYPGEOM.DIST returns the cumulative distribution function;\n\nif FALSE(), it returns the probability density function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INTERCEPT",
      t: 1,
      d: "Calculates the y-value at which the line resulting from linear regression of a dataset will intersect the y-axis (x=0).",
      a: "Y-intercept of line derived via linear regression.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "KURT",
      t: 1,
      d: 'Calculates the kurtosis of a dataset, which describes the shape, and in particular the "peakedness" of that dataset.',
      a: "Kurtosis of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LARGE",
      t: 1,
      d: "Returns the nth largest element from a data set, where n is user-defined.",
      a: "Nth largest element from a data set.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "The rank from largest to smallest of the element to return.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVA",
      t: 1,
      d: "Calculates the standard deviation based on a sample, setting text to the value `0`.",
      a: "Standard deviation of sample (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVP",
      t: 1,
      d: "Calculates the standard deviation based on an entire population.",
      a: "Standard deviation of an entire population.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "GEOMEAN",
      t: 1,
      d: "Calculates the geometric mean of a dataset.",
      a: "The geometric mean of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANK_EQ",
      t: 1,
      d: "Returns the rank of a specified value in a dataset. If there is more than one entry of the same value in the dataset, the top rank of the entries will be returned.",
      a: "Top rank of a specified value in a dataset.",
      m: [2, 3],
      p: [{
        name: "value",
        detail: "The value whose rank will be determined.",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "is_ascending",
        detail: "Whether to consider the values in `data` in descending or ascending order. If omitted, the default is descending (FALSE).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANK_AVG",
      t: 1,
      d: "Returns the rank of a specified value in a dataset. If there is more than one entry of the same value in the dataset, the average rank of the entries will be returned.",
      a: "Average rank of a specified value in a dataset.",
      m: [2, 3],
      p: [{
        name: "value",
        detail: "The value whose rank will be determined.",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "is_ascending",
        detail: "Whether to consider the values in `data` in descending or ascending order. If omitted, the default is descending (FALSE).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERCENTRANK_EXC",
      t: 1,
      d: "Returns the percentage rank (percentile) from 0 to 1 exclusive of a specified value in a dataset.",
      a: "Percentage rank (percentile) from 0 to 1 exclusive.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value",
        detail: "The value whose percentage rank will be determined.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant figures to use in the calculation. Default is 3.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTRANK_INC",
      t: 1,
      d: "Returns the percentage rank (percentile) from 0 to 1 inclusive of a specified value in a dataset.",
      a: "Percentage rank (percentile) from 0 to 1 inclusive.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value",
        detail: "The value whose percentage rank will be determined.",
        example: " A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant figures to use in the calculation. Default is 3.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FORECAST",
      t: 1,
      d: "Calculates the expected y-value for a specified x based on a linear regression of a dataset.",
      a: "Expected y-value based of linear regression.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The value on the x-axis to forecast.",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHERINV",
      t: 1,
      d: "Returns the inverse Fisher transformation of a specified value.",
      a: "Inverse fisher transformation of a specified value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse Fisher transformation.",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHER",
      t: 1,
      d: "Returns the Fisher transformation of a specified value.",
      a: "Fisher transformation of a specified value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the Fisher transformation.",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MODE_SNGL",
      t: 1,
      d: "Returns the most commonly occurring value in a dataset.",
      a: "Most commonly occurring value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating mode.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating mode.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "WEIBULL_DIST",
      t: 1,
      d: "Returns the value of the Weibull distribution function (or Weibull cumulative distribution function) for a specified shape and scale.",
      a: "Weibull distribution function.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the Weibull distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "shape",
        detail: "The shape parameter of the Weibull distribution function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "scale",
        detail: "The scale parameter of the Weibull distribution function.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the cumulative distribution function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COUNT",
      t: 1,
      d: "Returns the number of numeric values in a dataset.",
      a: "The number of numeric values in dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when counting.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when counting.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTA",
      t: 1,
      d: "Returns the number of values in a dataset.",
      a: "The number of values in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when counting.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when counting.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVEDEV",
      t: 1,
      d: "Calculates the average of the magnitudes of deviations of data from a dataset's mean.",
      a: "Average magnitude of deviations from mean.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "AVERAGE",
      t: 1,
      d: "Returns the numerical average value in a dataset, ignoring text.",
      a: "Numerical average value in a dataset, ignoring text.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the average value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the average value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEA",
      t: 1,
      d: "Returns the numerical average value in a dataset.",
      a: "Numerical average value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the average value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the average value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_DIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of successes (or a maximum number of successes) in a certain number of tries given a population of a certain size containing a certain number of successes, with replacement of draws.",
      a: "Binomial distribution probability.",
      m: [4, 4],
      p: [{
        name: "num_successes",
        detail: "The number of successes for which to calculate the probability in `num_trials` trials.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_trials",
        detail: "The number of independent trials.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the binomial cumulative distribution.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_INV",
      t: 1,
      d: "Calculates the smallest value for which the cumulative binomial distribution is greater than or equal to a specified criteria.",
      a: "Inverse cumulative binomial distribution function.",
      m: [3, 3],
      p: [{
        name: "num_trials",
        detail: "The number of independent trials.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "target_prob",
        detail: "The desired threshold probability.",
        example: "0.8",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONFIDENCE_NORM",
      t: 1,
      d: "Calculates the width of half the confidence interval for a normal distribution.",
      a: "Confidence interval for a normal distribution.",
      m: [3, 3],
      p: [{
        name: "alpha",
        detail: "One minus the desired confidence level. E.g. `0.1` for `0.9`, or 90%, confidence.",
        example: "0.05",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation of the population.",
        example: "1.6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pop_size",
        detail: "The size of the population.",
        example: "250",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CORREL",
      t: 1,
      d: "Calculates r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Pearson Product-Moment Correlation Coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_P",
      t: 1,
      d: "Calculates the covariance of a dataset.",
      a: "The covariance of a dataset.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_S",
      t: 1,
      d: "Calculates the sample covariance of a dataset.",
      a: "The sample covariance of a dataset.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEVSQ",
      t: 1,
      d: "Calculates the sum of squares of deviations based on a sample.",
      a: "The sum of squares of deviations based on a sample.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "EXPON_DIST",
      t: 1,
      d: "Returns the value of the exponential distribution function with a specified lambda at a specified value.",
      a: "Exponential distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the exponential distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "lambda",
        detail: "The lambda to specify the exponential distribution function.",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the exponential cumulative distribution.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIF",
      t: 1,
      d: "Returns the average of a range depending on criteria.",
      a: "Average of values depending on criteria.",
      m: [2, 3],
      p: [{
        name: "criteria_range",
        detail: "The range to check against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `criteria_range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "average_range",
        detail: "The range to average. If not included, `criteria_range` is used for the average instead.",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIFS",
      t: 1,
      d: "Returns the average of a range depending on multiple criteria.",
      a: "Average of values depending on multiple criteria.",
      m: [2, 255],
      p: [{
        name: "average_range",
        detail: "The range to average.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range1",
        detail: "The range to check against `criterion1`.",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to `criteria_range1`.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " C1:C10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERMUT",
      t: 1,
      d: "Returns the number of ways to choose some number of objects from a pool of a given size of objects, considering order.",
      a: "Number of permutations from a number of objects.",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "The size of the pool of objects to choose from.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "The number of objects to choose.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRIMMEAN",
      t: 1,
      d: "Calculates the mean of a dataset excluding some proportion of data from the high and low ends of the dataset.",
      a: "Mean of a dataset excluding high/low ends.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "exclude_proportion",
        detail: "The proportion of the dataset to exclude, from the extremities of the set.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_EXC",
      t: 1,
      d: "Returns the value at a given percentile of a dataset exclusive of 0 and 1.",
      a: "Value at a given percentile of a dataset exclusive of 0 and 1.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "percentile",
        detail: "The percentile, exclusive of 0 and 1, whose value within 'data' will be calculated and returned.",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_INC",
      t: 1,
      d: "Returns the value at a given percentile of a dataset.",
      a: "Value at a given percentile of a dataset.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "percentile",
        detail: "The percentile whose value within `data` will be calculated and returned.`",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PEARSON",
      t: 1,
      d: "Calculates r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Pearson Product-Moment Correlation Coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_INV",
      t: 1,
      d: "Returns the value of the inverse standard normal distribution function for a specified value.",
      a: "Inverse standard normal distribution function.",
      m: [1, 1],
      p: [{
        name: "x",
        detail: "The input to the inverse standard normal distribution function.",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_DIST",
      t: 1,
      d: "Returns the value of the standard normal cumulative distribution function for a specified value.",
      a: "Standard normal cumulative distribution function.",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the standard normal cumulative distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NORM_INV",
      t: 1,
      d: "Returns the value of the inverse normal distribution function for a specified value, mean, and standard deviation.",
      a: "Inverse normal distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the inverse normal distribution function.",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the normal distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the normal distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_DIST",
      t: 1,
      d: "Returns the value of the normal distribution function (or normal cumulative distribution function) for a specified value, mean, and standard deviation.",
      a: "Normal distribution function.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the normal distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the normal distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the normal distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the normal cumulative distribution function rather than the distribution function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NEGBINOM_DIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of failures before a certain number of successes given a probability of success in independent trials.",
      a: "Negative binomial distribution probability.",
      m: [4, 4],
      p: [{
        name: "num_failures",
        detail: "The number of failures to model.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_successes",
        detail: "The number of successes to model.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINA",
      t: 1,
      d: "Returns the minimum numeric value in a dataset.",
      a: "Minimum numeric value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the minimum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the minimum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MIN",
      t: 1,
      d: "Returns the minimum value in a numeric dataset.",
      a: "Minimum value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the minimum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the minimum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MEDIAN",
      t: 1,
      d: "Returns the median value in a numeric dataset.",
      a: "Median value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the median value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the median value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAXA",
      t: 1,
      d: "Returns the maximum numeric value in a dataset.",
      a: "Maximum numeric value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the maximum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the maximum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAX",
      t: 1,
      d: "Returns the maximum value in a numeric dataset.",
      a: "Maximum value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the maximum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the maximum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_INV",
      t: 1,
      d: "Returns the value of the inverse log-normal cumulative distribution with given mean and standard deviation at a specified value.",
      a: "Inverse log-normal cumulative distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the inverse log-normal cumulative distribution function.",
        example: "0.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the inverse log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the inverse log-normal cumulative distribution function.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_DIST",
      t: 1,
      d: "Returns the value of the log-normal cumulative distribution with given mean and standard deviation at a specified value.",
      a: "Log-normal cumulative distribution probability.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the log-normal cumulative distribution function.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "Z_TEST",
      t: 1,
      d: "Returns the one-tailed p-value of a Z-test with standard distribution.",
      a: "One-tailed p-value of a z-test.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "value",
        detail: "The test statistic to use in the Z-test.",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation to assume for the Z-test. If this is not provided, the standard deviation of the data will be used.",
        example: "3",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PROB",
      t: 1,
      d: "Given a set of values and corresponding probabilities, calculates the probability that a value chosen at random falls between two limits.",
      a: "Probability values lie in a range.",
      m: [3, 4],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A3:A6",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "probabilities",
        detail: "Array or range containing probabilities corresponding to `data`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "low_limit",
        detail: "The lower bound on the value range for which to calculate the probability.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "high_limit",
        detail: "The upper bound on the value range for which to calculate the probability.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_EXC",
      t: 1,
      d: "Returns a value nearest to a specified quartile of a dataset exclusive of 0 and 4.",
      a: "Value nearest to a specific quartile of a dataset exclusive of 0 and 4.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quartile_number",
        detail: "Which quartile to return.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_INC",
      t: 1,
      d: "Returns a value nearest to a specified quartile of a dataset.",
      a: "Value nearest to a specific quartile of a dataset.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quartile_number",
        detail: "Which quartile value to return.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POISSON_DIST",
      t: 1,
      d: "Returns the value of the Poisson distribution function (or Poisson cumulative distribution function) for a specified value and mean.",
      a: "Poisson distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the Poisson distribution function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the Poisson distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the Poisson cumulative distribution function rather than the distribution function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RSQ",
      t: 1,
      d: "Calculates the square of r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Square of the correlation coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST",
      t: 1,
      d: "Calculates the left tail probability for a Student's t-distribution with a given input (x).",
      a: "The left-tailed Student's t-distribution",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "If cumulative is TRUE, T.DIST returns the cumulative distribution function; if FALSE, it returns the probability density function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T_DIST_2T",
      t: 1,
      d: "Calculates the probability for two tailed Student's t-distribution with a given input (x).",
      a: "The two tailed Student's t-distribution",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST_RT",
      t: 1,
      d: "Calculates the right tail probability for a Student's t-distribution with a given input (x).",
      a: "The right-tailed Student's t-distribution",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV",
      t: 1,
      d: "Calculates the negative inverse of the one-tailed TDIST function.",
      a: "T.INV",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "The probability associated with the two-tailed t-distribution.",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV_2T",
      t: 1,
      d: "Calculates the inverse of the two-tailed TDIST function.",
      a: "T.INV.2T",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "The probability associated with the two-tailed t-distribution.",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_TEST",
      t: 1,
      d: "t-test. Returns the probability associated with Student's t-test. Determines whether two samples are likely to have come from the same two underlying populations that have the same mean.",
      a: "Returns the probability associated with t-test.",
      m: [4, 4],
      p: [{
        name: "range1",
        detail: "The first sample of data or group of cells to consider for the t-test.",
        example: "A1:A4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "range2",
        detail: "The second sample of data or group of cells to consider for the t-test.",
        example: "B1:B4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "Specifies the number of distribution tails.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "Specifies the type of t-test.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "F_DIST",
      t: 1,
      d: "Calculates the left-tailed F probability distribution (degree of diversity) for two data sets with given input x. Alternately called Fisher-Snedecor distribution or Snedecor's F distribution.",
      a: "F probability distribution (left-tailed).",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the F probability distribution function. The value at which to evaluate the function.",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "The numerator of the number of degrees of freedom.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "The denominator of the number of degrees of freedom.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Logical value that determines the form of the function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "F_DIST_RT",
      t: 1,
      d: "Calculates the right-tailed F probability distribution (degree of diversity) for two data sets with given input x. Alternately called Fisher-Snedecor distribution or Snedecor's F distribution.",
      a: "F probability distribution.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the F probability distribution function. The value at which to evaluate the function.",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "The numerator of the number of degrees of freedom.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "The denominator of the number of degrees of freedom.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_P",
      t: 1,
      d: "Calculates the variance based on an entire population.",
      a: "Variance of entire population.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_S",
      t: 1,
      d: "Calculates the variance based on a sample.",
      a: "Variance.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARA",
      t: 1,
      d: "Calculates the variance based on a sample, setting text to the value `0`.",
      a: "Variance of sample (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARPA",
      t: 1,
      d: "Calculates the variance based on an entire population, setting text to the value `0`.",
      a: "Variance of entire population (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STEYX",
      t: 1,
      d: "Calculates the standard error of the predicted y-value for each x in the regression of a dataset.",
      a: "Standard error of predicted y-values in regression.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STANDARDIZE",
      t: 1,
      d: "Calculates the normalized equivalent of a random variable given mean and standard deviation of the distribution.",
      a: "Normalized equivalent of a random variable.",
      m: [3, 3],
      p: [{
        name: "value",
        detail: "The value of the random variable to normalize.",
        example: "96",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean of the distribution.",
        example: "80",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation of the distribution.",
        example: "6.7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SMALL",
      t: 1,
      d: "Returns the nth smallest element from a data set, where n is user-defined.",
      a: "Nth smallest element in a data set.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "n",
        detail: "The rank from smallest to largest of the element to return.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLOPE",
      t: 1,
      d: "Calculates the slope of the line resulting from linear regression of a dataset.",
      a: "Slope of line from linear regression of data.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SKEW",
      t: 1,
      d: "Calculates the skewness of a dataset, which describes the symmetry of that dataset about the mean.",
      a: "Skewness of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SKEW_P",
      t: 1,
      d: "Calculates the skewness of a dataset, which describes the symmetry of that dataset about the mean. This assumes the dataset is for the population.",
      a: "Skewness of a population's dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "VLOOKUP",
      t: 2,
      d: "Vertical lookup. Searches down the first column of a range for a key and returns the value of a specified cell in the row found.",
      a: "Vertical lookup.",
      m: [3, 4],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The range to consider for the search. The first column in the range is searched for the key specified in `search_key`.",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "index",
        detail: "The column index of the value to be returned, where the first column in `range` is numbered 1.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_sorted",
        detail: "Indicates whether the column to be searched (the first column of the specified range) is sorted, in which case the closest match for `search_key` will be returned.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HLOOKUP",
      t: 2,
      d: "Horizontal lookup. Searches across the first row of a range for a key and returns the value of a specified cell in the column found.",
      a: "Horizontal lookup",
      m: [3, 4],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The range to consider for the search. The first row in the range is searched for the key specified in `search_key`.",
        example: "A2:Z6",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "index",
        detail: "The row index of the value to be returned, where the first row in `range` is numbered 1.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_sorted",
        detail: "Indicates whether the row to be searched (the first row of the specified range) is sorted.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOOKUP",
      t: 2,
      d: "Looks through a sorted row or column for a key and returns the value of the cell in a result range located in the same position as the search row or column.",
      a: "Look up a value.",
      m: [2, 3],
      p: [{
        name: "search_key",
        detail: 'The value to search for in the row or column. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "search_range|search_result_array",
        detail: "One method of using this function is to provide a single sorted row or column `search_range` to look through for the `search_key` with a second argument `result_range`. The other way is to combine these two arguments into one `search_result_array` where the first row or column is searched and a value is returned from the last row or column in the array. If `search_key` is not found, a non-exact match may be returned.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "result_range",
        detail: "The range from which to return a result. The value returned corresponds to the location where `search_key` is found in `search_range`. This range must be only a single row or column and should not be used if using the `search_result_array` method.",
        example: "B1:B100",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADDRESS",
      t: 2,
      d: "Returns a cell reference as a string.",
      a: "Cell reference as a string.",
      m: [2, 5],
      p: [{
        name: "row",
        detail: "The row number of the cell reference",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column",
        detail: "The column number (not name) of the cell reference. `A` is column number `1`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "absolute_relative_mode",
        detail: "An indicator of whether the reference is row/column absolute. `1` is row and column absolute (e.g. $A$1), `2` is row absolute and column relative (e.g. A$1), `3` is row relative and column absolute (e.g. $A1), and `4` is row and column relative (e.g. A1).",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "use_a1_notation",
        detail: "A boolean indicating whether to use `A1` style notation (TRUE) or `R1C1` style notation (FALSE).",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sheet",
        detail: "Text indicating the name of the sheet into which the address points.",
        example: '"Sheet2"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INDIRECT",
      t: 2,
      d: "Returns a cell reference specified by a string.",
      a: "A cell reference specified by a string.",
      m: [1, 2],
      p: [{
        name: "cell_reference_as_string",
        detail: "A cell reference, written as a string with surrounding quotation marks.",
        example: '"Sheet2!"&B10',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "is_A1_notation",
        detail: "Indicates if the cell reference is in A1 notation (TRUE) or R1C1 notation (FALSE).",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROW",
      t: 2,
      d: "Returns the row number of a specified cell.",
      a: "Row number of a specified cell.",
      m: [0, 1],
      p: [{
        name: "cell_reference",
        detail: "The cell whose row number will be returned.",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROWS",
      t: 2,
      d: "Returns the number of rows in a specified array or range.",
      a: "Number of rows in a specified array or range.",
      m: [1, 1],
      p: [{
        name: "range",
        detail: "The range whose row count will be returned.",
        example: "A9:A62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COLUMN",
      t: 2,
      d: "Returns the column number of a specified cell, with `A=1`.",
      a: "Column number of a specified cell.",
      m: [0, 1],
      p: [{
        name: "cell_reference",
        detail: "The cell whose column number will be returned. Column `A` corresponds to `1`.",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNS",
      t: 2,
      d: "Returns the number of columns in a specified array or range.",
      a: "Number of columns in a specified array or range.",
      m: [1, 1],
      p: [{
        name: "range",
        detail: "The range whose column count will be returned.",
        example: "A9:W62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OFFSET",
      t: 2,
      d: "Returns a range reference shifted a specified number of rows and columns from a starting cell reference.",
      a: "A range reference offset relative to a cell.",
      m: [3, 5],
      p: [{
        name: "cell_reference",
        detail: "The starting point from which to count the offset rows and columns.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "offset_rows",
        detail: "The number of rows to offset by.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "offset_columns",
        detail: "The number of columns to offset by.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "height",
        detail: "The height of the range to return starting at the offset target.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "width",
        detail: "The width of the range to return starting at the offset target.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MATCH",
      t: 2,
      d: "Returns the relative position of an item in a range that matches a specified value.",
      a: "Position of item in range that matches value.",
      m: [2, 3],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: '"Sunday"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The one-dimensional array to be searched.",
        example: "A2:A9",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "search_type",
        detail: "The search method. `1` (default) finds the largest value less than or equal to `search_key` when `range` is sorted in ascending order. `0` finds the exact value when `range` is unsorted. `-1` finds the smallest value greater than or equal to `search_key` when `range` is sorted in descending order.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INDEX",
      t: 2,
      d: "Returns the content of a cell, specified by row and column offset.",
      a: "Content of cell specified by row and column offset.",
      m: [2, 3],
      p: [{
        name: "reference",
        detail: "The array of cells to be offset into.",
        example: "A1:C20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "row",
        detail: "The number of offset rows.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column",
        detail: "The number of offset columns.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GETPIVOTDATA",
      t: 2,
      d: "Extracts an aggregated value from a pivot table that corresponds to the specified row and column headings.",
      a: "Extracts an aggregated value from a pivot table that corresponds to the specified row and column headings.",
      m: [2, 254],
      p: [{
        name: "value_name",
        detail: "The name of the value in the pivot table for which you want to get data.",
        example: '"SUM of number of units"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "any_pivot_table_cell",
        detail: "Any reference to a cell in the desired pivot table (top corner recommended).",
        example: "'Pivot table'!A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "original_column",
        detail: "The name of the column in the original data set (not the pivot table).",
        example: '"division"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }, {
        name: "pivot_item",
        detail: "The name of the row or column shown in the pivot table corresponding to *original_column* that you want to retrieve.",
        example: '"east"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CHOOSE",
      t: 2,
      d: "Returns an element from a list of choices based on index.",
      a: "An element from a list of choices based on index.",
      m: [2, 255],
      p: [{
        name: "index",
        detail: "Which choice (of the up to 30 provided) to return.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "choice1",
        detail: "A potential value to return. Required. May be a reference to a cell or an individual value.",
        example: '"A"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "choice2",
        detail: "Additional values among which to choose.",
        example: '"B"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "HYPERLINK",
      t: 2,
      d: "Creates a hyperlink inside a cell.",
      a: "Creates a hyperlink inside a cell.",
      p: [{
        name: "url",
        detail: "The full URL of the link location enclosed in quotation marks, or a reference to a cell containing such a URL.",
        example: '"http://www.luckysheet.com/"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "link_label",
        detail: "The text to display in the cell as the link, enclosed in quotation marks, or a reference to a cell containing such a label.",
        example: '"luckysheet"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TIME",
      t: 6,
      d: "Converts a provided hour, minute, and second into a time.",
      a: "Converts hour/minute/second into a time.",
      m: [3, 3],
      p: [{
        name: "hour",
        detail: "The hour component of the time.",
        example: "11",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "minute",
        detail: "The minute component of the time.",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "second",
        detail: "The second component of the time.",
        example: "59",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TIMEVALUE",
      t: 6,
      d: "Returns the fraction of a 24-hour day the time represents.",
      a: "Converts a time string into its serial number representation.",
      m: [1, 1],
      p: [{
        name: "time_string",
        detail: "The string that holds the time representation.",
        example: '"2:15 PM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EOMONTH",
      t: 6,
      d: "Returns a date on the last day of a month that falls a specified number of months before or after another date.",
      a: "Last day of a month before or after a date.",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "The date from which to calculate the result.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "The number of months before (negative) or after (positive) 'start_date' to consider.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EDATE",
      t: 6,
      d: "Returns a date a specified number of months before or after another date.",
      a: "Date a number of months before/after another date.",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "The date from which to calculate the result.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "The number of months before (negative) or after (positive) 'start_date' to calculate.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SECOND",
      t: 6,
      d: "Returns the second component of a specific time, in numeric format.",
      a: "Second component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the second component",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINUTE",
      t: 6,
      d: "Returns the minute component of a specific time, in numeric format.",
      a: "Minute component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the minute component.",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HOUR",
      t: 6,
      d: "Returns the hour component of a specific time, in numeric format.",
      a: "Hour component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the hour component.",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOW",
      t: 6,
      d: "Returns the current date and time as a date value.",
      a: "Current date and time as a date value.",
      m: [0, 0],
      p: []
    }, {
      n: "NETWORKDAYS",
      t: 6,
      d: "Returns the number of net working days between two provided days.",
      a: "Net working days between two provided days.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date of the period from which to calculate the number of net working days.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date of the period from which to calculate the number of net working days.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the date serial numbers to consider holidays.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NETWORKDAYS_INTL",
      t: 6,
      d: "Returns the number of net working days between two provided days excluding specified weekend days and holidays.",
      a: "Net working days between two dates (specifying weekends).",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "The start date of the period from which to calculate the number of net working days.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date of the period from which to calculate the number of net working days.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "weekend",
        detail: "A number or string representing which days of the week are considered weekends.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider as holidays.",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISOWEEKNUM",
      t: 6,
      d: "Returns a number representing the ISO week of the year where the provided date falls.",
      a: "ISO week number of the year.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date for which to determine the ISO week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WEEKNUM",
      t: 6,
      d: "Returns a number representing the week of the year where the provided date falls.",
      a: "Week number of the year.",
      m: [1, 2],
      p: [{
        name: "date",
        detail: "The date for which to determine the week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "type",
        detail: "A number representing the day that a week starts on. Sunday = 1.",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "WEEKDAY",
      t: 6,
      d: "Returns a number representing the day of the week of the date provided.",
      a: "Day of the week of the date provided (as number).",
      m: [1, 2],
      p: [{
        name: "date",
        detail: "The date for which to determine the day of the week. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "type",
        detail: "A number indicating which numbering system to use to represent weekdays. By default, counts starting with Sunday = 1.",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DAY",
      t: 6,
      d: "Returns the day of the month that a specific date falls on, in numeric format.",
      a: "Day of the month that a specific date falls on.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the day.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS",
      t: 6,
      d: "Returns the number of days between two dates.",
      a: "Number of days between two dates.",
      m: [2, 2],
      p: [{
        name: "end_date",
        detail: "The end of the date range.",
        example: "2011-3-15",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_date",
        detail: "The start of the date range.",
        example: "2011-2-1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS360",
      t: 6,
      d: "Returns the difference between two days based on the 360 day year used in some financial interest calculations.",
      a: "Days between two dates on a 360-day year.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "method",
        detail: "An indicator of what day count method to use.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATE",
      t: 6,
      d: "Converts a provided year, month, and day into a date.",
      a: "Converts year/month/day into a date.",
      m: [3, 3],
      p: [{
        name: "year",
        detail: "The year component of the date.",
        example: "1969",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "The month component of the date.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day",
        detail: "The day component of the date.",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATEVALUE",
      t: 6,
      d: "Converts a provided date string in a known format to a date value.",
      a: "Converts a date string to a date value.",
      m: [1, 1],
      p: [{
        name: "date_string",
        detail: "The string representing the date.",
        example: '"1969-7-20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATEDIF",
      t: 6,
      d: "Calculates the number of days, months, or years between two dates.",
      a: "Date Difference.",
      m: [3, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "unit",
        detail: 'A string abbreviation for unit of time. For example, "M" for month. Accepted values are "Y","M","D","MD","YM","YD".',
        example: "16)",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY",
      t: 6,
      d: "Calculates the date after a number of working days from a specified start date.",
      a: "Number of working days from start date.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The date from which to begin counting.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_days",
        detail: "The number of working days to advance from `start_date`. If negative, counts backwards.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider holidays.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY_INTL",
      t: 6,
      d: "Calculates the date after a specified number of workdays excluding specified weekend days and holidays.",
      a: "Date after a number of workdays (specifying weekends).",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "The date from which to begin counting.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_days",
        detail: "The number of working days to advance from `start_date`. If negative, counts backwards.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "weekend",
        detail: "A number or string representing which days of the week are considered weekends.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider holidays.",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEAR",
      t: 6,
      d: "Returns the year specified by a given date.",
      a: "Year specified by a given date.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the year.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEARFRAC",
      t: 6,
      d: "Returns the number of years, including fractional years, between two dates using a specified day count convention.",
      a: "Exact number of years between two dates.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TODAY",
      t: 6,
      d: "Returns the current date as a date value.",
      a: "Current date as a date value.",
      m: [0, 0],
      p: []
    }, {
      n: "MONTH",
      t: 6,
      d: "Returns the month of the year a specific date falls in, in numeric format.",
      a: "Month of the year a specific date falls in.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the month.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EFFECT",
      t: 8,
      d: "Calculates the annual effective interest rate given the nominal rate and number of compounding periods per year.",
      a: "Annual effective interest rate.",
      m: [2, 2],
      p: [{
        name: "nominal_rate",
        detail: "The nominal interest rate per year.",
        example: "0.99",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "periods_per_year",
        detail: "The number of compounding periods per year.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLAR",
      t: 12,
      d: "Formats a number into the currency specific to your spreadsheet locale.",
      a: "Formats a number as currency specific to your spreadsheet locale.",
      m: [1, 2],
      p: [{
        name: "number",
        detail: "The value to be formatted.",
        example: "1.2351",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_places",
        detail: "The number of decimal places to display.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARDE",
      t: 8,
      d: "Converts a price quotation given as a decimal fraction into a decimal value.",
      a: "Converts a decimal fraction to decimal value.",
      m: [2, 2],
      p: [{
        name: "fractional_price",
        detail: "The price quotation given using fractional decimal conventions.",
        example: "100.10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "unit",
        detail: "The units of the fraction, e.g. `8` for 1/8ths or `32` for 1/32nds.",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARFR",
      t: 8,
      d: "Converts a price quotation given as a decimal value into a decimal fraction.",
      a: "Converts a decimal value to decimal fraction.",
      m: [2, 2],
      p: [{
        name: "decimal_price",
        detail: "The price quotation given as a decimal value.",
        example: "100.125",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "unit",
        detail: "The units of the desired fraction, e.g. `8` for 1/8ths or `32` for 1/32nds.",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DB",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the arithmetic declining balance method.",
      a: "Depreciation via declining balance method.",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "The number of months in the first year of depreciation.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DDB",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the double-declining balance method.",
      a: "Depreciation via double-declining balance method.",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The factor by which depreciation decreases.",
        example: "2.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RATE",
      t: 8,
      d: "Calculates the interest rate of an annuity investment based on constant-amount periodic payments and the assumption of a constant interest rate.",
      a: "Interest rate of an annuity investment.",
      m: [3, 6],
      p: [{
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_per_period",
        detail: "The amount per period to be paid.",
        example: "-100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the interest rate will be.",
        example: "0.1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CUMPRINC",
      t: 8,
      d: "Calculates the cumulative principal paid over a range of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Cumulative principal paid over a set of periods.",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "first_period",
        detail: "The number of the payment period to begin the cumulative calculation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "last_period",
        detail: "The number of the payment period to end the cumulative calculation.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNUM",
      t: 8,
      d: "Calculates the number of coupons, or interest payments, between the settlement date and the maturity date of the investment.",
      a: "Number of coupons between settlement and maturity.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "02",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SYD",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the sum of years digits method.",
      a: "Depreciation via sum of years digits method.",
      m: [4, 4],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLEQ",
      t: 8,
      d: "Calculates the equivalent annualized rate of return of a US Treasury Bill based on discount rate.",
      a: "Equivalent rate of return for a Treasury bill.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the bill at time of purchase.",
        example: "2)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLYIELD",
      t: 8,
      d: "Calculates the yield of a US Treasury Bill based on price.",
      a: "The yield of a us treasury bill based on price.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLPRICE",
      t: 8,
      d: "Calculates the price of a US Treasury Bill based on discount rate.",
      a: "Price of US treasury bill.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the bill at time of purchase.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PV",
      t: 8,
      d: "Calculates the present value of an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Present value of an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount per period to be paid.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "D2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACCRINT",
      t: 8,
      d: "Calculates the accrued interest of a security that has periodic payments.",
      a: "Accrued interest of security with periodic payments.",
      m: [6, 8],
      p: [{
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "first_payment",
        detail: "The first date interest will be paid.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calc_method",
        detail: "[Optional-defaults to TRUE()] - A logical value that specifies the method used to calculate the total accrued interest when the settlement date is later than the first interest accrual date. \n\nIf the value is TRUE, the total accrued interest from the issue date to the settlement date is returned. \n\nIf the value is FALSE, return the accrued interest from the first interest accrual date to the settlement date.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ACCRINTM",
      t: 8,
      d: "Calculates the accrued interest of a security that pays interest at maturity.",
      a: "Accrued interest of security paying at maturity.",
      m: [4, 5],
      p: [{
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity date of the security.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "1000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYBS",
      t: 8,
      d: "Calculates the number of days from the first coupon, or interest payment, until settlement.",
      a: "Number of days from first coupon to settlement.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYS",
      t: 8,
      d: "Calculates the number of days in the coupon, or interest payment, period that contains the specified settlement date.",
      a: "Days in coupon period containing settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYSNC",
      t: 8,
      d: "Calculates the number of days from the settlement date until the next coupon, or interest payment.",
      a: "Days from settlement until next coupon.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNCD",
      t: 8,
      d: "Calculates next coupon, or interest payment, date after the settlement date.",
      a: "Next coupon date after the settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPPCD",
      t: 8,
      d: "Calculates last coupon, or interest payment, date before the settlement date.",
      a: "Last coupon date before settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FV",
      t: 8,
      d: "Calculates the future value of an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Future value of an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount per period to be paid.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FVSCHEDULE",
      t: 8,
      d: "Calculates the future value of some principal based on a specified series of potentially varying interest rates.",
      a: "Future value of principal from series of rates.",
      m: [2, 2],
      p: [{
        name: "principal",
        detail: "The amount of initial capital or value to compound against.",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "rate_schedule",
        detail: "A series of interest rates to compound against the `principal`.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "YIELD",
      t: 8,
      d: "Calculates the annual yield of a security paying periodic interest, such as a US Treasury Bond, based on price.",
      a: "Annual yield of a security paying periodic interest.",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "YIELDDISC",
      t: 8,
      d: "Calculates the annual yield of a discount (non-interest-bearing) security, based on price.",
      a: "Annual yield of a discount security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NOMINAL",
      t: 8,
      d: "Calculates the annual nominal interest rate given the effective rate and number of compounding periods per year.",
      a: "Annual nominal interest rate.",
      m: [2, 2],
      p: [{
        name: "effective_rate",
        detail: "The effective interest rate per year.",
        example: "0.85",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "periods_per_year",
        detail: "The number of compounding periods per year.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "XIRR",
      t: 8,
      d: "Calculates the internal rate of return of an investment based on a specified series of potentially irregularly spaced cash flows.",
      a: "Internal rate of return given non-periodic cashflows.",
      m: [2, 3],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "cashflow_dates",
        detail: "An array or range with dates corresponding to the cash flows in `cashflow_amounts`.",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the internal rate of return will be.",
        example: "250",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MIRR",
      t: 8,
      d: "Calculates the modified internal rate of return on an investment based on a series of periodic cash flows and the difference between the interest rate paid on financing versus the return received on reinvested income.",
      a: "Modified internal rate of return.",
      m: [3, 3],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "financing_rate",
        detail: "The interest rate paid on funds invested.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "reinvestment_return_rate",
        detail: "The return (as a percentage) earned on reinvestment of income received from the investment.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IRR",
      t: 8,
      d: "Calculates the internal rate of return on an investment based on a series of periodic cash flows.",
      a: "Internal rate of return given periodic cashflows.",
      m: [1, 2],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the internal rate of return will be.",
        example: "200",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPV",
      t: 8,
      d: "Calculates the net present value of an investment based on a series of periodic cash flows and a discount rate.",
      a: "The net present value of an investment based on a series of periodic cash flows and a discount rate.",
      m: [2, 255],
      p: [{
        name: "discount",
        detail: "The discount rate of the investment over one period.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cashflow1",
        detail: "The first future cash flow.",
        example: "200",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "cashflow2",
        detail: "Additional future cash flows.",
        example: "250",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "XNPV",
      t: 8,
      d: "Calculates the net present value of an investment based on a specified series of potentially irregularly spaced cash flows and a discount rate.",
      a: "Net present value given non-periodic cashflows.",
      m: [3, 3],
      p: [{
        name: "discount",
        detail: "The discount rate of the investment over one period.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cashflow_amounts",
        detail: "A range of cells containing the income or payments associated with the investment.",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "cashflow_dates",
        detail: "A range of cells with dates corresponding to the cash flows in `cashflow_amounts`.",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CUMIPMT",
      t: 8,
      d: "Calculates the cumulative interest over a range of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Cumulative interest paid over a set of periods.",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "first_period",
        detail: "The number of the payment period to begin the cumulative calculation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "last_period",
        detail: "The number of the payment period to end the cumulative calculation.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PMT",
      t: 8,
      d: "Calculates the periodic payment for an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Periodic payment for an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: " 100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "D2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IPMT",
      t: 8,
      d: "Calculates the payment on interest for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Payment on interest for an investment.",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The amortization period, in terms of number of periods.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "80000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "E2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PPMT",
      t: 8,
      d: "Calculates the payment on the principal of an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Payment on the principal of an investment.",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The amortization period, in terms of number of periods.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "3*12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INTRATE",
      t: 8,
      d: "Calculates the effective interest rate generated when an investment is purchased at one price and sold at another with no interest or dividends generated by the investment itself.",
      a: "Calculates effective interest rate.",
      m: [4, 5],
      p: [{
        name: "buy_date",
        detail: "The date of purchase of the investment.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sell_date",
        detail: "The date of sale of the investment.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "buy_price",
        detail: "The price at which the investment was purchased.",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sell_price",
        detail: "The price at which the investment was sold.",
        example: "101200",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICE",
      t: 8,
      d: "Calculates the price of a security paying periodic interest, such as a US Treasury Bond, based on expected yield.",
      a: "Price of a security paying periodic interest.",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.065",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEDISC",
      t: 8,
      d: "Calculates the price of a discount (non-interest-bearing) security, based on expected yield.",
      a: "Price of a discount security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the security at time of purchase.",
        example: "0.0525",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEMAT",
      t: 8,
      d: "Calculates the price of a security paying interest at maturity, based on expected yield.",
      a: "Price of security paying interest at maturity.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RECEIVED",
      t: 8,
      d: "Calculates the amount received at maturity for an investment in fixed-income securities purchased on a given date.",
      a: "Amount received at maturity for a security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "The amount invested (irrespective of face value of each security).",
        example: "10000000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "discount",
        detail: "The discount rate of the security invested in.",
        example: "0.0575",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DISC",
      t: 8,
      d: "Calculates the discount rate of a security based on price.",
      a: "The discount rate of a security based on price.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "97.975",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPER",
      t: 8,
      d: "Calculates the number of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Number of payment periods for an investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount of each payment made.",
        example: "500",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "40000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLN",
      t: 8,
      d: "Calculates the depreciation of an asset for one period using the straight-line method.",
      a: "Depreciation of asset using the straight-line method.",
      m: [3, 3],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "300000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "75000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DURATION",
      t: 8,
      d: "Calculates the number of compounding periods required for an investment of a specified present value appreciating at a given rate to reach a target value.",
      a: "Number of periods for an investment to reach a value.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MDURATION",
      t: 8,
      d: "Calculates the modified Macaulay duration of a security paying periodic interest, such as a US Treasury Bond, based on expected yield.",
      a: "Modified Macaulay duration.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2DEC",
      t: 9,
      d: "Converts a signed binary number to decimal format.",
      a: "Converts a signed binary number to decimal format.",
      m: [1, 1],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to decimal, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIN2HEX",
      t: 9,
      d: "Converts a signed binary number to signed hexadecimal format.",
      a: "Converts a binary number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to signed hexademical, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2OCT",
      t: 9,
      d: "Converts a signed binary number to signed octal format.",
      a: "Converts a binary number to octal.",
      m: [1, 2],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to signed octal, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2BIN",
      t: 9,
      d: "Converts a decimal number to signed binary format.",
      a: "Converts a decimal number to signed binary format.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed binary, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2HEX",
      t: 9,
      d: "Converts a decimal number to signed hexadecimal format.",
      a: "Converts a decimal number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed hexadecimal, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2OCT",
      t: 9,
      d: "Converts a decimal number to signed octal format.",
      a: "Converts a decimal number to signed octal format.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed octal, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2BIN",
      t: 9,
      d: "Converts a signed hexadecimal number to signed binary format.",
      a: "Converts a hexadecimal number to binary.",
      m: [1, 2],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to signed binary, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2DEC",
      t: 9,
      d: "Converts a signed hexadecimal number to decimal format.",
      a: "Converts a hexadecimal number to decimal.",
      m: [1, 1],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to decimal, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HEX2OCT",
      t: 9,
      d: "Converts a signed hexadecimal number to signed octal format.",
      a: "Converts a hexadecimal number to octal.",
      m: [1, 2],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to signed octal, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2BIN",
      t: 9,
      d: "Converts a signed octal number to signed binary format.",
      a: "Converts an octal number to binary.",
      m: [1, 2],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to signed binary, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2DEC",
      t: 9,
      d: "Converts a signed octal number to decimal format.",
      a: "Converts a signed octal number to decimal format.",
      m: [1, 1],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to decimal, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OCT2HEX",
      t: 9,
      d: "Converts a signed octal number to signed hexadecimal format.",
      a: "Converts an octal number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to signed hexadecimal, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COMPLEX",
      t: 9,
      d: "Creates a complex number given real and imaginary coefficients.",
      a: "Creates a complex number.",
      m: [2, 3],
      p: [{
        name: "real_part",
        detail: "The real coefficient.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "imaginary_part",
        detail: "The imaginary coefficient.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suffix",
        detail: "The suffix for the imaginary coefficient, can only be 'i' or 'j'. If omitted, 'i' will be used.",
        example: '"j"',
        require: "o",
        repeat: "n",
        type: "rangestring"
      }]
    }, {
      n: "IMREAL",
      t: 9,
      d: "Returns the real coefficient of a complex number.",
      a: "The real coefficient of a complex number.",
      m: [1, 1],
      p: [{
        name: "complex_number",
        detail: "The complex number, in the a+bi or a+bj format.",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMAGINARY",
      t: 9,
      d: "Returns the imaginary coefficient of a complex number.",
      a: "The imaginary coefficient of a complex number.",
      m: [1, 1],
      p: [{
        name: "complex_number",
        detail: "The complex number, in the a+bi or a+bj format.",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMCONJUGATE",
      t: 9,
      d: "Returns the complex conjugate of a number.",
      a: "The complex conjugate of a number.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The complex number to calculate the conjugate for.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMABS",
      t: 9,
      d: "Returns absolute value (or modulus) of a complex number.",
      a: "The absolute value of a complex number.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The complex number to calculate the absolute value of.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DELTA",
      t: 9,
      d: "Compare two numeric values, returning 1 if they're equal.",
      a: "Compare two numeric values.",
      m: [1, 2],
      p: [{
        name: "number1",
        detail: "The first number to compare.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number2",
        detail: "The second number to compare.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IMSUM",
      t: 9,
      d: "Returns the sum of a series of complex numbers.",
      a: "Sum of a series of complex numbers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first complex number or range to add together.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional complex numbers or ranges to add to `value1`.",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMSUB",
      t: 9,
      d: "Returns the difference between two complex numbers.",
      a: "The difference between two complex numbers.",
      m: [2, 2],
      p: [{
        name: "first_number",
        detail: "The complex number to subtract second_number from.",
        example: '"6+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "second_number",
        detail: "The complex number to subtract from first_number.",
        example: '"2+3i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMPRODUCT",
      t: 9,
      d: "Returns the result of multiplying a series of complex numbers together.",
      a: "Result of multiplying a series of complex numbers together.",
      m: [1, 255],
      p: [{
        name: "factor1",
        detail: "The first number or range to calculate for the product.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "factor2",
        detail: "Additional complex numbers or ranges to calculate for the product.",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMDIV",
      t: 9,
      d: "Returns one complex number divided by another.",
      a: "One complex number divided by another.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The complex number to be divided.",
        example: '"11+16i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "divisor",
        detail: "The complex number to divide by.",
        example: '"3+2i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOT",
      t: 10,
      d: "Returns the opposite of a logical value - `NOT(TRUE)` returns `FALSE`; `NOT(FALSE)` returns `TRUE`.",
      a: "Returns opposite of provided logical value.",
      m: [1, 1],
      p: [{
        name: "logical_expression",
        detail: "An expression or reference to a cell holding an expression that represents some logical value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRUE",
      t: 10,
      d: "Returns the logical value `TRUE`.",
      a: "Logical value `true`.",
      m: [0, 0],
      p: []
    }, {
      n: "FALSE",
      t: 10,
      d: "Returns the logical value `FALSE`.",
      a: "Logical value `false`.",
      m: [0, 0],
      p: []
    }, {
      n: "AND",
      t: 10,
      d: "Returns true if all of the provided arguments are logically true, and false if any of the provided arguments are logically false.",
      a: "Logical `and` operator.",
      m: [1, 255],
      p: [{
        name: "logical_expression1",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`, or an expression that can be coerced to a logical value.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical_expression2",
        detail: "More expressions that represent logical values.",
        example: 'A3 = "bar"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IFERROR",
      t: 10,
      d: "Returns the first argument if it is not an error value, otherwise returns the second argument if present, or a blank if the second argument is absent.",
      a: "Value if it is not an error, otherwise 2nd argument.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to return if `value` itself is not an error.",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_error",
        detail: "The value the function returns if `value` is an error.",
        example: '"Error in cell A1"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IF",
      t: 10,
      d: "Returns one value if a logical expression is `TRUE` and another if it is `FALSE`.",
      a: "Returns value depending on logical expression.",
      m: [2, 3],
      p: [{
        name: "logical_expression",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_true",
        detail: "The value the function returns if `logical_expression` is `TRUE`.",
        example: '"A2 is foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_false",
        detail: "The value the function returns if `logical_expression` is `FALSE`.",
        example: '"A2 was false"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OR",
      t: 10,
      d: "Returns true if any of the provided arguments are logically true, and false if all of the provided arguments are logically false.",
      a: "Logical `or` operator.",
      m: [1, 255],
      p: [{
        name: "logical_expression1",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`, or an expression that can be coerced to a logical value.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical_expression2",
        detail: "More expressions that evaluate to logical values.",
        example: ' A3 = "bar"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NE",
      t: 11,
      d: "Returns `TRUE` if two specified values are not equal and `FALSE` otherwise. Equivalent to the `!=` operator.",
      a: "Not equal.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to test against `value1` for inequality.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EQ",
      t: 11,
      d: "Returns `TRUE` if two specified values are equal and `FALSE` otherwise. Equivalent to the `==` operator.",
      a: "Equal.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to test against `value1` for equality.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GT",
      t: 11,
      d: "Returns `TRUE` if the first argument is strictly greater than the second, and `FALSE` otherwise. Equivalent to the `>` operator.",
      a: "Strictly greater than.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being greater than `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GTE",
      t: 11,
      d: "Returns `TRUE` if the first argument is greater than or equal to the second, and `FALSE` otherwise. Equivalent to the `>=` operator.",
      a: "Greater than or equal to.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being greater than or equal to `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LT",
      t: 11,
      d: "Returns `TRUE` if the first argument is strictly less than the second, and `FALSE` otherwise. Equivalent to the `<` operator.",
      a: "Less than.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being less than `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LTE",
      t: 11,
      d: "Returns `TRUE` if the first argument is less than or equal to the second, and `FALSE` otherwise. Equivalent to the `<=` operator.",
      a: "Less than or equal to.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being less than or equal to `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADD",
      t: 11,
      d: "Returns the sum of two numbers. Equivalent to the `+` operator.",
      a: "Sum of two numbers",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first addend.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "The second addend.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINUS",
      t: 11,
      d: "Returns the difference of two numbers. Equivalent to the `-` operator.",
      a: "Difference of two numbers",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The minuend, or number to be subtracted from.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "The subtrahend, or number to subtract from `value1`.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTIPLY",
      t: 11,
      d: "Returns the product of two numbers. Equivalent to the `*` operator.",
      a: "Product of two numbers",
      m: [2, 2],
      p: [{
        name: "factor1",
        detail: "The first multiplicand.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor2",
        detail: "The second multiplicand.",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DIVIDE",
      t: 11,
      d: "Returns one number divided by another. Equivalent to the `/` operator.",
      a: "One number divided by another",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCAT",
      t: 11,
      d: "Returns the concatenation of two values. Equivalent to the `&` operator.",
      a: "Concatenation of two values",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to which `value2` will be appended.",
        example: '"de"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to append to `value1`.",
        example: '"mystify"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNARY_PERCENT",
      t: 11,
      d: "Returns a value interpreted as a percentage; that is, `UNARY_PERCENT(100)` equals `1`.",
      a: "Value interpreted as a percentage.",
      m: [1, 1],
      p: [{
        name: "percentage",
        detail: "The value to interpret as a percentage.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCATENATE",
      t: 12,
      d: "Appends strings to one another.",
      a: "Appends strings to one another.",
      m: [1, 255],
      p: [{
        name: "string1",
        detail: "The initial string.",
        example: '"Super"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "string2",
        detail: "More strings to append in sequence.",
        example: '"calla"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CODE",
      t: 12,
      d: "Returns the numeric Unicode map value of the first character in the string provided.",
      a: "Numeric unicode map value of character.",
      m: [1, 1],
      p: [{
        name: "string",
        detail: "The string whose first character's Unicode map value will be returned.",
        example: '"a"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CHAR",
      t: 12,
      d: "Convert a number into a character according to the current Unicode table.",
      a: "Gets character associated with number.",
      m: [1, 1],
      p: [{
        name: "table_number",
        detail: "The number of the character to look up from the current Unicode table in decimal format.",
        example: "97",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ARABIC",
      t: 12,
      d: "Computes the value of a Roman numeral.",
      a: "Computes the value of a roman numeral.",
      m: [1, 1],
      p: [{
        name: "roman_numeral",
        detail: "The Roman numeral to format, whose value must be between 1 and 3999, inclusive.",
        example: '"XIV"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROMAN",
      t: 12,
      d: "Formats a number in Roman numerals.",
      a: "Formats a number in Roman numerals.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The number to format, between 1 and 3999, inclusive.",
        example: "499",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "REGEXEXTRACT",
      t: 12,
      d: "Extracts matching substrings according to a regular expression.",
      a: "Extracts matching substrings with regular expression.",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "The input text.",
        example: '"Needle in a haystack"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The first part of `text` that matches this expression will be returned.",
        example: '".e{2}dle"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXMATCH",
      t: 12,
      d: "Whether a piece of text matches a regular expression.",
      a: "Whether a piece of text matches regular expression.",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "The text to be tested against the regular expression.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The regular expression to test the text against.",
        example: '"S.r"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXREPLACE",
      t: 12,
      d: "Replaces part of a text string with a different text string using regular expressions.",
      a: "Replaces text with regular expressions.",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "The text, a part of which will be replaced.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The regular expression.  All matching instances in `text` will be replaced.",
        example: '"S.*d"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replacement",
        detail: "The text which will be inserted into the original text.",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T",
      t: 12,
      d: "Returns string arguments as text, or the empty string if the value is not text.",
      a: "String arguments as text.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument to be converted to text.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIXED",
      t: 12,
      d: "Formats a number with a fixed number of decimal places.",
      a: "Formats number with fixed number of decimal places.",
      m: [1, 3],
      p: [{
        name: "number",
        detail: "The number to format.",
        example: "3.141592653",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_places",
        detail: "The number of decimal places to display in the result.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suppress_separator",
        detail: "Whether or not to suppress the thousands separator used in some locales (e.g. `1,000` becomes `1000`). Separators will be present if this value is 0 or omitted, and absent otherwise.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIND",
      t: 12,
      d: "Returns the position at which a string is first found within text where the capitalization of letters matters. Returns `#VALUE!` if the string is not found.",
      a: "First position of string found in text, case-sensitive.",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "14",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FINDB",
      t: 12,
      d: "Returns the position at which a string is first found within text counting each double-character as 2.",
      a: "Position at which a string is first found within text (binary).",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"new"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: '"new year"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "JOIN",
      t: 12,
      d: "Concatenates the elements of one or more one-dimensional arrays using a specified delimiter.",
      a: "Concatenates elements of arrays with delimiter.",
      m: [2, 255],
      p: [{
        name: "delimiter",
        detail: "The character or string to place between each concatenated value.",
        example: '" and-a "',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_or_array1",
        detail: "The value or values to be appended using `delimiter`.",
        example: "{1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_or_array2",
        detail: "More values to be appended using `delimiter`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LEFT",
      t: 12,
      d: "Returns a substring from the beginning of a specified string.",
      a: "Substring from beginning of specified string.",
      m: [1, 2],
      p: [{
        name: "string",
        detail: "The string from which the left portion will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_characters",
        detail: "The number of characters to return from the left side of `string`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RIGHT",
      t: 12,
      d: "Returns a substring from the end of a specified string.",
      a: "A substring from the end of a specified string.",
      m: [1, 2],
      p: [{
        name: "string",
        detail: "The string from which the right portion will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_characters",
        detail: "The number of characters to return from the right side of `string`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MID",
      t: 12,
      d: "Returns a segment of a string.",
      a: "A segment of a string.",
      m: [3, 3],
      p: [{
        name: "string",
        detail: "The string to extract a segment from.",
        example: '"get this"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The index from the left of `string` from which to begin extracting. The first character in `string` has the index 1.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "extract_length",
        detail: "The length of the segment to extract.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LEN",
      t: 12,
      d: "Returns the length of a string.",
      a: "Length of a string.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string whose length will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LENB",
      t: 12,
      d: "Returns the length of a string in bytes.",
      a: "Length of a string in bytes.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string whose length will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOWER",
      t: 12,
      d: "Converts a specified string to lowercase.",
      a: "Converts a specified string to lowercase.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string to convert to lowercase.",
        example: '"LOREM IPSUM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UPPER",
      t: 12,
      d: "Converts a specified string to uppercase.",
      a: "Converts a specified string to uppercase.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string to convert to uppercase.",
        example: '"lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EXACT",
      t: 12,
      d: "Tests whether two strings are identical.",
      a: "Tests whether two strings are identical.",
      m: [2, 2],
      p: [{
        name: "string1",
        detail: "The first string to compare",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "string2",
        detail: "The second string to compare",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPLACE",
      t: 12,
      d: "Replaces part of a text string with a different text string.",
      a: "Replaces part of a text string with different text.",
      m: [4, 4],
      p: [{
        name: "text",
        detail: "The text, a part of which will be replaced.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "position",
        detail: "The position where the replacement will begin (starting from 1).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "length",
        detail: "The number of characters in the text to be replaced.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_text",
        detail: "The text which will be inserted into the original text.",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPT",
      t: 12,
      d: "Returns specified text repeated a number of times.",
      a: "Specified text repeated a number of times.",
      m: [2, 2],
      p: [{
        name: "text_to_repeat",
        detail: "The character or string to repeat.",
        example: '"ha"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_repetitions",
        detail: "The number of times `text_to_repeat` should appear in the value returned.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEARCH",
      t: 12,
      d: "Returns the position at which a string is first found within text and ignores capitalization of letters. Returns `#VALUE!` if the string is not found.",
      a: "First position of string found in text, ignoring case.",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUBSTITUTE",
      t: 12,
      d: "Replaces existing text with new text in a string.",
      a: "Replaces existing text with new text in a string.",
      m: [3, 4],
      p: [{
        name: "text_to_search",
        detail: "The text within which to search and replace.",
        example: '"search for it"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "search_for",
        detail: "The string to search for within `text_to_search`.",
        example: '"search for"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replace_with",
        detail: "The string that will replace `search_for`.",
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurrence_number",
        detail: "The instance of `search_for` within `text_to_search` to replace with `replace_with`. By default, all occurrences of `search_for` are replaced; however, if `occurrence_number` is specified, only the indicated instance of `search_for` is replaced.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CLEAN",
      t: 12,
      d: "Returns the text with the non-printable ASCII characters removed.",
      a: "Removes non-printable characters from a piece of text.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The text whose non-printable characters are to be removed.",
        example: '"AF"&CHAR(31)',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TEXT",
      t: 12,
      d: "Converts a number into text according to a specified format.",
      a: "Formats a number into text.",
      m: [2, 2],
      p: [{
        name: "number",
        detail: "The number, date, or time to format.",
        example: "1.23",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "format",
        detail: "The pattern by which to format the number, enclosed in quotation marks.",
        example: '"$0.00"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRIM",
      t: 12,
      d: "Removes leading, trailing, and repeated spaces in text.",
      a: "Removes space characters.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The text or reference to a cell containing text to be trimmed.",
        example: '" lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "VALUE",
      t: 12,
      d: "Converts a string in any of the date, time or number formats that Google Sheets understands into a number.",
      a: "Converts a date/time/number string into a number.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string containing the value to be converted.",
        example: '"123"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROPER",
      t: 12,
      d: "Capitalizes each word in a specified string.",
      a: "Capitalizes each word in a specified string.",
      m: [1, 1],
      p: [{
        name: "text_to_capitalize",
        detail: "The text which will be returned with the first letter of each word in uppercase and all other letters in lowercase.",
        example: '"united states"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CONVERT",
      t: 13,
      d: "Converts a numeric value to a different unit of measure.",
      a: "Unit conversion for numbers.",
      m: [3, 3],
      p: [{
        name: "value",
        detail: "The numeric value in `start_unit` to convert to `end_unit`.",
        example: "5.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_unit",
        detail: "The starting unit, the unit currently assigned to `value`.",
        example: '"g"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_unit",
        detail: "The unit of measure into which to convert the argument, `value`.",
        example: '"kg"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "SUMX2MY2",
      t: 14,
      d: "Calculates the sum of the differences of the squares of values in two arrays.",
      a: "Sum of the differences of squares.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values whose squares will be reduced by the squares of corresponding entries in `array_y` and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values whose squares will be subtracted from the squares of corresponding entries in `array_x` and added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMX2PY2",
      t: 14,
      d: "Calculates the sum of the sums of the squares of values in two arrays.",
      a: "Sum of the sums of squares.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values whose squares will be added to the squares of corresponding entries in `array_y` and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values whose squares will be added to the squares of corresponding entries in `array_x` and added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMXMY2",
      t: 14,
      d: "Calculates the sum of the squares of differences of values in two arrays.",
      a: "Sum of the squares of differences.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values that will be reduced by corresponding entries in `array_y`, squared, and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values that will be subtracted from corresponding entries in `array_x`, the result squared, and all such results added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRANSPOSE",
      t: 14,
      d: "Transposes the rows and columns of an array or range of cells.",
      a: "Transposes the rows and columns of an array.",
      m: [1, 1],
      p: [{
        name: "array_or_range",
        detail: "The array or range whose rows and columns will be swapped.",
        example: "{1,2}",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TREND",
      t: 14,
      d: "Given partial data about a linear trend, fits an ideal linear trend using the least squares method and/or predicts further values.",
      a: "Fits points to linear trend derived via least-squares.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal linear trend.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_data_x",
        detail: "The data points to return the `y` values for on the ideal curve fit.",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general linear form of `y = m*x+b` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `0` and only calculates the `m` values if `FALSE`, i.e. forces the curve fit to pass through the origin.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FREQUENCY",
      t: 14,
      d: "Calculates the frequency distribution of a one-column array into specified classes.",
      a: "The frequency distribution of array.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the values to be counted.",
        example: "A2:A40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "classes",
        detail: "The array or range containing the set of classes.",
        example: "B2:B5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GROWTH",
      t: 14,
      d: "Given partial data about an exponential growth trend, fits an ideal exponential growth trend and/or predicts further values.",
      a: "Fits points to exponential growth trend.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal exponential growth curve.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_data_x",
        detail: "The data points to return the `y` values for on the ideal curve fit.",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general exponential form of `y = b*m^x` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `1` and only calculates the `m` values if `FALSE`.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINEST",
      t: 14,
      d: "Given partial data about a linear trend, calculates various parameters about the ideal linear trend using the least-squares method.",
      a: "Best-fit linear trend via least-squares.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal linear trend.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calculate_b",
        detail: "Given a linear form of `y = m*x+b`, calculates the y-intercept (`b`) if `TRUE`. Otherwise, forces `b` to be `0` and only calculates the `m` values if `FALSE`, i.e. forces the curve fit to pass through the origin.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "verbose",
        detail: "A flag specifying whether to return additional regression statistics or only the linear coefficients and the y-intercept (default).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOGEST",
      t: 14,
      d: "Given partial data about an exponential growth curve, calculates various parameters about the best fit ideal exponential growth curve.",
      a: "Best-fit exponential growth curve.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal exponential growth curve.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general exponential form of `y = b*m^x` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `1` and only calculates the `m` values if `FALSE`.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "verbose",
        detail: "A flag specifying whether to return additional regression statistics or only the calculated coefficient and exponents.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MDETERM",
      t: 14,
      d: "Returns the matrix determinant of a square matrix specified as an array or range.",
      a: "Matrix determinant of a square matrix.",
      m: [1, 1],
      p: [{
        name: "square_matrix",
        detail: "An array or range with an equal number of rows and columns representing a matrix whose determinant will be calculated.",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINVERSE",
      t: 14,
      d: "Returns the multiplicative inverse of a square matrix specified as an array or range.",
      a: "Multiplicative inverse of square matrix.",
      m: [1, 1],
      p: [{
        name: "square_matrix",
        detail: "An array or range with an equal number of rows and columns representing a matrix whose multiplicative inverse will be calculated.",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MMULT",
      t: 14,
      d: "Calculates the matrix product of two matrices specified as arrays or ranges.",
      a: "The matrix product of two matrices.",
      m: [2, 2],
      p: [{
        name: "matrix1",
        detail: "The first matrix in the matrix multiplication operation, represented as an array or range.",
        example: "A1:B3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "matrix2",
        detail: "The second matrix in the matrix multiplication operation, represented as an array or range.",
        example: "C1:F2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMPRODUCT",
      t: 14,
      d: "Calculates the sum of the products of corresponding entries in two equal-sized arrays or ranges.",
      a: "Sum of products of elements in two arrays.",
      m: [1, 255],
      p: [{
        name: "array1",
        detail: "The first array or range whose entries will be multiplied with corresponding entries in the second such array or range.",
        example: "A2:C5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "The second array or range whose entries will be multiplied with corresponding entries in the first such array or range.",
        example: "D2:F5",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "ISFORMULA",
      t: 15,
      d: "Checks whether a value is a formula.",
      a: "Whether a value is a formula.",
      m: [1, 1],
      p: [{
        name: "cell",
        detail: "The cell to be verified as containing a formula.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CELL",
      t: 15,
      d: "Returns the requested information about the specified cell.",
      a: "Gets information about a cell.",
      m: [2, 2],
      p: [{
        name: "info_type",
        detail: "The type of information requested (see article for available types)",
        example: '"type"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "reference",
        detail: "The reference to the cell.",
        example: "C2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "NA",
      t: 15,
      d: 'Returns the "value not available" error, `#N/A`.',
      a: "The `#N/A` error.",
      m: [0, 0],
      p: []
    }, {
      n: "ERROR_TYPE",
      t: 15,
      d: "Returns a number corresponding to the error value in a different cell.",
      a: "Error value of cell (as number).",
      m: [1, 1],
      p: [{
        name: "reference",
        detail: "The cell to find the error number for although you can also provide the error value directly.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISBLANK",
      t: 15,
      d: "Checks whether the referenced cell is empty.",
      a: "Whether the referenced cell is empty.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Reference to the cell that will be checked for emptiness.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISERR",
      t: 15,
      d: "Checks whether a value is an error other than `#N/A`.",
      a: "Whether a value is an error other than `#n/a`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as an error type other than `#N/A`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISERROR",
      t: 15,
      d: "Checks whether a value is an error.",
      a: "Whether a value is an error.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as an error type.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISLOGICAL",
      t: 15,
      d: "Checks whether a value is `TRUE` or `FALSE`.",
      a: "Whether a value is `true` or `false`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a logical `TRUE` or `FALSE`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNA",
      t: 15,
      d: "Checks whether a value is the error `#N/A`.",
      a: "Whether a value is the error `#n/a`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be compared with the error value `#N/A`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNONTEXT",
      t: 15,
      d: "Checks whether a value is non-textual.",
      a: "Whether a value is non-textual.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be checked.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNUMBER",
      t: 15,
      d: "Checks whether a value is a number.",
      a: "Whether a value is a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a number.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISREF",
      t: 15,
      d: "Checks whether a value is a valid cell reference.",
      a: "Whether a value is a valid cell reference.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a cell reference.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISTEXT",
      t: 15,
      d: "Checks whether a value is text.",
      a: "Whether a value is text.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as text.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TYPE",
      t: 15,
      d: "Returns a number associated with the type of data passed into the function.",
      a: "Get the type of a value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value whose type is to be determined.",
        example: "C4",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "N",
      t: 15,
      d: "Returns the argument provided as a number. Text is converted to 0 and errors are returned as-is.",
      a: "Argument provided as a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument to be converted to a number.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DATE",
      t: 16,
      d: "Converts a provided number to a date.",
      a: "Converts a provided number to a date.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a date.",
        example: "25405",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PURE_NUMBER",
      t: 16,
      d: "Converts a provided date/time, percentage, currency or other formatted numeric value to a pure number without formatting.",
      a: "Converts any numeric value to a pure number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a pure number.",
        example: "50%",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_TEXT",
      t: 16,
      d: "Converts a provided numeric value to a text value.",
      a: "Converts a provided numeric value to a text value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to text.",
        example: "24",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DOLLARS",
      t: 16,
      d: "Converts a provided number to a dollar value.",
      a: "Converts a provided number to a dollar value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a dollar value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PERCENT",
      t: 16,
      d: "Converts a provided number to a percentage.",
      a: "Converts a provided number to a percentage.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a percentage.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DGET",
      t: 17,
      d: "Returns a single value from a database table-like array or range using a SQL-like query.",
      a: "Single value from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMAX",
      t: 17,
      d: "Returns the maximum value selected from a database table-like array or range using a SQL-like query.",
      a: "Maximum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMIN",
      t: 17,
      d: "Returns the minimum value selected from a database table-like array or range using a SQL-like query.",
      a: "Minimum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DAVERAGE",
      t: 17,
      d: "Returns the average of a set of values selected from a database table-like array or range using a SQL-like query.",
      a: "Average of a set of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNT",
      t: 17,
      d: "Counts numeric values selected from a database table-like array or range using a SQL-like query.",
      a: "Counts values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNTA",
      t: 17,
      d: "Counts values, including text, selected from a database table-like array or range using a SQL-like query.",
      a: "Counts values and text from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DPRODUCT",
      t: 17,
      d: "Returns the product of values selected from a database table-like array or range using a SQL-like query.",
      a: "Product of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEV",
      t: 17,
      d: "Returns the standard deviation of a population sample selected from a database table-like array or range using a SQL-like query.",
      a: "Standard deviation of population sample from table.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEVP",
      t: 17,
      d: "Returns the standard deviation of an entire population selected from a database table-like array or range using a SQL-like query.",
      a: "Standard deviation of entire population from table.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSUM",
      t: 17,
      d: "Returns the sum of values selected from a database table-like array or range using a SQL-like query.",
      a: "Sum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVAR",
      t: 17,
      d: "Returns the variance of a population sample selected from a database table-like array or range using a SQL-like query.",
      a: "Variance of population sample from table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVARP",
      t: 17,
      d: "Returns the variance of an entire population selected from a database table-like array or range using a SQL-like query.",
      a: "Variance of a population from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "AGE_BY_IDCARD",
      t: "3",
      d: "Calculate the age based on the Chinese ID number. Support 15 or 18",
      a: "Get age based on ID number.",
      m: [1, 2],
      p: [{
        name: "ID number",
        example: "A1",
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Deadline",
        example: '"2017-10-01"',
        detail: "The deadline or range of age calculation. The default is the current day.",
        require: "o",
        repeat: "n",
        type: "rangedatetime"
      }]
    }, {
      n: "SEX_BY_IDCARD",
      t: "3",
      d: "Calculate gender based on Chinese ID number. Support 15 or 18",
      a: "Get gender based on ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIRTHDAY_BY_IDCARD",
      t: "3",
      d: "Calculate the birthday based on the Chinese ID number. Support 15 or 18",
      a: "Get the birthday based on the ID number.",
      m: [1, 2],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Birthday format",
        example: "0",
        detail: "Date type, default:0:[1900/01/01], 1:[1900-01-01], 2:[1900年1月1日]",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROVINCE_BY_IDCARD",
      t: "3",
      d: "Calculate the province of birthplace based on the Chinese ID number. Support 15 or 18",
      a: "Get the province of birthplace based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CITY_BY_IDCARD",
      t: "3",
      d: "Calculate the city of birthplace based on the Chinese ID number. Support 15 or 18",
      a: "Get the city of birthplace based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "STAR_BY_IDCARD",
      t: "3",
      d: "Calculate the constellation based on the Chinese ID number. Support 15 or 18",
      a: "Get the constellation based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ANIMAL_BY_IDCARD",
      t: "3",
      d: "Calculate the zodiac (rat, ox, tiger, rabbit...) based on the Chinese ID number. Support 15 or 18",
      a: "Get the zodiac according to the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISIDCARD",
      t: "3",
      d: "Verify that the format of the ID card is correct. Support 15 or 18",
      a: "Verify the correctness of the ID card format.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DM_TEXT_CUTWORD",
      t: "4",
      d: "Text segmentation. Split a series of words into a series of individual words",
      a: "Chinese text segmentation.",
      m: [1, 2],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Word segmentation mode",
        example: "0",
        detail: "The default is 0[precision mode], 1[full mode], 2[search engine mode].",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TFIDF",
      t: "4",
      d: "Use tf-idf algorithm for keyword extraction. Identify keywords from a series of text",
      a: "tf-idf keyword recognition.",
      m: [1, 3],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Number of keywords",
        example: "20",
        detail: "The number of keywords returned by the algorithm, the default is 20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Corpus",
        example: "1",
        detail: "Select a corpus in a specific field, the default is 0[General], 1[Finance], 2[Medical]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TEXTRANK",
      t: "4",
      d: "Use TextRank algorithm to extract keywords. Identify keywords from a series of text",
      a: "TextRank keyword recognition.",
      m: [1, 3],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Number of keywords",
        example: "20",
        detail: "The number of keywords returned by the algorithm, the default is 20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Corpus",
        example: "1",
        detail: "Select a corpus in a specific field, the default is 0[General], 1[Finance], 2[Medical]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_CLOSE",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock closing price of A shares.",
      a: "Returns the closing price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_OPEN",
      t: "5",
      d: "According to the stock code and date, return the opening price of stock.",
      a: "Return the opening price of a shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MAX",
      t: "5",
      d: "According to the stock code and date, return the highest price of stock.",
      a: "Return the highest price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MIN",
      t: "5",
      d: "According to the stock code and date, return the lowest price of stock.",
      a: "Returns the lowest price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_VOLUMN",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock trading volume of A shares.",
      a: "Returns the corresponding stock trading volume of A shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_AMOUNT",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock turnover of A shares.",
      a: "Returns the corresponding stock turnover of A shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISDATE",
      t: "6",
      d: "Returns whether a value is a date.",
      a: "Whether a value is a date.",
      m: [1, 1],
      p: [{
        name: "value",
        example: '"1990-01-01"',
        detail: "The value to be verified as a date.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINESPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell to describe the continuous trend of data",
      a: "Generate sparklines line chart",
      m: [1, 8],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line thickness",
        example: "1",
        detail: "Line thickness of the line graph, the default is 1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line",
        example: "avg",
        detail: "A horizontal line, which can be min, max, avg, median, range or custom value, default 0 none",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line color",
        example: "#000",
        detail: "Color setting of auxiliary line, same as line color configuration, default #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Maximum mark",
        example: "#fc5c5c",
        detail: "Identifies the maximum value of the line graph, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Minimum mark",
        example: "#fc5c5c",
        detail: "Identify the minimum value of the line graph, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Mark size",
        example: "1.5",
        detail: "The maximum and minimum mark size settings, the default is 1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AREASPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell area chart, generally used to describe the continuous cumulative value trend of the data",
      a: "Generate sparklines area chart",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Fill color",
        example: "#CCF3F4",
        detail: "Form an area chart, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line thickness",
        example: "1",
        detail: "Line thickness of the line graph, the default is 1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line",
        example: "avg",
        detail: "A horizontal line, which can be min, max, avg, median, range or custom value, default 0 none",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line color",
        example: "#000",
        detail: "Color setting of auxiliary line, same as line color configuration, default #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the vertical histogram of cells, generally used to describe the size of discrete data",
      a: "Generate sparklines vertical histogram",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the bar chart, used to standardize the length of the bar chart, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKCOLUMNSPLINES",
      t: "3",
      d: "Generate sparklines, a cumulative vertical histogram embedded in a cell, generally used to describe the numerical size of multiple dimensions of discrete data",
      a: "Generate sparklines cumulative vertical histogram",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Stack by column",
        example: "1",
        detail: "If you need to stack by row, set this item to false or 0, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the cumulative bar, used to regulate the length of the bar, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can individually set the bar color of each dimension, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BARSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the size of discrete data",
      a: "Generate sparklines horizontal bar graph",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the bar chart, used to standardize the length of the bar chart, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKBARSPLINES",
      t: "3",
      d: "Generate sparklines, a cumulative horizontal bar graph embedded in a cell, which is generally used to describe the numerical size of multiple dimensions of discrete data",
      a: "Generate sparklines cumulative horizontal bar graph",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Stack by column",
        example: "1",
        detail: "If you need to stack by row, set this item to false or 0, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the cumulative bar, used to regulate the length of the bar, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can individually set the bar color of each dimension, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "DISCRETESPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the trend of discrete data",
      a: "Generate sparklines discrete graph",
      m: [1, 4],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Segmentation threshold",
        example: "1",
        detail: "Discrete graph column color distinction, for example: if the value is 0, blue is greater than 0, red is less than 0, and the default is 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Above threshold color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Below threshold color",
        example: "#fc5c5c",
        detail: "The color setting of the bar below the threshold, the same as the color above the threshold, default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRISTATESPLINES",
      t: "3",
      d: "Generate sparklines, a three-state graph embedded in the cell, which is generally used to describe the trend of three situations, such as winning, losing, or drawing.",
      a: "Generate sparklines three-state graph",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Zero value bar color",
        example: "#999",
        detail: "Zero value bar color setting, representing 0 value color, the same color configuration of the bar, default #999",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PIESPLINES",
      t: "3",
      d: "Generate sparklines pie chart embedded in the cell, generally used to describe the proportion of data",
      a: "Generate sparklines pie chart",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Rotation angle",
        example: "0",
        detail: "The rotation angle of the pie chart, the default is 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "border",
        example: "0",
        detail: "Pie chart border size, default is none 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Border color",
        example: "#000",
        detail: "The border color of the pie chart, the default is #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color of the slice can be set in the palette, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BOXSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell box plot, generally used to describe the statistical distribution of the data set",
      a: "Generate sparklines box plot",
      m: [1, 4],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Outlier ratio",
        example: "1.5",
        detail: "The threshold range of outliers, if it is 0 or false, it will not be displayed, the default is 1.5 times",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Target value",
        example: "10",
        detail: "The target value setting on the box plot, the default is false and does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Point size",
        example: "1.5",
        detail: "The radius of the target point and outlier is set, the default is 1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BULLETSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the task achievement rate",
      a: "Generating sparklines bullets",
      m: [2, 3],
      p: [{
        name: "Target",
        example: "10",
        detail: "The numerical value can be calculated effectively for the achieved target value, such as A1, 100, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "achieved",
        example: "8",
        detail: "Only when the value is completed can the value be calculated effectively, such as A1, 100, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Contrast",
        example: "12",
        detail: "Comparative values, such as excess, minimum, and bottom line for awards, can be effectively calculated, such as A1, 100, etc. You can set up to 9 comparison values",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMPOSESPLINES",
      t: "3",
      d: "Support multiple types of pictures in the same cell, each parameter represents a sparklines diagram",
      a: "Combine sparklines graphs into one cell",
      m: [1, 1],
      p: [{
        name: "config",
        example: "PIESPLINES(A1:A20)",
        detail: "Sparklines chart settings, such as A1:A20, a completed pie chart, line chart settings, etc.",
        require: "m",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SORT",
      t: "14",
      d: "Sorts the rows of a given array or range by the values in one or more columns.",
      a: "Sorts rows of range by specified column.",
      m: [1, 4],
      p: [{
        name: "range",
        detail: "The data to be sorted.",
        example: "A2:A17",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_column",
        detail: "The index of the column in `range` or a range outside of `range` containing the values by which to sort.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_ascending",
        detail: "`TRUE` or `FALSE` indicating whether to sort `sort_column` in ascending order. `FALSE` sorts in descending order.",
        example: "-1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_column2",
        detail: "Additional columns.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FILTER",
      t: "14",
      d: "Returns a filtered version of the source range, returning only rows or columns which meet the specified conditions.",
      a: "Filters a range based off provided conditions.",
      m: [2, 3],
      p: [{
        name: "range",
        detail: "The data to be filtered.",
        example: "A5:D20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "condition1",
        detail: "A column or row containing true or false values corresponding to the first column or row of `range`, or an array formula evaluating to true or false.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "condition2",
        detail: "Additional rows or columns containing boolean values `TRUE` or `FALSE` indicating whether the corresponding row or column in `range` should pass through `FILTER`. Can also contain array formula expressions which evaluate to such rows or columns. All conditions must be of the same type (row or column). Mixing row conditions and column conditions is not permitted.",
        example: '""',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNIQUE",
      t: "14",
      d: "Returns unique rows in the provided source range, discarding duplicates. Rows are returned in the order in which they first appear in the source range.",
      a: "Unique rows in the provided source range.",
      m: [1, 3],
      p: [{
        name: "range",
        detail: "The data to filter by unique entries.",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[Option] - Logical value, indicating how to compare; by row = FALSE() or omitted; by column = TRUE().",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurs_once",
        detail: "[Option] - Logical value, only one occurrence in the unique value is returned = TRUE(); including all unique values = FALSE() or omitted.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANDARRAY",
      t: "14",
      d: "Returns a grid of random numbers between 0 inclusive and 1 exclusive. The grid size will match the provided rows and columns arguments. If neither rows nor columns are provided, then the grid will be size 1 x 1.",
      a: "Returns a grid of random numbers.",
      m: [0, 2],
      p: [{
        name: "rows",
        detail: "The number of rows to populate with a random number.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "columns",
        detail: "The number of columns to populate with a random number.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEQUENCE",
      t: "14",
      d: "Returns a grid of sequential numbers starting at a specified start value and  increasing by a specified step size. By default, the sequence starts at and  increases by 1.",
      a: "Returns a grid of sequential numbers.",
      m: [1, 4],
      p: [{
        name: "rows",
        detail: "The number of rows in the function's resulting grid.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "columns",
        detail: "The number of columns in the function's resulting grid. If omitted, the result grid will have 1 column.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start",
        detail: "The number, at which to start the sequence. If omitted, the sequence will start at 1.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "step",
        detail: "The amount each value in the sequence will differ by. If omitted, each value will differ by 1.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVALUATE",
      t: "3",
      d: "Evaluate a formula or expression expressed in words and return the result",
      a: "Evaluate according to literal formula or expression.",
      m: [1, 1],
      p: [{
        name: "expression",
        example: '"A1+5*2^2"',
        detail: "Formula or expression",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REMOTE",
      t: "5",
      d: "Calls a function on a remote server",
      a: "Calls a function on a remote back end server/API.",
      m: [1, 1],
      p: [{
        name: "remote_expression",
        example: "SUM(A1:A10000000)",
        detail: "Formula",
        require: "m",
        repeat: "n",
        type: "string"
      }]
    }],
    toolbar: {
      undo: "Undo",
      redo: "Redo",
      "clear-format": "Clear Format",
      "format-painter": "Format-Painter",
      paintFormat: "Paint format",
      "currency-format": "Format as currency",
      "percentage-format": "Format as percent",
      "number-decrease": "Decrease decimal places",
      "number-increase": "Increase decimal places",
      moreFormats: "More formats",
      "border-all": "Border All",
      "merge-all": "Merge All Cell",
      font: "Font",
      "font-size": "Font size",
      bold: "Bold (Ctrl+B)",
      italic: "Italic (Ctrl+I)",
      "strike-through": "Strikethrough (Alt+Shift+5)",
      underline: "Underline",
      "font-color": "Font color",
      "align-left": "Left aligned",
      "align-center": "Horizontal Center",
      "align-right": "Right aligned",
      "align-top": "Top aligned",
      "align-mid": "Vertical Center",
      "align-bottom": "Bottom aligned",
      chooseColor: "choose color",
      resetColor: "Reset",
      customColor: "CUSTOM",
      alternatingColors: "Alternating colors",
      confirmColor: "OK",
      cancelColor: "Cancel",
      collapse: "Collapse",
      background: "Fill color",
      border: "Border",
      borderStyle: "Border style",
      "merge-cell": "Merge cells",
      chooseMergeType: "Choose merge type",
      horizontalAlign: "Horizontal align",
      verticalAlign: "Vertical align",
      alignment: "Alignment",
      textWrap: "Text wrap",
      textWrapMode: "Text wrap mode",
      textRotate: "Text rotate",
      textRotateMode: "Text rotate mode",
      freeze: "Freeze",
      sort: "Sort",
      filter: "Filter",
      sortAndFilter: "Sort and filter",
      findAndReplace: "Find and replace",
      "formula-sum": "SUM",
      autoSum: "Auto SUM",
      moreFunction: "More functions",
      conditionalFormat: "Conditional format",
      comment: "Comment",
      pivotTable: "Pivot Table",
      chart: "Chart",
      screenshot: "Screenshot",
      splitColumn: "Split text",
      insertImage: "Insert image",
      insertLink: "Insert link",
      dataVerification: "Data verification",
      protection: "Protect the sheet",
      clearText: "Clear color",
      noColorSelectedText: "No color is selected",
      toolMore: "More",
      toolLess: "Less",
      toolClose: "Close",
      toolMoreTip: "More features",
      moreOptions: "More options",
      cellFormat: "Cell format config",
      print: "Print"
    },
    alternatingColors: {
      applyRange: "Apply to range",
      selectRange: "Select a data range",
      header: "Header",
      footer: "Footer",
      errorInfo: "Cannot perform this operation on multiple selection areas, please select a single area and try again",
      textTitle: "Format style",
      custom: "CUSTOM",
      close: "close",
      selectionTextColor: "Click to select text color",
      selectionCellColor: "Click to select cell color",
      removeColor: "Remove alternating colors",
      colorShow: "color",
      currentColor: "Current",
      tipSelectRange: "Please select the range of alternating colors",
      errorNoRange: "No range is selected",
      errorExistColors: "Alternating colors already exist and cannot be edited"
    },
    button: {
      confirm: "OK",
      cancel: "Cancel",
      close: "Close",
      update: "Update",
      delete: "Delete",
      insert: "Insert",
      prevPage: "Previous",
      nextPage: "Next",
      total: "total:"
    },
    paint: {
      start: "Paint format start",
      end: "ESC",
      tipSelectRange: "Please select the range to be copied",
      tipNotMulti: "Cannot perform this operation on multiple selection ranges"
    },
    format: {
      moreCurrency: "More currency formats",
      moreDateTime: "More date and time formats",
      moreNumber: "More number formats",
      titleCurrency: "Currency formats",
      decimalPlaces: "Decimal places",
      titleDateTime: "Date and time formats",
      titleNumber: "Number formats",
      tipDecimalPlaces: "The decimal places must be between 0-9!",
      select: "Select",
      format: "format",
      currency: "currency"
    },
    info: {
      detailUpdate: "New opened",
      detailSave: "Local cache restored",
      row: "",
      column: "",
      loading: "Loading...",
      copy: "Copy",
      return: "Exit",
      rename: "Rename",
      tips: "WorkBook rename",
      noName: "Untitled spreadsheet",
      wait: "waiting for update",
      add: "Add",
      addLast: "more rows at bottom",
      backTop: "Back to the top",
      pageInfo: "Total ${total}，${totalPage} page，current ${currentPage}",
      nextPage: "Next",
      tipInputNumber: "Please enter the number",
      tipInputNumberLimit: "The increase range is limited to 1-100",
      tipRowHeightLimit: "Row height must be between 0 ~ 545",
      tipColumnWidthLimit: "The column width must be between 0 ~ 2038",
      pageInfoFull: "Total ${total}，${totalPage} page，All data displayed"
    },
    currencyDetail: [{
      name: "RMB",
      pos: "before",
      value: "¥"
    }, {
      name: "US dollar",
      pos: "before",
      value: "$"
    }, {
      name: "EUR",
      pos: "before",
      value: "€"
    }, {
      name: "GBP",
      pos: "before",
      value: "￡"
    }, {
      name: "HK",
      pos: "before",
      value: "$"
    }, {
      name: "JPY",
      pos: "before",
      value: "￥"
    }, {
      name: "Albanian Lek",
      pos: "before",
      value: "Lek"
    }, {
      name: "Algerian Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Afghani",
      pos: "after",
      value: "Af"
    }, {
      name: "Argentine Peso",
      pos: "before",
      value: "$"
    }, {
      name: "United Arab Emirates Dirham",
      pos: "before",
      value: "dh"
    }, {
      name: "Aruban Florin",
      pos: "before",
      value: "Afl"
    }, {
      name: "Omani Rial",
      pos: "before",
      value: "Rial"
    }, {
      name: "Azerbaijani manat",
      pos: "before",
      value: "?"
    }, {
      name: "Egyptian Pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Ethiopian Birr",
      pos: "before",
      value: "Birr"
    }, {
      name: "Angola Kwanza",
      pos: "before",
      value: "Kz"
    }, {
      name: "Australian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Patacas",
      pos: "before",
      value: "MOP"
    }, {
      name: "Barbados Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Papua New Guinea Kina",
      pos: "before",
      value: "PGK"
    }, {
      name: "Bahamian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Pakistan Rupee",
      pos: "before",
      value: "Rs"
    }, {
      name: "Paraguayan Guarani",
      pos: "after",
      value: "Gs"
    }, {
      name: "Bahraini Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Panamanian Balboa",
      pos: "before",
      value: "B/"
    }, {
      name: "Brazilian real",
      pos: "before",
      value: "R$"
    }, {
      name: "Belarusian ruble",
      pos: "after",
      value: "р"
    }, {
      name: "Bermudian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Bulgarian Lev",
      pos: "before",
      value: "lev"
    }, {
      name: "Iceland Krona",
      pos: "before",
      value: "kr"
    }, {
      name: "Bosnia-Herzegovina Convertible Mark",
      pos: "before",
      value: "KM"
    }, {
      name: "Polish Zloty",
      pos: "after",
      value: "z?"
    }, {
      name: "Boliviano",
      pos: "before",
      value: "Bs"
    }, {
      name: "Belize Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Botswana Pula",
      pos: "before",
      value: "P"
    }, {
      name: "Not Dannuzhamu",
      pos: "before",
      value: "Nu"
    }, {
      name: "Burundi Franc",
      pos: "before",
      value: "FBu"
    }, {
      name: "North Korean Won",
      pos: "before",
      value: "?KP"
    }, {
      name: "Danish Krone",
      pos: "after",
      value: "kr"
    }, {
      name: "East Caribbean Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Dominica Peso",
      pos: "before",
      value: "RD$"
    }, {
      name: "Russian Ruble",
      pos: "after",
      value: "?"
    }, {
      name: "Eritrean Nakfa",
      pos: "before",
      value: "Nfk"
    }, {
      name: "CFA franc",
      pos: "before",
      value: "CFA"
    }, {
      name: "Philippine Peso",
      pos: "before",
      value: "?"
    }, {
      name: "Fiji Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Cape Verde Escudo",
      pos: "before",
      value: "CVE"
    }, {
      name: "Falkland Islands Pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Gambian Dalasi",
      pos: "before",
      value: "GMD"
    }, {
      name: "Congolese franc",
      pos: "before",
      value: "FrCD"
    }, {
      name: "Colombian Peso",
      pos: "before",
      value: "$"
    }, {
      name: "Costa Rican Colon",
      pos: "before",
      value: "?"
    }, {
      name: "Cuban Peso",
      pos: "before",
      value: "$"
    }, {
      name: "Cuban convertible peso",
      pos: "before",
      value: "$"
    }, {
      name: "Guyana Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Kazakhstan Tenge",
      pos: "before",
      value: "?"
    }, {
      name: "Haitian gourde",
      pos: "before",
      value: "HTG"
    }, {
      name: "won",
      pos: "before",
      value: "?"
    }, {
      name: "Netherlands Antilles Guilder",
      pos: "before",
      value: "NAf."
    }, {
      name: "Honduras lempiras",
      pos: "before",
      value: "L"
    }, {
      name: "Djibouti Franc",
      pos: "before",
      value: "Fdj"
    }, {
      name: "Kyrgyzstan Som",
      pos: "before",
      value: "KGS"
    }, {
      name: "Guinea Franc",
      pos: "before",
      value: "FG"
    }, {
      name: "Canadian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Ghanaian Cedi",
      pos: "before",
      value: "GHS"
    }, {
      name: "Cambodian riel",
      pos: "before",
      value: "Riel"
    }, {
      name: "Czech Koruna",
      pos: "after",
      value: "K?"
    }, {
      name: "Zimbabwe Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Qatari Riyal",
      pos: "before",
      value: "Rial"
    }, {
      name: "Cayman Islands Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Comorian franc",
      pos: "before",
      value: "CF"
    }, {
      name: "Kuwaiti Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Croatian Kuna",
      pos: "before",
      value: "kn"
    }, {
      name: "Kenyan Shilling",
      pos: "before",
      value: "Ksh"
    }, {
      name: "Lesotho Loti",
      pos: "before",
      value: "LSL"
    }, {
      name: "Lao Kip",
      pos: "before",
      value: "?"
    }, {
      name: "Lebanese Pound",
      pos: "before",
      value: "L￡"
    }, {
      name: "Lithuanian litas",
      pos: "before",
      value: "Lt"
    }, {
      name: "Libyan Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Liberian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Rwanda Franc",
      pos: "before",
      value: "RF"
    }, {
      name: "Romanian Leu",
      pos: "before",
      value: "RON"
    }, {
      name: "Malagasy Ariary",
      pos: "before",
      value: "Ar"
    }, {
      name: "Maldivian Rufiyaa",
      pos: "before",
      value: "Rf"
    }, {
      name: "Malawi Kwacha",
      pos: "before",
      value: "MWK"
    }, {
      name: "Malaysian Ringgit",
      pos: "before",
      value: "RM"
    }, {
      name: "Macedonia wearing Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Mauritius Rupee",
      pos: "before",
      value: "MURs"
    }, {
      name: "Mauritanian Ouguiya",
      pos: "before",
      value: "MRO"
    }, {
      name: "Mongolian Tugrik",
      pos: "before",
      value: "?"
    }, {
      name: "Bangladeshi Taka",
      pos: "before",
      value: "?"
    }, {
      name: "Peruvian Nuevo Sol",
      pos: "before",
      value: "S/"
    }, {
      name: "Myanmar Kyat",
      pos: "before",
      value: "K"
    }, {
      name: "Moldovan Leu",
      pos: "before",
      value: "MDL"
    }, {
      name: "Moroccan Dirham",
      pos: "before",
      value: "dh"
    }, {
      name: "Mozambique Metical",
      pos: "before",
      value: "MTn"
    }, {
      name: "Mexican Peso",
      pos: "before",
      value: "$"
    }, {
      name: "Namibian Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "South African Rand",
      pos: "before",
      value: "R"
    }, {
      name: "South Sudanese Pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Nicaragua Cordoba",
      pos: "before",
      value: "C$"
    }, {
      name: "Nepalese Rupee",
      pos: "before",
      value: "Rs"
    }, {
      name: "Nigerian Naira",
      pos: "before",
      value: "?"
    }, {
      name: "Norwegian Krone",
      pos: "after",
      value: "kr"
    }, {
      name: "Georgian Lari",
      pos: "before",
      value: "GEL"
    }, {
      name: "Swedish Krona",
      pos: "after",
      value: "kr"
    }, {
      name: "Swiss Franc",
      pos: "before",
      value: "CHF"
    }, {
      name: "Serbian Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Sierra Leone",
      pos: "before",
      value: "SLL"
    }, {
      name: "Seychelles Rupee",
      pos: "before",
      value: "SCR"
    }, {
      name: "Saudi Riyal",
      pos: "before",
      value: "Rial"
    }, {
      name: "Sao Tome Dobra",
      pos: "before",
      value: "Db"
    }, {
      name: "Saint Helena pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Sri Lanka Rupee",
      pos: "before",
      value: "Rs"
    }, {
      name: "Swaziland Lilangeni",
      pos: "before",
      value: "SZL"
    }, {
      name: "Sudanese Pound",
      pos: "before",
      value: "SDG"
    }, {
      name: "Surinamese dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Solomon Islands Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Somali Shilling",
      pos: "before",
      value: "SOS"
    }, {
      name: "Tajikistan Somoni",
      pos: "before",
      value: "Som"
    }, {
      name: "Pacific Franc",
      pos: "after",
      value: "FCFP"
    }, {
      name: "Thai Baht",
      pos: "before",
      value: "?"
    }, {
      name: "Tanzanian Shilling",
      pos: "before",
      value: "TSh"
    }, {
      name: "Tongan Pa'anga",
      pos: "before",
      value: "T$"
    }, {
      name: "Trinidad and Tobago Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Tunisian Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Turkish Lira",
      pos: "before",
      value: "?"
    }, {
      name: "Vanuatu Vatu",
      pos: "before",
      value: "VUV"
    }, {
      name: "Guatemalan Quetzal",
      pos: "before",
      value: "Q"
    }, {
      name: "Commission Bolivar",
      pos: "before",
      value: "Bs"
    }, {
      name: "Brunei Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Ugandan Shilling",
      pos: "before",
      value: "UGX"
    }, {
      name: "Ukrainian Hryvnia",
      pos: "before",
      value: "грн."
    }, {
      name: "Uruguayan Peso",
      pos: "before",
      value: "$"
    }, {
      name: "Uzbekistan som",
      pos: "before",
      value: "so?m"
    }, {
      name: "Western Samoa Tala",
      pos: "before",
      value: "WST"
    }, {
      name: "Singapore Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "NT",
      pos: "before",
      value: "NT$"
    }, {
      name: "New Zealand Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Hungarian Forint",
      pos: "before",
      value: "Ft"
    }, {
      name: "Syrian Pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Jamaican Dollar",
      pos: "before",
      value: "$"
    }, {
      name: "Armenian Dram",
      pos: "before",
      value: "Dram"
    }, {
      name: "Yemeni Rial",
      pos: "before",
      value: "Rial"
    }, {
      name: "Iraqi Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "Iranian Rial",
      pos: "before",
      value: "Rial"
    }, {
      name: "New Israeli Shekel",
      pos: "before",
      value: "?"
    }, {
      name: "Indian Rupee",
      pos: "before",
      value: "?"
    }, {
      name: "Indonesian Rupiah",
      pos: "before",
      value: "Rp"
    }, {
      name: "Jordanian Dinar",
      pos: "before",
      value: "din"
    }, {
      name: "VND",
      pos: "after",
      value: "?"
    }, {
      name: "Zambian Kwacha",
      pos: "before",
      value: "ZMW"
    }, {
      name: "Gibraltar Pound",
      pos: "before",
      value: "￡"
    }, {
      name: "Chilean Peso",
      pos: "before",
      value: "$"
    }, {
      name: "CFA Franc BEAC",
      pos: "before",
      value: "FCFA"
    }],
    defaultFmt: [{
      text: "Automatic",
      value: "General",
      example: ""
    }, {
      text: "Plain text",
      value: "@",
      example: ""
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Number",
      value: "##0.00",
      example: "1000.12"
    }, {
      text: "Percent",
      value: "#0.00%",
      example: "12.21%"
    }, {
      text: "Scientific",
      value: "0.00E+00",
      example: "1.01E+5"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Accounting",
      value: "$(0.00)",
      example: "$(1200.09)"
    }, {
      text: "Currency",
      value: "$0.00",
      example: "$1200.09"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Date",
      value: "yyyy-MM-dd",
      example: "2017-11-29"
    }, {
      text: "Time",
      value: "hh:mm AM/PM",
      example: "3:00 PM"
    }, {
      text: "Time 24H",
      value: "hh:mm",
      example: "15:00"
    }, {
      text: "Date time",
      value: "yyyy-MM-dd hh:mm AM/PM",
      example: "2017-11-29 3:00 PM"
    }, {
      text: "Date time 24 H",
      value: "yyyy-MM-dd hh:mm",
      example: "2017-11-29 15:00"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Custom formats",
      value: "fmtOtherSelf",
      example: "",
      icon: "rightArrow"
    }],
    dateFmtList: [{
      name: "1930-08-05",
      value: "yyyy-MM-dd"
    }, {
      name: "1930/8/5",
      value: "yyyy/MM/dd"
    }, {
      name: "08-05",
      value: "MM-dd"
    }, {
      name: "8-5",
      value: "M-d"
    }, {
      name: "13:30:30",
      value: "h:mm:ss"
    }, {
      name: "13:30",
      value: "h:mm"
    }, {
      name: "PM 01:30",
      value: "AM/PM hh:mm"
    }, {
      name: "PM 1:30",
      value: "AM/PM h:mm"
    }, {
      name: "PM 1:30:30",
      value: "AM/PM h:mm:ss"
    }, {
      name: "08-05 PM 01:30",
      value: "MM-dd AM/PM hh:mm"
    }],
    fontFamily: {
      MicrosoftYaHei: "YaHei"
    },
    fontarray: ["Times New Roman", "Arial", "Tahoma", "Verdana"],
    fontjson: {
      "times new roman": 0,
      arial: 1,
      tahoma: 2,
      verdana: 3
    },
    border: {
      borderTop: "Top border",
      borderBottom: "Bottom border",
      borderLeft: "Left border",
      borderRight: "Right border",
      borderNone: "No border",
      borderAll: "All borders",
      borderOutside: "Outside border",
      borderInside: "Inside border",
      borderHorizontal: "Horizontal borders",
      borderVertical: "Vertical borders",
      borderColor: "border color",
      borderSize: "border size",
      borderSlash: "Slash border",
      borderDefault: "default",
      borderStyle: "border style"
    },
    merge: {
      mergeAll: "Merge all",
      mergeV: "Merge Vertically",
      mergeH: "Merge Horizontally",
      mergeCancel: "Unmerge",
      overlappingError: "Cannot merge overlapping areas",
      partiallyError: "Cannot perform this operation on partially merged cells"
    },
    align: {
      left: "left",
      center: "center",
      right: "right",
      top: "Top",
      middle: "Middle",
      bottom: "Bottom"
    },
    textWrap: {
      overflow: "Overflow",
      wrap: "Wrap",
      clip: "Clip"
    },
    rotation: {
      none: "None",
      angleup: "Tilt Up",
      angledown: "Tilt Down",
      vertical: "Stack Vertically",
      rotationUp: "Rotate Up",
      rotationDown: "Rotate Down"
    },
    freezen: {
      default: "Freeze",
      freezenRow: "First Row",
      freezenColumn: "First Column",
      freezenRC: "Both",
      freezenRowRange: "Freeze to current row",
      freezenColumnRange: "Freeze to current column",
      freezenRCRange: "Freeze to current cell",
      freezenCancel: "Cancel freezing",
      noSeletionError: "No Range to be selected",
      rangeRCOverErrorTitle: "Freeze reminder",
      rangeRCOverError: "The frozen pane is beyond the visible range, which will lead to abnormal operation. Please reset the frozen area."
    },
    sort: {
      asc: "Ascending ",
      desc: "Descending ",
      custom: "Custom sort",
      hasTitle: "Data has a header row",
      sortBy: "Sort by",
      addOthers: "Add another sort column",
      close: "close",
      confirm: "sort",
      columnOperation: "Column",
      secondaryTitle: "then by",
      sortTitle: "Sort range",
      sortRangeTitle: "Sort range from",
      sortRangeTitleTo: "to",
      noRangeError: "Cannot perform this operation on multiple selection areas, please select a single range and try again",
      mergeError: "There are merged cells in the selection, this operation cannot be performed!"
    },
    filter: {
      filter: "create filter",
      sortByAsc: "Ascending sort",
      sortByDesc: "Descending sort",
      filterByColor: "Filter by color",
      filterByCondition: "Filter by condition",
      filterByValues: "Filter by values",
      filiterInputNone: "None",
      filiterInputTip: "Enter filter value",
      filiterRangeStartTip: "Value for formula",
      filiterRangeEndTip: "Value for formula",
      filterValueByAllBtn: "Check all",
      filterValueByClearBtn: "Clear",
      filterValueByInverseBtn: "Inverse",
      filterValueByTip: "filter By Values",
      filterConform: "Confirm",
      filterCancel: "Cancel",
      clearFilter: "Clear filter",
      conditionNone: "None",
      conditionCellIsNull: "Is empty",
      conditionCellNotNull: "Is not empty",
      conditionCellTextContain: "Text contains",
      conditionCellTextNotContain: "Text does not contain",
      conditionCellTextStart: "Text starts with",
      conditionCellTextEnd: "Text ends with",
      conditionCellTextEqual: "Text is exactly",
      conditionCellDateEqual: "Date is",
      conditionCellDateBefore: "Date is before",
      conditionCellDateAfter: "Date is after",
      conditionCellGreater: "Greater than",
      conditionCellGreaterEqual: "Greater than or equal to",
      conditionCellLess: "Less than",
      conditionCellLessEqual: "Less than or equal to",
      conditionCellEqual: "Is equal to",
      conditionCellNotEqual: "Is not equal to",
      conditionCellBetween: "Is between",
      conditionCellNotBetween: "Is not between",
      filiterMoreDataTip: "Big amount of data! please wait",
      filiterMonthText: "Month",
      filiterYearText: "Year",
      filiterByColorTip: "Filter by cell color",
      filiterByTextColorTip: "Filter by font color",
      filterContainerOneColorTip: "This column contains only one color",
      filterDateFormatTip: "Date format",
      valueBlank: "(Null)",
      mergeError: "There are merged cells in the filter selection, this operation cannot be performed!"
    },
    rightclick: {
      copy: "Copy",
      copyAs: "Copy as",
      paste: "Paste",
      insert: "Insert",
      image: "Insert image",
      link: "Insert link",
      delete: "Delete",
      deleteCell: "Delete cell",
      deleteSelected: "Delete selected ",
      hide: "Hide",
      hideSelected: "Hide selected ",
      showHide: "Show hidden ",
      to: "Towards",
      left: "Left",
      right: "Right",
      top: "Above",
      bottom: "Below",
      moveLeft: "Move left",
      moveUp: "Move up",
      add: "Add",
      row: "Row",
      column: "Column",
      width: "Width",
      height: "Height",
      number: "Number",
      confirm: "Confirm",
      orderAZ: "Ascending sort",
      orderZA: "Descending sort",
      clearContent: "Clear content",
      matrix: "Matrix operation",
      sortSelection: "Sort",
      filterSelection: "Filter",
      chartGeneration: "Create chart",
      firstLineTitle: "first line title",
      untitled: "untitled",
      array1: "One-dimensional array",
      array2: "Two-dimensional array",
      array3: "Multidimensional Arrays",
      diagonal: "Diagonal",
      antiDiagonal: "Anti-diagonal",
      diagonalOffset: "Diagonal offset",
      offset: "Offset",
      boolean: "Boolean",
      flip: "Flip",
      upAndDown: "Up and down",
      leftAndRight: "Left and right",
      clockwise: "Clockwise",
      counterclockwise: "Counterclockwise",
      transpose: "Transpose",
      matrixCalculation: "Matrix calculation",
      plus: "Plus",
      minus: "Minus",
      multiply: "Multiply",
      divided: "Divided",
      power: "Power",
      root: "Root",
      log: "Log",
      delete0: "Delete 0 values at both ends",
      removeDuplicate: "Remove duplicate values",
      byRow: "By row",
      byCol: "By column",
      generateNewMatrix: "Generate new matrix",
      noMulti: "Cannot perform this operation on multiple selection areas, please select a single area",
      cannotDeleteAllRow: "Cannot delete all rows",
      cannotDeleteAllColumn: "Cannot delete all columns",
      cannotDeleteRowReadOnly: "Cannot delete row readonly",
      cannotDeleteColumnReadOnly: "Cannot delete column readonly",
      cannotInsertOnRowReadOnly: "Cannot insert on read-only row",
      cannotInsertOnColumnReadOnly: "Cannot insert into read-only column",
      rowOverLimit: "10000 row limit exceeded",
      columnOverLimit: "1000 column limit exceeded"
    },
    comment: {
      insert: "Insert",
      edit: "Edit",
      delete: "Delete",
      showOne: "Show/Hide",
      showAll: "Show/Hide All"
    },
    screenshot: {
      screenshotTipNoSelection: "Please select the scope of the screenshot",
      screenshotTipTitle: "Warning！",
      screenshotTipHasMerge: "This operation cannot be performed on merged cells",
      screenshotTipHasMulti: "This operation cannot be performed on multiple selection regions",
      screenshotTipSuccess: "Successful",
      screenshotImageName: "Screenshot",
      downLoadClose: "Close",
      downLoadCopy: "Copy to clipboard",
      downLoadBtn: "Download",
      browserNotTip: "not supported by IE browser!",
      rightclickTip: 'Please right-click "copy" on the picture',
      successTip: 'Successfully (if pasting fails, please right-click on the image to "copy image")'
    },
    splitText: {
      splitDelimiters: "Delimiters",
      splitOther: "Other",
      splitContinueSymbol: "Consecutive separators are treated as a single",
      splitDataPreview: "Preview",
      splitTextTitle: "Split text",
      splitConfirmToExe: "There is already data here, do you want to replace it?",
      splitSymbols: [{
        name: "Tab",
        value: "Tab"
      }, {
        name: "semicolon",
        value: "semicolon"
      }, {
        name: "comma",
        value: "comma"
      }, {
        name: "space",
        value: "space"
      }],
      tipNoMulti: "Cannot perform this operation on multiple selection areas, please select a single area and try again",
      tipNoMultiColumn: "Only one column of data can be converted at a time. The selected area can have multiple rows but not multiple columns. Please try again after selecting a single column range",
      tipNoSelect: "You cannot separate a cell without selecting it"
    },
    imageText: {
      imageSetting: "Image setting",
      close: "Close",
      conventional: "Conventional",
      moveCell1: "Move and resize cells",
      moveCell2: "Move and do not resize the cell",
      moveCell3: "Do not move and resize the cell",
      fixedPos: "Fixed position",
      border: "Border",
      width: "Width",
      radius: "Radius",
      style: "Style",
      solid: "Solid",
      dashed: "Dashed",
      dotted: "Dotted",
      double: "Double",
      color: "Color"
    },
    punctuation: {
      tab: "Tab",
      semicolon: "semicolon",
      comma: "comma",
      space: "space"
    },
    findAndReplace: {
      find: "Find",
      replace: "Replace",
      goto: "Go to",
      location: "Location",
      formula: "Formula",
      date: "Date",
      number: "Number",
      string: "String",
      error: "Error",
      condition: "Condition",
      rowSpan: "Row span",
      columnSpan: "Column span",
      locationExample: "Location",
      lessTwoRowTip: "Please select at least two rows",
      lessTwoColumnTip: "Please select at least two columns",
      findTextbox: "Find Content",
      replaceTextbox: "Replace Content",
      regexTextbox: "Regular Expression",
      wholeTextbox: "Whole word",
      distinguishTextbox: "Case sensitive",
      allReplaceBtn: "Replace All",
      replaceBtn: "Replace",
      allFindBtn: "Find All",
      findBtn: "Find next",
      noFindTip: "The content was not found",
      modeTip: "This operation is not available in this mode",
      searchTargetSheet: "Sheet",
      searchTargetCell: "Cell",
      searchTargetValue: "Value",
      searchInputTip: "Please enter the search content",
      noReplceTip: "There is nothing to replace",
      noMatchTip: "No match found",
      successTip: "${xlength} items found",
      locationConstant: "Constant",
      locationFormula: "Formula",
      locationDate: "Date",
      locationDigital: "Number",
      locationString: "String",
      locationBool: "Logical",
      locationError: "Error",
      locationNull: "Null",
      locationCondition: "Conditional format",
      locationRowSpan: "Row span",
      locationColumnSpan: "Column span",
      locationTiplessTwoRow: "Please select at least two rows",
      locationTiplessTwoColumn: "Please select at least two columns",
      locationTipNotFindCell: "Cell not found"
    },
    sheetconfig: {
      delete: "Delete",
      copy: "Copy",
      rename: "Rename",
      changeColor: "Change color",
      hide: "Hide",
      unhide: "Unhide",
      moveLeft: "Move left",
      moveRight: "Move right",
      resetColor: "Reset color",
      cancelText: "Cancel",
      chooseText: "Confirm color",
      focus: "Focus",
      tipNameRepeat: "The name of the tab page cannot be repeated! Please revise",
      noMoreSheet: "The workbook contains at least one visual worksheet. To delete the selected worksheet, please insert a new worksheet or show a hidden worksheet.",
      confirmDelete: "Are you sure to delete",
      redoDelete: "Can be undo by Ctrl+Z",
      noHide: "Can't hide, at least keep one sheet tag",
      chartEditNoOpt: "This operation is not allowed in chart editing mode!",
      sheetNameSpecCharError: `The name cannot contain:[ ] :  ? * / ' "`,
      sheetNamecannotIsEmptyError: "Sheet name cannot be empty"
    },
    conditionformat: {
      conditionformat_greaterThan: "Conditionformat-GreaterThan",
      conditionformat_greaterThan_title: "Format cells greater than",
      conditionformat_lessThan: "Conditionformat-LessThan",
      conditionformat_lessThan_title: "Format cells smaller than",
      conditionformat_between: "Conditionformat-Betweenness",
      conditionformat_between_title: "Format cells with values between",
      conditionformat_equal: "Conditionformat-Equal",
      conditionformat_equal_title: "Format cells equal to",
      conditionformat_textContains: "Conditionformat-TextContains",
      conditionformat_textContains_title: "Format cells containing the following text",
      conditionformat_occurrenceDate: "Conditionformat-OccurrenceDate",
      conditionformat_occurrenceDate_title: "Format cells containing the following dates",
      conditionformat_duplicateValue: "Conditionformat-DuplicateValue",
      conditionformat_duplicateValue_title: "Format cells containing the following types of values",
      conditionformat_top10: "Conditionformat-Top10",
      conditionformat_top10_percent: "Conditionformat-Top10%",
      conditionformat_top10_title: "Format the cells with the highest value",
      conditionformat_last10: "Conditionformat-Last10",
      conditionformat_last10_percent: "Conditionformat-Last10%",
      conditionformat_last10_title: "Format the cells with the smallest value",
      conditionformat_aboveAverage: "Conditionformat-AboveAverage",
      conditionformat_aboveAverage_title: "Format cells above average",
      conditionformat_belowAverage: "Conditionformat-SubAverage",
      conditionformat_belowAverage_title: "Format cells below average",
      rule: "Rule",
      newRule: "New rule",
      editRule: "Edit rule",
      deleteRule: "Delete rule",
      deleteCellRule: "Delete cell rule",
      deleteSheetRule: "Delete sheet rule",
      manageRules: "Management rules",
      showRules: "Show its formatting rules",
      highlightCellRules: "Highlight cell rules",
      itemSelectionRules: "Item selection rules",
      conditionformatManageRules: "Conditional Formatting Rule Manager",
      format: "Format",
      setFormat: "Set format",
      setAs: "Set as",
      setAsByArea: "For the selected area, set to",
      applyRange: "Apply range",
      selectRange: "Select application range",
      selectRange_percent: "Percentage of selected range",
      selectRange_average: "Average value of selected range",
      selectRange_value: "Value in the selected range",
      pleaseSelectRange: "Please select application range",
      selectDataRange: "Select data range",
      selectCell: "select cell",
      pleaseSelectCell: "Please select cell",
      pleaseSelectADate: "Please select a date",
      pleaseEnterInteger: "Please enter an integer between 1 and 1000",
      onlySingleCell: "Only a single cell can be referenced",
      conditionValueCanOnly: "The condition value can only be a number or a single cell",
      ruleTypeItem1: "Format all cells based on their respective values",
      ruleTypeItem2: "Only format cells that contain",
      ruleTypeItem2_title: "Only for cells that meet the following conditions",
      ruleTypeItem3: "Format only the top or bottom numbers",
      ruleTypeItem3_title: "Is the value in the following ranking",
      ruleTypeItem4: "Format only values above or below the average",
      ruleTypeItem4_title: "Is a value that satisfies the following conditions",
      ruleTypeItem5: "Format only unique or repeated values",
      ruleTypeItem6: "Use formulas to determine which cells to format",
      formula: "Formula",
      textColor: "Text color",
      cellColor: "Cell color",
      confirm: "Confirm",
      confirmColor: "Confirm color",
      cancel: "Cancel",
      close: "Close",
      clearColorSelect: "Clear color select",
      sheet: "Sheet",
      currentSheet: "Current Sheet",
      dataBar: "data bar",
      dataBarColor: "data bar color",
      gradientDataBar_1: "Blue-white gradient data bar",
      gradientDataBar_2: "Green-white gradient data bar",
      gradientDataBar_3: "Red-white gradient data bar",
      gradientDataBar_4: "Orange-white gradient stripes",
      gradientDataBar_5: "Light blue-white gradient stripes",
      gradientDataBar_6: "Purple-white gradient data bar",
      solidColorDataBar_1: "Blue data bar",
      solidColorDataBar_2: "Green data bar",
      solidColorDataBar_3: "Red data bar",
      solidColorDataBar_4: "Orange data bar",
      solidColorDataBar_5: "Light blue data bar",
      solidColorDataBar_6: "Purple data bar",
      colorGradation: "color gradation",
      colorGradation_1: "Green-yellow-red color gradation",
      colorGradation_2: "Red-yellow-green color gradation",
      colorGradation_3: "Green-white-red color gradation",
      colorGradation_4: "Red-white-green color gradation",
      colorGradation_5: "Blue-white-red color gradation",
      colorGradation_6: "Red-white-blue color gradation",
      colorGradation_7: "White-red color gradation",
      colorGradation_8: "Red-white color gradation",
      colorGradation_9: "Green-white color gradation",
      colorGradation_10: "White-green color gradation",
      colorGradation_11: "Green-yellow color gradation",
      colorGradation_12: "Yellow-green color gradation",
      icons: "icons",
      pleaseSelectIcon: "Please click to select a group of icons:",
      cellValue: "Cell value",
      specificText: "Specific text",
      occurrenceDate: "Date",
      greaterThan: "Greater than",
      lessThan: "Less than",
      between: "Between",
      equal: "Equal",
      in: "In",
      between2: "",
      contain: "Contain",
      textContains: "Text contains",
      duplicateValue: "Duplicate value",
      uniqueValue: "Unique value",
      top: "Top",
      top10: "Top 10",
      top10_percent: "Top 10%",
      last: "Last",
      last10: "Last 10",
      last10_percent: "Last 10%",
      oneself: "",
      above: "Above",
      aboveAverage: "Above average",
      below: "Below",
      belowAverage: "Below average",
      all: "All",
      yesterday: "YTD",
      today: "Today",
      tomorrow: "Tomorrow",
      lastWeek: "Last week",
      thisWeek: "This week",
      lastMonth: "Last month",
      thisMonth: "This month",
      lastYear: "Last year",
      thisYear: "This year",
      last7days: "Last 7 days",
      last30days: "Last 30 days",
      next7days: "Next 7 days",
      next30days: "Next 30 days",
      next60days: "Next 60 days",
      chooseRuleType: "Choose rule type",
      editRuleDescription: "Edit rule description",
      newFormatRule: "New format rule",
      editFormatRule: "Edit format rule",
      formatStyle: "Style",
      fillType: "Fill",
      color: "Color",
      twocolor: "Two-color",
      tricolor: "Tricolor",
      multicolor: "Multi color",
      grayColor: "Gray color",
      gradient: "Gradient",
      solid: "Solid",
      maxValue: "Max value",
      medianValue: "Median value",
      minValue: "Min value",
      direction: "Direction",
      threeWayArrow: "Three-way arrow",
      fourWayArrow: "Four-way arrow",
      fiveWayArrow: "Five-way arrow",
      threeTriangles: "Three triangles",
      shape: "Shape",
      threeColorTrafficLight: "Three-color traffic light",
      fourColorTrafficLight: "Four-color traffic light",
      threeSigns: "Three signs",
      greenRedBlackGradient: "Green-red-black gradient",
      rimless: "Rimless",
      bordered: "Bordered",
      mark: "Mark",
      threeSymbols: "Three symbols",
      tricolorFlag: "Tricolor flag",
      circled: "Circled",
      noCircle: "No circle",
      grade: "Grade",
      grade4: "4 Grade",
      grade5: "5 Grade",
      threeStars: "3 Stars",
      fiveQuadrantDiagram: "Five-quadrant diagram",
      fiveBoxes: "5 Boxes"
    },
    insertLink: {
      linkText: "Display text",
      linkType: "Link type",
      linkAddress: "Link address",
      linkSheet: "Worksheet",
      linkCell: "Cell range",
      linkTooltip: "Tooltip",
      selectCellRange: "Select cell range",
      cellRangePlaceholder: "Select cells using the cursor or enter directly",
      placeholder1: "Please enter the web link address",
      placeholder2: "Please enter the cell to be quoted, example A1",
      placeholder3: "Please enter the prompt content",
      tooltipInfo1: "Please enter a valid link",
      invalidCellRangeTip: "Please enter the correct ell range, such as Sheet1!A1:C8",
      openLink: "Open link",
      goTo: "Go to ${linkAddress}"
    },
    linkTypeList: [{
      text: "Webpages",
      value: "webpage"
    }, {
      text: "Cell range",
      value: "cellrange"
    }, {
      text: "Sheet",
      value: "sheet"
    }],
    dataVerification: {
      cellRange: "Cell range",
      selectCellRange: "Click to select a cell range",
      selectCellRange2: "Please select a range of cells",
      verificationCondition: "Verification condition",
      allowMultiSelect: "Allow multiple selection",
      dropdown: "drop-down list",
      checkbox: "Checkbox",
      number: "Number",
      number_integer: "Number-integer",
      number_decimal: "Number-decimal",
      text_content: "Text-content",
      text_length: "Text-length",
      date: "Date",
      validity: "Effectiveness",
      placeholder1: "Please enter the options, separated by commas, such as 1,2,3,4,5",
      placeholder2: "Please enter content",
      placeholder3: "Numeric value, such as 10",
      placeholder4: "Please enter the specified text",
      placeholder5: "Please enter the prompt displayed when the cell is selected",
      selected: "Selected",
      notSelected: "Not selected",
      between: "Between",
      notBetween: "Not between",
      equal: "Equal",
      notEqualTo: "Not equal to",
      moreThanThe: "More than the",
      lessThan: "Less than",
      greaterOrEqualTo: "Greater or equal to",
      lessThanOrEqualTo: "Less than or equal to",
      include: "Include",
      exclude: "Exclude",
      earlierThan: "Earlier than",
      noEarlierThan: "No earlier than",
      laterThan: "Later than",
      noLaterThan: "No later than",
      identificationNumber: "Identification number",
      phoneNumber: "Phone number",
      remote: "Automatic remote acquisition option",
      prohibitInput: "Prohibit input when input data is invalid",
      hintShow: "Show prompt when the cell is selected",
      deleteVerification: "Delete verification",
      tooltipInfo1: "The drop-down list option cannot be empty",
      tooltipInfo2: "Checkbox content cannot be empty",
      tooltipInfo3: "The value entered is not a numeric type",
      tooltipInfo4: "The value 2 cannot be less than the value 1",
      tooltipInfo5: "The text content cannot be empty",
      tooltipInfo6: "The value entered is not a date type",
      tooltipInfo7: "Date 2 cannot be less than date 1",
      textlengthInteger: "Text length must be an integer greater than or equal to 0"
    },
    formula: {
      sum: "Sum",
      average: "Average",
      count: "Count",
      max: "Max",
      min: "Min",
      ifGenerate: "If formula generator",
      find: "Learn more",
      tipNotBelongToIf: "This cell function does not belong to the if formula!",
      tipSelectCell: "Please select the cell to insert the function",
      ifGenCompareValueTitle: "Comparison value",
      ifGenSelectCellTitle: "Click to select cell",
      ifGenRangeTitle: "Range",
      ifGenRangeTo: "to",
      ifGenRangeEvaluate: "Range evaluate",
      ifGenSelectRangeTitle: "Click to select range",
      ifGenCutWay: "Partition way",
      ifGenCutSame: "Same Partition value",
      ifGenCutNpiece: "Partition by N",
      ifGenCutCustom: "Custom",
      ifGenCutConfirm: "Confirm",
      ifGenTipSelectCell: "Select cells",
      ifGenTipSelectCellPlace: "Please select cells",
      ifGenTipSelectRange: "Select range",
      ifGenTipSelectRangePlace: "Please select range",
      ifGenTipNotNullValue: "The comparison value cannot be empty!",
      ifGenTipLableTitile: "Label",
      ifGenTipRangeNotforNull: "The range cannot be empty!",
      ifGenTipCutValueNotforNull: "The partition value cannot be empty!",
      ifGenTipNotGenCondition: "No conditions are available for generation!"
    },
    formulaMore: {
      valueTitle: "Value",
      tipSelectDataRange: "Select data range",
      tipDataRangeTile: "Data range",
      findFunctionTitle: "Search function",
      tipInputFunctionName: "Function name or brief description of function",
      Array: "Array",
      Database: "Database",
      Date: "Date",
      Engineering: "Engineering",
      Filter: "Filter",
      Financial: "Financial",
      luckysheet: "Luckysheet",
      other: "Other",
      Logical: "Logical",
      Lookup: "Lookup",
      Math: "Math",
      Operator: "Operator",
      Parser: "Parser",
      Statistical: "Statistical",
      Text: "Text",
      dataMining: "Data Mining",
      selectFunctionTitle: "Select a function",
      calculationResult: "Result",
      tipSuccessText: "Success",
      tipParamErrorText: "Parameter type error",
      helpClose: "Close",
      helpCollapse: "Collapse",
      helpExample: "Example",
      helpAbstract: "Abstract",
      execfunctionError: "Error in the formula",
      execfunctionSelfError: "The formula cannot refer to its own cell",
      execfunctionSelfErrorResult: "The formula cannot refer to its own cell, which will lead to inaccurate calculation results",
      allowRepeatText: "Repeatable",
      allowOptionText: "Optional",
      selectCategory: "Or select a category"
    },
    drag: {
      noMerge: "Cannot perform this operation on merged cells",
      affectPivot: "This change cannot be made to the selected cell because it will affect the pivot table!",
      noMulti: "Cannot perform this operation on multiple selection areas, please select a single area",
      noPaste: "Unable to paste this content here, please select a cell in the paste area and try to paste again",
      noPartMerge: "Cannot perform this operation on partially merged cells",
      inputCorrect: "Please enter the correct value",
      notLessOne: "The number of rows and columns cannot be less than 1",
      offsetColumnLessZero: "The offset column cannot be negative!",
      pasteMustKeybordAlert: "在表格中进行复制粘贴: Ctrl + C 进行复制, Ctrl + V 进行粘贴, Ctrl + X 进行剪切",
      pasteMustKeybordAlertHTMLTitle: "在表格中进行复制粘贴",
      pasteMustKeybordAlertHTML: "<span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + C</span>&nbsp;&nbsp;进行复制<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + V</span>&nbsp;&nbsp;进行粘贴<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + X</span>&nbsp;&nbsp;进行剪切"
    },
    pivotTable: {
      title: "Pivot Table",
      closePannel: "Close",
      editRange: "Range",
      tipPivotFieldSelected: "Select the fields",
      tipClearSelectedField: "Clear all fields",
      btnClearSelectedField: "Clear",
      btnFilter: "Filter",
      titleRow: "Row",
      titleColumn: "Column",
      titleValue: "Value",
      tipShowColumn: "Statistics fields are displayed as columns",
      tipShowRow: "Statistics fields are displayed as rows",
      titleSelectionDataRange: "Select range",
      titleDataRange: "Data range",
      valueSum: "SUM",
      valueStatisticsSUM: "Sum",
      valueStatisticsCOUNT: "Count",
      valueStatisticsCOUNTA: "Count A",
      valueStatisticsCOUNTUNIQUE: "Count Unique",
      valueStatisticsAVERAGE: "Average",
      valueStatisticsMAX: "Max",
      valueStatisticsMIN: "Min",
      valueStatisticsMEDIAN: "Median",
      valueStatisticsPRODUCT: "Product",
      valueStatisticsSTDEV: "Stdev",
      valueStatisticsSTDEVP: "Stdevp",
      valueStatisticslet: "Var",
      valueStatisticsVARP: "VarP",
      errorNotAllowEdit: "This operation is prohibited in non-editing mode!",
      errorNotAllowMulti: "Cannot perform this operation on multiple selection areas, please select a single range and try again",
      errorSelectRange: "Please select the range of the new pivot table",
      errorIsDamage: "The source data of this pivot table is corrupted!",
      errorNotAllowPivotData: "Cannot select pivot table as source data!",
      errorSelectionRange: "Selection failed, wrong input range!",
      errorIncreaseRange: "Please expand the selected range!",
      titleAddColumn: "Add column to pivot table",
      titleMoveColumn: "Move the column to the white box below",
      titleClearColumnFilter: "Clear the filter for this column",
      titleFilterColumn: "Filter",
      titleSort: "Sort",
      titleNoSort: "No sort",
      titleSortAsc: "ASC",
      titleSortDesc: "DESC",
      titleSortBy: "Sort by",
      titleShowSum: "Show total",
      titleStasticTrue: "Yes",
      titleStasticFalse: "No"
    },
    dropCell: {
      copyCell: "Copy",
      sequence: "Sequence",
      onlyFormat: "Only format",
      noFormat: "Not format",
      day: "Day",
      workDay: "Work Day",
      month: "Month",
      year: "Year",
      chineseNumber: "Chinese numbers"
    },
    imageCtrl: {
      borderTile: "Image border color",
      borderCur: "Color"
    },
    protection: {
      protectiontTitle: "Protection",
      enterPassword: "Enter a password (optional)",
      enterHintTitle: "Prompt when editing is prohibited (optional)",
      enterHint: "The cell or chart you are trying to change is in a protected worksheet. If you want to change it, please unprotect the worksheet. You may need to enter a password",
      swichProtectionTip: "Protect the sheet and contents of locked cells",
      authorityTitle: "Allow users of this sheet to:",
      selectLockedCells: "Select locked cells",
      selectunLockedCells: "Select unlocked cells",
      formatCells: "Format cells",
      formatColumns: "Format columns",
      formatRows: "Format rows",
      insertColumns: "Insert columns",
      insertRows: "Insert rows",
      insertHyperlinks: "Insert hyperlinks",
      deleteColumns: "Delete columns",
      deleteRows: "Delete rows",
      sort: "Sort",
      filter: "Filter",
      usePivotTablereports: "Use Pivot Table reports",
      editObjects: "Edit objects",
      editScenarios: "Edit scenarios",
      allowRangeTitle: "Allow users of range to:",
      allowRangeAdd: "New...",
      allowRangeAddTitle: "Title",
      allowRangeAddSqrf: "Reference",
      selectCellRange: "Click to select a cell range",
      selectCellRangeHolder: "Cell range",
      allowRangeAddTitlePassword: "Password",
      allowRangeAddTitleHint: "Prompt",
      allowRangeAddTitleHintTitle: "Prompt when a password is set (optional)",
      allowRangeAddtitleDefault: "Input range name",
      rangeItemDblclick: "Double click to edit",
      rangeItemHasPassword: "Has password",
      rangeItemErrorTitleNull: "Title is null",
      rangeItemErrorRangeNull: "Reference is null",
      rangeItemErrorRange: "Reference is error",
      validationTitle: "Password validation",
      validationTips: "Need to enter a password to unlock the protection of the worksheet",
      validationInputHint: "Enter a password",
      checkPasswordNullalert: "Password is required!",
      checkPasswordWrongalert: "Incorrect password, please try again!",
      checkPasswordSucceedalert: "Unlock Succeed!",
      defaultRangeHintText: "The cell is being password protected.",
      defaultSheetHintText: "The cell or chart is in a protected worksheet. To make changes, please unprotect the worksheet. You may need to enter a password"
    },
    cellFormat: {
      cellFormatTitle: "Format cells",
      protection: "Protection",
      locked: "Locked",
      hidden: "Hidden",
      protectionTips: "To lock cells or hide formulas, protect the worksheet. On the toolbar, Click Protect Sheet Button",
      tipsPart: "Partial checked",
      tipsAll: "All checked",
      selectionIsNullAlert: "Selection is required!",
      sheetDataIsNullAlert: "error, Data is none!"
    },
    print: {
      normalBtn: "Normal",
      layoutBtn: "Page Layout",
      pageBtn: "Page break preview",
      menuItemPrint: "Print (Ctrl+P)",
      menuItemAreas: "Print areas",
      menuItemRows: "Print title rows",
      menuItemColumns: "Print title columns"
    },
    edit: {
      typing: "typing"
    },
    websocket: {
      success: "WebSocket connection success",
      refresh: "An error occurred in the WebSocket connection, please refresh the page!",
      wait: "An error occurred in the WebSocket connection, please be patient!",
      close: "WebSocket connection closed",
      contact: "Server communication error occurred, please refresh the page and try again, if not, please contact the administrator!",
      support: "The current browser does not support WebSocket"
    }
  };
  var zh = {
    generalDialog: {
      partiallyError: "无法对部分合并单元格执行此操作",
      readOnlyError: "无法对只读模式执行此操作",
      dataNullError: "无法对不存在的数据执行此操作",
      noSeletionError: "还未进行选区操作",
      cannotSelectMultiple: "无法选择多选区"
    },
    functionlist: [{
      n: "SUMIF",
      t: 0,
      d: "对范围中符合指定条件的值求和。",
      a: "对范围中符合指定条件的值求和。",
      m: [2, 3],
      p: [{
        name: "范围",
        detail: "要根据条件进行检测的范围。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "条件",
        detail: "要应用于范围的模式或测试条件。\n\n如果范围包含的是要检测的文本，则条件必须为字符串。条件可以包含通配符，包括用于匹配单个字符的?或用于匹配零个或连续多个字符的*。要匹配问号星号本身，请在该字符前面加上波浪号(~)前缀（即~?和~*）。字符串条件必须用引号括起来。函数会检查范围中的每个单元格与条件是否相等或匹配（如果使用了通配符）。\n\n如果范围包含的是要检测的数字，则条件可以是字符串也可以是数字。如果给定的条件是一个数字，则检查范围中的每个单元格是否等于条件。另外，条件也可能是包含数字的字符串（也将对其进行相等检测），或者带有以下前缀的数字：=（检查是否相等）、>（检查范围单元格的值是否大于条件值）或<（检查范围单元格的值是否小于条件值）",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "求和范围",
        detail: "要求和的范围（如果与范围不同）。",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TAN",
      t: 0,
      d: "返回已知角度的正切值。",
      a: "返回已知角度的正切值。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要求其正切值的角度，以弧度表示。",
        example: "45*PI()/180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TANH",
      t: 0,
      d: "返回给定实数的双曲正切值。",
      a: "返回给定实数的双曲正切值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其双曲正切值的实数。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CEILING",
      t: 0,
      d: "将数值向上取整为最接近的指定因数的倍数。",
      a: "将数值向上取整为最接近的指定因数的倍数。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要向上舍入的数值。",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因数",
        detail: "要将值舍入到此数的整数倍。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN",
      t: 0,
      d: "返回数值的反正切值，以弧度表示。",
      a: "返回数值的反正切值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反正切值的数值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ASINH",
      t: 0,
      d: "返回数值的反双曲正弦值。",
      a: "返回数值的反双曲正弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反双曲正弦值的数值。",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ABS",
      t: 0,
      d: "返回数值的绝对值。",
      a: "返回数值的绝对值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要返回其绝对值的数。",
        example: "-2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOS",
      t: 0,
      d: "返回数值的反余弦值，以弧度表示。",
      a: "返回数值的反余弦值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反余弦值的数值。必须介于-1和1之间，包括两端值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOSH",
      t: 0,
      d: "返回数值的反双曲余弦值。",
      a: "返回数值的反双曲余弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反双曲余弦值的数值。必须大于等于1。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTINOMIAL",
      t: 0,
      d: "返回参数和的阶乘除以各参数阶乘的乘积后得到的值。",
      a: "返回参数和的阶乘除以各参数阶乘的乘积后得到的值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "用于计算的第一项数值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "用于计算的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "ATANH",
      t: 0,
      d: "返回数值的反双曲正切值。",
      a: "返回数值的反双曲正切值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反双曲正切值的数值。必须介于-1和1之间（不包括-1和1）。",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN2",
      t: 0,
      d: "以弧度为单位返回 x 轴与从原点 (0,0) 到指定坐标点 (`x`,`y`) 之间连线的夹角。",
      a: "以弧度为单位返回 x 轴与从原点 (0,0) 到指定坐标点 (`x`,`y`) 之间连线的夹角。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "要计算其与x轴夹角大小的线段的终点x坐标。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "y",
        detail: "要计算其与x轴夹角大小的线段的终点y坐标。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTBLANK",
      t: 1,
      d: "返回给定范围内的空单元格数。",
      a: "返回给定范围内的空单元格数。",
      m: [1, 1],
      p: [{
        name: "范围",
        detail: "要统计空白单元格数量的范围。",
        example: "A2:C100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "COSH",
      t: 0,
      d: "返回给定实数的双曲余弦值。",
      a: "返回给定实数的双曲余弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其双曲余弦值的实数值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INT",
      t: 0,
      d: "将数值向下取整为小于或等于该数的最接近的整数。",
      a: "将数值向下取整为小于或等于该数的最接近的整数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向下取整为最接近的整数的数值。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISEVEN",
      t: 0,
      d: "检查所提供的数值是否为偶数。",
      a: "检查所提供的数值是否为偶数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要验证其是否为偶数的数值。\n\n如果值为偶数或指向包含偶数的单元格的引用，ISEVEN将返回TRUE，否则返回FALSE。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISODD",
      t: 0,
      d: "检查所提供的数值是否为奇数。",
      a: "检查所提供的数值是否为奇数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要验证其是否为奇数的数值。\n\n如果值为奇数或指向包含奇数的单元格，ISODD将返回TRUE，否则返回FALSE。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LCM",
      t: 0,
      d: "返回一个或多个整数的最小公倍数。",
      a: "返回一个或多个整数的最小公倍数。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要在求最小公倍数数的计算中检查其因数的第一项数值或范围。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可选] - 在求最小公倍数时要考虑其因数的其他数值或范围。",
        example: "3",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LN",
      t: 0,
      d: "返回数值以 e（欧拉数）为底的对数。",
      a: "返回数值以 e（欧拉数）为底的对数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要以 e 为底数计算其对数的值。\n\n值必须为正数。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG",
      t: 0,
      d: "根据指定底数返回数字的对数。",
      a: "根据指定底数返回数字的对数。",
      m: [1, 2],
      p: [{
        name: "值",
        detail: "想要计算其对数的正实数。",
        example: "128",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "底数",
        detail: "[可选] - 对数的底数。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG10",
      t: 0,
      d: "返回数值以10为底的对数。",
      a: "返回数值以10为底的对数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其以10为底的对数的数值。\n\n值必须为正值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MOD",
      t: 0,
      d: "返回两数相除的余数, 结果的符号与除数相同。",
      a: "返回两数相除的余数。",
      m: [2, 2],
      p: [{
        name: "被除数",
        detail: "要将其相除以得到余数的数值。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "除数",
        detail: "用于除其他数的数值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MROUND",
      t: 0,
      d: "将数值取整为另一整数最接近的整数倍。",
      a: "将数值取整为另一整数最接近的整数倍。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要取整为另一整数最接近的整数倍的数值。",
        example: "21",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因数",
        detail: "值将取此因数的整数倍。",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ODD",
      t: 0,
      d: "将数值向上取整为最接近的奇整数。",
      a: "将数值向上取整为最接近的奇整数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向上取整的数值，取整值为大于此值的最接近的奇数。\n\n如果值为负数，则将其取整为绝对值大于该值的相邻负奇数。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMSQ",
      t: 0,
      d: "返回一组数值和/或单元格的平方总和。",
      a: "返回一组数值和/或单元格的平方总和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要将其平方相加的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 要将其平方与值1的平方相加的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMBIN",
      t: 0,
      d: "给定集合中的对象总数和要选择的对象数量，返回共有多少种不同选择方式。",
      a: "给定集合中的对象总数和要选择的对象数量",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "要从中进行选择的对象集合的大小。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "要选择的对象数量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUM",
      t: 0,
      d: "返回一组数值和/或单元格的总和。",
      a: "返回一组数值和/或单元格的总和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要相加的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可选] - 要相加的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SUBTOTAL",
      t: 0,
      d: "使用指定的汇总函数，返回一系列纵向单元格的分类汇总。",
      a: "使用指定的汇总函数",
      m: [2, 256],
      p: [{
        name: "函数代码",
        detail: "用于计算分类汇总的函数。\n\n1代表AVERAGE\n\n2代表COUNT\n\n3代表COUNTA\n\n4代表MAX\n\n5代表MIN\n\n6代表PRODUCT\n\n7代表STDEV\n\n8代表STDEVP\n\n9代表SUM\n\n10代表VAR\n\n11代表VARP\n\n通过在这些2位代码前附加10（对于1位代码）或1（对于2位代码），可以将隐藏值忽略。例如，102代表忽略隐藏单元格的COUNT，而110则代表忽略隐藏值的VAR。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "范围1",
        detail: "要计算分类汇总的第一个范围。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "范围2",
        detail: "[可选] - 要计算分类汇总的其他范围。",
        example: "B2:B8",
        require: "o",
        repeat: "y",
        type: "range"
      }]
    }, {
      n: "ASIN",
      t: 0,
      d: "返回数值的反正弦值，以弧度表示。",
      a: "返回数值的反正弦值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其反正弦值的数值。必须介于-1和1之间，包括两端值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTIF",
      t: 1,
      d: "返回范围内满足某个条件的单元格的数量。",
      a: "返回范围内满足某个条件的单元格的数量。",
      m: [2, 2],
      p: [{
        name: "范围",
        detail: "要根据条件进行检测的范围。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "条件",
        detail: "要应用于范围的模式或测试条件。\n\n如果范围包含的是要检测的文本，则条件必须为字符串。条件可以包含通配符，包括用于匹配单个字符的?或用于匹配零个或连续多个字符的*。要匹配问号星号本身，请在该字符前面加上波浪号(~)前缀（即~?和~*）。字符串条件必须用引号括起来。函数会检查范围中的每个单元格与条件是否相等或匹配（如果使用了通配符）。\n\n如果范围包含的是要检测的数字，则条件可以是字符串也可以是数字。如果给定的条件是一个数字，则检查范围中的每个单元格是否等于条件。另外，条件也可能是包含数字的字符串（也将对其进行相等检测），或者带有以下前缀的数字：=、>、>=、<或<=，这些条件将分别用于检查范围中的单元格是否等于、大于、大于等于、小于、小于等于条件值。",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RADIANS",
      t: 0,
      d: "将以度表示的角度值转换为弧度。",
      a: "将以度表示的角度值转换为弧度。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要从度转换为弧度的角度。",
        example: "180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RAND",
      t: 0,
      d: "返回一个介于0和1之间（包括0但不包括1）的随机数。",
      a: "返回一个介于0和1之间（包括0但不包括1）的随机数。",
      m: [0, 0],
      p: []
    }, {
      n: "COUNTUNIQUE",
      t: 0,
      d: "计算一列指定值和范围中不重复数值的个数。",
      a: "计算一列指定值和范围中不重复数值的个数。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要检查其是否唯一的第一个值或范围。",
        example: "A1:C100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可选] - 要检查是否唯一的其他值或范围。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DEGREES",
      t: 0,
      d: "将以弧度表示的角度值转换为度。",
      a: "将以弧度表示的角度值转换为度。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要从弧度转换为度的角度。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ERFC",
      t: 9,
      d: "返回数值的互补高斯误差函数。",
      a: "返回数值的互补高斯误差函数。",
      m: [1, 1],
      p: [{
        name: "z",
        detail: "要为其计算互补高斯误差函数的数值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVEN",
      t: 0,
      d: "将数值向上取整为最接近的偶整数。",
      a: "将数值向上取整为最接近的偶整数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向上取整的数值，取整值为大于此值的最接近的偶数。\n\n如果值为负数，则将其取整为绝对值大于该值的相邻负偶数。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EXP",
      t: 0,
      d: "返回欧拉数 e (~2.718) 的指定次幂。",
      a: "返回欧拉数 e (~2.718) 的指定次幂。",
      m: [1, 1],
      p: [{
        name: "指数",
        detail: "指定e的自乘幂次值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACT",
      t: 0,
      d: "返回数值的阶乘。",
      a: "返回数值的阶乘。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算并返回其阶乘的数字或对数字（所在单元格）的引用。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACTDOUBLE",
      t: 0,
      d: "返回数值的“双阶乘”。",
      a: "返回数值的“双阶乘”。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算并返回其双阶乘的数字或对数字（所在单元格）的引用。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PI",
      t: 0,
      d: "返回带有14位小数的 PI 值。",
      a: "返回带有14位小数的 PI 值。",
      m: [0, 0],
      p: []
    }, {
      n: "FLOOR",
      t: 0,
      d: "将数值向下取整为指定因数的最接近的整数倍。",
      a: "将数值向下取整为指定因数的最接近的整数倍。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要向下舍入为因数的最接近整数倍的数值。",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因数",
        detail: "要将值舍入到此数的整数倍。\n\n因数不得为0。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GCD",
      t: 0,
      d: "返回一个或多个整数的最大公约数。",
      a: "返回一个或多个整数的最大公约数。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要在查找最大公约数的计算中检查其因数的第一项数值或范围。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可选] - 在求最大公约数时要考虑其因数的其他数值或范围。",
        example: "96",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANDBETWEEN",
      t: 0,
      d: "返回介于两个整数之间（包括这两个整数）的随机数。",
      a: "返回介于两个整数之间（包括这两个整数）的随机数。",
      m: [2, 2],
      p: [{
        name: "下界",
        detail: "随机值范围的下界。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "上界",
        detail: "随机值范围的上界。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUND",
      t: 0,
      d: "将数字四舍五入到指定的位数。",
      a: "将数字四舍五入到指定的位数。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要四舍五入的数字。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位数",
        detail: "要进行四舍五入运算的位数。\n\n位数可以取负值，在这种情况下会将值的小数点左侧部分舍入到指定的位数。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDDOWN",
      t: 0,
      d: "朝着零的方向将数字进行向下舍入。",
      a: "朝着零的方向将数字进行向下舍入。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "需要向下舍入的任意实数。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位数",
        detail: "要通过舍入达到的小数位数。\n\n位数可以取负值，在这种情况下会将值的小数点左侧部分舍入到指定的位数。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDUP",
      t: 0,
      d: "朝着远离 0（零）的方向将数字进行向上舍入。",
      a: "朝着远离 0（零）的方向将数字进行向上舍入。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要将其舍入为位数位数字的值，始终向上舍入。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位数",
        detail: "要通过舍入达到的小数位数。\n\n位数可以取负值，在这种情况下会将值的小数点左侧部分舍入到指定的位数。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SERIESSUM",
      t: 0,
      d: "给定参数 x、n、m 和 a，返回幂级数的和 a1xn + a2x(n+m) + ... + aix(n+(i-1)m)，其中 i 为范围 a 中的项数。",
      a: "给定参数 x、n、m 和 a",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "幂级数的输入值。随相应的近似类型而变，有可能为角度、指数或其他一些值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "在幂级数中x的初始自乘幂次。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "m",
        detail: "x的幂次中的附加增量。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "a",
        detail: "包含幂级数系数的数组或范围。",
        example: "{FACT(0)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIGN",
      t: 0,
      d: "给定输入数值，如果为负返回-1；如果为正返回1；如果为零则返回0。",
      a: "给定输入数值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要返回其符号的数值。",
        example: "-42",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIN",
      t: 0,
      d: "给定角度（以弧度表示），返回其正弦值。",
      a: "给定角度（以弧度表示）",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要返回其正弦值的角度，以弧度表示。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SINH",
      t: 0,
      d: "返回给定实数的双曲正弦值。",
      a: "返回给定实数的双曲正弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其双曲正弦值的实数值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRT",
      t: 0,
      d: "返回一个正数的正平方根。",
      a: "返回一个正数的正平方根。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要计算其正平方根的数值。\n\n值必须为正数；如果为负，SQRT 将返回 #NUM! 错误。",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRTPI",
      t: 0,
      d: "返回 PI 与给定正数乘积的正平方根。",
      a: "返回 PI 与给定正数乘积的正平方根。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要将其与 PI 相乘并返回该乘积的平方根的数值\n\n值必须为正数；如果为负数，SQRTPI 将返回 #NUM! 错误。",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GAMMALN",
      t: 1,
      d: "返回指定伽玛函数的以 e（欧拉数）为底的对数。",
      a: "返回指定伽玛函数的以 e（欧拉数）为底的对数。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "伽玛函数的输入值。返回的将是伽玛 (值) 的自然对数。\n\n值必须为正数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COS",
      t: 0,
      d: "返回给定角度的余弦值（角度以弧度表示）。",
      a: "返回给定角度的余弦值（角度以弧度表示）。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要取其余弦值的角度，以弧度表示。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRUNC",
      t: 0,
      d: "截除指定有效位之外的部分，取数据的指定有效位。",
      a: "截除指定有效位之外的部分",
      m: [1, 2],
      p: [{
        name: "值",
        detail: "要截取的数据。",
        example: "3.141592654",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位数",
        detail: "[可选 - 默认值为0] - 小数点右侧要保留的有效位数。\n\n如果位数大于值中的有效位数，则将“值”原样返回。\n\n位数可以取负值，在这种情况下会将小数点左侧指定位数的值更改为零。小数点右侧的所有位数都会被舍弃。如果值的所有位都被更改为零，则TRUNC会返回0。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUOTIENT",
      t: 0,
      d: "返回以一个数除以另一个数所得的结果，不包含余数。",
      a: "返回以一个数除以另一个数所得的结果",
      m: [2, 2],
      p: [{
        name: "被除数",
        detail: "要被除的数值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "除数",
        detail: "用于除其他数的数值。\n\n除数不得为0。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POWER",
      t: 0,
      d: "返回数值的指定次幂。",
      a: "返回数值的指定次幂。",
      m: [2, 2],
      p: [{
        name: "底数",
        detail: "要计算其指数次幂的数值。\n\n如果底数为负，则指数必须为整数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "指数",
        detail: "指定底数的自乘幂次值。",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMIFS",
      t: 0,
      d: "根据多项条件返回范围之和。",
      a: "根据多项条件返回范围之和。",
      m: [3, 257],
      p: [{
        name: "求和范围",
        detail: "要对其求和的范围。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "条件范围1",
        detail: "要在哪个范围内检查条件1。",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "条件1",
        detail: "要应用于条件范围1的模式或测试条件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "条件范围2, 条件2...",
        detail: "[ 可选 ] - 要检查的其他范围和条件。",
        example: " C1:C10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTIFS",
      t: 1,
      d: "根据多项条件返回范围中的单元格数量。",
      a: "根据多项条件返回范围中的单元格数量。",
      m: [2, 256],
      p: [{
        name: "条件范围1",
        detail: "要在哪个范围内检查条件1。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "条件1",
        detail: "要应用于条件范围1的模式或测试条件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "条件范围2, 条件2...",
        detail: "[ 可选 ] - 要检查的其他范围和条件，可重复。",
        example: " B1:B10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PRODUCT",
      t: 0,
      d: "返回将一组数相乘所得的结果。",
      a: "返回将一组数相乘所得的结果。",
      m: [1, 255],
      p: [{
        name: "乘数1",
        detail: "用于计算乘积的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "乘数2 ... 乘数30",
        detail: "[可选] - 要相乘的其他数值。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HARMEAN",
      t: 1,
      d: "计算数据集的调和平均值。",
      a: "计算数据集的调和平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HYPGEOMDIST",
      t: 1,
      d: "返回超几何分布。 如果已知样本量、总体成功次数和总体大小，则 HYPGEOM.DIST 返回样本取得已知成功次数的概率。",
      a: "返回超几何分布。",
      m: [5, 5],
      p: [{
        name: "Sample_s",
        detail: "样本中成功的次数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Number_sample",
        detail: "样本量。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Population_s",
        detail: "总体中成功的次数。",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Number_pop",
        detail: "总体大小。",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函数形式的逻辑值。\n\n如果 cumulative 为 TRUE()，则 HYPGEOM.DIST 返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INTERCEPT",
      t: 1,
      d: "计算数据集的线性回归方程直线与 Y 轴的相交点 (x=0) 的 y 值。",
      a: "计算数据集的线性回归方程直线与 Y 轴的相交点 (x=0) 的 y 值。",
      m: [2, 2],
      p: [{
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "KURT",
      t: 1,
      d: "计算数据集的峭度，该指标指示数据集（分布）的形态，尤其是该形态的陡峭程度。",
      a: "计算数据集的峭度",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "数据集中的第一个值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LARGE",
      t: 1,
      d: "返回数据集中第 n 个最大元素，n 由用户指定。",
      a: "返回数据集中第 n 个最大元素",
      m: [2, 2],
      p: [{
        name: "数据",
        detail: "包含相关数据集的数组或范围。",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "要返回的元素的排行位置（从大到小顺序）。\n\n例如，将n设为4将使LARGE返回数据中排名第4的最大元素。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVA",
      t: 1,
      d: "基于样本计算标准偏差，将文本取值为0。",
      a: "基于样本计算标准偏差",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2,…",
        detail: "[可选] - 样本中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVP",
      t: 1,
      d: "基于样本总体计算标准偏差。",
      a: "基于样本总体计算标准偏差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "数据集中的第一个值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "GEOMEAN",
      t: 1,
      d: "计算数据集的几何平均值。",
      a: "计算数据集的几何平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANK_EQ",
      t: 1,
      d: "返回指定值在数据集中的排名。如果相同的值在数据集中存在多项，则返回其中的最高排名。",
      a: "返回指定值在数据集中的排名。如果相同的值在数据集中存在多项，则返回其中的最高排名。",
      m: [2, 3],
      p: [{
        name: "number",
        detail: "要确定其排名的值。",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "ref",
        detail: "包含相关数据集的数组或范围。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "order",
        detail: "[可选 - 默认为按降序 (FALSE()) ] - 要按升序还是按降序考虑“data”中的值。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANK_AVG",
      t: 1,
      d: "返回指定值在数据集中的排名。如果相同的值在数据集中存在多项，则返回这些项排名的平均值。",
      a: "返回指定值在数据集中的排名。如果相同的值在数据集中存在多项，则返回这些项排名的平均值。",
      m: [2, 3],
      p: [{
        name: "number",
        detail: "要确定其排名的值。",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "ref",
        detail: "包含相关数据集的数组或范围。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "order",
        detail: "[可选 - 默认为按降序 (FALSE()) ] - 要按升序还是按降序考虑“data”中的值。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERCENTRANK_EXC",
      t: 1,
      d: "以百分数形式返回指定值在给定数据集中的百分比排名（介于0和1之间，不包括两端值）。",
      a: "以百分数形式返回指定值在给定数据集中的百分比排名（介于0和1之间，不包括两端值）。",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "包含相关数据集的数组或范围。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "x",
        detail: "要确定其百分比排位的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significance",
        detail: "[可选 - 默认值为 3] - 要在计算中使用的有效位数。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTRANK_INC",
      t: 1,
      d: "以百分比形式返回指定值在给定数据集中的百分比排名（介于0和1之间，包括两端值）。",
      a: "以百分比形式返回指定值在给定数据集中的百分比排名（介于0和1之间，包括两端值）。",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "包含相关数据集的数组或范围。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "x",
        detail: "要确定其百分比排位的值。",
        example: " A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significance",
        detail: "[可选 - 默认值为 3] - 要在计算中使用的有效位数。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FORECAST",
      t: 1,
      d: "基于数据集的线性回归，计算指定 x 的预期 y 值。",
      a: "基于数据集的线性回归",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "x轴上用于预测的值。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHERINV",
      t: 1,
      d: "返回指定数值的 Fisher 逆变换。",
      a: "返回指定数值的 Fisher 逆变换。",
      m: [1, 1],
      p: [{
        name: "y",
        detail: "要计算其Fisher逆变换的数值。",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHER",
      t: 1,
      d: "返回指定数值的 Fisher 变换。",
      a: "返回指定数值的 Fisher 变换。",
      m: [1, 1],
      p: [{
        name: "x",
        detail: "要计算其Fisher变换的数值。",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MODE_SNGL",
      t: 1,
      d: "返回数据集中出现次数最多的值。",
      a: "返回数据集中出现次数最多的值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算模式时要检查的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计算模式时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "WEIBULL_DIST",
      t: 1,
      d: "给定形状和尺度，返回韦伯分布函数（或韦伯累积分布函数）的值。",
      a: "给定形状和尺度",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "WEIBULL 分布函数的输入值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "alpha",
        detail: "Weibull 分布函数的形状参数。\n\nalpha 值必须大于 0。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "beta",
        detail: "Weibull 分布函数的尺度参数。\n\nbeta 值必须大于 0。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "TRUE() 表示使用累积分布函数，FALSE() 则表示使用概率密度函数。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COUNT",
      t: 1,
      d: "返回数据集中数值的个数。",
      a: "返回数据集中数值的个数。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计数时要检查的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计数时要检查的其他值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTA",
      t: 1,
      d: "返回数据集中值的数量。",
      a: "返回数据集中值的数量。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计数时要检查的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计数时要检查的其他值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVEDEV",
      t: 1,
      d: "计算数据与数据集均值之间的偏差大小的平均值。",
      a: "计算数据与数据集均值之间的偏差大小的平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 样本中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "AVERAGE",
      t: 1,
      d: "返回数据集的算术平均值，对文本忽略不计。",
      a: "返回数据集的算术平均值",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算平均值时用到的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计算平均值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEA",
      t: 1,
      d: "返回数据集的算术平均值。",
      a: "返回数据集的算术平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算平均值时用到的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计算平均值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_DIST",
      t: 1,
      d: "返回一元二项式分布的概率。",
      a: "返回一元二项式分布的概率。",
      m: [4, 4],
      p: [{
        name: "number_s",
        detail: "试验的成功次数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "trials",
        detail: "独立检验的次数。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一给定检验的成功概率。",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "是否使用二项式累积分布。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_INV",
      t: 1,
      d: "计算累积二项式分布大于或等于指定条件的最小值。",
      a: "计算累积二项式分布大于或等于指定条件的最小值。",
      m: [3, 3],
      p: [{
        name: "trials",
        detail: "贝努利试验次数。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一次给定检验的成功概率。",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "alpha",
        detail: "期望的临界概率。",
        example: "0.8",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONFIDENCE_NORM",
      t: 1,
      d: "计算正态分布的置信区间的一半宽度。",
      a: "计算正态分布的置信区间的一半宽度。",
      m: [3, 3],
      p: [{
        name: "alpha",
        detail: "用来计算置信水平的显著性水平。\n\n置信水平等于 100*(1 - alpha)%，亦即，如果 alpha 为 0.05，则置信水平为 95%。",
        example: "0.05",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "数据区域的总体标准偏差。",
        example: "1.6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "size",
        detail: "样本总量的大小。",
        example: "250",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CORREL",
      t: 1,
      d: "计算给定数据集的皮尔逊积矩相关系数 r。",
      a: "计算给定数据集的皮尔逊积矩相关系数 r。",
      m: [2, 2],
      p: [{
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_P",
      t: 1,
      d: "计算数据集的总体协方差。",
      a: "计算数据集的总体协方差。",
      m: [2, 2],
      p: [{
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_S",
      t: 1,
      d: "计算数据集的样本协方差。",
      a: "计算数据集的样本协方差。",
      m: [2, 2],
      p: [{
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEVSQ",
      t: 1,
      d: "基于样本计算其偏差的平方和。",
      a: "基于样本计算其偏差的平方和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 样本中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "EXPON_DIST",
      t: 1,
      d: "返回带有指定 Lambda 和指定值的指数分布函数的值。",
      a: "返回带有指定 Lambda 和指定值的指数分布函数的值。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "指数分布函数的输入值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "lambda",
        detail: "用于指定指数分布函数的 lambda 值。",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "是否使用指数累积分布。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIF",
      t: 1,
      d: "根据条件返回范围的平均值。",
      a: "根据条件返回范围的平均值。",
      m: [2, 3],
      p: [{
        name: "criteria_range",
        detail: "要对其检查 criterion 的范围。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion",
        detail: '要应用于 criteria_range 的模式或测试条件。\n\n等于："文本" 或 1 或 "=文本" 或 "=1"\n\n大于：">1"\n\n大于等于：">=1"\n\n小于："<1"\n\n小于等于："<=1"\n\n不等于："<>1"或"<>文本"',
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "average_range",
        detail: "[可选] - 要计算平均值的范围。如果未提供此参数，则改用 criteria_range 来计算平均值。",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIFS",
      t: 1,
      d: "根据多项条件返回范围的平均值。",
      a: "根据多项条件返回范围的平均值。",
      m: [2, 255],
      p: [{
        name: "average_range",
        detail: "要计算平均值的范围。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range1",
        detail: "要对其检查 criterion1 的范围。",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion1",
        detail: "要应用于 criteria_range1 的模式或测试条件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2, criterion2, ...",
        detail: "[可选] - 要检查的其他范围和条件。",
        example: " C1:C10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERMUT",
      t: 1,
      d: "返回可从数字对象中选择的给定数目对象的排列数。",
      a: "返回可从数字对象中选择的给定数目对象的排列数。",
      m: [2, 2],
      p: [{
        name: "number",
        detail: "表示对象个数的整数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_chosen",
        detail: "表示每个排列中对象个数的整数。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRIMMEAN",
      t: 1,
      d: "在排除数据集高低两端的部分数据之后计算所得的均值。",
      a: "在排除数据集高低两端的部分数据之后计算所得的均值。",
      m: [2, 2],
      p: [{
        name: "数据",
        detail: "包含相关数据集的数组或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "排除比例",
        detail: "要从数据集的极值部分排除的数据占数据集的比例。\n\n排除比例必须大于等于0且小于1。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_EXC",
      t: 1,
      d: "返回数组的 K 百分点值，K 介于 0 到 1 之间，不含 0 与 1。",
      a: "返回数组的 K 百分点值，K 介于 0 到 1 之间，不含 0 与 1。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "定义相对位置的数组或数据区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "0 到 1 之间的百分点值，不包含 0 和 1。",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_INC",
      t: 1,
      d: "返回数组的 K 百分点值，K 介于 0 到 1 之间，包含 0 与 1。",
      a: "返回数组的 K 百分点值，K 介于 0 到 1 之间，包含 0 与 1。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "定义相对位置的数组或数据区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "0 到 1 之间的百分点值，包含 0 和 1。",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PEARSON",
      t: 1,
      d: "返回皮尔生(Pearson)乘积矩相关系数 r。",
      a: "返回皮尔生(Pearson)乘积矩相关系数 r。",
      m: [2, 2],
      p: [{
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_INV",
      t: 1,
      d: "返回标准正态累积分布函数的反函数值。 该分布的平均值为 0，标准偏差为 1。",
      a: "返回标准正态累积分布函数的反函数值。 该分布的平均值为 0，标准偏差为 1。",
      m: [1, 1],
      p: [{
        name: "probability",
        detail: "对应于正态分布的概率。",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_DIST",
      t: 1,
      d: "返回标准正态分布函数（该分布的平均值为 0，标准偏差为 1）。",
      a: "返回标准正态分布函数（该分布的平均值为 0，标准偏差为 1）。",
      m: [2, 2],
      p: [{
        name: "z",
        detail: "需要计算其分布的数值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函数形式的逻辑值。\n\n如果为 TRUE()，则返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NORM_INV",
      t: 1,
      d: "返回指定平均值和标准偏差的正态累积分布函数的反函数值。",
      a: "返回指定平均值和标准偏差的正态累积分布函数的反函数值。",
      m: [3, 3],
      p: [{
        name: "probability",
        detail: "对应于正态分布的概率。",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分布的算术平均值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分布的标准偏差。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_DIST",
      t: 1,
      d: "返回指定平均值和标准偏差的正态分布函数。",
      a: "返回指定平均值和标准偏差的正态分布函数。",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "需要计算其分布的数值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分布的算术平均值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分布的标准偏差。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函数形式的逻辑值。\n\n如果为 TRUE()，则返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NEGBINOM_DIST",
      t: 1,
      d: "返回负二项式分布。",
      a: "返回负二项式分布。",
      m: [4, 4],
      p: [{
        name: "number_f",
        detail: "要模拟的失败次数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_s",
        detail: "要模拟的成功次数。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一次给定检验的成功概率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函数形式的逻辑值。\n\n如果为 TRUE()，则返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINA",
      t: 1,
      d: "返回数据集中的最小数值。",
      a: "返回数据集中的最小数值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算最小值时所用的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可选] - 在计算最小值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MIN",
      t: 1,
      d: "返回数值数据集中的最小值。",
      a: "返回数值数据集中的最小值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算最小值时所用的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可选] - 在计算最小值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MEDIAN",
      t: 1,
      d: "返回数值数据集中的中值。",
      a: "返回数值数据集中的中值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算中值时所用的第一个数值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可选] - 在计算中值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAXA",
      t: 1,
      d: "返回数据集中的最大数值。",
      a: "返回数据集中的最大数值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算最大值时所用的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 在计算最大值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAX",
      t: 1,
      d: "返回数值数据集中的最大值。",
      a: "返回数值数据集中的最大值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "计算最大值时所用的第一个值或范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可选] - 在计算最大值时要考虑的其他数值或范围。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_INV",
      t: 1,
      d: "返回 x 的对数累积分布函数的反函数值。",
      a: "返回 x 的对数累积分布函数的反函数值。",
      m: [3, 3],
      p: [{
        name: "probability",
        detail: "与对数分布相关的概率，介于 0 与 1 之间（不含 0 与 1）。",
        example: "0.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "ln(x) 的平均值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "ln(x) 的标准偏差，正数。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_DIST",
      t: 1,
      d: "返回 x 的对数分布函数。",
      a: "返回 x 的对数分布函数。",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "用来计算函数的值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "ln(x) 的平均值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "ln(x) 的标准偏差，正数。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函数形式的逻辑值。\n\n如果为 TRUE()，则返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "Z_TEST",
      t: 1,
      d: "返回 z 检验的单尾 P 值。",
      a: "返回 z 检验的单尾 P 值。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "用来检验 x 的数组或数据区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "x",
        detail: "要测试的值。",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sigma",
        detail: "[可选] - 总体（已知）标准偏差。 如果省略，则使用样本标准偏差。",
        example: "3",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PROB",
      t: 1,
      d: "返回区域中的数值落在指定区间内的概率。",
      a: "返回区域中的数值落在指定区间内的概率。",
      m: [3, 4],
      p: [{
        name: "x_range",
        detail: "具有各自相应概率值的 x 数值区域。",
        example: "A3:A6",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "prob_range",
        detail: "与 x_range 中的值相关联的一组概率值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "lower_limit",
        detail: "要计算其概率的数值下界。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "upper_limit",
        detail: "[可选 - 默认值为下界] - 要计算其概率的可选数值上界。\n\n如果省略上界，PROB则计算随机选取相应值的次数恰好等于下界的概率。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_EXC",
      t: 1,
      d: "基于 0 到 1 之间（不包括 0 和 1）的百分点值返回数据集的四分位数。",
      a: "基于 0 到 1 之间（不包括 0 和 1）的百分点值返回数据集的四分位数。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "要求得四分位数值的数组或数字型单元格区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quart",
        detail: "要返回第几个四分位值。\n\n1返回数据中最靠近第一个四分位值的值（25%标记）。\n\n2返回数据中最接近中值的值（50%标记）。\n\n3返回数据中最接近第三个四分位值的值（75%标记）。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_INC",
      t: 1,
      d: "根据 0 到 1 之间的百分点值（包含 0 和 1）返回数据集的四分位数。",
      a: "根据 0 到 1 之间的百分点值（包含 0 和 1）返回数据集的四分位数。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "要求得四分位数值的数组或数字型单元格区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quart",
        detail: "要返回第几个四分位值。\n\n0返回数据中的最小值（0%标记）。\n\n1返回数据中最靠近第一个四分位值的值（25%标记）。\n\n2返回数据中最接近中值的值（50%标记）。\n\n3返回数据中最接近第三个四分位值的值（75%标记）。\n\n4返回数据中的最大值（100%标记）。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POISSON_DIST",
      t: 1,
      d: "返回泊松分布。",
      a: "返回泊松分布。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "事件数。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "期望值。非负数",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "一逻辑值，确定所返回的概率分布的形式。\n\n如果为 TRUE()，则返回发生的随机事件数在零（含零）和 x（含 x）之间的累积泊松概率；\n\n如果为 FALSE()，则返回发生的事件数正好是 x 的泊松概率密度函数。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RSQ",
      t: 1,
      d: "返回皮尔生(Pearson)乘积矩相关系数 r 的平方。",
      a: "返回皮尔生(Pearson)乘积矩相关系数 r 的平方。",
      m: [2, 2],
      p: [{
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST",
      t: 1,
      d: "返回学生的左尾 t 分布。",
      a: "返回学生的左尾 t 分布。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "T-分布函数的输入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度数值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "决定函数形式的逻辑值。\n\n如果 cumulative 为 TRUE()，则 HYPGEOM.DIST 返回累积分布函数；\n\n如果为 FALSE()，则返回概率密度函数。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T_DIST_2T",
      t: 1,
      d: "返回学生的双尾 t 分布。",
      a: "返回学生的双尾 t 分布。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "T-分布函数的输入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度数值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST_RT",
      t: 1,
      d: "返回学生的右尾 t 分布。",
      a: "返回学生的右尾 t 分布。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "T-分布函数的输入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度数值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV",
      t: 1,
      d: "返回学生的 t 分布的左尾反函数。",
      a: "返回学生的 t 分布的左尾反函数。",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "与学生的 t 分布相关的概率。\n\n必须大于 0 且小于 1。",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "deg_freedom",
        detail: "自由度数值。\n\n如果所提供的参数不是整数，将截取其整数部分。\n\n必须大于等于 1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV_2T",
      t: 1,
      d: "返回学生 t 分布的双尾反函数。",
      a: "返回学生 t 分布的双尾反函数。",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "与学生的 t 分布相关的概率。\n\n必须大于 0 且小于1。",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "deg_freedom",
        detail: "自由度数值。\n\n如果所提供的参数不是整数，将截取其整数部分。\n\n必须大于等于 1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_TEST",
      t: 1,
      d: "返回与t-检验相关的概率。用于判断两个样本是否可能是出自平均值相同的两个样本总体。",
      a: "返回与t-检验相关的概率。用于判断两个样本是否可能是出自平均值相同的两个样本总体。",
      m: [4, 4],
      p: [{
        name: "array1",
        detail: "将用于 t 检验的第一个数据样本或第一组单元格。",
        example: "A1:A4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "将用于 t 检验的第二个数据样本或第二组单元格。",
        example: "B1:B4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "指定分布的尾数。\n\n如果为 1：使用单尾分布。\n\n如果为 2：使用双尾分布。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定 t 检验的类型。\n\n如果为 1：执行配对检验。\n\n如果为 2：执行双样本等方差（同方差）检验。\n\n如果为3：执行双样本不等方差（异方差）检验。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "F_DIST",
      t: 1,
      d: "给定输入值 x，计算两个数据集的左尾 F 概率分布（差异程度）。此分布也称为 Fisher-Snedecor 分布或 Snedecor F 分布。",
      a: "给定输入值 x",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "用来计算函数的值。",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "分子自由度。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "分母自由度。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "用于确定函数形式的逻辑值。默认值为 FALSE。\n\n如果为 TRUE()：F.DIST 将返回累积分布函数值。\n\n如果为 FALSE()：F.DIST 将返回概率密度函数值。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "F_DIST_RT",
      t: 1,
      d: "给定输入x，计算两个数据集的右尾F概率分布（差异程度）。 此分布也称为Fisher-Snedecor分布或Snedecor F分布。",
      a: "给定输入x",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "用来计算函数的值。",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "分子自由度。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "分母自由度。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_P",
      t: 1,
      d: "基于样本总体计算方差。",
      a: "基于样本总体计算方差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "数据集中的第一个值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, …",
        detail: "[可选] - 数据集中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_S",
      t: 1,
      d: "基于样本计算方差。",
      a: "基于样本计算方差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, …",
        detail: "[可选] - 样本中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARA",
      t: 1,
      d: "基于样本计算方差，将文本取值为0。",
      a: "基于样本计算方差",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2, ...",
        detail: "[可选] - 样本中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARPA",
      t: 1,
      d: "基于样本总体计算方差，将文本取值为0。",
      a: "基于样本总体计算方差",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "样本中的第一项值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他数值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STEYX",
      t: 1,
      d: "返回通过线性回归法预测每个 x 的 y 值时所产生的标准误差。",
      a: "返回通过线性回归法预测每个 x 的 y 值时所产生的标准误差。",
      m: [2, 2],
      p: [{
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STANDARDIZE",
      t: 1,
      d: "给定分布的均值和标准偏差，计算一个随机变量正态化的相应值。",
      a: "给定分布的均值和标准偏差，计算一个随机变量正态化的相应值。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "要正态化的随机变量值。",
        example: "96",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分布的均值。",
        example: "80",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分布的标准偏差。",
        example: "6.7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SMALL",
      t: 1,
      d: "返回数据集中的第 k 个最小值。",
      a: "返回数据集中的第 k 个最小值。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "需要找到第 k 个最小值的数组或数值数据区域。",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "k",
        detail: "要返回的数据在数组或数据区域里的位置（从小到大）。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLOPE",
      t: 1,
      d: "计算通过数据集的线性回归得到的直线的斜率。",
      a: "计算通过数据集的线性回归得到的直线的斜率。",
      m: [2, 2],
      p: [{
        name: "数据_y",
        detail: "代表因变量数据数组或矩阵的范围。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "数据_x",
        detail: "代表自变量数据数组或矩阵的范围。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SKEW",
      t: 1,
      d: "返回分布的偏斜度。 偏斜度表明分布相对于平均值的不对称程度。 正偏斜度表明分布的不对称尾部趋向于更多正值。 负偏斜度表明分布的不对称尾部趋向于更多负值。",
      a: "返回分布的偏斜度。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "数据集中的第一个值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SKEW_P",
      t: 1,
      d: "返回基于样本总体的分布不对称度：表明分布相对于平均值的不对称程度。",
      a: "返回基于样本总体的分布不对称度：表明分布相对于平均值的不对称程度。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "数据集中的第一个值或范围。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可选] - 数据集中包含的其他值或范围。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "VLOOKUP",
      t: 2,
      d: "纵向查找。在范围的第一列中自上而下搜索某个键值，并返回所找到的行中指定单元格的值。",
      a: "纵向查找。在范围的第一列中自上而下搜索某个键值",
      m: [3, 4],
      p: [{
        name: "搜索键值",
        detail: '要搜索的值，如 42、"Cats" 或 I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "范围",
        detail: "要进行搜索的范围。VLOOKUP 将在该范围的第一列中搜索搜索键值中指定的键值。",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "索引",
        detail: "要返回的值的列索引，范围中的第一列编号为 1。\n\n如果索引不是介于 1 和范围中的列数之间，将返回 #VALUE! 。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "已排序",
        detail: "[默认值为 TRUE() ] - 指示要搜索的列（指定范围的第一列）是否已排序。大多数情况下，建议设为 FALSE()。\n\n建议将已排序设为 FALSE。如果设为 FALSE，将返回完全匹配项。如果存在多个匹配值，将返回找到的第一个值对应的单元格的内容，如果找不到匹配值，则返回 #N/A。\n\n如果将已排序设为 TRUE 或省略，将返回（小于或等于搜索键值的）最接近的匹配项。如果搜索的列中所有的值均大于搜索键值，则返回 #N/A。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HLOOKUP",
      t: 2,
      d: "横向查找。在范围的第一行中搜索某个键值，并返回所找到的列中指定单元格的值。",
      a: "横向查找。在范围的第一行中搜索某个键值",
      m: [3, 4],
      p: [{
        name: "搜索键值",
        detail: '要搜索的值。例如，42、"Cats"或I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "范围",
        detail: "要进行搜索的范围。将在该范围的第一行中搜索在搜索键值中指定的键值。",
        example: "A2:Z6",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "索引",
        detail: "要返回的值的行索引，范围中的第一行编号为1。\n\n如果索引不是介于1和范围中的行数之间，将返回#VALUE!。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "已排序",
        detail: "[可选 - 默认值为TRUE()] - 指示要搜索的行（指定范围的第一行）是否已排序。\n\n如果将已排序设为TRUE或省略，将返回最接近的匹配值（小于或等于搜索键值）。如果在搜索的行中所有的值均大于搜索键值，则返回#N/A。\n\n如果将已排序设为TRUE或将其省略，而范围的首行并非处于已排序状态，则返回值可能会是错误的。\n\n如果将已排序设为FALSE，则仅返回完全匹配。如果存在多个匹配值，将返回与找到的第一个值对应的单元格的内容，如果找不到匹配值则返回#N/A。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOOKUP",
      t: 2,
      d: "在行或列中查找相应键，并将相应单元格的值返回到与搜索行或列所在位置相同的结果范围中。",
      a: "在行或列中查找相应键",
      m: [2, 3],
      p: [{
        name: "搜索键值",
        detail: '要在行或列中搜索的值。例如，42、"Cats" 或 I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "搜索范围 | 搜索结果数组",
        detail: "使用 LOOKUP 的一种方法是给定单行或单列形式的搜索范围进行搜索查找，这种方式要用到另一个参数结果范围。另一种方式是将这两个参数合并为一个搜索结果数组，其中第一行或第一列用于搜索，并将返回值放在该数组的最后一行或最后一列中。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "结果范围",
        detail: "[ 可选 ] - 用于存放返回结果的范围。返回值对应于在搜索范围中找到搜索键值的位置。此范围必须仅为单行或单列，而如果您使用的是搜索结果数组方式，则不应提供此参数。",
        example: "B1:B100",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADDRESS",
      t: 2,
      d: "返回字符串形式的单元格引用。",
      a: "返回字符串形式的单元格引用。",
      m: [2, 5],
      p: [{
        name: "row_num",
        detail: "一个数值，指定要在单元格引用中使用的行号。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column_num",
        detail: "一个数值，指定要在单元格引用中使用的列号（而非名称）。A列的编号为1。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "abs_num",
        detail: "[可选 - 默认值为1] - 一个数值，指定要返回的引用类型。\n\n1 表示行列均采用绝对值（例如$A$1）；\n\n2 表示采用绝对行号，相对列标（例如A$1）；\n\n3 表示采用相对行号，绝对列标（例如$A1）；\n\n4 表示行列均采用相对值（例如A1）。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "A1",
        detail: "[可选 - 默认值为TRUE()] - 一个布尔值，指示采用A1标记形式(TRUE)还是R1C1标记形式(FALSE)。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sheet_text",
        detail: "[可选 - 默认缺省] - 用于指定地址所指向的工作表名称。",
        example: '"Sheet2"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INDIRECT",
      t: 2,
      d: "返回以字符串指定的单元格引用。",
      a: "返回以字符串指定的单元格引用。",
      m: [1, 2],
      p: [{
        name: "ref_text",
        detail: "以带引号的字符串形式提供的单元格引用。",
        example: '"Sheet2!"&B10',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "A1",
        detail: "[可选 - 默认值为TRUE()] - 一个布尔值，指示采用A1标记形式(TRUE)还是R1C1标记形式(FALSE)。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROW",
      t: 2,
      d: "返回指定单元格的行号",
      a: "返回指定单元格的行号",
      m: [0, 1],
      p: [{
        name: "reference",
        detail: "[可选 - 默认为此公式所在的单元格] - 要返回其行号的单元格。\n\n如果单元格引用指向的范围其宽度大于一个单元格，而此公式不是用作数组公式的，这时会仅返回单元格引用中首行的编号值。",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROWS",
      t: 2,
      d: "返回指定数组或范围中的行数。",
      a: "返回指定数组或范围中的行数。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要返回其行数的范围。",
        example: "A9:A62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COLUMN",
      t: 2,
      d: "按照 `A=1` 的规则返回指定单元格的列号。",
      a: "按照 `A=1` 的规则返回指定单元格的列号。",
      m: [0, 1],
      p: [{
        name: "reference",
        detail: "[可选 - 默认为包含此公式的单元格] - 要返回其列号的单元格。A列对应的编号为1。\n\n如果单元格引用是宽度超过一个单元格的范围，而此公式不是作为数组公式来使用的，因此将返回单元格引用中的第一列的位置。",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNS",
      t: 2,
      d: "返回指定数组或范围中的列数。",
      a: "返回指定数组或范围中的列数。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要返回其列数的范围。",
        example: "A9:W62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OFFSET",
      t: 2,
      d: "给定某范围的起始单元格引用以及该范围涵盖的行列数量，返回该范围的引用。",
      a: "给定某范围的起始单元格引用以及该范围涵盖的行列数量，返回该范围的引用。",
      m: [3, 5],
      p: [{
        name: "reference",
        detail: "用于计算行列偏移量的起点。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rows",
        detail: "要偏移的行数。\n\n行偏移量必须是整数，但也可以是负数。如果提供的参数带有小数，小数部分将被截去。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "要偏移的列数。\n\n列偏移量必须是整数，但也可以是负数。如果提供的参数带有小数，小数部分将被截去。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "height",
        detail: "[可选] - 要从偏移目标开始返回的范围的高度。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "width",
        detail: "[可选] - 要从偏移目标开始返回的范围的宽度。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MATCH",
      t: 2,
      d: "在单元格中搜索指定项，然后返回该项在单元格区域中的相对位置。",
      a: "在单元格中搜索指定项，然后返回该项在单元格区域中的相对位置。",
      m: [2, 3],
      p: [{
        name: "lookup_value",
        detail: "要在 lookup_array 中匹配的值。",
        example: '"Sunday"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "lookup_array",
        detail: "要搜索的单元格区域。\n\n如果所用的范围的高度和宽度均大于1，MATCH将返回#N/A!。",
        example: "A2:A9",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "match_type",
        detail: "[可选 - 默认值为1] - 要采用的搜索方式。\n\n1为默认类型，此时MATCH会假设范围已按升序排序，并返回小于等于搜索键值的最大值。\n\n0表示完全匹配，在范围未排序的情况下需要使用此方式。\n\n-1让MATCH假设范围是按降序排序的，并返回大于等于搜索键值的最小值。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INDEX",
      t: 2,
      d: "返回表格或中的元素值，此元素由行号和列号的索引值给定。",
      a: "返回表格或中的元素值，此元素由行号和列号的索引值给定。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "单元格区域或数组常量。",
        example: "A1:C20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "row_num",
        detail: "选择数组中的某行，函数从该行返回数值。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column_num",
        detail: "选择数组中的某列，函数从该列返回数值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GETPIVOTDATA",
      t: 2,
      d: "从与指定行和列标题对应的数据透视表中提取汇总值。",
      a: "从与指定行和列标题对应的数据透视表中提取汇总值。",
      m: [2, 254],
      p: [{
        name: "data_field",
        detail: "您想从数据透视表中获取其数据的值名称。\n值名称必须括在引号中或是指向包含相关文本的任何单元格的引用。\n如果有多个值字段，则必须使用数据透视表中显示的确切名称（如“销售总额”）。",
        example: '"SUM of number of units"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pivot_table",
        detail: "目标数据透视表中的任何单元格的引用（推荐位于顶角的单元格）。",
        example: "'Pivot table'!A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "field1",
        detail: "[可选] - 源数据集（不是数据透视表）中列的名称。",
        example: '"division"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }, {
        name: "item1",
        detail: "[可选] - 数据透视表中显示的与您要检索的字段名称 1 相对应的行或列的名称。",
        example: '"east"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CHOOSE",
      t: 2,
      d: "基于索引返回选项列表中的元素。",
      a: "基于索引返回选项列表中的元素。",
      m: [2, 255],
      p: [{
        name: "index_num",
        detail: "指定要返回哪一项。\n\n如果索引为零、负值或大于提供的选择数量，将返回#VALUE!错误。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value1",
        detail: "一项可能的返回值。必须提供。可以是单元格引用或单独的值。",
        example: '"A"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "[可选] - 其他可以选择的值。选择",
        example: '"B"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "HYPERLINK",
      t: 2,
      d: "在单元格内创建一个超链接。",
      a: "在单元格内创建一个超链接。",
      p: [{
        name: "网址",
        detail: "以引号括住的链接位置的完整网址，或对包含这种网址的单元格的引用。\n\n仅允许某些链接类型。其中包括：http://、https://、mailto:、aim:、ftp://、gopher://、telnet://和news://，明确禁用使用其他协议。如果指定的是其他协议，将会在单元格中显示链接标签，但该标签不会以链接形式呈现。\n\n如果未指定协议，则假设使用http://，并将其作为网址的前缀。",
        example: '"http://www.google.com/"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "链接标签",
        detail: '[可选 - 默认为网址] - 要在单元格中作为链接显示的文本（用引号括起来的），或者指向包含这种标签的单元格的引用。\n\n如果链接标签是指向某个空单元格的引用，如果网址有效，就将其作为链接显示，否则作为纯文本显示。\n\n如果链接标签为空字符串常量("")，所在单元格显示的内容将为空白，但通过点击该单元格或转入该单元格仍然可以访问链接。',
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TIME",
      t: 6,
      d: "将给定的小时、分钟和秒转换为时间。",
      a: "将给定的小时、分钟和秒转换为时间。",
      m: [3, 3],
      p: [{
        name: "小时",
        detail: "0（零）到 32767 之间的数字，代表小时。\n\n任何大于 23 的值都会除以 24，余数将作为小时值。",
        example: "11",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "分钟",
        detail: "0（零）到 32767 之间的数字，代表分钟。\n\n任何大于 59 的值将转换为小时和分钟。",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "秒",
        detail: "0（零）到 32767 之间的数字，代表秒。\n\n任何大于 59 的值将转换为小时、分钟和秒。",
        example: "59",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TIMEVALUE",
      t: 6,
      d: "按一天24小时返回该时间的分数表示。",
      a: "按一天24小时返回该时间的分数表示。",
      m: [1, 1],
      p: [{
        name: "time_text",
        detail: "用于表示时间的字符串。",
        example: '"2:15 PM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EOMONTH",
      t: 6,
      d: "返回某个月份最后一天的序列号，该月份在另一个日期之前或之后的数个月（月数由参数指定）。",
      a: "返回某个月份最后一天的序列号",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "用于计算结果的参照日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "用于计算的起始日期之前（负）或之后（正）的月数。返回的是计算所得月份的最后那天。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EDATE",
      t: 6,
      d: "返回表示某个日期的序列号，该日期在另一个日期的数月之前/之后。",
      a: "返回表示某个日期的序列号",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "用于计算结果的参照日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "用于计算的起始日期之前（负）或之后（正）的月数。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SECOND",
      t: 6,
      d: "返回时间值的秒数。 秒数是 0（零）到 59 范围内的整数。",
      a: "返回时间值的秒数。 秒数是 0（零）到 59 范围内的整数。",
      m: [1, 1],
      p: [{
        name: "时间",
        detail: "用于计算秒钟部分的时间。必须为以下值之一：指向包含日期/时间值的单元格的引用、返回日期/时间的函数或者数字。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINUTE",
      t: 6,
      d: "以数字格式返回特定时间的分钟部分。",
      a: "以数字格式返回特定时间的分钟部分。",
      m: [1, 1],
      p: [{
        name: "时间",
        detail: "用于计算分钟部分的时间。必须为以下值之一：指向包含日期/时间值的单元格的引用、返回日期/时间的函数或者数字。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HOUR",
      t: 6,
      d: "以数字格式返回特定时间的小时部分。",
      a: "以数字格式返回特定时间的小时部分。",
      m: [1, 1],
      p: [{
        name: "时间",
        detail: "用于计算小时部分的时间。必须为以下值之一：指向包含日期/时间值的单元格的引用、返回日期/时间的函数或者数字。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOW",
      t: 6,
      d: "以日期值格式返回当前日期和时间。",
      a: "以日期值格式返回当前日期和时间。",
      m: [0, 0],
      p: []
    }, {
      n: "NETWORKDAYS",
      t: 6,
      d: "返回所提供的两个日期之间的净工作日天数。",
      a: "返回所提供的两个日期之间的净工作日天数。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "用于计算净工作日天数的时间段开始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "用于计算净工作日天数的时间段结束日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[可选] - 一个范围或数组常量，其中包含作为节假日的日期序号。\n\n在节假日数组中提供的值必须是日期序号值（例如由N所返回的值）或日期值（例如由DATE、DATEVALUE或TO_DATE返回的值）。由范围指定的值应该是标准的日期值或日期序数值。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NETWORKDAYS_INTL",
      t: 6,
      d: "返回给定的两个日期之间的净工作日天数（排除指定的周末和节假日）。",
      a: "返回给定的两个日期之间的净工作日天数（排除指定的周末和节假日）。",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "用于计算净工作日天数的时间段开始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "用于计算净工作日天数的时间段结束日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "weekend",
        detail: "[可选 - 默认值为1] - 用于表示哪些天为周末的数字或字符串。\n字符串方式：可以使用由0和1组成的字符串来指定周末，串中的第一个数字字符代表周一，最后一个则代表周日。零表示这一天是工作日，1表示这一天为周末。例如，“0000011”表示将周六和周日作为周末。\n数字方式：这种方式不使用上述字符串形式，而是使用一个数字。1 =周六/周日为周末，2 =周日/周一为周末，依此类推则7 =周五/周六。11 =周日为唯一周末，12 =周一为唯一周末，依此类推则17 =周六为唯一周末。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[ 可选 ] - 这是一个范围或数组常量，其中包含作为节假日的日期。\n在节假日数组内提供的值必须为日期序数值（例如N的返回值）或日期值（例如DATE、DATEVALUE或TO_DATE的返回值）。由范围指定的值应该是标准的日期值或日期序数值。",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISOWEEKNUM",
      t: 6,
      d: "返回给定日期在全年中的 ISO 周数。",
      a: "返回给定日期在全年中的 ISO 周数。",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "用于日期和时间计算的日期-时间代码。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WEEKNUM",
      t: 6,
      d: "返回特定日期的周数。",
      a: "返回特定日期的周数。",
      m: [1, 2],
      p: [{
        name: "serial_number",
        detail: "要确定其位于第几周的日期，必须是对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "return_type",
        detail: "[可选 - 默认值为 1 ] - 代表一周起始日的数字，系统也使用该数字来确定一年的第一周（1=周日，2=周一）。",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "WEEKDAY",
      t: 6,
      d: "返回一个数字，对应于给定日期所在的星期几。",
      a: "返回一个数字，对应于给定日期所在的星期几。",
      m: [1, 2],
      p: [{
        name: "serial_number",
        detail: "要为其确定星期几的日期。必须是对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "return_type",
        detail: "[可选 - 默认值为 1] - 以数字指示使用哪种编号顺序来表示星期几。默认情况下，按星期日 (= 1) 开始计算。\n\n如果类型为 1，则星期值将从星期日开始算起，并且星期日的值为 1，因此星期六的值就是 7。\n\n如果类型为 2，则星期值将从星期一开始算起，并且星期一的值为 1，因此星期日的值就是 7。\n\n如果类型为 3，则星期值将从星期一算起，并且星期一的值为 0，因此星期日的值就是 6。",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DAY",
      t: 6,
      d: "以数字格式返回特定日期所在的当月几号。",
      a: "以数字格式返回特定日期所在的当月几号。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "要从中提取具体几号的日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS",
      t: 6,
      d: "返回两个日期之间的天数。",
      a: "返回两个日期之间的天数。",
      m: [2, 2],
      p: [{
        name: "end_date",
        detail: "计算中要使用的结束日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "2011-3-15",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_date",
        detail: "计算中要使用的开始日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "2011-2-1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS360",
      t: 6,
      d: "按照每年360天，返回两个日期之间的差（用于计算利息）。",
      a: "按照每年360天，返回两个日期之间的差（用于计算利息）。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "计算中要使用的开始日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "计算中要使用的结束日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "method",
        detail: "[可选 - 默认为FALSE()] - 指示要使用哪种天数计算方法。\n\nFALSE - 采用美国 (NASD) 方法时，如果起始日期为某月的最后一天，为便于计算，会将起始日期的当月几号更改为30。此外，如果结束日期是所在月份的最后一天，而且起始日期在其所在月的30号之前，则将结束日期更改为结束日期之后那个月的第一天，否则将结束日期更改为该月的30号。\n\nTRUE - 采用欧洲方法时，会将所有日期在31号的起始日期或结束日期更改为当月的30号。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATE",
      t: 6,
      d: "将提供的年、月、日转换为日期。",
      a: "将提供的年、月、日转换为日期。",
      m: [3, 3],
      p: [{
        name: "year",
        detail: "日期的年份部分，包含一到四位数字。\n\n介于 0（零）到 1899 之间，会将该值与 1900 相加来计算年份；\n\n介于 1900 到 9999 之间，将使用该数值作为年份；\n\n小于 0 或大于等于 10000，返回 错误值 #NUM!。",
        example: "1969",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "日期的月份部分，一个正整数或负整数。\n\n如果 month 大于 12，则 month 会将该月份数与指定年中的第一个月相加。\n\n如果 month 小于 1，month 则从指定年份的一月份开始递减该月份数，然后再加上 1 个月。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day",
        detail: "日期的日部分，一个正整数或负整数。\n\n如果 day 大于月中指定的天数，则 day 会将天数与该月中的第一天相加。\n\n如果 day 小于 1，则 day 从指定月份的第一天开始递减该天数，然后再加上 1 天。",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATEVALUE",
      t: 6,
      d: "将提供的日期字符串转换为日期的序列号。",
      a: "将提供的日期字符串转换为日期的序列号。",
      m: [1, 1],
      p: [{
        name: "date_text",
        detail: "表示日期的字符串。",
        example: '"1969-7-20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATEDIF",
      t: 6,
      d: "计算两个日期之间的天数、月数或年数。",
      a: "计算两个日期之间的天数、月数或年数。",
      m: [3, 3],
      p: [{
        name: "起始日期",
        detail: "计算中要使用的开始日期。必须是对包含DATE值的单元格的引用、返回DATE类型的函数或数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "结束日期",
        detail: "计算中要使用的结束日期。必须是对包含DATE值的单元格的引用、返回DATE类型的函数或数字。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "单位",
        detail: '时间单位的缩写文字。例如 "M" 代表月。有效值包括："Y"、"M"、"D"、"MD"、"YM" 和 "YD"。\n\n"Y"：返回起始日期和结束日期之间的整年数。\n\n"M"：返回起始日期和结束日期之间的整月数。\n\n"D"：返回起始日期和结束日期之间的天数。\n\n"MD"：返回起始日期和结束日期之间的天数（不计整月数）。\n\n"YM"：返回起始日期和结束日期之间的整月数（不计整年数）。\n\n"YD"：返回起始日期和结束日期之间的天数（假设起始日期和结束日期的间隔不超过一年）。',
        example: "16)",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY",
      t: 6,
      d: "指定工作日天数，计算结束日期。",
      a: "指定工作日天数，计算结束日期。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "计算的开始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "days",
        detail: "start_date 之前或之后不含周末及节假日的天数。\n\n为正值将生成未来日期；\n\n为负值生成过去日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "holidays",
        detail: "[可选] - 一个范围或数组常量，其中包含作为节假日的日期序号。\n\n在节假日数组中提供的值必须是日期序号值（例如由N所返回的值）或日期值（例如由DATE、DATEVALUE或TO_DATE返回的值）。由范围指定的值应该是标准的日期值或日期序数值。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY_INTL",
      t: 6,
      d: "返回指定的若干个工作日之前或之后的日期的序列号（使用自定义周末参数）。 ",
      a: "返回指定的若干个工作日之前或之后的日期的序列号（使用自定义周末参数）。 ",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "开始日期（将被截尾取整）。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "days",
        detail: "start_date 之前或之后的工作日的天数。\n\n正值表示未来日期；\n\n负值表示过去日期；\n\n零值表示开始日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "weekend",
        detail: "[可选 - 默认值为1] - 用于表示哪些天为周末的数字或字符串。\n字符串方式：可以使用由0和1组成的字符串来指定周末，串中的第一个数字字符代表周一，最后一个则代表周日。零表示这一天是工作日，1表示这一天为周末。例如，“0000011”表示将周六和周日作为周末。\n数字方式：这种方式不使用上述字符串形式，而是使用一个数字。1 =周六/周日为周末，2 =周日/周一为周末，依此类推则7 =周五/周六。11 =周日为唯一周末，12 =周一为唯一周末，依此类推则17 =周六为唯一周末。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[ 可选 ] - 这是一个范围或数组常量，其中包含作为节假日的日期。\n在节假日数组内提供的值必须为日期序数值（例如N的返回值）或日期值（例如DATE、DATEVALUE或TO_DATE的返回值）。由范围指定的值应该是标准的日期值或日期序数值。",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEAR",
      t: 6,
      d: "返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。",
      a: "返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "用于计算年份的日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEARFRAC",
      t: 6,
      d: "返回 start_date 和 end_date 之间的天数占全年天数的百分比。",
      a: "返回 start_date 和 end_date 之间的天数占全年天数的百分比。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "计算中要使用的开始日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "计算中要使用的结束日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 要使用的日计数基准类型。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TODAY",
      t: 6,
      d: "以日期值格式返回当前日期。",
      a: "以日期值格式返回当前日期。",
      m: [0, 0],
      p: []
    }, {
      n: "MONTH",
      t: 6,
      d: "返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。",
      a: "返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "要从中提取月份的日期。必须是以下一种：对包含日期的单元格的引用、返回日期类型的函数或者数字。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EFFECT",
      t: 8,
      d: "根据名义利率及每年的复利计息期数来计算实际年利率。",
      a: "根据名义利率及每年的复利计息期数来计算实际年利率。",
      m: [2, 2],
      p: [{
        name: "nominal_rate",
        detail: "每年的名义利率。",
        example: "0.99",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "npery",
        detail: "每年的复利计算期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLAR",
      t: 12,
      d: "将数字格式设置为与语言区域相对应的货币格式。",
      a: "将数字格式设置为与语言区域相对应的货币格式。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: "要设置格式的值。",
        example: "1.2351",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "decimals",
        detail: "[可选 - 默认值为 2] - 要显示的小数位数。\n\n如果这是负数，则将数字四舍五入到小数点左侧。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARDE",
      t: 8,
      d: "将以整数部分和分数部分转换为以小数部分表示的金额数字",
      a: "将以整数部分和分数部分转换为以小数部分表示的金额数字",
      m: [2, 2],
      p: [{
        name: "fractional_dollar",
        detail: "以整数部份和分数部分表示的数字，用小数点隔开。",
        example: "100.10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fraction",
        detail: "用作分数中的分母的整数。",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARFR",
      t: 8,
      d: "将小数转换为分数表示的金额数字。",
      a: "将小数转换为分数表示的金额数字。",
      m: [2, 2],
      p: [{
        name: "decimal_dollar",
        detail: "小数。",
        example: "100.125",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fraction",
        detail: "用作分数中的分母的整数。",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DB",
      t: 8,
      d: "使用固定余额递减法，返回指定期间内某项固定资产的折旧值。",
      a: "使用固定余额递减法，返回指定期间内某项固定资产的折旧值。",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "资产原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折旧末尾时的值（有时也称为资产残值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "资产的折旧期数（有时也称作资产的使用寿命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限内要计算折旧的折旧期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "[可选 - 默认值为12] - 折旧第一年中的月数。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DDB",
      t: 8,
      d: "用双倍余额递减法，返回指定期间内某项固定资产的折旧值。",
      a: "用双倍余额递减法，返回指定期间内某项固定资产的折旧值。",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "资产原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折旧末尾时的值（有时也称为资产残值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "资产的折旧期数（有时也称作资产的使用寿命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限内要计算折旧的折旧期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "[可选 - 默认值为2] - 折旧的递减系数。",
        example: "2.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RATE",
      t: 8,
      d: "返回年金每期的利率。",
      a: "返回年金每期的利率。",
      m: [3, 6],
      p: [{
        name: "nper",
        detail: "年金的付款总期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "每期的付款金额，在年金周期内不能更改。",
        example: "-100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值即一系列未来付款当前值的总和。",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选 - 默认值为0] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "guess",
        detail: "[可选 - 默认值为0.1] - 预期利率。",
        example: "0.1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CUMPRINC",
      t: 8,
      d: "基于等额分期付款和固定利率，计算投资在多个付款期内的累计本金偿还额。",
      a: "基于等额分期付款和固定利率，计算投资在多个付款期内的累计本金偿还额。",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "总付款期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "年金的现值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_period",
        detail: "开始累计计算的付款期序号。\n\n首期必须大于等于1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_period",
        detail: "结束累计计算的付款期序号。\n\n末期必须大于首期。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNUM",
      t: 8,
      d: "返回在结算日和到期日之间的付息次数，向上舍入到最近的整数。",
      a: "返回在结算日和到期日之间的付息次数，向上舍入到最近的整数。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。到期日是有价证券有效期截止时的日期。",
        example: "02",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SYD",
      t: 8,
      d: "返回在指定期间内资产按年限总和折旧法计算的折旧。",
      a: "返回在指定期间内资产按年限总和折旧法计算的折旧。",
      m: [4, 4],
      p: [{
        name: "cost",
        detail: "资产原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折旧末尾时的值（有时也称为资产残值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "资产的折旧期数（有时也称作资产的使用寿命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限内要计算折旧的折旧期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLEQ",
      t: 8,
      d: "基于贴现率计算美国政府短期债券的等效年化收益率。",
      a: "基于贴现率计算美国政府短期债券的等效年化收益率。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "债券的结算日期，此日期为债券发行后交付给买家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "债券的到期或结束日期，届时可将其以面值或票面价值赎回。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "债券购买时的贴现率。",
        example: "2)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLYIELD",
      t: 8,
      d: "基于价格计算美国政府短期债券的收益率。",
      a: "基于价格计算美国政府短期债券的收益率。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "债券的结算日期，此日期为债券发行后交付给买家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "债券的到期或结束日期，届时可将其以面值或票面价值赎回。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "债券的购买价格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLPRICE",
      t: 8,
      d: "基于贴现率计算美国政府短期债券的价格。",
      a: "基于贴现率计算美国政府短期债券的价格。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "债券的结算日期，此日期为债券发行后交付给买家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "债券的到期或结束日期，届时可将其以面值或票面价值赎回。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "债券购买时的贴现率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PV",
      t: 8,
      d: "基于等额分期付款和固定利率，计算年金投资的现值。",
      a: "基于等额分期付款和固定利率，计算年金投资的现值。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款总期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "每期的付款金额，在年金周期内不能更改。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "D2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACCRINT",
      t: 8,
      d: "返回定期付息证券的应计利息。",
      a: "返回定期付息证券的应计利息。",
      m: [6, 8],
      p: [{
        name: "issue",
        detail: "有价证券的发行日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "first_interest",
        detail: "有价证券的首次计息日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有价证券的年息票利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "par",
        detail: "证券的票面值。",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示““欧洲30/360”方法” - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calc_method",
        detail: "[可选 - 默认为TRUE()] - 一个逻辑值，指定当结算日期晚于首次计息日期时用于计算总应计利息的方法。\n\n如果值为 TRUE，则返回从发行日到结算日的总应计利息。\n\n如果值为 FALSE，则返回从首次计息日到结算日的应计利息。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ACCRINTM",
      t: 8,
      d: "返回在到期日支付利息的有价证券的应计利息。",
      a: "返回在到期日支付利息的有价证券的应计利息。",
      m: [4, 5],
      p: [{
        name: "issue",
        detail: "有价证券的发行日。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "有价证券的到期日。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有价证券的年息票利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "par",
        detail: "证券的票面值。",
        example: "1000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYBS",
      t: 8,
      d: "返回从付息期开始到结算日的天数。",
      a: "返回从付息期开始到结算日的天数。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYS",
      t: 8,
      d: "返回结算日所在的付息期的天数。",
      a: "返回结算日所在的付息期的天数。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYSNC",
      t: 8,
      d: "返回从结算日到下一票息支付日之间的天数。",
      a: "返回从结算日到下一票息支付日之间的天数。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNCD",
      t: 8,
      d: "计算结算日之后的下一票息或利息派发日期。",
      a: "计算结算日之后的下一票息或利息派发日期。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPPCD",
      t: 8,
      d: "计算结算日之前的最后一个票息或利息支付日。",
      a: "计算结算日之前的最后一个票息或利息支付日。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FV",
      t: 8,
      d: "基于等额分期付款和固定利率，计算年金投资的未来价值。",
      a: "基于等额分期付款和固定利率，计算年金投资的未来价值。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款总期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "各期所应支付的金额，在整个年金期间保持不变。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "[可选 - 默认值为 0 ] - 现值，或一系列未来付款的当前值的累积和。",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为 0 ] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FVSCHEDULE",
      t: 8,
      d: "返回应用一系列复利率计算的初始本金的未来值。",
      a: "返回应用一系列复利率计算的初始本金的未来值。",
      m: [2, 2],
      p: [{
        name: "principal",
        detail: "现值。",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "schedule",
        detail: "用于计算本金复利的一组利率。\n\n利率表必须是范围或数组，其中包含要用于计算复利的一组利率。这些利率值应该以十进制小数形式表示，或者使用UNARY_PERCENT以百分比形式表示，即表示为0.09或UNARY_PERCENT(9)，而不要表示为9。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "YIELD",
      t: 8,
      d: "返回定期支付利息的债券的收益率。",
      a: "返回定期支付利息的债券的收益率。",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有价证券的年息票利率。",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pr",
        detail: "有价证券的价格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有价证券的清偿价值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "YIELDDISC",
      t: 8,
      d: "基于价格计算折价发行的（不带息）债券的年收益率。",
      a: "基于价格计算折价发行的（不带息）债券的年收益率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "有价证券的价格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有价证券的清偿价值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NOMINAL",
      t: 8,
      d: "基于给定的实际利率和年复利期数，返回名义年利率。",
      a: "基于给定的实际利率和年复利期数，返回名义年利率。",
      m: [2, 2],
      p: [{
        name: "effect_rate",
        detail: "每年的实际利率。",
        example: "0.85",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "npery",
        detail: "每年的复利期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "XIRR",
      t: 8,
      d: "返回一组不一定定期发生的现金流的内部收益率。",
      a: "返回一组不一定定期发生的现金流的内部收益率。",
      m: [2, 3],
      p: [{
        name: "values",
        detail: "其中含有投资相关收益或支出的数组或范围。\n\n现金流数额中必须至少包含一项负的和一项正的现金流金额才能计算回报率。",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "dates",
        detail: "与现金流数额参数中的现金流对应的日期数组或范围。",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "guess",
        detail: "[可选 - 默认值为0.1] - 对内部回报率的估算值。",
        example: "250",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MIRR",
      t: 8,
      d: "返回一系列定期现金流的修改后内部收益率。",
      a: "返回一系列定期现金流的修改后内部收益率。",
      m: [3, 3],
      p: [{
        name: "values",
        detail: "其中含有投资相关收益或支出的数组或范围。\n\n现金流数额中必须至少包含一项负的和一项正的现金流金额才能计算回报率。",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "finance_rate",
        detail: "现金流中使用的资金支付的利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "reinvest_rate",
        detail: "将现金流再投资的收益率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IRR",
      t: 8,
      d: "返回由值中的数字表示的一系列现金流的内部收益率。 ",
      a: "返回由值中的数字表示的一系列现金流的内部收益率。 ",
      m: [1, 2],
      p: [{
        name: "values",
        detail: "其中含有投资相关收益或支出的数组或范围。\n\n现金流数额中必须至少包含一项负的和一项正的现金流金额才能计算回报率。",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "guess",
        detail: "[可选 - 默认为 0.1] - 内部收益率的估值。",
        example: "200",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPV",
      t: 8,
      d: "使用贴现率和一系列未来支出（负值）和收益（正值）来计算一项投资的净现值。",
      a: "使用贴现率和一系列未来支出（负值）和收益（正值）来计算一项投资的净现值。",
      m: [2, 255],
      p: [{
        name: "rate",
        detail: "某一期间的贴现率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value1",
        detail: "第一笔支出（负值）和收益（正值）。",
        example: "200",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2, ...",
        detail: "[可选] - 其他支出（负值）和收益（正值）。",
        example: "250",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "XNPV",
      t: 8,
      d: "返回一组现金流的净现值，这些现金流不一定定期发生。",
      a: "返回一组现金流的净现值，这些现金流不一定定期发生。",
      m: [3, 3],
      p: [{
        name: "rate",
        detail: "应用于现金流的贴现率。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "values",
        detail: "与 dates 中的支付时间相对应的一系列现金流。",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "dates",
        detail: "与现金流支付相对应的支付日期表。",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CUMIPMT",
      t: 8,
      d: "基于等额分期付款和固定利率，计算投资在一系列付款期内的累计利息。",
      a: "基于等额分期付款和固定利率，计算投资在一系列付款期内的累计利息。",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "利息率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "总付款期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_period",
        detail: "开始累计计算的付款期序号。\n\n首期必须大于等于1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_period",
        detail: "结束累计计算的付款期序号。\n\n末期必须大于首期。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PMT",
      t: 8,
      d: "用于根据固定付款额和固定利率计算贷款的付款额。",
      a: "用于根据固定付款额和固定利率计算贷款的付款额。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "贷款利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "该项贷款的付款总数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值，或一系列未来付款额现在所值的总额，也叫本金。",
        example: " 100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选 - 默认值为 0] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "D2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为 0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IPMT",
      t: 8,
      d: "基于固定利率及等额分期付款方式，返回给定期数内对投资的利息偿还额。",
      a: "基于固定利率及等额分期付款方式，返回给定期数内对投资的利息偿还额。",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "per",
        detail: "用于计算其利息数额的期数，必须在 1 到 nper 之间。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款总期数。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值，或一系列未来付款的当前值的累积和。",
        example: "80000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选 - 默认值为 0] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "E2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为 0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PPMT",
      t: 8,
      d: "返回根据定期固定付款和固定利率而定的投资在已知期间内的本金偿付额。",
      a: "返回根据定期固定付款和固定利率而定的投资在已知期间内的本金偿付额。",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "per",
        detail: "指定期数，该值必须在 1 到 nper 范围内。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款总期数。",
        example: "3*12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值即一系列未来付款当前值的总和。",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选 - 默认值为 0] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为 0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INTRATE",
      t: 8,
      d: "返回完全投资型证券的利率。",
      a: "返回完全投资型证券的利率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "有价证券的投资额。",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有价证券到期时的兑换值。",
        example: "101200",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICE",
      t: 8,
      d: "返回定期付息的面值 ￥100 的有价证券的价格。",
      a: "返回定期付息的面值 ￥100 的有价证券的价格。",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有价证券的年息票利率。",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有价证券的年收益率。",
        example: "0.065",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值 ￥100 的有价证券的清偿价值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEDISC",
      t: 8,
      d: "返回折价发行的面值 ￥100 的有价证券的价格。",
      a: "返回折价发行的面值 ￥100 的有价证券的价格。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "有价证券的贴现率。",
        example: "0.0525",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值 ￥100 的有价证券的清偿价值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEMAT",
      t: 8,
      d: "返回到期付息的面值 ￥100 的有价证券的价格。",
      a: "返回到期付息的面值 ￥100 的有价证券的价格。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "issue",
        detail: "有价证券的发行日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有价证券在发行日的利率。",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有价证券的年收益率。",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RECEIVED",
      t: 8,
      d: "返回一次性付息的有价证券到期收回的金额。",
      a: "返回一次性付息的有价证券到期收回的金额。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "有价证券的投资额。",
        example: "10000000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "discount",
        detail: "有价证券的贴现率。",
        example: "0.0575",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DISC",
      t: 8,
      d: "返回有价证券的贴现率。",
      a: "返回有价证券的贴现率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "有价证券的价格（按面值为 ￥100 计算）。",
        example: "97.975",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值 ￥100 的有价证券的清偿价值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPER",
      t: 8,
      d: "基于固定利率及等额分期付款方式，返回某项投资的总期数。",
      a: "基于固定利率及等额分期付款方式，返回某项投资的总期数。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "各期所应支付的金额，在整个年金期间保持不变。",
        example: "500",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "现值，或一系列未来付款的当前值的累积和。",
        example: "40000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可选 - 默认值为0] - 未来值，或在最后一次付款后希望得到的现金余额。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可选 - 默认值为0] - 指定各期的付款时间是在期初还是期末。\n\n0 表示期末；\n\n1 表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLN",
      t: 8,
      d: "返回一个期间内的资产的直线折旧。",
      a: "返回一个期间内的资产的直线折旧。",
      m: [3, 3],
      p: [{
        name: "cost",
        detail: "资产原值。",
        example: "300000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折旧末尾时的值（有时也称为资产残值）。",
        example: "75000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "资产的折旧期数（有时也称作资产的使用寿命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DURATION",
      t: 8,
      d: "返回假设面值 ￥100 的定期付息有价证券的修正期限。",
      a: "返回假设面值 ￥100 的定期付息有价证券的修正期限。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "coupon",
        detail: "有价证券的年息票利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有价证券的年收益率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MDURATION",
      t: 8,
      d: "返回假设面值 ￥100 的有价证券的 Macauley 修正期限。",
      a: "返回假设面值 ￥100 的有价证券的 Macauley 修正期限。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有价证券的结算日。 有价证券结算日是在发行日之后，有价证券卖给购买者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有价证券的到期日。 到期日是有价证券有效期截止时的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "coupon",
        detail: "有价证券的年息票利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有价证券的年收益率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次数。\n\n如果按年支付，frequency = 1；\n\n按半年期支付，frequency = 2；\n\n按季支付，frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: "[可选 - 默认为0] - 指示要使用哪种天数计算方法。\n\n0表示“美国(NASD) 30/360”方法 - 此方法按照美国全国证券交易商协会标准，假设每月30天、每年360天，并对所输入的月末日期进行具体调整。\n\n1表示“实际/实际”方法 - 此方法计算基于指定日期之间的实际天数和所涉及的年份中的实际天数进行计算。此方法用于美国长期债券，也是在非财经用途方面使用最多的方法。\n\n2表示“实际/360”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为360天。\n\n3表示“实际/365”方法 - 此方法基于指定日期之间的实际天数进行计算，但假定每年为365天。\n\n4表示“欧洲30/360”方法 - 类似于0，此方法基于每月30天、每年360天进行计算，但按照欧洲金融惯例对月末日期进行调整。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2DEC",
      t: 9,
      d: "将二进制数转换为十进制数。",
      a: "将二进制数转换为十进制数。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要转换为十进制数的带符号的10位二进制数值（以字符串形式提供）。\n\n带符号的二进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n对于此函数，最大的正数输入值为0111111111，最小的负数输入值为1000000000。\n\n如果所提供的带符号的二进制数是有效的二进制数，会自动将其转换为相应的字符串输入。例如，BIN2DEC(100)和BIN2DEC("100")得出的结果相同，均为4。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIN2HEX",
      t: 9,
      d: "将二进制数转换为十六进制数。",
      a: "将二进制数转换为十六进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的十六进制数的带符号的10位二进制数值（以字符串形式提供）。\n\n带符号的二进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n对于此函数，最大的正数输入值为0111111111，最小的负数输入值为1000000000。\n\n如果所提供的带符号的二进制数是有效的二进制数，会自动将其转换为相应的字符串输入。例如，BIN2HEX(11111)和BIN2HEX("11111")得出 的结果相同，均为1F。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: '[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。例如，BIN2HEX("11111",8)所得的结果值为0000001F。\n\n如果带符号的二进制数的最高位为1，则忽略此值；即当提供的带符号的二进制数大于等于1000000000时忽略此值。',
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2OCT",
      t: 9,
      d: "将二进制数转换为八进制数。",
      a: "将二进制数转换为八进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的八进制数的带符号的10位二进制数值（以字符串形式提供）。\n\n带符号的二进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n对于此函数，最大的正数输入值为0111111111，最小的负数输入值为1000000000。\n\n如果所提供的带符号的二进制数是有效的二进制数，会自动将其转换为相应的字符串输入。例如，BIN2OCT(11111)和BIN2OCT("11111")得出的结果相同，均为37。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: '[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。例如，BIN2OCT("11111")得到的结果值为00000037。\n\n如果带符号的二进制数的最高位为1，则忽略此值；即当提供的带符号的二进制数大于等于1000000000时忽略此值。',
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2BIN",
      t: 9,
      d: "将十进制数转换为二进制数。",
      a: "将十进制数转换为二进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的二进制数的十进制数值（以字符串形式提供）。\n\n对于此函数，最大的正数输入值为511，最小的负数输入值为-512。\n\n如果所提供的十进制数是有效的十进制数，会自动将其转换为相应的字符串输入。例如，DEC2BIN(199)和DEC2BIN("199")得出的结果相同，均为11000111。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果十进制数为负数，则忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2HEX",
      t: 9,
      d: "将十进制数转换为十六进制数。",
      a: "将十进制数转换为十六进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的十六进制数的十进制数值（以字符串形式提供）。\n\n此函数可接受的最大正数值为549755813887，最小负数值为-549755814888。\n\n如果所提供的十进制数是有效的十进制数，会自动将其转换为相应的字符串输入。例如，DEC2HEX(100)和DEC2HEX("100")得出的结果相同，均为64。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果十进制数为负数，则忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2OCT",
      t: 9,
      d: "将十进制数转换为八进制数。",
      a: "将十进制数转换为八进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的八进制数的十进制数值（以字符串形式提供）。\n\n此函数可接受的最大正数值为536870911，最小负数值为-53687092。\n\n如果所提供的十进制数是有效的十进制数，会自动将其转换为相应的字符串输入。例如，DEC2OCT(199)和DEC2OCT("199")得出的结果相同，均为307。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果十进制数为负数，则忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2BIN",
      t: 9,
      d: "将十六进制数转换为二进制数。",
      a: "将十六进制数转换为二进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的二进制数的带符号的40位十六进制数值（以字符串形式提供）。\n\n带符号的十六进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为1FF，最小负数值为FFFFFFFE00。\n\n如果所提供的带符号的十六进制数是有效的十六进制数，函数会自动将其转换为相应的字符串输入。例如，HEX2BIN(199)和HEX2BIN("199")得出的结果相同，均为110011001。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果带符号的十六进制数的最高位为1，则忽略此值；即当提供的带符号的十六进制数大于等于8000000000时忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2DEC",
      t: 9,
      d: "将十六进制数转换为十进制数。",
      a: "将十六进制数转换为十进制数。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要转换为十进制数的带符号的40位十六进制数值（以字符串形式提供）。\n\n带符号的十六进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为7fffffffff，最小负数值为8000000000。\n\n如果所提供的带符号的十六进制数是有效的十六进制数，函数会自动将其转换为相应的字符串输入。例如，HEX2DEC(199)和HEX2DEC("199")得出的结果相同，均为409。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HEX2OCT",
      t: 9,
      d: "将十六进制数转换为八进制数。",
      a: "将十六进制数转换为八进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的八进制数的带符号的40位十六进制数值（以字符串形式提供）。\n\n带符号的十六进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为1FFFFFFF，最小负数值为FFE0000000。\n\n如果所提供的带符号的十六进制数是有效的十六进制数，函数会自动将其转换为相应的字符串输入。例如，HEX2OCT(199)和HEX2OCT("199")得出的结果相同，均为631。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果带符号的十六进制数的最高位为1，则忽略此值；即当给定的带符号的十六进制数大于等于8000000000时忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2BIN",
      t: 9,
      d: "将八进制数转换为二进制数。",
      a: "将八进制数转换为二进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的二进制数的带符号的30位八进制数值（以字符串形式提供）。\n\n带符号的八进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为777，最小负数值为7777777000。\n\n如果所提供的带符号的八进制数是有效的八进制数，函数会自动将其转换为相应的字符串输入。例如，OCT2BIN(177)和OCT2BIN("177")得出的结果相同，均为1111111。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果带符号的八进制数的最高位为1，则忽略此值；即当给定的带符号的八进制数大于等于4000000000时忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2DEC",
      t: 9,
      d: "将八进制数转换为十进制数。",
      a: "将八进制数转换为十进制数。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要转换为十进制数的带符号的30位八进制数值（以字符串形式提供）。\n\n带符号的ba进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为3777777777，最小负数值为4000000000。\n\n如果所提供的带符号的八进制数是有效的八进制数，函数会自动将其转换为相应的字符串输入。例如，OCT2DEC(177)和OCT2DEC("177")得出的结果相同，均为127。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OCT2HEX",
      t: 9,
      d: "将八进制数转换为十六进制数。",
      a: "将八进制数转换为十六进制数。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要转换为带符号的十六进制数的带符号的30位八进制数值（以字符串形式提供）。\n\n带符号的ba进制数的最高位是符号位；也就是说，负数是以二的补码形式表示的。\n\n此函数可接受的最大正数值为3777777777，最小负数值为4000000000。\n\n如果所提供的带符号的八进制数是有效的八进制数，函数会自动将其转换为相应的字符串输入。例如，OCT2HEX(177)和OCT2HEX("177")得出的结果相同，均为7F。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可选 ] - 结果中要确保的有效位数。\n\n如果设置的有效位数大于结果中的有效位数，则在结果的左侧填充0，使总有效位数达到有效位数。\n\n如果带符号的八进制数的最高位为1，则忽略此值；即当给定的带符号的八进制数大于等于4000000000时忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COMPLEX",
      t: 9,
      d: "将实系数及虚系数转换为 x+yi 或 x+yj 形式的复数。",
      a: "将实系数及虚系数转换为 x+yi 或 x+yj 形式的复数。",
      m: [2, 3],
      p: [{
        name: "real_num",
        detail: "复数的实系数。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "i_num",
        detail: "复数的虚系数。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suffix",
        detail: '[可选 - 默认为 "i"] - 复数中虚系数的后缀。',
        example: '"j"',
        require: "o",
        repeat: "n",
        type: "rangestring"
      }]
    }, {
      n: "IMREAL",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的复数的实系数。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的复数的实系数。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要计算其实系数的复数。",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMAGINARY",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的复数的虚系数。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的复数的虚系数。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要计算其虚系数的复数。",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMCONJUGATE",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的复数的共轭复数。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的复数的共轭复数。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要计算其共轭数的复数。",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMABS",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的复数的绝对值（模）。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的复数的绝对值（模）。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "要计算其绝对值的复数。",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DELTA",
      t: 9,
      d: "检验两个值是否相等。 如果 number1=number2，则返回 1；否则返回 0。",
      a: "检验两个值是否相等。 如果 number1=number2，则返回 1；否则返回 0。",
      m: [1, 2],
      p: [{
        name: "number1",
        detail: "第一个数字。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number2",
        detail: "[可选 - 默认为 0] - 第二个数字。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IMSUM",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 个复数的和。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 个复数的和。",
      m: [1, 255],
      p: [{
        name: "inumber1",
        detail: "要相加的第一个复数",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2, …",
        detail: "[可选] - 要与值1 相加的其他复数",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMSUB",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的两个复数的差。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的两个复数的差。",
      m: [2, 2],
      p: [{
        name: "inumber1",
        detail: "从（复）数中减去 inumber2。",
        example: '"6+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2",
        detail: "从 inumber1 中减（复）数。",
        example: '"2+3i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMPRODUCT",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 个复数的乘积。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 个复数的乘积。",
      m: [1, 255],
      p: [{
        name: "inumber1",
        detail: "用于计算乘积的第一个复数",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2, …",
        detail: "[可选] - 要相乘的其他复数。",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMDIV",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的两个复数的商。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的两个复数的商。",
      m: [2, 2],
      p: [{
        name: "inumber1",
        detail: "复数分子或被除数。",
        example: '"11+16i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2",
        detail: "复数分母或除数。",
        example: '"3+2i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOT",
      t: 10,
      d: "返回某个逻辑值的相反值 - “NOT(TRUE())”将返回 FALSE；“NOT(FALSE())”将返回 TRUE。",
      a: "返回某个逻辑值的相反值 - “NOT(TRUE())”将返回 FALSE；“NOT(FALSE())”将返回 TRUE。",
      m: [1, 1],
      p: [{
        name: "logical",
        detail: "计算结果为 TRUE 或 FALSE 的任何值或表达式。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRUE",
      t: 10,
      d: "返回逻辑值 TRUE。",
      a: "返回逻辑值 TRUE。",
      m: [0, 0],
      p: []
    }, {
      n: "FALSE",
      t: 10,
      d: "返回逻辑值 FALSE。",
      a: "返回逻辑值 FALSE。",
      m: [0, 0],
      p: []
    }, {
      n: "AND",
      t: 10,
      d: "所有参数的计算结果为 TRUE 时，返回 TRUE；只要有一个参数的计算结果为 FALSE，即返回 FALSE。",
      a: "所有参数的计算结果为 TRUE 时，返回 TRUE；只要有一个参数的计算结果为 FALSE，即返回 FALSE。",
      m: [1, 255],
      p: [{
        name: "logical1",
        detail: "要测试的第一个条件，其计算结果可以为 TRUE 或 FALSE。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical2,...",
        detail: "[可选] - 要测试的其他条件，其计算结果可以为 TRUE 或 FALSE，最多可包含 255 个条件。",
        example: 'A3 = "bar"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IFERROR",
      t: 10,
      d: "如果第一个参数不是错误值，就返回第一个参数；否则，返回第二个参数。",
      a: "如果第一个参数不是错误值",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "检查是否存在错误的参数。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_error",
        detail: "公式的计算结果错误时返回的值。 计算以下错误类型：#N/A、#VALUE!、#REF!、#DIV/0!、#NUM!、#NAME? 或 #NULL!。",
        example: '"Error in cell A1"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IF",
      t: 10,
      d: "当逻辑表达式的值为 TRUE 时返回一个值，而当其为 FALSE 时返回另一个值。",
      a: "当逻辑表达式的值为 TRUE 时返回一个值，而当其为 FALSE 时返回另一个值。",
      m: [2, 3],
      p: [{
        name: "logical_test",
        detail: "一个表达式或对包含表达式的单元格的引用，该表达式代表某种逻辑值（即TRUE或FALSE）。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_true",
        detail: "当逻辑表达式为TRUE时的返回值。",
        example: '"A2 is foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_false",
        detail: "[可选 - 默认为空白] - 当逻辑表达式等于FALSE时的函数返回值。",
        example: '"A2 was false"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OR",
      t: 10,
      d: "只要有一个参数的计算结果为 TRUE 时，返回 TRUE；所有参数的计算结果为 FALSE，即返回 FALSE。",
      a: "只要有一个参数的计算结果为 TRUE 时，返回 TRUE；所有参数的计算结果为 FALSE，即返回 FALSE。",
      m: [1, 255],
      p: [{
        name: "logical1",
        detail: "要测试的第一个条件，其计算结果可以为 TRUE 或 FALSE。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "逻辑表达式2",
        detail: "[可选] - 其他表达式或对包含表达式的单元格的引用，这些表达式代表某种逻辑值（即TRUE或FALSE）或者可以强制转换为逻辑值。",
        example: ' A3 = "bar"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NE",
      t: 11,
      d: "如果指定的值不相等，则返回“TRUE”；否则返回“FALSE”。相当于“<>”运算符。",
      a: "如果指定的值不相等，则返回“TRUE”；否则返回“FALSE”。相当于“<>”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一个值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要检查是否与 value1 不相等的值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EQ",
      t: 11,
      d: "如果指定的值相等，则返回“TRUE”；否则返回“FALSE”。相当于“=”运算符。",
      a: "如果指定的值相等，则返回“TRUE”；否则返回“FALSE”。相当于“=”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一个值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要检查是否与 value1 相等的值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GT",
      t: 11,
      d: "如果第一个参数严格大于第二个，则返回 TRUE；否则返回 FALSE。相当于“>”运算符。",
      a: "如果第一个参数严格大于第二个，则返回 TRUE；否则返回 FALSE。相当于“>”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否大于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二个值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GTE",
      t: 11,
      d: "如果第一个参数大于或等于第二个，则返回 TRUE；否则返回 FALSE。相当于“>=”运算符。",
      a: "如果第一个参数大于或等于第二个，则返回 TRUE；否则返回 FALSE。相当于“>=”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否大于等于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二个值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LT",
      t: 11,
      d: "如果第一个参数严格小于第二个，则返回 TRUE；否则返回 FALSE。相当于“<”运算符。",
      a: "如果第一个参数严格小于第二个，则返回 TRUE；否则返回 FALSE。相当于“<”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否小于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二个值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LTE",
      t: 11,
      d: "如果第一个参数小于或等于第二个，则返回 TRUE；否则返回 FALSE。相当于“<=”运算符。",
      a: "如果第一个参数小于或等于第二个，则返回 TRUE；否则返回 FALSE。相当于“<=”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否小于等于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二个值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADD",
      t: 11,
      d: "返回两个数值之和。相当于 `+` 运算符。",
      a: "返回两个数值之和。相当于 `+` 运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一个加数。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "第二个加数。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINUS",
      t: 11,
      d: "返回两个数值之差。相当于“-”运算符。",
      a: "返回两个数值之差。相当于“-”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "被减数，即要对其计减的数值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "减数，即要从 value1 中减除的数值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTIPLY",
      t: 11,
      d: "返回两个数的乘积。相当于“*”运算符。",
      a: "返回两个数的乘积。相当于“*”运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一个乘数。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "第二个乘数。",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DIVIDE",
      t: 11,
      d: "返回两个参数相除所得的结果。相当于 `/` 运算符。",
      a: "返回两个参数相除所得的结果。相当于 `/` 运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要被除的数值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "用于除其他数的数值。\n\n除数不得为0。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCAT",
      t: 11,
      d: "返回两个值的串联。相当于 `&` 运算符。",
      a: "返回两个值的串联。相当于 `&` 运算符。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "value2 将附于其后的值。",
        example: '"de"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要附于 value1 之后的值。",
        example: '"mystify"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNARY_PERCENT",
      t: 11,
      d: "返回按百分比解释的数值。例如，“UNARY_PERCENT(100)”等于1。",
      a: "返回按百分比解释的数值。例如，“UNARY_PERCENT(100)”等于1。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "要作为百分比解释的数值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCATENATE",
      t: 12,
      d: "将两个或多个文本字符串联接为一个字符串。",
      a: "将两个或多个文本字符串联接为一个字符串。",
      m: [1, 255],
      p: [{
        name: "text1",
        detail: "初始字符串。",
        example: '"Super"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text2 ...",
        detail: "[可选] - 要按顺序连接在一起的其他字符串。",
        example: '"calla"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CODE",
      t: 12,
      d: "返回所提供的字符串中首字符的 Unicode 映射值。",
      a: "返回所提供的字符串中首字符的 Unicode 映射值。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其首字符的Unicode映射值的字符串。",
        example: '"a"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CHAR",
      t: 12,
      d: "按照当前 Unicode 编码表，将数字转换为对应的字符。",
      a: "按照当前 Unicode 编码表，将数字转换为对应的字符。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "介于 1 到 255 之间的数字。",
        example: "97",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ARABIC",
      t: 12,
      d: "将罗马数字转换为阿拉伯数字。",
      a: "将罗马数字转换为阿拉伯数字。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要转换格式的罗马数字",
        example: '"XIV"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROMAN",
      t: 12,
      d: "将数字格式设置为罗马数字形式。",
      a: "将数字格式设置为罗马数字形式。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "要设置格式的数字，介于1到3999之间（包括这两个数字）。",
        example: "499",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "REGEXEXTRACT",
      t: 12,
      d: "按照正则表达式提取匹配的子串。",
      a: "按照正则表达式提取匹配的子串。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "输入文本。",
        example: '"Needle in a haystack"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "此函数将返回文本中符合此表达式的第一个子串。",
        example: '".e{2}dle"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXMATCH",
      t: 12,
      d: "判断一段文本是否与正则表达式相匹配。",
      a: "判断一段文本是否与正则表达式相匹配。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "要用正则表达式测试的文本。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "用来测试文本的正则表达式。",
        example: '"S.r"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXREPLACE",
      t: 12,
      d: "使用正则表达式将文本字符串中的一部分替换为其他文本字符串。",
      a: "使用正则表达式将文本字符串中的一部分替换为其他文本字符串。",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "要对其局部进行替换操作的文本。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "正则表达式。 text 中所有匹配的实例都将被替换。",
        example: '"S.*d"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replacement",
        detail: "要插入到原有文本中的文本。",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T",
      t: 12,
      d: "返回文本格式的字符串参数。",
      a: "返回文本格式的字符串参数。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为文本的参数。\n\n如果值为文本，T将返回值本身。\n\n如果值为指向包含文本的单元格的引用，T将返回值中的内容。\n\n如果值为错误值或包含错误值的单元格，T将返回该错误值。\n\n对于所有其他情况，T将返回空串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIXED",
      t: 12,
      d: "以固定的小数位数设置数字的格式。",
      a: "以固定的小数位数设置数字的格式。",
      m: [1, 3],
      p: [{
        name: "number",
        detail: "要进行舍入并转换为文本的数字。",
        example: "3.141592653",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "decimals",
        detail: "[可选 - 默认值为2] - 结果中要显示的小数位数。\n\n如果数值的有效位数小于小数位数，将以零填充。如果数值的有效位数大于小数位数，则将其舍入到所需的小数位数而不是将其截断。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "no_commas",
        detail: "[可选 - 默认值为FALSE()] - 一个逻辑值，如果为 TRUE()，则会禁止 FIXED 在返回的文本中包含逗号。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIND",
      t: 12,
      d: "返回字符串在文本中首次出现的位置（区分大小写）。",
      a: "返回字符串在文本中首次出现的位置（区分大小写）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要搜索的文本中查找的字符串。",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中搜索搜索字符串的首次出现位置的文本。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[可选 - 默认值为1] - 要在要搜索的文本中开始搜索的字符位置。",
        example: "14",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FINDB",
      t: 12,
      d: "返回某个字符串在文本中首次出现的位置（每个双字节字符占两个位置）。",
      a: "返回某个字符串在文本中首次出现的位置（每个双字节字符占两个位置）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要搜索的文本中查找的字符串。",
        example: '"新"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中搜索搜索字符串的首次出现位置的文本。",
        example: '"农历新年"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[可选 - 默认值为 1] - 要在要搜索的文本中开始搜索的字符位置。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "JOIN",
      t: 12,
      d: "将一个或多个使用指定定界符的一维数组的元素连接到一起。",
      a: "将一个或多个使用指定定界符的一维数组的元素连接到一起。",
      m: [2, 255],
      p: [{
        name: "separator",
        detail: "置于相互连接的值之间的字符或字符串。\n\n定界符可以为空，例如JOIN(,{1,2,3})。",
        example: '" and-a "',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "array1",
        detail: "要使用定界符连接的一个或多个值。",
        example: "{1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "array2, ...",
        detail: "[可选] - 要使用定界符连接的其他值或数组。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LEFT",
      t: 12,
      d: "从文本字符串的第一个字符开始返回指定个数的字符。",
      a: "从文本字符串的第一个字符开始返回指定个数的字符。",
      m: [1, 2],
      p: [{
        name: "text",
        detail: "包含要提取的字符的文本字符串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_chars",
        detail: "[可选 - 默认值为1] - 指定要由 LEFT 提取的字符的数量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RIGHT",
      t: 12,
      d: "根据所指定的字符数返回文本字符串中最后一个或多个字符。",
      a: "根据所指定的字符数返回文本字符串中最后一个或多个字符。",
      m: [1, 2],
      p: [{
        name: "text",
        detail: "包含要提取的字符的文本字符串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_chars",
        detail: "[可选 - 默认值为1] - 指定要由 RIGHT 提取的字符的数量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MID",
      t: 12,
      d: "返回文本字符串中从指定位置开始的特定数目的字符。",
      a: "返回文本字符串中从指定位置开始的特定数目的字符。",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "包含要提取的字符的文本字符串。",
        example: '"get this"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "要从字符串中开始提取的位置。字符串中第一个字符的索引为1。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_chars",
        detail: "指定要由 MID 提取的字符的数量。\n\n如果提取的字符数尚不足提取长度个字符时就到达了字符串尾部，则MID返回从开始位置到字符串尾部的字符。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LEN",
      t: 12,
      d: "返回给定字符串的长度。",
      a: "返回给定字符串的长度。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其长度的字符串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LENB",
      t: 12,
      d: "返回文本中所包含的字符数。与双字节字符集(DBCS)一起使用。",
      a: "返回文本中所包含的字符数。与双字节字符集(DBCS)一起使用。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其字节数的字符串。（一个汉字为两个字节数）",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOWER",
      t: 12,
      d: "将指定字符串中的字母转换为小写。",
      a: "将指定字符串中的字母转换为小写。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要转换为小写的字符串。",
        example: '"LOREM IPSUM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UPPER",
      t: 12,
      d: "将指定字符串中的字母转换为大写。",
      a: "将指定字符串中的字母转换为大写。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要转换为大写的字符串。",
        example: '"lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EXACT",
      t: 12,
      d: "比较两个字符串是否相同。",
      a: "比较两个字符串是否相同。",
      m: [2, 2],
      p: [{
        name: "text1",
        detail: "要比较的第一个字符串。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text2",
        detail: "要比较的第二个字符串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPLACE",
      t: 12,
      d: "将文本字符串的一部分替换为其他文本字符串。",
      a: "将文本字符串的一部分替换为其他文本字符串。",
      m: [4, 4],
      p: [{
        name: "old_text",
        detail: "要对其局部进行替换操作的文本。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "开始进行替换操作的位置（文本开头位置为 1）。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_chars",
        detail: "要在文本中替换的字符个数。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_text",
        detail: "要插入到原有文本中的文本。",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPT",
      t: 12,
      d: "返回指定文本的多次重复。",
      a: "返回指定文本的多次重复。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "要重复的字符或字符串。",
        example: '"ha"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_times",
        detail: "要重复的文本要在返回值中出现的次数。\n\n最大重复次数为100。即使重复次数大于100，REPT也仅将相应文本重复100次。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEARCH",
      t: 12,
      d: "返回字符串在文本中首次出现的位置（不区分大小写）。",
      a: "返回字符串在文本中首次出现的位置（不区分大小写）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要搜索的文本中查找的字符串。",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中搜索搜索字符串的首次出现位置的文本。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[ 可选 - 默认值为1 ] - 要在要搜索的文本中开始搜索的字符位置。",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUBSTITUTE",
      t: 12,
      d: "在文本字符串中用 new_text 替换 old_text。",
      a: "在文本字符串中用 new_text 替换 old_text。",
      m: [3, 4],
      p: [{
        name: "text",
        detail: "需要替换其中字符的文本，或对含有文本（需要替换其中字符）的单元格的引用。",
        example: '"search for it"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "old_text",
        detail: "需要替换的文本。",
        example: '"search for"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "new_text",
        detail: "用于替换 old_text 的文本。",
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "instance_num",
        detail: "[ 可选 ] - 指定要用 new_text 替换 old_text 的事件。 如果指定了 instance_num，则只有满足要求的 old_text 被替换。 否则，文本中出现的所有 old_text 都会更改为 new_text。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CLEAN",
      t: 12,
      d: "移除文本中的不可打印 ASCII 字符后将其返回。",
      a: "移除文本中的不可打印 ASCII 字符后将其返回。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要移除其中不可打印字符的文本。",
        example: '"AF"&CHAR(31)',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TEXT",
      t: 12,
      d: "按照指定格式将数字转换为文本。",
      a: "按照指定格式将数字转换为文本。",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "要设置格式的数字、日期或时间。",
        example: "1.23",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "format_text",
        detail: '以括号括起来的模式串，将按该模式设置数字的格式。\n\n0表示在数值位数少于格式指定的位数时必定以零填充。例如，TEXT(12.3,"000.00")将返回012.30。当数值的小数位数超过模式指定的小数位数时，四舍五入为指定的小数位数。例如，TEXT(12.305,"00.00")将返回12.31。\n\n#类似于0，但并不是在小数点的两侧都以零填充。例如，TEXT(12.3,"###.##")将返回12.3。',
        example: '"$0.00"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRIM",
      t: 12,
      d: "删除指定字符串前后的空格。",
      a: "删除指定字符串前后的空格。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要修剪的字符串或指向包含该字符串的单元格的引用。",
        example: '" lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "VALUE",
      t: 12,
      d: "将可识别的任何日期、时间或数字格式的字符串转换为数字。",
      a: "将可识别的任何日期、时间或数字格式的字符串转换为数字。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "包含要转换的值的字符串。",
        example: '"123"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROPER",
      t: 12,
      d: "将指定字符串中每个单词的首字母转为大写。",
      a: "将指定字符串中每个单词的首字母转为大写。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要转换的文本，其中每个单词的首字母都将转为大写，所有其他字母则转为小写。",
        example: '"united states"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CONVERT",
      t: 13,
      d: "将数字从一种度量系统转换为另一种度量系统。",
      a: "将数字从一种度量系统转换为另一种度量系统。",
      m: [3, 3],
      p: [{
        name: "number",
        detail: "是以 from_unit 为单位的需要进行转换的数值。",
        example: "5.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "from_unit",
        detail: "是数值的单位。",
        example: '"g"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "to_unit",
        detail: "是结果的单位。",
        example: '"kg"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "SUMX2MY2",
      t: 14,
      d: "返回两数组中对应数值的平方差之和。",
      a: "返回两数组中对应数值的平方差之和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一个数组或数值区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二个数组或数值区域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMX2PY2",
      t: 14,
      d: "返回两数组中对应数值的平方和之和。",
      a: "返回两数组中对应数值的平方和之和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一个数组或数值区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二个数组或数值区域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMXMY2",
      t: 14,
      d: "返回两数组中对应数值之差的平方和。",
      a: "返回两数组中对应数值之差的平方和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一个数组或数值区域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二个数组或数值区域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRANSPOSE",
      t: 14,
      d: "将数组或单元格范围的行列转置。",
      a: "将数组或单元格范围的行列转置。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要将其行列互换的数组或范围。",
        example: "{1,2}",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TREND",
      t: 14,
      d: "返回线性趋势值。",
      a: "返回线性趋势值。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "关系表达式 y = mx + b 中已知的 y 值集合。\n\n如果 known_y 为二维数组或范围，则 known_x 的维数必须与之相同，或者省略此参数。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可选 - 默认该数组为{1,2,3,...},其大小与 known_y 相同] - 关系表达式 y = mx + b 中已知的可选 x 值集合。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_x",
        detail: "[可选 - 默认与 known_x 相同] -  需要函数 TREND 返回对应 y 值的新 x 值。",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可选 - 默认值为TRUE()] - 一个逻辑值，用于指定是否将常量 b 强制设为 0。\n\nTRUE() 表示 b 将按正常计算；\n\nFALSE() 表示 b 将被设为 0（零），m 将被调整以使 y = mx。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FREQUENCY",
      t: 14,
      d: "计算数值在某个区域内的出现频率，然后返回一个垂直数组。",
      a: "计算数值在某个区域内的出现频率，然后返回一个垂直数组。",
      m: [2, 2],
      p: [{
        name: "data_array",
        detail: "要对其频率进行计数的一组数值或对这组数值的引用。",
        example: "A2:A40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "bins_array",
        detail: "要将 data_array 中的值插入到的间隔数组或对间隔的引用。\n\n为清晰起见，应将类别排序，但如果未排序，FREQUENCY会在内部对这些指定的值进行排序并返回正确结果。",
        example: "B2:B5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GROWTH",
      t: 14,
      d: "使用现有数据计算预测的指数等比。",
      a: "使用现有数据计算预测的指数等比。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "关系表达式 y = b*m^x 中已知的 y 值集合。\n\n如果已知数据_y为二维数组或范围，则已知数据_x的维数必须与之相同，或者省略此参数。\n\n如果已知数据_y为一维数组或范围，已知数据_x则可代表二维数组或范围中的多个自变量。也就是说，如果已知数据_y为单行，则将已知数据_x中的每行解释为各自独立的值，类似情况也适用于已知数据_y为单列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可选 - 默认该数组为{1,2,3,...},其大小与 known_y 相同] - 关系表达式 y = b*m^x 中已知的可选 x 值集合。\n\n如果已知数据_y为一维数组或范围，已知数据_x则可代表二维数组或范围中的多个自变量。也就是说，如果已知数据_y为单行，则将已知数据_x中的每行解释为各自独立的值，类似情况也适用于已知数据_y为单列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_x",
        detail: "[可选 - 默认与 known_x 相同] - 需要函数 GROWTH 返回对应 y 值的新 x 值。",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可选 - 默认值为TRUE()] -一个逻辑值，用于指定是否将常量 b 强制设为 1。\n\nTRUE() 表示 b 将按正常计算；\n\nFALSE() 表示 b 将被设为 1，m 将被调整以使 y = m^x。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINEST",
      t: 14,
      d: "可通过使用最小二乘法计算与现有数据最佳拟合的直线，来计算某直线的统计值，然后返回描述此直线的数组。",
      a: "可通过使用最小二乘法计算与现有数据最佳拟合的直线，来计算某直线的统计值，然后返回描述此直线的数组。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "关系表达式 y = mx + b 中已知的 y 值集合。\n\n如果 known_y 为二维数组或范围，则 known_x 的维数必须与之相同，或者省略此参数。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可选 - 默认该数组为{1,2,3,...},其大小与 known_y 相同] - 关系表达式 y = mx + b 中已知的可选 x 值集合。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可选 - 默认值为TRUE()] - 一个逻辑值，用于指定是否将常量 b 强制设为 0。\n\nTRUE() 表示 b 将按正常计算；\n\nFALSE() 表示 b 将被设为 0（零），m 将被调整以使 y = mx。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "stats",
        detail: "[可选 - 默认值为FALSE()] - 一个逻辑值，用于指定是否返回附加回归统计值。\n\n如果详细为TRUE，除了对应于每个自变量的一组线性系数和y截距之外，LINEST还返回以下信息：\n\n每项系数和截距的标准误差、\n\n限定系数（介于0和1之间，1表示完全相关）、\n\n因变量值的标准误差、\n\nF统计或F观测值，指示所观测到的因变量和自变量变量之间的关系是随机的还是线性的、\n\n自由度，用于在参照表中查找F统计值以估算可信度、\n\n回归平方和，以及\n\n残差平方和。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOGEST",
      t: 14,
      d: "在回归分析中，计算最符合数据的指数回归拟合曲线，并返回描述该曲线的数值数组。",
      a: "在回归分析中，计算最符合数据的指数回归拟合曲线，并返回描述该曲线的数值数组。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "关系表达式 y = mx + b 中已知的 y 值集合。\n\n如果 known_y 为二维数组或范围，则 known_x 的维数必须与之相同，或者省略此参数。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可选 - 默认该数组为{1,2,3,...},其大小与 known_y 相同] - 关系表达式 y = mx + b 中已知的可选 x 值集合。\n\n如果 known_y 为一维数组或范围，known_x 则可代表二维数组或范围中的多个自变量。也就是说，如果 known_y 为单行，则将 known_x 中的每行解释为各自独立的值，类似情况也适用于 known_y 为单列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可选 - 默认值为TRUE()] - 一个逻辑值，用于指定是否将常量 b 强制设为 0。\n\nTRUE() 表示 b 将按正常计算；\n\nFALSE() 表示 b 将被设为 0（零），m 将被调整以使 y = mx。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "stats",
        detail: "[可选 - 默认值为FALSE()] - 一个逻辑值，用于指定是否返回附加回归统计值。\n\n如果详细为TRUE，则除了为每个自变量和系数 b 返回一组指数值之外，LOGEST 还将返回以下数据：\n\n每项指数和系数的标准误差、\n\n限定系数（介于 0 和 1 之间，1 表示完全相关）、\n\n因变量值的标准误差、\n\nF 统计或 F 观测值，指示所观测到的因变量和自变量之间的关系是随机的还是指数的、\n\n自由度 - 用于在参照表中查找 F 统计值以估算可信度、\n\n回归平方和，以及\n\n残差平方和。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MDETERM",
      t: 14,
      d: "返回一个数组的矩阵行列式的值。",
      a: "返回一个数组的矩阵行列式的值。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "行数和列数相等的数值数组。",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINVERSE",
      t: 14,
      d: "返回数组中存储的矩阵的逆矩阵。",
      a: "返回数组中存储的矩阵的逆矩阵。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "行数和列数相等的数值数组。",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MMULT",
      t: 14,
      d: "返回两个数组的矩阵乘积。结果矩阵的行数与 array1 的行数相同，矩阵的列数与 array2 的列数相同。",
      a: "返回两个数组的矩阵乘积。结果矩阵的行数与 array1 的行数相同，矩阵的列数与 array2 的列数相同。",
      m: [2, 2],
      p: [{
        name: "array1",
        detail: "要进行矩阵乘法运算的第一个矩阵数组。\n\narray1 列数必须与 array2 的行数相同",
        example: "A1:B3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "要进行矩阵乘法运算的第二个矩阵数组。\n\narray2 的行数必须与 array1 列数相同",
        example: "C1:F2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMPRODUCT",
      t: 14,
      d: "在给定的几组数组中，将数组间对应的元素相乘，并返回乘积之和。",
      a: "在给定的几组数组中，将数组间对应的元素相乘，并返回乘积之和。",
      m: [1, 255],
      p: [{
        name: "array1",
        detail: "其相应元素需要进行相乘并求和的第一个数组参数。",
        example: "A2:C5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "[可选] - 其相应元素需要进行相乘并求和的其它数组参数。",
        example: "D2:F5",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "ISFORMULA",
      t: 15,
      d: "检查公式是否位于引用的单元格中。",
      a: "检查公式是否位于引用的单元格中。",
      m: [1, 1],
      p: [{
        name: "cell",
        detail: "要检查是否存在公式的单元格。\n\n如果 cell 为包含公式的单元格，则 ISFORMULA 将返回 TRUE。如果 cell 为相应单元格范围，则当该范围内的首个单元格包含公式时，系统会返回 TRUE。如果是任何其他值，系统都将返回 FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CELL",
      t: 15,
      d: "返回有关单元格的格式、位置或内容的信息。",
      a: "返回有关单元格的格式、位置或内容的信息。",
      m: [2, 2],
      p: [{
        name: "info_type",
        detail: "一个文本值，指定要返回的单元格信息的类型。",
        example: '"type"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "reference",
        detail: "需要其相关信息的单元格。",
        example: "C2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "NA",
      t: 15,
      d: "返回错误值 #N/A。",
      a: "返回错误值 #N/A。",
      m: [0, 0],
      p: []
    }, {
      n: "ERROR_TYPE",
      t: 15,
      d: "返回与其他单元格中的错误值相对应的数字。",
      a: "返回与其他单元格中的错误值相对应的数字。",
      m: [1, 1],
      p: [{
        name: "error_val",
        detail: "用于查找错误号的单元格，虽然您也可以直接提供错误值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISBLANK",
      t: 15,
      d: "检查所引用的单元格是否为空。",
      a: "检查所引用的单元格是否为空。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "对要检查其是否为空的单元格的引用。\n\n如果是空单元格，则 TRUE；否则返回 FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISERR",
      t: 15,
      d: "检查某个值是否为 #N/A 以外的错误值。",
      a: "检查某个值是否为 #N/A 以外的错误值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其是否为#N/A以外的错误类型的值。\n\n如果值是除#N/A之外的任何错误（包括#DIV/0!、#NAME?、#NULL!、#NUM!、#VALUE!和#REF!），ISERR将返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISERROR",
      t: 15,
      d: "检查某个值是否为错误值。",
      a: "检查某个值是否为错误值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其是否为错误类型的值。\n\n只要值是某种错误值（包括#DIV/0!、#N/A、#NAME?、#NULL!、#NUM!、#VALUE!和#REF!），ISERROR就会返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISLOGICAL",
      t: 15,
      d: "检查某个值是 TRUE 还是 FALSE。",
      a: "检查某个值是 TRUE 还是 FALSE。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其为逻辑TRUE还是逻辑FALSE的值。\n\n*如果值为TRUE或FALSE，或为指向值为TRUE或FALSE的单元格的引用，ISLOGICAL将返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNA",
      t: 15,
      d: "检查某个值是否为错误值 #N/A。",
      a: "检查某个值是否为错误值 #N/A。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要与错误值#N/A进行比较的值。\n\n*如果值为#N/A或指向包含#N/A的单元格的引用，则ISNA将返回TRUE，否则返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNONTEXT",
      t: 15,
      d: "检查某个值是否为非文本。",
      a: "检查某个值是否为非文本。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要检查的文本。\n\n*如果参数为文本值或指向包含文本的单元格的引用，ISNONTEXT将返回FALSE，否则返回TRUE。\n\n当值为指向空单元格的引用时，ISNONTEXT会返回TRUE。\n\n当值为空字符串时，ISNONTEXT将返回FALSE，因为空串被视作文本。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNUMBER",
      t: 15,
      d: "检查某个值是否为数字。",
      a: "检查某个值是否为数字。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其是否为数字的值。\n\n*如果参数为数字或指向内容为数字值的单元格的引用，ISNUMBER将返回TRUE，否则返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISREF",
      t: 15,
      d: "检查某个值是否为有效的单元格引用。",
      a: "检查某个值是否为有效的单元格引用。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其是否为单元格引用的值。\n\n*如果参数是有效的单元格引用，ISREF将返回TRUE，否则返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISTEXT",
      t: 15,
      d: "检查某个值是否为文本。",
      a: "检查某个值是否为文本。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要验证其是否为文本的值。\n\n如果参数为文本值或指向包含文本值的单元格的引用，ISTEXT将返回TRUE，否则返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TYPE",
      t: 15,
      d: "返回数值的类型。",
      a: "返回数值的类型。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要确定其类型的数据。\n\n数字 返回 1;\n\n文本 返回 2;\n\n逻辑值 返回 4;\n\n错误值 返回 16;\n\n数组 返回 64;",
        example: "C4",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "N",
      t: 15,
      d: "返回转化为数值后的值。",
      a: "返回转化为数值后的值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为数字的参数。\n\n如果值为数字，则返回该数字。\n\n如果值为日期，则返回该日期的序列号。\n\n如果值为TRUE，则返回1。\n\n如果值为FALSE，则返回0。\n\n如果值为错误值，则返回错误值。\n\n如果值为其他值，则返回0。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DATE",
      t: 16,
      d: "将指定的数字转换为日期。",
      a: "将指定的数字转换为日期。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为日期的参数或其单元格引用。\n\n如果值为数字或指向内容为数值的单元格的引用，TO_DATE会将值转换为相应的日期并返回，值代表从十二月30日到对应的日期之间的天数，\n\n负值表示对应的日期在十二月30日之前，而小数值则代表一天中从午夜算起的时间。\n如果值不是数字或指向内容为数值的单元格的引用，则TO_DATE将在不做任何修改的情况下返回值。",
        example: "25405",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PURE_NUMBER",
      t: 16,
      d: "将给定的日期/时间、百分比、货币金额或其他格式的数值转换为不带格式的纯数字。",
      a: "将给定的日期/时间、百分比、货币金额或其他格式的数值转换为不带格式的纯数字。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为纯数字的参数或其单元格引用。\n\n如果值为数字或指向包含数值的单元格的引用，TO_PURE_NUMBER将以不带任何格式与解释的形式返回值。\n\n如果值不是数字或指向内容为数值的单元格的引用，则TO_PERCENT将在不做任何修改的情况下返回值。",
        example: "50%",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_TEXT",
      t: 16,
      d: "将给定的数字值转换为文本格式。",
      a: "将给定的数字值转换为文本格式。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为文本的参数或其单元格引用。\n\n如果值为数字或指向包含数值的单元格的引用，TO_TEXT将返回字符串形式的值，并保持现有格式。即原为货币的仍为货币，原为十进制数的仍为十进制数，原为百分比的仍为百分比，原为日期的仍为日期。\n\n如果值不是数字或指向内容为数值的单元格的引用，则TO_TEXT将在不做任何修改的情况下返回值。",
        example: "24",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DOLLARS",
      t: 16,
      d: "将指定的数字转换为美元金额。",
      a: "将指定的数字转换为美元金额。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为美元金额的参数或其单元格引用。\n\n如果值不是数字或指向内容为数值的单元格的引用，则 TO_DOLLARS 将在不做任何修改的情况下返回值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PERCENT",
      t: 16,
      d: "将指定的数字转换为百分比。",
      a: "将指定的数字转换为百分比。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要转换为百分比的参数或其单元格引用。\n\n如果值为数字或指向包含数值的单元格的引用，TO_PERCENT会以1 = 100%为标准，将值转换为百分比。\n\n如果值不是数字或指向内容为数值的单元格的引用，则TO_PERCENT将在不做任何修改的情况下返回值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DGET",
      t: 17,
      d: "使用 SQL 式查询，从列表或数据库的列中提取符合指定条件的单个值。",
      a: "使用 SQL 式查询，从列表或数据库的列中提取符合指定条件的单个值。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMAX",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的最大数字。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的最大数字。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMIN",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的最小数字。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的最小数字。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DAVERAGE",
      t: 17,
      d: "使用 SQL 式查询，对列表或数据库中满足指定条件的记录字段（列）中的数值求平均值。",
      a: "使用 SQL 式查询，对列表或数据库中满足指定条件的记录字段（列）中的数值求平均值。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNT",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中包含数字的单元格的个数。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中包含数字的单元格的个数。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNTA",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的非空单元格的个数。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的非空单元格的个数。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DPRODUCT",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的数值的乘积。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的数值的乘积。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEV",
      t: 17,
      d: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为一个样本估算出的总体标准偏差。",
      a: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为一个样本估算出的总体标准偏差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEVP",
      t: 17,
      d: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为样本总体计算出的总体标准偏差。",
      a: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为样本总体计算出的总体标准偏差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSUM",
      t: 17,
      d: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的数字之和。",
      a: "使用 SQL 式查询，返回列表或数据库中满足指定条件的记录字段（列）中的数字之和。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVAR",
      t: 17,
      d: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为一个样本估算出的总体方差。",
      a: "使用 SQL 式查询，返回利用列表或数据库中满足指定条件的记录字段（列）中的数字作为一个样本估算出的总体方差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVARP",
      t: 17,
      d: "使用 SQL 式查询，通过使用列表或数据库中满足指定条件的记录字段（列）中的数字计算样本总体的样本总体方差。",
      a: "使用 SQL 式查询，通过使用列表或数据库中满足指定条件的记录字段（列）中的数字计算样本总体的样本总体方差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "构成列表或数据库的单元格区域，列表的第一行包含每一列的标签。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定 database 中的哪一列包含要提取和用于计算的值。\n\nfield 可以是与 database 第一行中某个列标题对应的文本标签，也可以是指定相关列的数字索引，第一列的索引值为 1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定条件的单元格区域。计算之前将使用这些条件来过滤 database 中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "AGE_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出年龄。支持15位或18位身份证",
      a: "根据身份证号得到年龄。",
      m: [1, 2],
      p: [{
        name: "身份证号",
        example: "A1",
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "截止日期",
        example: '"2017-10-01"',
        detail: "年龄计算的截止日期或范围，默认为当日。",
        require: "o",
        repeat: "n",
        type: "rangedatetime"
      }]
    }, {
      n: "SEX_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出性别。支持15位或18位身份证",
      a: "根据身份证号得到性别。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIRTHDAY_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出生日。支持15位或18位身份证",
      a: "根据身份证号得到生日。",
      m: [1, 2],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "生日格式",
        example: "0",
        detail: "日期类型,默认0:[1900/01/01], 1:[1900-01-01], 2:[1900年1月1日]",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROVINCE_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出籍贯的省份。支持15位或18位身份证",
      a: "根据身份证号得到籍贯的省份。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CITY_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出籍贯的城市。支持15位或18位身份证",
      a: "根据身份证号得到籍贯的城市。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "STAR_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出星座。支持15位或18位身份证",
      a: "根据身份证号得到星座。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ANIMAL_BY_IDCARD",
      t: "3",
      d: "根据中国身份证号计算出生肖（鼠、牛、虎、兔...）。支持15位或18位身份证",
      a: "根据身份证号得到生肖。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISIDCARD",
      t: "3",
      d: "验证身份证的格式是否正确。支持15位或18位身份证",
      a: "验证身份证格式正确性。",
      m: [1, 1],
      p: [{
        name: "身份证号",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份证号或范围。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DM_TEXT_CUTWORD",
      t: "4",
      d: "文本分词。把一连串文字拆分为一系列单独词语",
      a: "中文文本分词。",
      m: [1, 2],
      p: [{
        name: "文本",
        example: '"我来到北京清华大学"',
        detail: "任意需要分词的文本。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "分词模式",
        example: "0",
        detail: "默认为0[精确模式], 1[全模式], 2[搜索引擎模式]。",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TFIDF",
      t: "4",
      d: "采用tf-idf算法进行关键词提取。从一连串文字中识别关键词",
      a: "tf-idf关键词识别。",
      m: [1, 3],
      p: [{
        name: "文本",
        example: '"我来到北京清华大学"',
        detail: "任意需要分词的文本。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "关键词个数",
        example: "20",
        detail: "算法返回的关键词个数，默认20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "语料库",
        example: "1",
        detail: "选择特定领域的语料库，默认0[通用], 1[金融], 2[医疗]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TEXTRANK",
      t: "4",
      d: "采用TextRank算法进行关键词提取。从一连串文字中识别关键词",
      a: "TextRank关键词识别。",
      m: [1, 3],
      p: [{
        name: "文本",
        example: '"我来到北京清华大学"',
        detail: "任意需要分词的文本。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "关键词个数",
        example: "20",
        detail: "算法返回的关键词个数，默认20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "语料库",
        example: "1",
        detail: "选择特定领域的语料库，默认0[通用], 1[金融], 2[医疗]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_CLOSE",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票收盘价。",
      a: "返回A股对应股票收盘价。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_OPEN",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票开盘价。",
      a: "返回A股对应股票开盘价。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MAX",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票最高价。",
      a: "返回A股对应股票最高价。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MIN",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票最低价。",
      a: "返回A股对应股票最低价。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_VOLUMN",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票成交量。",
      a: "返回A股对应股票成交量。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_AMOUNT",
      t: "5",
      d: "根据股票代码和日期，返回A股对应股票成交额。",
      a: "返回A股对应股票成交额。",
      m: [1, 3],
      p: [{
        name: "股票代码",
        example: '"000001"',
        detail: "6位股票代码，必填项。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "复权除权",
        example: "0",
        detail: "选择股票的除权复权类型，默认0[前复权], 1[原始价格], 2[后复权]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISDATE",
      t: "6",
      d: "验证日期的格式是否正确。支持多种日期格式",
      a: "验证日期格式正确性。",
      m: [1, 1],
      p: [{
        name: "日期",
        example: '"1990-01-01"',
        detail: "日期值，例如1990/01/01, 1990年1月1日等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINESPLINES",
      t: "3",
      d: "生成嵌入在单元格内的折线图sparklines，用于描述数据的连续走势",
      a: "生成单元格折线图",
      m: [1, 8],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "线条颜色",
        example: "#2ec7c9",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "线条粗细",
        example: "1",
        detail: "折线图线段粗细，默认为1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "辅助线",
        example: "avg",
        detail: "一条横线，可以是min、max、avg、median、范围或自定义数值，默认0无",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "辅助线颜色",
        example: "#000",
        detail: "辅助线的颜色设置，同线条颜色配置，默认#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值标识",
        example: "#fc5c5c",
        detail: "标识线图最大值，同线条颜色配置，默认0不显示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最小值标识",
        example: "#fc5c5c",
        detail: "标识线图最小值，同线条颜色配置，默认0不显示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "标识大小",
        example: "1.5",
        detail: "最大值和最小值的标识大小设置，默认为1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AREASPLINES",
      t: "3",
      d: "生成嵌入在单元格内的面积图sparklines，一般用于描述数据的连续累积值走势",
      a: "生成单元格面积图",
      m: [1, 5],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "线条颜色",
        example: "#2ec7c9",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "填充颜色",
        example: "#CCF3F4",
        detail: "形成面积图，同线条颜色配置，默认0不显示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "线条粗细",
        example: "1",
        detail: "折线图线段粗细，默认为1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "辅助线",
        example: "avg",
        detail: "一条横线，可以是min、max、avg、median、范围或自定义数值，默认0无",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "辅助线颜色",
        example: "#000",
        detail: "辅助线的颜色设置，同线条颜色配置，默认#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的垂直柱状图sparklines，一般用于描述离散数据之间的大小情况",
      a: "生成单元格垂直柱状图",
      m: [1, 6],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条间隔",
        example: "1",
        detail: "柱条之间的间隔距离，默认为1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条颜色",
        example: "#fc5c5c",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "负向柱条颜色",
        example: "#97b552",
        detail: "负向柱条颜色设置，代表负值的颜色，同柱条颜色配置，默认#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "柱图最大值，用于规范柱图长度，默认为自动计算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "调色板可以单独设置每个柱条的颜色，可设置多个，支持两种格式：1颜色例如#000，代表第一个柱的颜色是黑色；2数值范围:颜色，例如-2:#000表示数值为-2的柱为黑色，0:5:#000表示数值0-5的柱为黑色，默认为空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKCOLUMNSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的累积垂直柱状图sparklines，一般用于描述离散数据多个维度的数值大小",
      a: "生成单元格累积垂直柱状图",
      m: [1, 5],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "按列堆积",
        example: "1",
        detail: "如果需要按行堆积则本项设为false或0，默认为是1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条间隔",
        example: "1",
        detail: "柱条之间的间隔距离，默认为1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "累积柱图最大值，用于规范柱图长度，默认为自动计算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "累积色板",
        example: "#97b552",
        detail: "调色板可以单独设置每个维度的柱条颜色，可设置为A1:A10等范围，默认为#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BARSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的横向条形图sparklines，一般用于描述离散数据之间的大小情况",
      a: "生成单元格横向条形图",
      m: [1, 6],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条间隔",
        example: "1",
        detail: "柱条之间的间隔距离，默认为1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条颜色",
        example: "#fc5c5c",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "负向柱条颜色",
        example: "#97b552",
        detail: "负向柱条颜色设置，代表负值的颜色，同柱条颜色配置，默认#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "柱图最大值，用于规范柱图长度，默认为自动计算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "调色板可以单独设置每个柱条的颜色，可设置多个，支持两种格式：1颜色例如#000，代表第一个柱的颜色是黑色；2数值范围:颜色，例如-2:#000表示数值为-2的柱为黑色，0:5:#000表示数值0-5的柱为黑色，默认为空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKBARSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的累积横向条形图sparklines，一般用于描述离散数据多个维度的数值大小",
      a: "生成单元格累积横向条形图",
      m: [1, 5],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "按列堆积",
        example: "1",
        detail: "如果需要按行堆积则本项设为false或0，默认为是1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条间隔",
        example: "1",
        detail: "柱条之间的间隔距离，默认为1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "累积柱图最大值，用于规范柱图长度，默认为自动计算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "累积色板",
        example: "#97b552",
        detail: "调色板可以单独设置每个维度的柱条颜色，可设置为A1:A10等范围，默认为#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "DISCRETESPLINES",
      t: "3",
      d: "生成嵌入在单元格内的离散图sparklines，一般用于描述离散数据走势",
      a: "生成单元格离散图",
      m: [1, 4],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "分割阈值",
        example: "1",
        detail: "离散图柱形颜色的区分，例如：该值为0，则大于0为蓝色，小于0为红色，默认为0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "阈值以上颜色",
        example: "#2ec7c9",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "阈值以下颜色",
        example: "#fc5c5c",
        detail: "阈值以下柱条颜色设置，同阈值以上颜色，默认#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRISTATESPLINES",
      t: "3",
      d: "生成嵌入在单元格内的三态图sparklines，一般用于描述三种态势的走势例如胜负平",
      a: "生成单元格三态图",
      m: [1, 6],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条间隔",
        example: "1",
        detail: "柱条之间的间隔距离，默认为1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱条颜色",
        example: "#fc5c5c",
        detail: "线图的线条颜色，可以是否个范围A1、色表索引数值或者具体颜色值，设置为0或false则不显示，支持regx、rgb、rgba等。默认#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "负向柱条颜色",
        example: "#97b552",
        detail: "负向柱条颜色设置，代表负值的颜色，同柱条颜色配置，默认#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "零值柱条颜色",
        example: "#999",
        detail: "零值柱条颜色设置，代表0值颜色，同柱条颜色配置，默认#999",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "调色板可以单独设置每个柱条的颜色，可设置多个，支持两种格式：1颜色例如#000，代表第一个柱的颜色是黑色；2数值范围:颜色，例如-2:#000表示数值为-2的柱为黑色，0-5:#000表示数值0-5的柱为黑色，默认为空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PIESPLINES",
      t: "3",
      d: "生成嵌入在单元格内的饼图sparklines，一般用于描述数据占比",
      a: "生成单元格饼图",
      m: [1, 5],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "旋转角度",
        example: "0",
        detail: "饼图的旋转角度，默认为0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "饼图边框",
        example: "0",
        detail: "饼图边框大小，默认为无0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "边框颜色",
        example: "#000",
        detail: "饼图边框颜色，默认为#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "饼图色板",
        example: "#97b552",
        detail: "调色板可以设置切片的颜色，可设置为A1:A10等范围，默认为#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BOXSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的箱线图sparklines，一般用于描述数据集的统计分布",
      a: "生成单元格箱线图",
      m: [1, 4],
      p: [{
        name: "数据范围",
        example: "A1:A20",
        detail: "数据范围，数值才能被有效计算，例如A1:A20， {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "离群点比例",
        example: "1.5",
        detail: "离群点的阈值范围，如果为0或false则不显示，默认为1.5倍",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "目标点值",
        example: "10",
        detail: "箱线图上的目标值设置，默认为false不显示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "数据点大小",
        example: "1.5",
        detail: "目标点和离群点的半径大小设置，默认为1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BULLETSPLINES",
      t: "3",
      d: "生成嵌入在单元格内的子弹图sparklines，一般用于描述任务达成率",
      a: "生成单元格子弹图",
      m: [2, 3],
      p: [{
        name: "目标",
        example: "10",
        detail: "达成的目标值，数值才能被有效计算，例如A1， 100等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "实际完成",
        example: "8",
        detail: "目前完成值，数值才能被有效计算，例如A1， 100等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "对比值",
        example: "12",
        detail: "对比值，例如超额、最低、获奖底线等，数值才能被有效计算，例如A1， 100等。可以设置最多9个对比值",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMPOSESPLINES",
      t: "3",
      d: "支持多个类型的图画在同一个单元格,每个参数代表一个sparklines图",
      a: "组合sparklines图到一个单元格",
      m: [1, 1],
      p: [{
        name: "图设置",
        example: "PIESPLINES(A1:A20)",
        detail: "sparklines图设置，例如A1:A20， 一个完成的饼图、线图设置等。",
        require: "m",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SORT",
      t: "14",
      d: "返回数组中元素的排序数组。返回的数组与提供的数组参数形状相同。",
      a: "返回数组中元素的排序数组。返回的数组与提供的数组参数形状相同。",
      m: [1, 4],
      p: [{
        name: "array",
        detail: "要排序的范围或数组。",
        example: "A2:A17",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_index",
        detail: "[可选] - 表示要排序的行或列的数字。（默认row1/col1）",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_order",
        detail: "[可选] - 表示所需排序顺序的数字；1表示升序（默认），-1表示降序。",
        example: "-1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[可选] - 表示所需排序方向的逻辑值；按行排序为FALSE()（默认），按列排序为TRUE()。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FILTER",
      t: "14",
      d: "基于一个布尔（真/假）数组过滤一个数组。",
      a: "基于一个布尔（真/假）数组过滤一个数组。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "要筛选的数组或范围。",
        example: "A5:D20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "include",
        detail: "布尔数组，其高度或宽度与数组相同",
        example: "1",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "if_empty",
        detail: "[可选] - 如果包含数组中的所有值都为空(filter不返回任何值)，则返回的值。",
        example: '""',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNIQUE",
      t: "14",
      d: "返回列表或区域中的唯一值的列表。",
      a: "返回列表或区域中的唯一值的列表。",
      m: [1, 3],
      p: [{
        name: "array",
        detail: "从其返回唯一值的数组或区域。",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[可选] - 逻辑值，指示如何比较；按行 = FALSE() 或省略；按列 = TRUE()。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurs_once",
        detail: "[可选] - 逻辑值，仅返回唯一值中出现一次 = TRUE()；包括所有唯一值 = FALSE() 或省略。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANDARRAY",
      t: "14",
      d: "返回 0 到 1 之间的随机数字数组。",
      a: "返回 0 到 1 之间的随机数字数组。",
      m: [0, 2],
      p: [{
        name: "rows",
        detail: "[可选] - 要返回的行数。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "[可选] - 要返回的列数。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEQUENCE",
      t: "14",
      d: "生成数字序列的列表。",
      a: "生成数字序列的列表。",
      m: [1, 4],
      p: [{
        name: "rows",
        detail: "要返回的行数。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "[可选] - 要返回的列数。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start",
        detail: "[可选] - 序列中的第一个数字。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "step",
        detail: "[可选] - 序列中每个序列值的增量。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVALUATE",
      t: "3",
      d: "对以文字表示的公式或者表达式求值，并返回结果。",
      a: "根据文字公式或者表达式求值。",
      m: [1, 1],
      p: [{
        name: "公式",
        example: '"A1+5*2^2"',
        detail: "公式或表达式",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }],
    toolbar: {
      undo: "撤销",
      redo: "重做",
      "clear-format": "清除格式",
      "format-painter": "格式刷",
      "currency-format": "货币格式",
      "percentage-format": "百分比格式",
      "number-decrease": "减少小数位数",
      "number-increase": "增加小数位数",
      moreFormats: "更多格式",
      "border-all": "所有边框",
      "merge-all": "全部合并单元格",
      font: "字体",
      "font-size": "字号",
      bold: "粗体 (Ctrl+B)",
      italic: "斜体 (Ctrl+I)",
      "strike-through": "删除线 (Alt+Shift+5)",
      underline: "下划线",
      "font-color": "文本颜色",
      "align-left": "左对齐",
      "align-center": "水平居中",
      "align-right": "右对齐",
      "align-top": "上对齐",
      "align-mid": "垂直居中",
      "align-bottom": "下对齐",
      chooseColor: "颜色选择",
      resetColor: "重置颜色",
      customColor: "自定义",
      alternatingColors: "交替颜色",
      confirmColor: "确定颜色",
      cancelColor: "取消",
      collapse: "收起",
      background: "背景色",
      border: "边框",
      borderStyle: "边框类型",
      "merge-cell": "合并单元格",
      chooseMergeType: "选择合并类型",
      horizontalAlign: "水平对齐",
      verticalAlign: "垂直对齐",
      alignment: "对齐方式",
      textWrap: "文本换行",
      textWrapMode: "换行方式",
      textRotate: "文本旋转",
      textRotateMode: "旋转方式",
      freeze: "冻结",
      sort: "排序",
      filter: "筛选",
      sortAndFilter: "排序和筛选",
      findAndReplace: "查找替换",
      "formula-sum": "求和",
      autoSum: "自动求和",
      moreFunction: "更多函数",
      conditionalFormat: "条件格式",
      comment: "批注",
      pivotTable: "数据透视表",
      chart: "图表",
      screenshot: "截图",
      splitColumn: "分列",
      insertImage: "插入图片",
      insertLink: "插入链接",
      dataVerification: "数据验证",
      protection: "保护工作表内容",
      clearText: "清除颜色选择",
      noColorSelectedText: "没有颜色被选择",
      toolMore: "更多",
      toolLess: "少于",
      toolClose: "收起",
      toolMoreTip: "更多功能",
      moreOptions: "更多选项",
      cellFormat: "设置单元格格式",
      print: "打印"
    },
    alternatingColors: {
      applyRange: "应用范围",
      selectRange: "选择应用范围",
      header: "页眉",
      footer: "页脚",
      errorInfo: "不能对多重选择区域执行此操作，请选择单个区域，然后再试",
      textTitle: "格式样式",
      custom: "自定义",
      close: "关闭",
      selectionTextColor: "选择文本颜色",
      selectionCellColor: "选择单元格颜色",
      removeColor: "移除交替颜色",
      colorShow: "颜色",
      currentColor: "当前颜色",
      tipSelectRange: "请选择交替颜色应用范围",
      errorNoRange: "您选择的应用范围不是选区！",
      errorExistColors: "您选择的应用范围已存在交替颜色且不属于你要编辑的应用范围！"
    },
    button: {
      confirm: "确定",
      cancel: "取消",
      close: "关闭",
      update: "Update",
      delete: "Delete",
      insert: "新建",
      prevPage: "上一页",
      nextPage: "下一页",
      total: "总共："
    },
    paint: {
      start: "格式刷开启",
      end: "ESC键退出",
      tipSelectRange: "请选择需要复制格式的区域",
      tipNotMulti: "无法对多重选择区域执行此操作"
    },
    format: {
      moreCurrency: "更多货币格式",
      moreDateTime: "更多日期与时间格式",
      moreNumber: "更多数字格式",
      titleCurrency: "货币格式",
      decimalPlaces: "小数位数",
      titleDateTime: "日期与时间格式",
      titleNumber: "数字格式",
      tipDecimalPlaces: "小数位数必须在0-9之间！",
      select: "选择",
      format: "格式",
      currency: "货币"
    },
    info: {
      detailUpdate: "新打开",
      detailSave: "已恢复本地缓存",
      row: "行",
      column: "列",
      loading: "加载中···",
      copy: "副本",
      return: "返回",
      rename: "重命名",
      tips: "表格重命名",
      noName: "无标题的电子表格",
      wait: "待更新",
      add: "添加",
      addLast: "在底部添加",
      backTop: "回到顶部",
      pageInfo: "共${total}条，${totalPage}页，当前已显示${currentPage}页",
      nextPage: "下一页",
      tipInputNumber: "请输入数字",
      tipInputNumberLimit: "增加范围限制在1-100",
      tipRowHeightLimit: "行高必须在0 ~ 545之间",
      tipColumnWidthLimit: "列宽必须在0 ~ 2038之间",
      pageInfoFull: "共${total}条，${totalPage}页，已显示全部数据"
    },
    currencyDetail: [{
      name: "人民币",
      pos: "before",
      value: "¥"
    }, {
      name: "美元",
      pos: "before",
      value: "$"
    }, {
      name: "欧元",
      pos: "before",
      value: "€"
    }, {
      name: "英镑",
      pos: "before",
      value: "￡"
    }, {
      name: "港元",
      pos: "before",
      value: "$"
    }, {
      name: "日元",
      pos: "before",
      value: "￥"
    }, {
      name: "阿尔巴尼亚列克",
      pos: "before",
      value: "Lek"
    }, {
      name: "阿尔及利亚第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "阿富汗尼",
      pos: "after",
      value: "Af"
    }, {
      name: "阿根廷比索",
      pos: "before",
      value: "$"
    }, {
      name: "阿拉伯联合酋长国迪拉姆",
      pos: "before",
      value: "dh"
    }, {
      name: "阿鲁巴弗罗林",
      pos: "before",
      value: "Afl"
    }, {
      name: "阿曼里亚尔",
      pos: "before",
      value: "Rial"
    }, {
      name: "阿塞拜疆马纳特",
      pos: "before",
      value: "?"
    }, {
      name: "埃及镑",
      pos: "before",
      value: "￡"
    }, {
      name: "埃塞俄比亚比尔",
      pos: "before",
      value: "Birr"
    }, {
      name: "安哥拉宽扎",
      pos: "before",
      value: "Kz"
    }, {
      name: "澳大利亚元",
      pos: "before",
      value: "$"
    }, {
      name: "澳门元",
      pos: "before",
      value: "MOP"
    }, {
      name: "巴巴多斯元",
      pos: "before",
      value: "$"
    }, {
      name: "巴布亚新几内亚基那",
      pos: "before",
      value: "PGK"
    }, {
      name: "巴哈马元",
      pos: "before",
      value: "$"
    }, {
      name: "巴基斯坦卢比",
      pos: "before",
      value: "Rs"
    }, {
      name: "巴拉圭瓜拉尼",
      pos: "after",
      value: "Gs"
    }, {
      name: "巴林第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "巴拿马巴波亚",
      pos: "before",
      value: "B/"
    }, {
      name: "巴西里亚伊",
      pos: "before",
      value: "R$"
    }, {
      name: "白俄罗斯卢布",
      pos: "after",
      value: "р"
    }, {
      name: "百慕大元",
      pos: "before",
      value: "$"
    }, {
      name: "保加利亚列弗",
      pos: "before",
      value: "lev"
    }, {
      name: "冰岛克朗",
      pos: "before",
      value: "kr"
    }, {
      name: "波黑可兑换马克",
      pos: "before",
      value: "KM"
    }, {
      name: "波兰兹罗提",
      pos: "after",
      value: "z?"
    }, {
      name: "玻利维亚诺",
      pos: "before",
      value: "Bs"
    }, {
      name: "伯利兹元",
      pos: "before",
      value: "$"
    }, {
      name: "博茨瓦纳普拉",
      pos: "before",
      value: "P"
    }, {
      name: "不丹努扎姆",
      pos: "before",
      value: "Nu"
    }, {
      name: "布隆迪法郎",
      pos: "before",
      value: "FBu"
    }, {
      name: "朝鲜圆",
      pos: "before",
      value: "?KP"
    }, {
      name: "丹麦克朗",
      pos: "after",
      value: "kr"
    }, {
      name: "东加勒比元",
      pos: "before",
      value: "$"
    }, {
      name: "多米尼加比索",
      pos: "before",
      value: "RD$"
    }, {
      name: "俄国卢布",
      pos: "after",
      value: "?"
    }, {
      name: "厄立特里亚纳克法",
      pos: "before",
      value: "Nfk"
    }, {
      name: "非洲金融共同体法郎",
      pos: "before",
      value: "CFA"
    }, {
      name: "菲律宾比索",
      pos: "before",
      value: "?"
    }, {
      name: "斐济元",
      pos: "before",
      value: "$"
    }, {
      name: "佛得角埃斯库多",
      pos: "before",
      value: "CVE"
    }, {
      name: "福克兰群岛镑",
      pos: "before",
      value: "￡"
    }, {
      name: "冈比亚达拉西",
      pos: "before",
      value: "GMD"
    }, {
      name: "刚果法郎",
      pos: "before",
      value: "FrCD"
    }, {
      name: "哥伦比亚比索",
      pos: "before",
      value: "$"
    }, {
      name: "哥斯达黎加科朗",
      pos: "before",
      value: "?"
    }, {
      name: "古巴比索",
      pos: "before",
      value: "$"
    }, {
      name: "古巴可兑换比索",
      pos: "before",
      value: "$"
    }, {
      name: "圭亚那元",
      pos: "before",
      value: "$"
    }, {
      name: "哈萨克斯坦坚戈",
      pos: "before",
      value: "?"
    }, {
      name: "海地古德",
      pos: "before",
      value: "HTG"
    }, {
      name: "韩元",
      pos: "before",
      value: "?"
    }, {
      name: "荷属安的列斯盾",
      pos: "before",
      value: "NAf."
    }, {
      name: "洪都拉斯拉伦皮拉",
      pos: "before",
      value: "L"
    }, {
      name: "吉布提法郎",
      pos: "before",
      value: "Fdj"
    }, {
      name: "吉尔吉斯斯坦索姆",
      pos: "before",
      value: "KGS"
    }, {
      name: "几内亚法郎",
      pos: "before",
      value: "FG"
    }, {
      name: "加拿大元",
      pos: "before",
      value: "$"
    }, {
      name: "加纳塞地",
      pos: "before",
      value: "GHS"
    }, {
      name: "柬埔寨瑞尔",
      pos: "before",
      value: "Riel"
    }, {
      name: "捷克克朗",
      pos: "after",
      value: "K?"
    }, {
      name: "津巴布韦元",
      pos: "before",
      value: "$"
    }, {
      name: "卡塔尔里亚尔",
      pos: "before",
      value: "Rial"
    }, {
      name: "开曼群岛元",
      pos: "before",
      value: "$"
    }, {
      name: "科摩罗法郎",
      pos: "before",
      value: "CF"
    }, {
      name: "科威特第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "克罗地亚库纳",
      pos: "before",
      value: "kn"
    }, {
      name: "肯尼亚先令",
      pos: "before",
      value: "Ksh"
    }, {
      name: "莱索托洛蒂",
      pos: "before",
      value: "LSL"
    }, {
      name: "老挝基普",
      pos: "before",
      value: "?"
    }, {
      name: "黎巴嫩镑",
      pos: "before",
      value: "L￡"
    }, {
      name: "立陶宛立特",
      pos: "before",
      value: "Lt"
    }, {
      name: "利比亚第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "利比亚元",
      pos: "before",
      value: "$"
    }, {
      name: "卢旺达法郎",
      pos: "before",
      value: "RF"
    }, {
      name: "罗马尼亚列伊",
      pos: "before",
      value: "RON"
    }, {
      name: "马达加斯加阿里亚里",
      pos: "before",
      value: "Ar"
    }, {
      name: "马尔代夫拉菲亚",
      pos: "before",
      value: "Rf"
    }, {
      name: "马拉维克瓦查",
      pos: "before",
      value: "MWK"
    }, {
      name: "马来西亚林吉特",
      pos: "before",
      value: "RM"
    }, {
      name: "马其顿戴第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "毛里求斯卢比",
      pos: "before",
      value: "MURs"
    }, {
      name: "毛里塔尼亚乌吉亚",
      pos: "before",
      value: "MRO"
    }, {
      name: "蒙古图格里克",
      pos: "before",
      value: "?"
    }, {
      name: "孟加拉塔卡",
      pos: "before",
      value: "?"
    }, {
      name: "秘鲁新索尔",
      pos: "before",
      value: "S/"
    }, {
      name: "缅甸开亚特",
      pos: "before",
      value: "K"
    }, {
      name: "摩尔多瓦列伊",
      pos: "before",
      value: "MDL"
    }, {
      name: "摩洛哥迪拉姆",
      pos: "before",
      value: "dh"
    }, {
      name: "莫桑比克梅蒂卡尔",
      pos: "before",
      value: "MTn"
    }, {
      name: "墨西哥比索",
      pos: "before",
      value: "$"
    }, {
      name: "纳米比亚元",
      pos: "before",
      value: "$"
    }, {
      name: "南非兰特",
      pos: "before",
      value: "R"
    }, {
      name: "南苏丹镑",
      pos: "before",
      value: "￡"
    }, {
      name: "尼加拉瓜科多巴",
      pos: "before",
      value: "C$"
    }, {
      name: "尼泊尔卢比",
      pos: "before",
      value: "Rs"
    }, {
      name: "尼日利亚奈拉",
      pos: "before",
      value: "?"
    }, {
      name: "挪威克朗",
      pos: "after",
      value: "kr"
    }, {
      name: "乔治亚拉瑞",
      pos: "before",
      value: "GEL"
    }, {
      name: "瑞典克朗",
      pos: "after",
      value: "kr"
    }, {
      name: "瑞士法郎",
      pos: "before",
      value: "CHF"
    }, {
      name: "塞尔维亚第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "塞拉利昂利昂",
      pos: "before",
      value: "SLL"
    }, {
      name: "塞舌尔卢比",
      pos: "before",
      value: "SCR"
    }, {
      name: "沙特里亚尔",
      pos: "before",
      value: "Rial"
    }, {
      name: "圣多美多布拉",
      pos: "before",
      value: "Db"
    }, {
      name: "圣赫勒拿群岛磅",
      pos: "before",
      value: "￡"
    }, {
      name: "斯里兰卡卢比",
      pos: "before",
      value: "Rs"
    }, {
      name: "斯威士兰里兰吉尼",
      pos: "before",
      value: "SZL"
    }, {
      name: "苏丹镑",
      pos: "before",
      value: "SDG"
    }, {
      name: "苏里南元",
      pos: "before",
      value: "$"
    }, {
      name: "所罗门群岛元",
      pos: "before",
      value: "$"
    }, {
      name: "索马里先令",
      pos: "before",
      value: "SOS"
    }, {
      name: "塔吉克斯坦索莫尼",
      pos: "before",
      value: "Som"
    }, {
      name: "太平洋法郎",
      pos: "after",
      value: "FCFP"
    }, {
      name: "泰国铢",
      pos: "before",
      value: "?"
    }, {
      name: "坦桑尼亚先令",
      pos: "before",
      value: "TSh"
    }, {
      name: "汤加潘加",
      pos: "before",
      value: "T$"
    }, {
      name: "特立尼达和多巴哥元",
      pos: "before",
      value: "$"
    }, {
      name: "突尼斯第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "土耳其里拉",
      pos: "before",
      value: "?"
    }, {
      name: "瓦努阿图瓦图",
      pos: "before",
      value: "VUV"
    }, {
      name: "危地马拉格查尔",
      pos: "before",
      value: "Q"
    }, {
      name: "委内瑞拉博利瓦",
      pos: "before",
      value: "Bs"
    }, {
      name: "文莱元",
      pos: "before",
      value: "$"
    }, {
      name: "乌干达先令",
      pos: "before",
      value: "UGX"
    }, {
      name: "乌克兰格里夫尼亚",
      pos: "before",
      value: "грн."
    }, {
      name: "乌拉圭比索",
      pos: "before",
      value: "$"
    }, {
      name: "乌兹别克斯坦苏姆",
      pos: "before",
      value: "so?m"
    }, {
      name: "西萨摩亚塔拉",
      pos: "before",
      value: "WST"
    }, {
      name: "新加坡元",
      pos: "before",
      value: "$"
    }, {
      name: "新台币",
      pos: "before",
      value: "NT$"
    }, {
      name: "新西兰元",
      pos: "before",
      value: "$"
    }, {
      name: "匈牙利福林",
      pos: "before",
      value: "Ft"
    }, {
      name: "叙利亚镑",
      pos: "before",
      value: "￡"
    }, {
      name: "牙买加元",
      pos: "before",
      value: "$"
    }, {
      name: "亚美尼亚德拉姆",
      pos: "before",
      value: "Dram"
    }, {
      name: "也门里亚尔",
      pos: "before",
      value: "Rial"
    }, {
      name: "伊拉克第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "伊朗里亚尔",
      pos: "before",
      value: "Rial"
    }, {
      name: "以色列新谢克尔",
      pos: "before",
      value: "?"
    }, {
      name: "印度卢比",
      pos: "before",
      value: "?"
    }, {
      name: "印度尼西亚卢比",
      pos: "before",
      value: "Rp"
    }, {
      name: "约旦第纳尔",
      pos: "before",
      value: "din"
    }, {
      name: "越南盾",
      pos: "after",
      value: "?"
    }, {
      name: "赞比亚克瓦查",
      pos: "before",
      value: "ZMW"
    }, {
      name: "直布罗陀镑",
      pos: "before",
      value: "￡"
    }, {
      name: "智利比索",
      pos: "before",
      value: "$"
    }, {
      name: "中非金融合作法郎",
      pos: "before",
      value: "FCFA"
    }],
    defaultFmt: [{
      text: "自动",
      value: "General",
      example: ""
    }, {
      text: "纯文本",
      value: "@",
      example: ""
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "数字",
      value: "##0.00",
      example: "1000.12"
    }, {
      text: "百分比",
      value: "#0.00%",
      example: "12.21%"
    }, {
      text: "科学计数",
      value: "0.00E+00",
      example: "1.01E+5"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "会计",
      value: "¥(0.00)",
      example: "¥(1200.09)"
    }, {
      text: "万元",
      value: "w",
      example: "1亿2000万2500"
    }, {
      text: "货币",
      value: "¥0.00",
      example: "¥1200.09"
    }, {
      text: "万元2位小数",
      value: "w0.00",
      example: "2万2500.55"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "日期",
      value: "yyyy-MM-dd",
      example: "2017-11-29"
    }, {
      text: "时间",
      value: "hh:mm AM/PM",
      example: "3:00 PM"
    }, {
      text: "时间24H",
      value: "hh:mm",
      example: "15:00"
    }, {
      text: "日期时间",
      value: "yyyy-MM-dd hh:mm AM/PM",
      example: "2017-11-29 3:00 PM"
    }, {
      text: "日期时间24H",
      value: "yyyy-MM-dd hh:mm",
      example: "2017-11-29 15:00"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "自定义格式",
      value: "fmtOtherSelf",
      example: "",
      icon: "rightArrow"
    }],
    dateFmtList: [{
      name: "1930-08-05",
      value: "yyyy-MM-dd"
    }, {
      name: "1930/8/5",
      value: "yyyy/MM/dd"
    }, {
      name: "1930年8月5日",
      value: 'yyyy"年"M"月"d"日"'
    }, {
      name: "08-05",
      value: "MM-dd"
    }, {
      name: "8-5",
      value: "M-d"
    }, {
      name: "8月5日",
      value: 'M"月"d"日"'
    }, {
      name: "13:30:30",
      value: "h:mm:ss"
    }, {
      name: "13:30",
      value: "h:mm"
    }, {
      name: "下午01:30",
      value: "上午/下午 hh:mm"
    }, {
      name: "下午1:30",
      value: "上午/下午 h:mm"
    }, {
      name: "下午1:30:30",
      value: "上午/下午 h:mm:ss"
    }, {
      name: "08-05 下午01:30",
      value: "MM-dd 上午/下午 hh:mm"
    }],
    fontFamily: {
      MicrosoftYaHei: "Microsoft YaHei"
    },
    fontarray: ["Times New Roman", "Arial", "Tahoma", "Verdana", "微软雅黑", "宋体", "黑体", "楷体", "仿宋", "新宋体", "华文新魏", "华文行楷", "华文隶书"],
    fontjson: {
      "times new roman": 0,
      arial: 1,
      tahoma: 2,
      verdana: 3,
      微软雅黑: 4,
      "microsoft yahei": 4,
      宋体: 5,
      simsun: 5,
      黑体: 6,
      simhei: 6,
      楷体: 7,
      kaiti: 7,
      仿宋: 8,
      fangsong: 8,
      新宋体: 9,
      nsimsun: 9,
      华文新魏: 10,
      stxinwei: 10,
      华文行楷: 11,
      stxingkai: 11,
      华文隶书: 12,
      stliti: 12
    },
    border: {
      borderTop: "上框线",
      borderBottom: "下框线",
      borderLeft: "左框线",
      borderRight: "右框线",
      borderNone: "无",
      borderAll: "所有",
      borderOutside: "外侧",
      borderInside: "内侧",
      borderHorizontal: "内侧横线",
      borderVertical: "内侧竖线",
      borderColor: "边框颜色",
      borderSize: "边框粗细",
      borderSlash: "边框斜线",
      borderDefault: "默认样式",
      borderStyle: "边框样式"
    },
    merge: {
      mergeAll: "全部合并",
      mergeV: "垂直合并",
      mergeH: "水平合并",
      mergeCancel: "取消合并",
      overlappingError: "不能合并重叠区域",
      partiallyError: "无法对部分合并单元格执行此操作"
    },
    align: {
      left: "左对齐",
      center: "中间对齐",
      right: "右对齐",
      top: "顶部对齐",
      middle: "居中对齐",
      bottom: "底部对齐"
    },
    textWrap: {
      overflow: "溢出",
      wrap: "自动换行",
      clip: "截断"
    },
    rotation: {
      none: "无旋转",
      angleup: "向上倾斜",
      angledown: "向下倾斜",
      vertical: "竖排文字",
      rotationUp: "向上90°",
      rotationDown: "向下90°"
    },
    freezen: {
      default: "冻结第一行",
      freezenRow: "冻结第一行",
      freezenColumn: "冻结第A列",
      freezenRC: "冻结第一行第A列",
      freezenRowRange: "冻结至当前行",
      freezenColumnRange: "冻结至当前列",
      freezenRCRange: "冻结至当前行列",
      freezenCancel: "取消冻结",
      noSeletionError: "没有选区",
      rangeRCOverErrorTitle: "冻结提醒",
      rangeRCOverError: "冻结窗格超过可见范围，会导致无法正常操作，请重新设置冻结区域。"
    },
    sort: {
      asc: "升序",
      desc: "降序",
      custom: "自定义排序",
      hasTitle: "数据具有标题行",
      sortBy: "排序依据",
      addOthers: "添加其他排序列",
      close: "关闭",
      confirm: "排序",
      columnOperation: "列",
      secondaryTitle: "次要排序",
      sortTitle: "排序范围",
      sortRangeTitle: "排序范围从",
      sortRangeTitleTo: "到",
      noRangeError: "不能对多重选择区域执行此操作，请选择单个区域，然后再试",
      mergeError: "选区有合并单元格，无法执行此操作！"
    },
    filter: {
      filter: "筛选",
      clearFilter: "清除筛选",
      sortByAsc: "升序排列",
      sortByDesc: "降序排列",
      filterByColor: "按颜色筛选",
      filterByCondition: "按条件过滤",
      filterByValues: "按值过滤",
      filiterInputNone: "无",
      filiterInputTip: "输入筛选值",
      filiterRangeStartTip: "范围开始",
      filiterRangeEndTip: "范围结束",
      filterValueByAllBtn: "全选",
      filterValueByClearBtn: "清除",
      filterValueByInverseBtn: "反选",
      filterValueByTip: "按照值进行筛选",
      filterConform: "确 认",
      filterCancel: "取 消",
      conditionNone: "无",
      conditionCellIsNull: "单元格为空",
      conditionCellNotNull: "单元格有数据",
      conditionCellTextContain: "文本包含",
      conditionCellTextNotContain: "文本不包含",
      conditionCellTextStart: "文本开头为",
      conditionCellTextEnd: "文本结尾为",
      conditionCellTextEqual: "文本等于",
      conditionCellDateEqual: "日期等于",
      conditionCellDateBefore: "日期早于",
      conditionCellDateAfter: "日期晚于",
      conditionCellGreater: "大于",
      conditionCellGreaterEqual: "大于等于",
      conditionCellLess: "小于",
      conditionCellLessEqual: "小于等于",
      conditionCellEqual: "等于",
      conditionCellNotEqual: "不等于",
      conditionCellBetween: "介于",
      conditionCellNotBetween: "不在其中",
      filiterMoreDataTip: "数据量大！请稍后",
      filiterMonthText: "月",
      filiterYearText: "年",
      filiterByColorTip: "按单元格颜色筛选",
      filiterByTextColorTip: "按单元格字体颜色筛选",
      filterContainerOneColorTip: "本列仅包含一种颜色",
      filterDateFormatTip: "日期格式",
      valueBlank: "(空白)",
      mergeError: "筛选选区有合并单元格，无法执行此操作！"
    },
    rightclick: {
      copy: "复制",
      copyAs: "复制为",
      paste: "粘贴",
      insert: "插入",
      image: "插入图片",
      link: "插入链接",
      delete: "删除",
      deleteCell: "删除单元格",
      deleteSelected: "删除选中",
      hide: "隐藏",
      hideSelected: "隐藏选中",
      showHide: "显示隐藏",
      to: "向",
      left: "左",
      right: "右",
      top: "上",
      bottom: "下",
      moveLeft: "左移",
      moveUp: "上移",
      add: "增加",
      row: "行",
      column: "列",
      width: "宽",
      height: "高",
      number: "数字",
      confirm: "确认",
      orderAZ: "升序排列",
      orderZA: "降序排列",
      clearContent: "清除内容",
      matrix: "矩阵操作选区",
      sortSelection: "排序选区",
      filterSelection: "筛选选区",
      chartGeneration: "图表生成",
      firstLineTitle: "首行为标题",
      untitled: "无标题",
      array1: "一维数组",
      array2: "二维数组",
      array3: "多维数组",
      diagonal: "对角线",
      antiDiagonal: "反对角线",
      diagonalOffset: "对角偏移",
      offset: "偏移量",
      boolean: "布尔值",
      flip: "翻转",
      upAndDown: "上下",
      leftAndRight: "左右",
      clockwise: "顺时针",
      counterclockwise: "逆时针",
      transpose: "转置",
      matrixCalculation: "矩阵计算",
      plus: "加",
      minus: "减",
      multiply: "乘",
      divided: "除",
      power: "次方",
      root: "次方根",
      log: "log",
      delete0: "删除两端0值",
      removeDuplicate: "删除重复值",
      byRow: "按行",
      byCol: "按列",
      generateNewMatrix: "生成新矩阵",
      noMulti: "无法对多重选择区域执行此操作,请选择单个区域",
      cannotDeleteAllRow: "无法删除所有行",
      cannotDeleteAllColumn: "无法删除所有列",
      cannotDeleteRowReadOnly: "无法删除只读行",
      cannotDeleteColumnReadOnly: "无法删除只读列",
      cannotInsertOnRowReadOnly: "无法对只读行插入",
      cannotInsertOnColumnReadOnly: "无法对只读列插入",
      rowOverLimit: "超出10000行限制",
      columnOverLimit: "超出1000列限制"
    },
    comment: {
      insert: "新建批注",
      edit: "编辑批注",
      delete: "删除",
      showOne: "显示/隐藏批注",
      showAll: "显示/隐藏所有批注"
    },
    screenshot: {
      screenshotTipNoSelection: "请框选需要截图的范围",
      screenshotTipTitle: "提示！",
      screenshotTipHasMerge: "无法对合并单元格执行此操作",
      screenshotTipHasMulti: "无法对多重选择区域执行此操作",
      screenshotTipSuccess: "截取成功",
      screenshotImageName: "截图",
      downLoadClose: "关闭",
      downLoadCopy: "复制到剪切板",
      downLoadBtn: "下载",
      browserNotTip: "下载功能IE浏览器不支持！",
      rightclickTip: "请在图片上右键点击'复制'",
      successTip: "已成功复制（如果粘贴失败，请在图片上右键点击'复制图片'）"
    },
    splitText: {
      splitDelimiters: "分割符号",
      splitOther: "其它",
      splitContinueSymbol: "连续分隔符号视为单个处理",
      splitDataPreview: "数据预览",
      splitTextTitle: "文本分列",
      splitConfirmToExe: "此处已有数据，是否替换它？",
      splitSymbols: [{
        name: "Tab键",
        value: "Tab"
      }, {
        name: "分号",
        value: "semicolon"
      }, {
        name: "逗号",
        value: "comma"
      }, {
        name: "空格",
        value: "space"
      }],
      tipNoMulti: "不能对多重选择区域执行此操作，请选择单个区域，然后再试",
      tipNoMultiColumn: "一次只能转换一列数据，选定区域可以有多行，但不能有多列，请在选定单列区域以后再试",
      tipNoSelect: "没有选择单元格不能进行分列"
    },
    imageText: {
      imageSetting: "图片设置",
      close: "关闭",
      conventional: "常规",
      moveCell1: "移动并调整单元格大小",
      moveCell2: "移动并且不调整单元格的大小",
      moveCell3: "不要移动单元格并调整其大小",
      fixedPos: "固定位置",
      border: "边框",
      width: "宽度",
      radius: "半径",
      style: "样式",
      solid: "实线",
      dashed: "虚线",
      dotted: "点状",
      double: "双线",
      color: "颜色"
    },
    punctuation: {
      tab: "Tab 键",
      semicolon: "分号",
      comma: "逗号",
      space: "空格"
    },
    findAndReplace: {
      find: "查找",
      replace: "替换",
      goto: "转到",
      location: "定位条件",
      formula: "公式",
      date: "日期",
      number: "数字",
      string: "字符",
      error: "错误",
      condition: "条件格式",
      rowSpan: "间隔行",
      columnSpan: "间隔列",
      locationExample: "定位",
      lessTwoRowTip: "请选择最少两行",
      lessTwoColumnTip: "请选择最少两行",
      findTextbox: "查找内容",
      replaceTextbox: "替换内容",
      regexTextbox: "正则表达式匹配",
      wholeTextbox: "整词匹配",
      distinguishTextbox: "区分大小写匹配",
      allReplaceBtn: "全部替换",
      replaceBtn: "替换",
      allFindBtn: "查找全部",
      findBtn: "查找下一个",
      noFindTip: "没有查找到该内容",
      modeTip: "该模式下不可进行此操作",
      searchTargetSheet: "工作表",
      searchTargetCell: "单元格",
      searchTargetValue: "值",
      searchInputTip: "请输入查找内容",
      noReplceTip: "没有可替换的内容",
      noMatchTip: "找不到匹配项",
      successTip: "已经帮您搜索并进行了${xlength}处替换",
      locationConstant: "常量",
      locationFormula: "公式",
      locationDate: "日期",
      locationDigital: "数字",
      locationString: "字符",
      locationBool: "逻辑值",
      locationError: "错误",
      locationNull: "空值",
      locationCondition: "条件格式",
      locationRowSpan: "间隔行",
      locationColumnSpan: "间隔列",
      locationTiplessTwoRow: "请选择最少两行",
      locationTiplessTwoColumn: "请选择最少两列",
      locationTipNotFindCell: "未找到单元格"
    },
    sheetconfig: {
      delete: "删除",
      copy: "复制",
      rename: "重命名",
      changeColor: "更改颜色",
      hide: "隐藏",
      unhide: "取消隐藏",
      moveLeft: "向左移",
      moveRight: "向右移",
      resetColor: "重置颜色",
      cancelText: "取消",
      chooseText: "确定颜色",
      focus: "聚焦",
      tipNameRepeat: "标签页的名称不能重复！请重新修改",
      noMoreSheet: "工作薄内至少含有一张可视工作表。若需删除选定的工作表，请先插入一张新工作表或显示一张隐藏的工作表。",
      confirmDelete: "是否删除",
      redoDelete: "可以通过Ctrl+Z撤销删除",
      noHide: "不能隐藏, 至少保留一个sheet标签",
      chartEditNoOpt: "图表编辑模式下不允许该操作！",
      sheetNameSpecCharError: "名称不能超过31个字符，首尾不能是' 且名称不能包含:\r\n[ ] : \\ ? * /",
      sheetNamecannotIsEmptyError: "名称不能为空!"
    },
    conditionformat: {
      conditionformat_greaterThan: "条件格式——大于",
      conditionformat_greaterThan_title: "为大于以下值的单元格设置格式",
      conditionformat_lessThan: "条件格式——小于",
      conditionformat_lessThan_title: "为小于以下值的单元格设置格式",
      conditionformat_between: "条件格式——介于",
      conditionformat_between_title: "为介于以下值的单元格设置格式",
      conditionformat_equal: "条件格式——等于",
      conditionformat_equal_title: "为等于以下值的单元格设置格式",
      conditionformat_textContains: "条件格式——文本包含",
      conditionformat_textContains_title: "为包含以下文本的单元格设置格式",
      conditionformat_occurrenceDate: "条件格式——发生日期",
      conditionformat_occurrenceDate_title: "为包含以下日期的单元格设置格式",
      conditionformat_duplicateValue: "条件格式——重复值",
      conditionformat_duplicateValue_title: "为包含以下类型值的单元格设置格式",
      conditionformat_top10: "条件格式——前 10 项",
      conditionformat_top10_percent: "条件格式——前 10%",
      conditionformat_top10_title: "为值最大的那些单元格设置格式",
      conditionformat_last10: "条件格式——最后 10 项",
      conditionformat_last10_percent: "条件格式——最后 10%",
      conditionformat_last10_title: "为值最小的那些单元格设置格式",
      conditionformat_aboveAverage: "条件格式——高于平均值",
      conditionformat_aboveAverage_title: "为高于平均值的单元格设置格式",
      conditionformat_belowAverage: "条件格式——低于平均值",
      conditionformat_belowAverage_title: "为低于平均值的单元格设置格式",
      rule: "规则",
      newRule: "新建规则",
      editRule: "编辑规则",
      deleteRule: "删除规则",
      deleteCellRule: "清除所选单元格的规则",
      deleteSheetRule: "清除整个工作表的规则",
      manageRules: "管理规则",
      showRules: "显示其格式规则",
      highlightCellRules: "突出显示单元格规则",
      itemSelectionRules: "项目选取规则",
      conditionformatManageRules: "条件格式规则管理器",
      format: "格式",
      setFormat: "设置格式",
      setAs: "设置为",
      setAsByArea: "针对选定区域，设置为",
      applyRange: "应用范围",
      selectRange: "点击选择应用范围",
      selectRange_percent: "所选范围的百分比",
      selectRange_average: "选定范围的平均值",
      selectRange_value: "选定范围中的数值",
      pleaseSelectRange: "请选择应用范围",
      selectDataRange: "点击选择数据范围",
      selectCell: "选择单元格",
      pleaseSelectCell: "请选择单元格",
      pleaseSelectADate: "请选择日期",
      pleaseEnterInteger: "请输入一个介于 1 和 1000 之间的整数",
      onlySingleCell: "只能对单个单元格进行引用",
      conditionValueCanOnly: "条件值只能是数字或者单个单元格",
      ruleTypeItem1: "基于各自值设置所有单元格的格式",
      ruleTypeItem2: "只为包含以下内容的单元格设置格式",
      ruleTypeItem2_title: "只为满足以下条件的单元格",
      ruleTypeItem3: "仅对排名靠前或靠后的数值设置格式",
      ruleTypeItem3_title: "为以下排名内的值",
      ruleTypeItem4: "仅对高于或低于平均值的数值设置格式",
      ruleTypeItem4_title: "为满足以下条件的值",
      ruleTypeItem5: "仅对唯一值或重复值设置格式",
      ruleTypeItem6: "使用公式确定要设置格式的单元格",
      formula: "公式",
      textColor: "文本颜色",
      cellColor: "单元格颜色",
      confirm: "确定",
      confirmColor: "确定颜色",
      cancel: "取消",
      close: "关闭",
      clearColorSelect: "清除颜色选择",
      sheet: "表",
      currentSheet: "当前工作表",
      dataBar: "数据条",
      dataBarColor: "数据条颜色",
      gradientDataBar_1: "蓝-白渐变数据条",
      gradientDataBar_2: "绿-白渐变数据条",
      gradientDataBar_3: "红-白渐变数据条",
      gradientDataBar_4: "橙-白渐变数据条",
      gradientDataBar_5: "浅蓝-白渐变数据条",
      gradientDataBar_6: "紫-白渐变数据条",
      solidColorDataBar_1: "蓝色数据条",
      solidColorDataBar_2: "绿色数据条",
      solidColorDataBar_3: "红色数据条",
      solidColorDataBar_4: "橙色数据条",
      solidColorDataBar_5: "浅蓝色数据条",
      solidColorDataBar_6: "紫色数据条",
      colorGradation: "色阶",
      colorGradation_1: "绿-黄-红色阶",
      colorGradation_2: "红-黄-绿色阶",
      colorGradation_3: "绿-白-红色阶",
      colorGradation_4: "红-白-绿色阶",
      colorGradation_5: "蓝-白-红色阶",
      colorGradation_6: "红-白-蓝色阶",
      colorGradation_7: "白-红色阶",
      colorGradation_8: "红-白色阶",
      colorGradation_9: "绿-白色阶",
      colorGradation_10: "白-绿色阶",
      colorGradation_11: "绿-黄色阶",
      colorGradation_12: "黄-绿色阶",
      icons: "图标集",
      pleaseSelectIcon: "请点击选择一组图标：",
      cellValue: "单元格值",
      specificText: "特定文本",
      occurrenceDate: "发生日期",
      greaterThan: "大于",
      lessThan: "小于",
      between: "介于",
      equal: "等于",
      in: "和",
      to: "到",
      between2: "之间",
      contain: "包含",
      textContains: "文本包含",
      duplicateValue: "重复值",
      uniqueValue: "唯一值",
      top: "前",
      top10: "前 10 项",
      top10_percent: "前 10%",
      last: "后",
      last10: "后 10 项",
      last10_percent: "后 10%",
      oneself: "个",
      above: "高于",
      aboveAverage: "高于平均值",
      below: "低于",
      belowAverage: "低于平均值",
      all: "全部",
      yesterday: "昨天",
      today: "今天",
      tomorrow: "明天",
      lastWeek: "上周",
      thisWeek: "本周",
      lastMonth: "上月",
      thisMonth: "本月",
      lastYear: "去年",
      thisYear: "本年",
      last7days: "最近7天",
      last30days: "最近30天",
      next7days: "未来7天",
      next30days: "未来30天",
      next60days: "未来60天",
      chooseRuleType: "选择规则类型",
      editRuleDescription: "编辑规则说明",
      newFormatRule: "新建格式规则",
      editFormatRule: "编辑格式规则",
      formatStyle: "格式样式",
      fillType: "填充类型",
      color: "颜色",
      twocolor: "双色",
      tricolor: "三色",
      multicolor: "彩色",
      grayColor: "灰色",
      gradient: "渐变",
      solid: "实心",
      maxValue: "最大值",
      medianValue: "中间值",
      minValue: "最小值",
      direction: "方向",
      threeWayArrow: "三向箭头",
      fourWayArrow: "四向箭头",
      fiveWayArrow: "五向箭头",
      threeTriangles: "3个三角形",
      shape: "形状",
      threeColorTrafficLight: "三色交通灯",
      fourColorTrafficLight: "四色交通灯",
      threeSigns: "三标志",
      greenRedBlackGradient: "绿-红-黑渐变",
      rimless: "无边框",
      bordered: "有边框",
      mark: "标记",
      threeSymbols: "三个符号",
      tricolorFlag: "三色旗",
      circled: "有圆圈",
      noCircle: "无圆圈",
      grade: "等级",
      grade4: "四等级",
      grade5: "五等级",
      threeStars: "3个星形",
      fiveQuadrantDiagram: "五象限图",
      fiveBoxes: "5个框"
    },
    insertLink: {
      linkText: "显示文本",
      linkType: "链接类型",
      linkAddress: "链接地址",
      linkSheet: "工作表",
      linkCell: "单元格范围",
      linkTooltip: "提示",
      selectCellRange: "选择单元格范围",
      cellRangePlaceholder: "可用鼠标框选单元格，或直接输入范围",
      placeholder1: "请输入网页链接地址",
      placeholder2: "请输入要引用的单元格，例A1",
      placeholder3: "请输入提示内容",
      tooltipInfo1: "请输入有效的链接",
      invalidCellRangeTip: "请输入正确的单元格范围，比如 工作表1!A1:C8",
      openLink: "打开链接",
      goTo: "跳转至 ${linkAddress}"
    },
    linkTypeList: [{
      text: "网页",
      value: "webpage"
    }, {
      text: "单元格范围",
      value: "cellrange"
    }, {
      text: "工作表",
      value: "sheet"
    }],
    dataVerification: {
      cellRange: "单元格范围",
      selectCellRange: "点击选择单元格范围",
      selectCellRange2: "请选择单元格范围",
      verificationCondition: "验证条件",
      allowMultiSelect: "是否允许多选",
      dropdown: "下拉列表",
      checkbox: "复选框",
      number: "数字",
      number_integer: "数字-整数",
      number_decimal: "数字-小数",
      text_content: "文本-内容",
      text_length: "文本-长度",
      date: "日期",
      validity: "有效性",
      placeholder1: "请输入选项，以英文逗号分隔，如1,2,3,4,5",
      placeholder2: "请输入内容",
      placeholder3: "数值，如10",
      placeholder4: "请输入指定的文本",
      placeholder5: "请输入选中单元格时显示的提示语",
      selected: "选择时",
      notSelected: "未选择",
      between: "介于",
      notBetween: "不介于",
      equal: "等于",
      notEqualTo: "不等于",
      moreThanThe: "大于",
      lessThan: "小于",
      greaterOrEqualTo: "大于等于",
      lessThanOrEqualTo: "小于等于",
      include: "包括",
      exclude: "不包括",
      earlierThan: "早于",
      noEarlierThan: "不早于",
      laterThan: "晚于",
      noLaterThan: "不晚于",
      identificationNumber: "身份证号码",
      phoneNumber: "手机号",
      remote: "自动远程获取选项",
      prohibitInput: "输入数据无效时禁止输入",
      hintShow: "选中单元格时显示提示语",
      deleteVerification: "删除验证",
      tooltipInfo1: "下拉列表选项不可为空",
      tooltipInfo2: "复选框内容不可为空",
      tooltipInfo3: "输入的值不是数值类型",
      tooltipInfo4: "数值2不能小于数值1",
      tooltipInfo5: "文本内容不能为空",
      tooltipInfo6: "输入的值不是日期类型",
      tooltipInfo7: "日期2不能小于日期1",
      textlengthInteger: "文本长度必须是大于等于0的整数"
    },
    formula: {
      sum: "求和",
      average: "平均值",
      count: "计数",
      max: "最大值",
      min: "最小值",
      ifGenerate: "if公式生成器",
      find: "更多函数",
      tipNotBelongToIf: "该单元格函数不属于if公式！",
      tipSelectCell: "请选择单元格插入函数",
      ifGenCompareValueTitle: "比较值",
      ifGenSelectCellTitle: "点击选择单元格",
      ifGenRangeTitle: "范围",
      ifGenRangeTo: "至",
      ifGenRangeEvaluate: "范围评估",
      ifGenSelectRangeTitle: "点击选择范围",
      ifGenCutWay: "划分方式",
      ifGenCutSame: "划分值相同",
      ifGenCutNpiece: "划分为N份",
      ifGenCutCustom: "自定义输入",
      ifGenCutConfirm: "生成",
      ifGenTipSelectCell: "选择单元格",
      ifGenTipSelectCellPlace: "请选择单元格",
      ifGenTipSelectRange: "选择单范围",
      ifGenTipSelectRangePlace: "请选择范围",
      ifGenTipNotNullValue: "比较值不能为空！",
      ifGenTipLableTitile: "标签",
      ifGenTipRangeNotforNull: "范围不能为空！",
      ifGenTipCutValueNotforNull: "划分值不能为空！",
      ifGenTipNotGenCondition: "没有生成可用的条件！"
    },
    formulaMore: {
      valueTitle: "值",
      tipSelectDataRange: "选取数据范围",
      tipDataRangeTile: "数据范围",
      findFunctionTitle: "查找函数",
      tipInputFunctionName: "请输入您要查找的函数名称或函数功能的简要描述",
      Array: "数组",
      Database: "数据源",
      Date: "日期",
      Engineering: "工程计算",
      Filter: "过滤器",
      Financial: "财务",
      luckysheet: "Luckysheet内置",
      other: "其它",
      Logical: "逻辑",
      Lookup: "查找",
      Math: "数学",
      Operator: "运算符",
      Parser: "转换工具",
      Statistical: "统计",
      Text: "文本",
      dataMining: "数据挖掘",
      selectFunctionTitle: "选择函数",
      calculationResult: "计算结果",
      tipSuccessText: "成功",
      tipParamErrorText: "参数类型错误",
      helpClose: "关闭",
      helpCollapse: "收起",
      helpExample: "示例",
      helpAbstract: "摘要",
      execfunctionError: '提示", "公式存在错误',
      execfunctionSelfError: "公式不可引用其本身的单元格",
      execfunctionSelfErrorResult: "公式不可引用其本身的单元格，会导致计算结果不准确",
      allowRepeatText: "可重复",
      allowOptionText: "可选",
      selectCategory: "或选择类别"
    },
    drag: {
      noMerge: "无法对合并单元格执行此操作",
      affectPivot: "无法对所选单元格进行此更改，因为它会影响数据透视表！",
      noMulti: "无法对多重选择区域执行此操作,请选择单个区域",
      noPaste: "无法在此处粘贴此内容，请选择粘贴区域的一个单元格，然后再次尝试粘贴",
      noPartMerge: "无法对部分合并单元格执行此操作",
      inputCorrect: "请输入正确的数值",
      notLessOne: "行列数不能小于1",
      offsetColumnLessZero: "偏移列不能为负数！",
      pasteMustKeybordAlert: "Copy and paste in the Sheet: Ctrl + C to copy, Ctrl + V to paste, Ctrl + X to cut",
      pasteMustKeybordAlertHTMLTitle: "Copy and paste in the Sheet",
      pasteMustKeybordAlertHTML: "<span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + C</span>&nbsp;&nbsp;to copy<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + V</span>&nbsp;&nbsp;to paste<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + X</span>&nbsp;&nbsp;to cut"
    },
    pivotTable: {
      title: "数据透视表",
      closePannel: "关闭",
      editRange: "编辑范围",
      tipPivotFieldSelected: "选择需要添加到数据透视表的字段",
      tipClearSelectedField: "清除所有已选字段",
      btnClearSelectedField: "清除",
      btnFilter: "筛选",
      titleRow: "行",
      titleColumn: "列",
      titleValue: "数值",
      tipShowColumn: "统计字段显示为列",
      tipShowRow: "统计字段显示为行",
      titleSelectionDataRange: "选取数据范围",
      titleDataRange: "数据范围",
      valueSum: "总计",
      valueStatisticsSUM: "求和",
      valueStatisticsCOUNT: "数值计数",
      valueStatisticsCOUNTA: "计数",
      valueStatisticsCOUNTUNIQUE: "去重计数",
      valueStatisticsAVERAGE: "平均值",
      valueStatisticsMAX: "最大值",
      valueStatisticsMIN: "最小值",
      valueStatisticsMEDIAN: "中位数",
      valueStatisticsPRODUCT: "乘积",
      valueStatisticsSTDEV: "标准差",
      valueStatisticsSTDEVP: "整体标准差",
      valueStatisticslet: "方差",
      valueStatisticsVARP: "整体方差",
      errorNotAllowEdit: "非编辑模式下禁止该操作！",
      errorNotAllowMulti: "不能对多重选择区域执行此操作，请选择单个区域，然后再试",
      errorSelectRange: "请选择新建透视表的区域",
      errorIsDamage: "此数据透视表的源数据已损坏！",
      errorNotAllowPivotData: "不可选择数据透视表为源数据！",
      errorSelectionRange: "选择失败, 输入范围错误！",
      errorIncreaseRange: "请扩大选择的数据范围!",
      titleAddColumn: "添加列到数据透视表",
      titleMoveColumn: "移动该列到下方白框",
      titleClearColumnFilter: "清除该列的筛选条件",
      titleFilterColumn: "筛选该列",
      titleSort: "排序",
      titleNoSort: "无排序",
      titleSortAsc: "升序",
      titleSortDesc: "降序",
      titleSortBy: "排序依据",
      titleShowSum: "显示总计",
      titleStasticTrue: "是",
      titleStasticFalse: "否"
    },
    dropCell: {
      copyCell: "复制单元格",
      sequence: "填充序列",
      onlyFormat: "仅填充格式",
      noFormat: "不带格式填充",
      day: "以天数填充",
      workDay: "以工作日填充",
      month: "以月填充",
      year: "以年填充",
      chineseNumber: "以中文小写数字填充"
    },
    imageCtrl: {
      borderTile: "图片边框颜色选择",
      borderCur: "当前颜色"
    },
    protection: {
      protectiontTitle: "保护工作表",
      enterPassword: "请输入密码（可留空）",
      enterHint: "您试图更改的单元格或图表位于受保护的工作表中。若要更改，请取消工作表保护。您可能需要输入密码",
      swichProtectionTip: "保护工作表及锁定的单元格内容",
      authorityTitle: "允许此工作表的用户进行:",
      selectLockedCells: "选定锁定单元格",
      selectunLockedCells: "选定解除锁定的单元格",
      formatCells: "设置单元格格式",
      formatColumns: "设置列格式",
      formatRows: "设置行格式",
      insertColumns: "插入列",
      insertRows: "插入行",
      insertHyperlinks: "插入超链接",
      deleteColumns: "删除列",
      deleteRows: "删除行",
      sort: "排序",
      filter: "使用自动筛选",
      usePivotTablereports: "使用数据透视表和报表",
      editObjects: "编辑对象",
      editScenarios: "编辑方案",
      allowRangeTitle: "允许用户编辑区域",
      allowRangeAdd: "新建...",
      allowRangeAddTitle: "标题",
      allowRangeAddSqrf: "引用单元格",
      selectCellRange: "点击选择单元格范围",
      selectCellRangeHolder: "请输入单元格范围",
      allowRangeAddTitlePassword: "密码",
      allowRangeAddTitleHint: "提示",
      allowRangeAddTitleHintTitle: "设置密码后，提示用户输入密码(可留空)",
      allowRangeAddtitleDefault: "请输入区域名称",
      rangeItemDblclick: "双击进行编辑",
      rangeItemHasPassword: "已设置密码",
      rangeItemErrorTitleNull: "标题不能为空",
      rangeItemErrorRangeNull: "单元格范围不能为空",
      rangeItemErrorRange: "单元格范围格式错误",
      validationTitle: "验证提示",
      validationTips: "需要输入密码来撤销工作表的保护",
      validationInputHint: "请输入密码",
      checkPasswordNullalert: "密码不能为空！",
      checkPasswordWrongalert: "密码错误，请重试！",
      checkPasswordSucceedalert: "解锁成功，可以编辑该区域!",
      defaultRangeHintText: "该单元格正在受密码保护。",
      defaultSheetHintText: "该单元格或图表位于受保护的工作表中，若要进行更改，请取消工作表保护，您可能需要输入密码。"
    },
    cellFormat: {
      cellFormatTitle: "设置单元格格式",
      protection: "保护",
      locked: "锁定单元格",
      hidden: "隐藏公式",
      protectionTips: "只有保护工作表功能(在菜单栏点击保护工作表按钮进行设置)开启后，锁定单元格或隐藏公式才能生效",
      tipsPart: "部分选中",
      tipsAll: "全部选中",
      selectionIsNullAlert: "请选择一个范围！",
      sheetDataIsNullAlert: "数据为空无法设置！"
    },
    print: {
      normalBtn: "常规视图",
      layoutBtn: "页面布局",
      pageBtn: "分页预览",
      menuItemPrint: "打印(Ctrl+P)",
      menuItemAreas: "打印区域",
      menuItemRows: "打印标题行",
      menuItemColumns: "打印标题列"
    },
    edit: {
      typing: "正在输入"
    },
    websocket: {
      success: "WebSocket连接成功",
      refresh: "WebSocket连接发生错误, 请刷新页面！",
      wait: "WebSocket连接发生错误, 请耐心等待！",
      close: "WebSocket连接关闭",
      contact: "服务器通信发生错误，请刷新页面后再试，如若不行请联系管理员！",
      support: "当前浏览器不支持WebSocket"
    }
  };
  var es = {
    generalDialog: {
      partiallyError: "No se puede realizar esta operación en celdas parcialmente unidas",
      readOnlyError: "No se puede realizar esto en modo de solo lectura",
      dataNullError: "No se puede hacer esto con datos que no existen",
      noSeletionError: "The selection operation has not been performed yetLa operación de selección aún no se ha realizado",
      cannotSelectMultiple: "No se puede seleccionar la zona de selección múltiple"
    },
    functionlist: [{
      n: "SUMIF",
      t: 0,
      d: "Returns a conditional sum across a range.",
      a: "A conditional sum across a range.",
      m: [2, 3],
      p: [{
        name: "range",
        detail: "The range which is tested against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sum_range",
        detail: "The range to be summed, if different from `range`.",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TAN",
      t: 0,
      d: "Returns the tangent of an angle provided in radians.",
      a: "Tangent of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the tangent of, in radians.",
        example: "45*PI()/180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TANH",
      t: 0,
      d: "Returns the hyperbolic tangent of any real number.",
      a: "Hyperbolic tangent of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic tangent of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CEILING",
      t: 0,
      d: "Rounds a number up to the nearest integer multiple of specified significance `factor`.",
      a: "Rounds number up to nearest multiple of a factor.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round up to the nearest integer multiple of `factor`.",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN",
      t: 0,
      d: "Returns the inverse tangent of a value, in radians.",
      a: "Inverse tangent of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse tangent.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ASINH",
      t: 0,
      d: "Returns the inverse hyperbolic sine of a number.",
      a: "Inverse hyperbolic sine of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic sine.",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ABS",
      t: 0,
      d: "Returns the absolute value of a number.",
      a: "Absolute value of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number of which to return the absolute value.",
        example: "-2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOS",
      t: 0,
      d: "Returns the inverse cosine of a value, in radians.",
      a: "Inverse cosine of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse cosine. Must be between `-1` and `1`, inclusive.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOSH",
      t: 0,
      d: "Returns the inverse hyperbolic cosine of a number.",
      a: "Inverse hyperbolic cosine of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic cosine. Must be greater than or equal to `1`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTINOMIAL",
      t: 0,
      d: "Returns the factorial of the sum of values divided by the product of the values' factorials.",
      a: "Multinomial distribution function.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "ATANH",
      t: 0,
      d: "Returns the inverse hyperbolic tangent of a number.",
      a: "Inverse hyperbolic tangent of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse hyperbolic tangent. Must be between -1 and 1, exclusive.",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN2",
      t: 0,
      d: "Returns the angle between the x-axis and a line segment from the origin (0,0) to specified coordinate pair (`x`,`y`), in radians.",
      a: "Arctangent of a value.",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The x coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "y",
        detail: "The y coordinate of the endpoint of the line segment for which to calculate the angle from the x-axis.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTBLANK",
      t: 1,
      d: "Returns the number of empty values in a list of values and ranges.",
      a: "Number of empty values.",
      m: [1, 1],
      p: [{
        name: "value1",
        detail: "The first value or range in which to count the number of blanks.",
        example: "A2:C100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "COSH",
      t: 0,
      d: "Returns the hyperbolic cosine of any real number.",
      a: "Hyperbolic cosine of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic cosine of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INT",
      t: 0,
      d: "Rounds a number down to the nearest integer that is less than or equal to it.",
      a: "Rounds number down to nearest integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round down to the nearest integer.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISEVEN",
      t: 0,
      d: "Checks whether the provided value is even.",
      a: "Whether the provided value is even.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as even.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISODD",
      t: 0,
      d: "Checks whether the provided value is odd.",
      a: "Whether the provided value is odd.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as odd.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LCM",
      t: 0,
      d: "Returns the least common multiple of one or more integers.",
      a: "Least common multiple of one or more integers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range whose factors to consider in a calculation to find the least common multiple.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges whose factors to consider to find the least common multiple.",
        example: "3",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LN",
      t: 0,
      d: "Returns the logarithm of a number, base e (Euler's number).",
      a: "The logarithm of a number, base e (euler's number).",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm, base e.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG",
      t: 0,
      d: "Returns the logarithm of a number with respect to a base.",
      a: "The logarithm of a number with respect to a base.",
      m: [1, 2],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm.",
        example: "128",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "base",
        detail: "The base to use for calculation of the logarithm.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG10",
      t: 0,
      d: "Returns the logarithm of a number, base 10.",
      a: "The logarithm of a number, base 10.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the logarithm, base 10.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MOD",
      t: 0,
      d: "Returns the result of the modulo operator, the remainder after a division operation.",
      a: "Modulo (remainder) operator.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided to find the remainder.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MROUND",
      t: 0,
      d: "Rounds one number to the nearest integer multiple of another.",
      a: "Rounds a number to the nearest integer multiple.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The number to round to the nearest integer multiple of another.",
        example: "21",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ODD",
      t: 0,
      d: "Rounds a number up to the nearest odd integer.",
      a: "Rounds a number up to the nearest odd integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round to the next greatest odd number.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMSQ",
      t: 0,
      d: "Returns the sum of the squares of a series of numbers and/or cells.",
      a: "Sum of squares.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first number or range whose squares to add together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional numbers or ranges whose squares to add to the square(s) of `value1`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMBIN",
      t: 0,
      d: "Returns the number of ways to choose some number of objects from a pool of a given size of objects.",
      a: "Number of combinations from a set of objects.",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "The size of the pool of objects to choose from.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "The number of objects to choose.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUM",
      t: 0,
      d: "Returns the sum of a series of numbers and/or cells.",
      a: "Sum of a series of numbers and/or cells.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first number or range to add together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional numbers or ranges to add to `value1`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SUBTOTAL",
      t: 0,
      d: "Returns a subtotal for a vertical range of cells using a specified aggregation function.",
      a: "Subtotal for a range using a specific function.",
      m: [2, 256],
      p: [{
        name: "function_code",
        detail: "The function to use in subtotal aggregation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "range1",
        detail: "The first range over which to calculate a subtotal.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "range2",
        detail: "Additional ranges over which to calculate subtotals.",
        example: "B2:B8",
        require: "o",
        repeat: "y",
        type: "range"
      }]
    }, {
      n: "ASIN",
      t: 0,
      d: "Returns the inverse sine of a value, in radians.",
      a: "Inverse sine of a value, in radians.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse sine. Must be between `-1` and `1`, inclusive.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTIF",
      t: 1,
      d: "Returns a conditional count across a range.",
      a: "A conditional count across a range.",
      m: [2, 2],
      p: [{
        name: "range",
        detail: "The range that is tested against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RADIANS",
      t: 0,
      d: "Converts an angle value in degrees to radians.",
      a: "Converts an angle value in degrees to radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to convert from degrees to radians.",
        example: "180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RAND",
      t: 0,
      d: "Returns a random number between 0 inclusive and 1 exclusive.",
      a: "A random number between 0 inclusive and 1 exclusive.",
      m: [0, 0],
      p: []
    }, {
      n: "COUNTUNIQUE",
      t: 0,
      d: "Counts the number of unique values in a list of specified values and ranges.",
      a: "Counts number of unique values in a range.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider for uniqueness.",
        example: "A1:C100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider for uniqueness.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DEGREES",
      t: 0,
      d: "Converts an angle value in radians to degrees.",
      a: "Converts an angle value in radians to degrees.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to convert from radians to degrees.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ERFC",
      t: 9,
      d: "Returns the complementary Gauss error function of a value.",
      a: "Complementary gauss error function of a value.",
      m: [1, 1],
      p: [{
        name: "z",
        detail: "The number for which to calculate the complementary Gauss error function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVEN",
      t: 0,
      d: "Rounds a number up to the nearest even integer.",
      a: "Rounds a number up to the nearest even integer.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to round to the next greatest even number.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EXP",
      t: 0,
      d: "Returns Euler's number, e (~2.718) raised to a power.",
      a: "Euler's number, e (~2.718) raised to a power.",
      m: [1, 1],
      p: [{
        name: "exponent",
        detail: "The exponent to raise e to.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACT",
      t: 0,
      d: "Returns the factorial of a number.",
      a: "Factorial of a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number or reference to a number whose factorial will be calculated and returned.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACTDOUBLE",
      t: 0,
      d: 'Returns the "double factorial" of a number.',
      a: '"double factorial" of a number.',
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number or reference to a number whose double factorial will be calculated and returned.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PI",
      t: 0,
      d: "Returns the value of Pi to 14 decimal places.",
      a: "The number pi.",
      m: [0, 0],
      p: []
    }, {
      n: "FLOOR",
      t: 0,
      d: "Rounds a number down to the nearest integer multiple of specified significance `factor`.",
      a: "Rounds number down to nearest multiple of a factor.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round down to the nearest integer multiple of `factor`.",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The number to whose multiples `value` will be rounded.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GCD",
      t: 0,
      d: "Returns the greatest common divisor of one or more integers.",
      a: "Greatest common divisor of one or more integers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range whose factors to consider in a calculation to find the greatest common divisor.",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges whose factors to consider to find the greatest common divisor.",
        example: "96",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANDBETWEEN",
      t: 0,
      d: "Returns a uniformly random integer between two values, inclusive.",
      a: "Random integer between two values, inclusive.",
      m: [2, 2],
      p: [{
        name: "low",
        detail: "The low end of the random range.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "high",
        detail: "The high end of the random range.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUND",
      t: 0,
      d: "Rounds a number to a certain number of decimal places according to standard rules.",
      a: "Rounds a number according to standard rules.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDDOWN",
      t: 0,
      d: "Rounds a number to a certain number of decimal places, always rounding down to the next valid increment.",
      a: "Rounds down a number.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places, always rounding down.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDUP",
      t: 0,
      d: "Rounds a number to a certain number of decimal places, always rounding up to the next valid increment.",
      a: "Rounds up a number.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to round to `places` number of places, always rounding up.",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of decimal places to which to round.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SERIESSUM",
      t: 0,
      d: "Given parameters `x`, `n`, `m`, and `a`, returns the power series sum a",
      a: "Sum of a power series.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the power series. Varies depending on the type of approximation, may be angle, exponent, or some other value.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "The initial power to which to raise `x` in the power series.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "m",
        detail: "The additive increment by which to increase `x`.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "a",
        detail: "The array or range containing the coefficients of the power series.",
        example: "{FACT(0)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIGN",
      t: 0,
      d: "Given an input number, returns `-1` if it is negative, `1` if positive, and `0` if it is zero.",
      a: "Sign of a provided number (+/-/0).",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value whose sign will be evaluated.",
        example: "-42",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIN",
      t: 0,
      d: "Returns the sine of an angle provided in radians.",
      a: "Sine of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the sine of, in radians.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SINH",
      t: 0,
      d: "Returns the hyperbolic sine of any real number.",
      a: "Hyperbolic sine of any real number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Any real value to calculate the hyperbolic sine of.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRT",
      t: 0,
      d: "Returns the positive square root of a positive number.",
      a: "Positive square root of a positive number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number for which to calculate the positive square root.",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRTPI",
      t: 0,
      d: "Returns the positive square root of the product of Pi and the given positive number.",
      a: "Square root of the product of pi and number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The number which will be multiplied by Pi and have the product's square root returned",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GAMMALN",
      t: 1,
      d: "Returns the logarithm of a specified Gamma function, base e (Euler's number).",
      a: "Logarithm of gamma function.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The input to the Gamma function. The natural logarithm of Gamma(`value`) will be returned.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COS",
      t: 0,
      d: "Returns the cosine of an angle provided in radians.",
      a: "Cosine of an angle provided in radians.",
      m: [1, 1],
      p: [{
        name: "angle",
        detail: "The angle to find the cosine of, in radians.",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRUNC",
      t: 0,
      d: "Truncates a number to a certain number of significant digits by omitting less significant digits.",
      a: "Truncates a number.",
      m: [1, 2],
      p: [{
        name: "value",
        detail: "The value to be truncated.",
        example: "3.141592654",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "The number of significant digits to the right of the decimal point to retain.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUOTIENT",
      t: 0,
      d: "Returns one number divided by another.",
      a: "One number divided by another.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POWER",
      t: 0,
      d: "Returns a number raised to a power.",
      a: "A number raised to a power.",
      m: [2, 2],
      p: [{
        name: "base",
        detail: "The number to raise to the `exponent` power.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "exponent",
        detail: "The exponent to raise `base` to.",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMIFS",
      t: 0,
      d: "Returns the sum of a range depending on multiple criteria.",
      a: "Sums a range depending on multiple criteria.",
      m: [3, 257],
      p: [{
        name: "sum_range",
        detail: "The range to sum.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criteria_range1",
        detail: "The range to check against criterion1.",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to criteria_range1.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " C1:C10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTIFS",
      t: 1,
      d: "Returns the count of a range depending on multiple criteria.",
      a: "Count values depending on multiple criteria.",
      m: [2, 256],
      p: [{
        name: "criteria_range1",
        detail: "The range to check against `criterion1`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to `criteria_range1`.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " B1:B10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PRODUCT",
      t: 0,
      d: "Returns the result of multiplying a series of numbers together.",
      a: "Result of multiplying a series of numbers together.",
      m: [1, 255],
      p: [{
        name: "factor1",
        detail: "The first number or range to calculate for the product.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor2",
        detail: "More numbers or ranges to calculate for the product.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HARMEAN",
      t: 1,
      d: "Calculates the harmonic mean of a dataset.",
      a: "The harmonic mean of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HYPGEOMDIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of successes in a certain number of tries given a population of a certain size containing a certain number of successes, without replacement of draws.",
      a: "Hypergeometric distribution probability.",
      m: [5, 5],
      p: [{
        name: "num_successes",
        detail: "The desired number of successes.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_draws",
        detail: "The number of permitted draws.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "successes_in_pop",
        detail: "The total number of successes in the population.",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pop_size",
        detail: "The total size of the population",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf cumulative is TRUE(), HYPGEOM.DIST returns the cumulative distribution function;\n\nif FALSE(), it returns the probability density function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INTERCEPT",
      t: 1,
      d: "Calculates the y-value at which the line resulting from linear regression of a dataset will intersect the y-axis (x=0).",
      a: "Y-intercept of line derived via linear regression.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "KURT",
      t: 1,
      d: 'Calculates the kurtosis of a dataset, which describes the shape, and in particular the "peakedness" of that dataset.',
      a: "Kurtosis of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LARGE",
      t: 1,
      d: "Returns the nth largest element from a data set, where n is user-defined.",
      a: "Nth largest element from a data set.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "The rank from largest to smallest of the element to return.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVA",
      t: 1,
      d: "Calculates the standard deviation based on a sample, setting text to the value `0`.",
      a: "Standard deviation of sample (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVP",
      t: 1,
      d: "Calculates the standard deviation based on an entire population.",
      a: "Standard deviation of an entire population.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "GEOMEAN",
      t: 1,
      d: "Calculates the geometric mean of a dataset.",
      a: "The geometric mean of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANK_EQ",
      t: 1,
      d: "Returns the rank of a specified value in a dataset. If there is more than one entry of the same value in the dataset, the top rank of the entries will be returned.",
      a: "Top rank of a specified value in a dataset.",
      m: [2, 3],
      p: [{
        name: "value",
        detail: "The value whose rank will be determined.",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "is_ascending",
        detail: "Whether to consider the values in `data` in descending or ascending order. If omitted, the default is descending (FALSE).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANK_AVG",
      t: 1,
      d: "Returns the rank of a specified value in a dataset. If there is more than one entry of the same value in the dataset, the average rank of the entries will be returned.",
      a: "Average rank of a specified value in a dataset.",
      m: [2, 3],
      p: [{
        name: "value",
        detail: "The value whose rank will be determined.",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "is_ascending",
        detail: "Whether to consider the values in `data` in descending or ascending order. If omitted, the default is descending (FALSE).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERCENTRANK_EXC",
      t: 1,
      d: "Returns the percentage rank (percentile) from 0 to 1 exclusive of a specified value in a dataset.",
      a: "Percentage rank (percentile) from 0 to 1 exclusive.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value",
        detail: "The value whose percentage rank will be determined.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant figures to use in the calculation. Default is 3.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTRANK_INC",
      t: 1,
      d: "Returns the percentage rank (percentile) from 0 to 1 inclusive of a specified value in a dataset.",
      a: "Percentage rank (percentile) from 0 to 1 inclusive.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value",
        detail: "The value whose percentage rank will be determined.",
        example: " A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant figures to use in the calculation. Default is 3.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FORECAST",
      t: 1,
      d: "Calculates the expected y-value for a specified x based on a linear regression of a dataset.",
      a: "Expected y-value based of linear regression.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The value on the x-axis to forecast.",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHERINV",
      t: 1,
      d: "Returns the inverse Fisher transformation of a specified value.",
      a: "Inverse fisher transformation of a specified value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the inverse Fisher transformation.",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHER",
      t: 1,
      d: "Returns the Fisher transformation of a specified value.",
      a: "Fisher transformation of a specified value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value for which to calculate the Fisher transformation.",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MODE_SNGL",
      t: 1,
      d: "Returns the most commonly occurring value in a dataset.",
      a: "Most commonly occurring value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating mode.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating mode.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "WEIBULL_DIST",
      t: 1,
      d: "Returns the value of the Weibull distribution function (or Weibull cumulative distribution function) for a specified shape and scale.",
      a: "Weibull distribution function.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the Weibull distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "shape",
        detail: "The shape parameter of the Weibull distribution function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "scale",
        detail: "The scale parameter of the Weibull distribution function.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the cumulative distribution function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COUNT",
      t: 1,
      d: "Returns the number of numeric values in a dataset.",
      a: "The number of numeric values in dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when counting.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when counting.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTA",
      t: 1,
      d: "Returns the number of values in a dataset.",
      a: "The number of values in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when counting.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when counting.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVEDEV",
      t: 1,
      d: "Calculates the average of the magnitudes of deviations of data from a dataset's mean.",
      a: "Average magnitude of deviations from mean.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "AVERAGE",
      t: 1,
      d: "Returns the numerical average value in a dataset, ignoring text.",
      a: "Numerical average value in a dataset, ignoring text.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the average value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the average value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEA",
      t: 1,
      d: "Returns the numerical average value in a dataset.",
      a: "Numerical average value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the average value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the average value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_DIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of successes (or a maximum number of successes) in a certain number of tries given a population of a certain size containing a certain number of successes, with replacement of draws.",
      a: "Binomial distribution probability.",
      m: [4, 4],
      p: [{
        name: "num_successes",
        detail: "The number of successes for which to calculate the probability in `num_trials` trials.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_trials",
        detail: "The number of independent trials.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the binomial cumulative distribution.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_INV",
      t: 1,
      d: "Calculates the smallest value for which the cumulative binomial distribution is greater than or equal to a specified criteria.",
      a: "Inverse cumulative binomial distribution function.",
      m: [3, 3],
      p: [{
        name: "num_trials",
        detail: "The number of independent trials.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "target_prob",
        detail: "The desired threshold probability.",
        example: "0.8",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONFIDENCE_NORM",
      t: 1,
      d: "Calculates the width of half the confidence interval for a normal distribution.",
      a: "Confidence interval for a normal distribution.",
      m: [3, 3],
      p: [{
        name: "alpha",
        detail: "One minus the desired confidence level. E.g. `0.1` for `0.9`, or 90%, confidence.",
        example: "0.05",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation of the population.",
        example: "1.6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pop_size",
        detail: "The size of the population.",
        example: "250",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CORREL",
      t: 1,
      d: "Calculates r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Pearson Product-Moment Correlation Coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_P",
      t: 1,
      d: "Calculates the covariance of a dataset.",
      a: "The covariance of a dataset.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_S",
      t: 1,
      d: "Calculates the sample covariance of a dataset.",
      a: "The sample covariance of a dataset.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEVSQ",
      t: 1,
      d: "Calculates the sum of squares of deviations based on a sample.",
      a: "The sum of squares of deviations based on a sample.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "EXPON_DIST",
      t: 1,
      d: "Returns the value of the exponential distribution function with a specified lambda at a specified value.",
      a: "Exponential distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the exponential distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "lambda",
        detail: "The lambda to specify the exponential distribution function.",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the exponential cumulative distribution.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIF",
      t: 1,
      d: "Returns the average of a range depending on criteria.",
      a: "Average of values depending on criteria.",
      m: [2, 3],
      p: [{
        name: "criteria_range",
        detail: "The range to check against `criterion`.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion",
        detail: "The pattern or test to apply to `criteria_range`.",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "average_range",
        detail: "The range to average. If not included, `criteria_range` is used for the average instead.",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIFS",
      t: 1,
      d: "Returns the average of a range depending on multiple criteria.",
      a: "Average of values depending on multiple criteria.",
      m: [2, 255],
      p: [{
        name: "average_range",
        detail: "The range to average.",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range1",
        detail: "The range to check against `criterion1`.",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion1",
        detail: "The pattern or test to apply to `criteria_range1`.",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2",
        detail: "Additional ranges to check.",
        example: " C1:C10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERMUT",
      t: 1,
      d: "Returns the number of ways to choose some number of objects from a pool of a given size of objects, considering order.",
      a: "Number of permutations from a number of objects.",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "The size of the pool of objects to choose from.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "The number of objects to choose.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRIMMEAN",
      t: 1,
      d: "Calculates the mean of a dataset excluding some proportion of data from the high and low ends of the dataset.",
      a: "Mean of a dataset excluding high/low ends.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "exclude_proportion",
        detail: "The proportion of the dataset to exclude, from the extremities of the set.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_EXC",
      t: 1,
      d: "Returns the value at a given percentile of a dataset exclusive of 0 and 1.",
      a: "Value at a given percentile of a dataset exclusive of 0 and 1.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "percentile",
        detail: "The percentile, exclusive of 0 and 1, whose value within 'data' will be calculated and returned.",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_INC",
      t: 1,
      d: "Returns the value at a given percentile of a dataset.",
      a: "Value at a given percentile of a dataset.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "percentile",
        detail: "The percentile whose value within `data` will be calculated and returned.`",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PEARSON",
      t: 1,
      d: "Calculates r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Pearson Product-Moment Correlation Coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_INV",
      t: 1,
      d: "Returns the value of the inverse standard normal distribution function for a specified value.",
      a: "Inverse standard normal distribution function.",
      m: [1, 1],
      p: [{
        name: "x",
        detail: "The input to the inverse standard normal distribution function.",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_DIST",
      t: 1,
      d: "Returns the value of the standard normal cumulative distribution function for a specified value.",
      a: "Standard normal cumulative distribution function.",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the standard normal cumulative distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NORM_INV",
      t: 1,
      d: "Returns the value of the inverse normal distribution function for a specified value, mean, and standard deviation.",
      a: "Inverse normal distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the inverse normal distribution function.",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the normal distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the normal distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_DIST",
      t: 1,
      d: "Returns the value of the normal distribution function (or normal cumulative distribution function) for a specified value, mean, and standard deviation.",
      a: "Normal distribution function.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the normal distribution function.",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the normal distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the normal distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the normal cumulative distribution function rather than the distribution function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NEGBINOM_DIST",
      t: 1,
      d: "Calculates the probability of drawing a certain number of failures before a certain number of successes given a probability of success in independent trials.",
      a: "Negative binomial distribution probability.",
      m: [4, 4],
      p: [{
        name: "num_failures",
        detail: "The number of failures to model.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_successes",
        detail: "The number of successes to model.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "prob_success",
        detail: "The probability of success in any given trial.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINA",
      t: 1,
      d: "Returns the minimum numeric value in a dataset.",
      a: "Minimum numeric value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the minimum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the minimum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MIN",
      t: 1,
      d: "Returns the minimum value in a numeric dataset.",
      a: "Minimum value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the minimum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the minimum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MEDIAN",
      t: 1,
      d: "Returns the median value in a numeric dataset.",
      a: "Median value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the median value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the median value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAXA",
      t: 1,
      d: "Returns the maximum numeric value in a dataset.",
      a: "Maximum numeric value in a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the maximum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the maximum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAX",
      t: 1,
      d: "Returns the maximum value in a numeric dataset.",
      a: "Maximum value in a numeric dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range to consider when calculating the maximum value.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to consider when calculating the maximum value.",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_INV",
      t: 1,
      d: "Returns the value of the inverse log-normal cumulative distribution with given mean and standard deviation at a specified value.",
      a: "Inverse log-normal cumulative distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the inverse log-normal cumulative distribution function.",
        example: "0.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the inverse log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the inverse log-normal cumulative distribution function.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_DIST",
      t: 1,
      d: "Returns the value of the log-normal cumulative distribution with given mean and standard deviation at a specified value.",
      a: "Log-normal cumulative distribution probability.",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the log-normal cumulative distribution function.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation (sigma) of the log-normal cumulative distribution function.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Determine the logical value of the function form. \n\nIf TRUE(), it returns the cumulative distribution function;\n\nIf it is FALSE(), it returns the probability density function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "Z_TEST",
      t: 1,
      d: "Returns the one-tailed p-value of a Z-test with standard distribution.",
      a: "One-tailed p-value of a z-test.",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "value",
        detail: "The test statistic to use in the Z-test.",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation to assume for the Z-test. If this is not provided, the standard deviation of the data will be used.",
        example: "3",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PROB",
      t: 1,
      d: "Given a set of values and corresponding probabilities, calculates the probability that a value chosen at random falls between two limits.",
      a: "Probability values lie in a range.",
      m: [3, 4],
      p: [{
        name: "data",
        detail: "Array or range containing the dataset to consider.",
        example: "A3:A6",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "probabilities",
        detail: "Array or range containing probabilities corresponding to `data`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "low_limit",
        detail: "The lower bound on the value range for which to calculate the probability.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "high_limit",
        detail: "The upper bound on the value range for which to calculate the probability.",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_EXC",
      t: 1,
      d: "Returns a value nearest to a specified quartile of a dataset exclusive of 0 and 4.",
      a: "Value nearest to a specific quartile of a dataset exclusive of 0 and 4.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quartile_number",
        detail: "Which quartile to return.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_INC",
      t: 1,
      d: "Returns a value nearest to a specified quartile of a dataset.",
      a: "Value nearest to a specific quartile of a dataset.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quartile_number",
        detail: "Which quartile value to return.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POISSON_DIST",
      t: 1,
      d: "Returns the value of the Poisson distribution function (or Poisson cumulative distribution function) for a specified value and mean.",
      a: "Poisson distribution function.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the Poisson distribution function.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean (mu) of the Poisson distribution function.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Whether to use the Poisson cumulative distribution function rather than the distribution function.",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RSQ",
      t: 1,
      d: "Calculates the square of r, the Pearson product-moment correlation coefficient of a dataset.",
      a: "Square of the correlation coefficient.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST",
      t: 1,
      d: "Calculates the left tail probability for a Student's t-distribution with a given input (x).",
      a: "The left-tailed Student's t-distribution",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "If cumulative is TRUE, T.DIST returns the cumulative distribution function; if FALSE, it returns the probability density function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T_DIST_2T",
      t: 1,
      d: "Calculates the probability for two tailed Student's t-distribution with a given input (x).",
      a: "The two tailed Student's t-distribution",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST_RT",
      t: 1,
      d: "Calculates the right tail probability for a Student's t-distribution with a given input (x).",
      a: "The right-tailed Student's t-distribution",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "The input to the t-distribution function.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV",
      t: 1,
      d: "Calculates the negative inverse of the one-tailed TDIST function.",
      a: "T.INV",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "The probability associated with the two-tailed t-distribution.",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV_2T",
      t: 1,
      d: "Calculates the inverse of the two-tailed TDIST function.",
      a: "T.INV.2T",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "The probability associated with the two-tailed t-distribution.",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "The number of degrees of freedom.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_TEST",
      t: 1,
      d: "t-test. Returns the probability associated with Student's t-test. Determines whether two samples are likely to have come from the same two underlying populations that have the same mean.",
      a: "Returns the probability associated with t-test.",
      m: [4, 4],
      p: [{
        name: "range1",
        detail: "The first sample of data or group of cells to consider for the t-test.",
        example: "A1:A4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "range2",
        detail: "The second sample of data or group of cells to consider for the t-test.",
        example: "B1:B4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "Specifies the number of distribution tails.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "Specifies the type of t-test.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "F_DIST",
      t: 1,
      d: "Calculates the left-tailed F probability distribution (degree of diversity) for two data sets with given input x. Alternately called Fisher-Snedecor distribution or Snedecor's F distribution.",
      a: "F probability distribution (left-tailed).",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "The input to the F probability distribution function. The value at which to evaluate the function.",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "The numerator of the number of degrees of freedom.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "The denominator of the number of degrees of freedom.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "Logical value that determines the form of the function.",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "F_DIST_RT",
      t: 1,
      d: "Calculates the right-tailed F probability distribution (degree of diversity) for two data sets with given input x. Alternately called Fisher-Snedecor distribution or Snedecor's F distribution.",
      a: "F probability distribution.",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "The input to the F probability distribution function. The value at which to evaluate the function.",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "The numerator of the number of degrees of freedom.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "The denominator of the number of degrees of freedom.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_P",
      t: 1,
      d: "Calculates the variance based on an entire population.",
      a: "Variance of entire population.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_S",
      t: 1,
      d: "Calculates the variance based on a sample.",
      a: "Variance.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARA",
      t: 1,
      d: "Calculates the variance based on a sample, setting text to the value `0`.",
      a: "Variance of sample (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the sample.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the sample.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARPA",
      t: 1,
      d: "Calculates the variance based on an entire population, setting text to the value `0`.",
      a: "Variance of entire population (text as 0).",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the population.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the population.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STEYX",
      t: 1,
      d: "Calculates the standard error of the predicted y-value for each x in the regression of a dataset.",
      a: "Standard error of predicted y-values in regression.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STANDARDIZE",
      t: 1,
      d: "Calculates the normalized equivalent of a random variable given mean and standard deviation of the distribution.",
      a: "Normalized equivalent of a random variable.",
      m: [3, 3],
      p: [{
        name: "value",
        detail: "The value of the random variable to normalize.",
        example: "96",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "The mean of the distribution.",
        example: "80",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_deviation",
        detail: "The standard deviation of the distribution.",
        example: "6.7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SMALL",
      t: 1,
      d: "Returns the nth smallest element from a data set, where n is user-defined.",
      a: "Nth smallest element in a data set.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the dataset to consider.",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "n",
        detail: "The rank from smallest to largest of the element to return.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLOPE",
      t: 1,
      d: "Calculates the slope of the line resulting from linear regression of a dataset.",
      a: "Slope of line from linear regression of data.",
      m: [2, 2],
      p: [{
        name: "data_y",
        detail: "The range representing the array or matrix of dependent data.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "data_x",
        detail: "The range representing the array or matrix of independent data.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SKEW",
      t: 1,
      d: "Calculates the skewness of a dataset, which describes the symmetry of that dataset about the mean.",
      a: "Skewness of a dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SKEW_P",
      t: 1,
      d: "Calculates the skewness of a dataset, which describes the symmetry of that dataset about the mean. This assumes the dataset is for the population.",
      a: "Skewness of a population's dataset.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first value or range of the dataset.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional values or ranges to include in the dataset.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "VLOOKUP",
      t: 2,
      d: "Vertical lookup. Searches down the first column of a range for a key and returns the value of a specified cell in the row found.",
      a: "Vertical lookup.",
      m: [3, 4],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The range to consider for the search. The first column in the range is searched for the key specified in `search_key`.",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "index",
        detail: "The column index of the value to be returned, where the first column in `range` is numbered 1.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_sorted",
        detail: "Indicates whether the column to be searched (the first column of the specified range) is sorted, in which case the closest match for `search_key` will be returned.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HLOOKUP",
      t: 2,
      d: "Horizontal lookup. Searches across the first row of a range for a key and returns the value of a specified cell in the column found.",
      a: "Horizontal lookup",
      m: [3, 4],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The range to consider for the search. The first row in the range is searched for the key specified in `search_key`.",
        example: "A2:Z6",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "index",
        detail: "The row index of the value to be returned, where the first row in `range` is numbered 1.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_sorted",
        detail: "Indicates whether the row to be searched (the first row of the specified range) is sorted.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOOKUP",
      t: 2,
      d: "Looks through a sorted row or column for a key and returns the value of the cell in a result range located in the same position as the search row or column.",
      a: "Look up a value.",
      m: [2, 3],
      p: [{
        name: "search_key",
        detail: 'The value to search for in the row or column. For example, `42`, `"Cats"`, or `I24`.',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "search_range|search_result_array",
        detail: "One method of using this function is to provide a single sorted row or column `search_range` to look through for the `search_key` with a second argument `result_range`. The other way is to combine these two arguments into one `search_result_array` where the first row or column is searched and a value is returned from the last row or column in the array. If `search_key` is not found, a non-exact match may be returned.",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "result_range",
        detail: "The range from which to return a result. The value returned corresponds to the location where `search_key` is found in `search_range`. This range must be only a single row or column and should not be used if using the `search_result_array` method.",
        example: "B1:B100",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADDRESS",
      t: 2,
      d: "Returns a cell reference as a string.",
      a: "Cell reference as a string.",
      m: [2, 5],
      p: [{
        name: "row",
        detail: "The row number of the cell reference",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column",
        detail: "The column number (not name) of the cell reference. `A` is column number `1`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "absolute_relative_mode",
        detail: "An indicator of whether the reference is row/column absolute. `1` is row and column absolute (e.g. $A$1), `2` is row absolute and column relative (e.g. A$1), `3` is row relative and column absolute (e.g. $A1), and `4` is row and column relative (e.g. A1).",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "use_a1_notation",
        detail: "A boolean indicating whether to use `A1` style notation (TRUE) or `R1C1` style notation (FALSE).",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sheet",
        detail: "Text indicating the name of the sheet into which the address points.",
        example: '"Sheet2"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INDIRECT",
      t: 2,
      d: "Returns a cell reference specified by a string.",
      a: "A cell reference specified by a string.",
      m: [1, 2],
      p: [{
        name: "cell_reference_as_string",
        detail: "A cell reference, written as a string with surrounding quotation marks.",
        example: '"Sheet2!"&B10',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "is_A1_notation",
        detail: "Indicates if the cell reference is in A1 notation (TRUE) or R1C1 notation (FALSE).",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROW",
      t: 2,
      d: "Returns the row number of a specified cell.",
      a: "Row number of a specified cell.",
      m: [0, 1],
      p: [{
        name: "cell_reference",
        detail: "The cell whose row number will be returned.",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROWS",
      t: 2,
      d: "Returns the number of rows in a specified array or range.",
      a: "Number of rows in a specified array or range.",
      m: [1, 1],
      p: [{
        name: "range",
        detail: "The range whose row count will be returned.",
        example: "A9:A62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COLUMN",
      t: 2,
      d: "Returns the column number of a specified cell, with `A=1`.",
      a: "Column number of a specified cell.",
      m: [0, 1],
      p: [{
        name: "cell_reference",
        detail: "The cell whose column number will be returned. Column `A` corresponds to `1`.",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNS",
      t: 2,
      d: "Returns the number of columns in a specified array or range.",
      a: "Number of columns in a specified array or range.",
      m: [1, 1],
      p: [{
        name: "range",
        detail: "The range whose column count will be returned.",
        example: "A9:W62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OFFSET",
      t: 2,
      d: "Returns a range reference shifted a specified number of rows and columns from a starting cell reference.",
      a: "A range reference offset relative to a cell.",
      m: [3, 5],
      p: [{
        name: "cell_reference",
        detail: "The starting point from which to count the offset rows and columns.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "offset_rows",
        detail: "The number of rows to offset by.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "offset_columns",
        detail: "The number of columns to offset by.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "height",
        detail: "The height of the range to return starting at the offset target.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "width",
        detail: "The width of the range to return starting at the offset target.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MATCH",
      t: 2,
      d: "Returns the relative position of an item in a range that matches a specified value.",
      a: "Position of item in range that matches value.",
      m: [2, 3],
      p: [{
        name: "search_key",
        detail: 'The value to search for. For example, `42`, `"Cats"`, or `I24`.',
        example: '"Sunday"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "range",
        detail: "The one-dimensional array to be searched.",
        example: "A2:A9",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "search_type",
        detail: "The search method. `1` (default) finds the largest value less than or equal to `search_key` when `range` is sorted in ascending order. `0` finds the exact value when `range` is unsorted. `-1` finds the smallest value greater than or equal to `search_key` when `range` is sorted in descending order.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INDEX",
      t: 2,
      d: "Returns the content of a cell, specified by row and column offset.",
      a: "Content of cell specified by row and column offset.",
      m: [2, 3],
      p: [{
        name: "reference",
        detail: "The array of cells to be offset into.",
        example: "A1:C20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "row",
        detail: "The number of offset rows.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column",
        detail: "The number of offset columns.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GETPIVOTDATA",
      t: 2,
      d: "Extracts an aggregated value from a pivot table that corresponds to the specified row and column headings.",
      a: "Extracts an aggregated value from a pivot table that corresponds to the specified row and column headings.",
      m: [2, 254],
      p: [{
        name: "value_name",
        detail: "The name of the value in the pivot table for which you want to get data.",
        example: '"SUM of number of units"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "any_pivot_table_cell",
        detail: "Any reference to a cell in the desired pivot table (top corner recommended).",
        example: "'Pivot table'!A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "original_column",
        detail: "The name of the column in the original data set (not the pivot table).",
        example: '"division"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }, {
        name: "pivot_item",
        detail: "The name of the row or column shown in the pivot table corresponding to *original_column* that you want to retrieve.",
        example: '"east"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CHOOSE",
      t: 2,
      d: "Returns an element from a list of choices based on index.",
      a: "An element from a list of choices based on index.",
      m: [2, 255],
      p: [{
        name: "index",
        detail: "Which choice (of the up to 30 provided) to return.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "choice1",
        detail: "A potential value to return. Required. May be a reference to a cell or an individual value.",
        example: '"A"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "choice2",
        detail: "Additional values among which to choose.",
        example: '"B"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "HYPERLINK",
      t: 2,
      d: "Creates a hyperlink inside a cell.",
      a: "Creates a hyperlink inside a cell.",
      p: [{
        name: "url",
        detail: "The full URL of the link location enclosed in quotation marks, or a reference to a cell containing such a URL.",
        example: '"http://www.luckysheet.com/"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "link_label",
        detail: "The text to display in the cell as the link, enclosed in quotation marks, or a reference to a cell containing such a label.",
        example: '"luckysheet"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TIME",
      t: 6,
      d: "Converts a provided hour, minute, and second into a time.",
      a: "Converts hour/minute/second into a time.",
      m: [3, 3],
      p: [{
        name: "hour",
        detail: "The hour component of the time.",
        example: "11",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "minute",
        detail: "The minute component of the time.",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "second",
        detail: "The second component of the time.",
        example: "59",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TIMEVALUE",
      t: 6,
      d: "Returns the fraction of a 24-hour day the time represents.",
      a: "Converts a time string into its serial number representation.",
      m: [1, 1],
      p: [{
        name: "time_string",
        detail: "The string that holds the time representation.",
        example: '"2:15 PM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EOMONTH",
      t: 6,
      d: "Returns a date on the last day of a month that falls a specified number of months before or after another date.",
      a: "Last day of a month before or after a date.",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "The date from which to calculate the result.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "The number of months before (negative) or after (positive) 'start_date' to consider.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EDATE",
      t: 6,
      d: "Returns a date a specified number of months before or after another date.",
      a: "Date a number of months before/after another date.",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "The date from which to calculate the result.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "The number of months before (negative) or after (positive) 'start_date' to calculate.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SECOND",
      t: 6,
      d: "Returns the second component of a specific time, in numeric format.",
      a: "Second component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the second component",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINUTE",
      t: 6,
      d: "Returns the minute component of a specific time, in numeric format.",
      a: "Minute component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the minute component.",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HOUR",
      t: 6,
      d: "Returns the hour component of a specific time, in numeric format.",
      a: "Hour component of a specific time.",
      m: [1, 1],
      p: [{
        name: "time",
        detail: "The time from which to calculate the hour component.",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOW",
      t: 6,
      d: "Returns the current date and time as a date value.",
      a: "Current date and time as a date value.",
      m: [0, 0],
      p: []
    }, {
      n: "NETWORKDAYS",
      t: 6,
      d: "Returns the number of net working days between two provided days.",
      a: "Net working days between two provided days.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date of the period from which to calculate the number of net working days.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date of the period from which to calculate the number of net working days.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the date serial numbers to consider holidays.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NETWORKDAYS_INTL",
      t: 6,
      d: "Returns the number of net working days between two provided days excluding specified weekend days and holidays.",
      a: "Net working days between two dates (specifying weekends).",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "The start date of the period from which to calculate the number of net working days.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date of the period from which to calculate the number of net working days.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "weekend",
        detail: "A number or string representing which days of the week are considered weekends.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider as holidays.",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISOWEEKNUM",
      t: 6,
      d: "Returns a number representing the ISO week of the year where the provided date falls.",
      a: "ISO week number of the year.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date for which to determine the ISO week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WEEKNUM",
      t: 6,
      d: "Returns a number representing the week of the year where the provided date falls.",
      a: "Week number of the year.",
      m: [1, 2],
      p: [{
        name: "date",
        detail: "The date for which to determine the week number. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "type",
        detail: "A number representing the day that a week starts on. Sunday = 1.",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "WEEKDAY",
      t: 6,
      d: "Returns a number representing the day of the week of the date provided.",
      a: "Day of the week of the date provided (as number).",
      m: [1, 2],
      p: [{
        name: "date",
        detail: "The date for which to determine the day of the week. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "type",
        detail: "A number indicating which numbering system to use to represent weekdays. By default, counts starting with Sunday = 1.",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DAY",
      t: 6,
      d: "Returns the day of the month that a specific date falls on, in numeric format.",
      a: "Day of the month that a specific date falls on.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the day.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS",
      t: 6,
      d: "Returns the number of days between two dates.",
      a: "Number of days between two dates.",
      m: [2, 2],
      p: [{
        name: "end_date",
        detail: "The end of the date range.",
        example: "2011-3-15",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_date",
        detail: "The start of the date range.",
        example: "2011-2-1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS360",
      t: 6,
      d: "Returns the difference between two days based on the 360 day year used in some financial interest calculations.",
      a: "Days between two dates on a 360-day year.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "method",
        detail: "An indicator of what day count method to use.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATE",
      t: 6,
      d: "Converts a provided year, month, and day into a date.",
      a: "Converts year/month/day into a date.",
      m: [3, 3],
      p: [{
        name: "year",
        detail: "The year component of the date.",
        example: "1969",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "The month component of the date.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day",
        detail: "The day component of the date.",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATEVALUE",
      t: 6,
      d: "Converts a provided date string in a known format to a date value.",
      a: "Converts a date string to a date value.",
      m: [1, 1],
      p: [{
        name: "date_string",
        detail: "The string representing the date.",
        example: '"1969-7-20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATEDIF",
      t: 6,
      d: "Calculates the number of days, months, or years between two dates.",
      a: "Date Difference.",
      m: [3, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "unit",
        detail: 'A string abbreviation for unit of time. For example, "M" for month. Accepted values are "Y","M","D","MD","YM","YD".',
        example: "16)",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY",
      t: 6,
      d: "Calculates the date after a number of working days from a specified start date.",
      a: "Number of working days from start date.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The date from which to begin counting.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_days",
        detail: "The number of working days to advance from `start_date`. If negative, counts backwards.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider holidays.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY_INTL",
      t: 6,
      d: "Calculates the date after a specified number of workdays excluding specified weekend days and holidays.",
      a: "Date after a number of workdays (specifying weekends).",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "The date from which to begin counting.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_days",
        detail: "The number of working days to advance from `start_date`. If negative, counts backwards.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "weekend",
        detail: "A number or string representing which days of the week are considered weekends.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "A range or array constant containing the dates to consider holidays.",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEAR",
      t: 6,
      d: "Returns the year specified by a given date.",
      a: "Year specified by a given date.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the year.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEARFRAC",
      t: 6,
      d: "Returns the number of years, including fractional years, between two dates using a specified day count convention.",
      a: "Exact number of years between two dates.",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "The start date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "The end date to consider in the calculation. Must be a reference to a cell containing a date, a function returning a date type, or a number.",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TODAY",
      t: 6,
      d: "Returns the current date as a date value.",
      a: "Current date as a date value.",
      m: [0, 0],
      p: []
    }, {
      n: "MONTH",
      t: 6,
      d: "Returns the month of the year a specific date falls in, in numeric format.",
      a: "Month of the year a specific date falls in.",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "The date from which to extract the month.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EFFECT",
      t: 8,
      d: "Calculates the annual effective interest rate given the nominal rate and number of compounding periods per year.",
      a: "Annual effective interest rate.",
      m: [2, 2],
      p: [{
        name: "nominal_rate",
        detail: "The nominal interest rate per year.",
        example: "0.99",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "periods_per_year",
        detail: "The number of compounding periods per year.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLAR",
      t: 12,
      d: "Formats a number into the currency specific to your spreadsheet locale.",
      a: "Formats a number as currency specific to your spreadsheet locale.",
      m: [1, 2],
      p: [{
        name: "number",
        detail: "The value to be formatted.",
        example: "1.2351",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_places",
        detail: "The number of decimal places to display.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARDE",
      t: 8,
      d: "Converts a price quotation given as a decimal fraction into a decimal value.",
      a: "Converts a decimal fraction to decimal value.",
      m: [2, 2],
      p: [{
        name: "fractional_price",
        detail: "The price quotation given using fractional decimal conventions.",
        example: "100.10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "unit",
        detail: "The units of the fraction, e.g. `8` for 1/8ths or `32` for 1/32nds.",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARFR",
      t: 8,
      d: "Converts a price quotation given as a decimal value into a decimal fraction.",
      a: "Converts a decimal value to decimal fraction.",
      m: [2, 2],
      p: [{
        name: "decimal_price",
        detail: "The price quotation given as a decimal value.",
        example: "100.125",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "unit",
        detail: "The units of the desired fraction, e.g. `8` for 1/8ths or `32` for 1/32nds.",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DB",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the arithmetic declining balance method.",
      a: "Depreciation via declining balance method.",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "The number of months in the first year of depreciation.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DDB",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the double-declining balance method.",
      a: "Depreciation via double-declining balance method.",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "The factor by which depreciation decreases.",
        example: "2.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RATE",
      t: 8,
      d: "Calculates the interest rate of an annuity investment based on constant-amount periodic payments and the assumption of a constant interest rate.",
      a: "Interest rate of an annuity investment.",
      m: [3, 6],
      p: [{
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_per_period",
        detail: "The amount per period to be paid.",
        example: "-100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the interest rate will be.",
        example: "0.1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CUMPRINC",
      t: 8,
      d: "Calculates the cumulative principal paid over a range of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Cumulative principal paid over a set of periods.",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "first_period",
        detail: "The number of the payment period to begin the cumulative calculation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "last_period",
        detail: "The number of the payment period to end the cumulative calculation.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNUM",
      t: 8,
      d: "Calculates the number of coupons, or interest payments, between the settlement date and the maturity date of the investment.",
      a: "Number of coupons between settlement and maturity.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "02",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SYD",
      t: 8,
      d: "Calculates the depreciation of an asset for a specified period using the sum of years digits method.",
      a: "Depreciation via sum of years digits method.",
      m: [4, 4],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The single period within `life` for which to calculate depreciation.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLEQ",
      t: 8,
      d: "Calculates the equivalent annualized rate of return of a US Treasury Bill based on discount rate.",
      a: "Equivalent rate of return for a Treasury bill.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the bill at time of purchase.",
        example: "2)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLYIELD",
      t: 8,
      d: "Calculates the yield of a US Treasury Bill based on price.",
      a: "The yield of a us treasury bill based on price.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLPRICE",
      t: 8,
      d: "Calculates the price of a US Treasury Bill based on discount rate.",
      a: "Price of US treasury bill.",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the bill at time of purchase.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PV",
      t: 8,
      d: "Calculates the present value of an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Present value of an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount per period to be paid.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "D2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACCRINT",
      t: 8,
      d: "Calculates the accrued interest of a security that has periodic payments.",
      a: "Accrued interest of security with periodic payments.",
      m: [6, 8],
      p: [{
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "first_payment",
        detail: "The first date interest will be paid.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calc_method",
        detail: "[Optional-defaults to TRUE()] - A logical value that specifies the method used to calculate the total accrued interest when the settlement date is later than the first interest accrual date. \n\nIf the value is TRUE, the total accrued interest from the issue date to the settlement date is returned. \n\nIf the value is FALSE, return the accrued interest from the first interest accrual date to the settlement date.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ACCRINTM",
      t: 8,
      d: "Calculates the accrued interest of a security that pays interest at maturity.",
      a: "Accrued interest of security paying at maturity.",
      m: [4, 5],
      p: [{
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity date of the security.",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "1000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYBS",
      t: 8,
      d: "Calculates the number of days from the first coupon, or interest payment, until settlement.",
      a: "Number of days from first coupon to settlement.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYS",
      t: 8,
      d: "Calculates the number of days in the coupon, or interest payment, period that contains the specified settlement date.",
      a: "Days in coupon period containing settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYSNC",
      t: 8,
      d: "Calculates the number of days from the settlement date until the next coupon, or interest payment.",
      a: "Days from settlement until next coupon.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNCD",
      t: 8,
      d: "Calculates next coupon, or interest payment, date after the settlement date.",
      a: "Next coupon date after the settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPPCD",
      t: 8,
      d: "Calculates last coupon, or interest payment, date before the settlement date.",
      a: "Last coupon date before settlement date.",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FV",
      t: 8,
      d: "Calculates the future value of an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Future value of an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount per period to be paid.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FVSCHEDULE",
      t: 8,
      d: "Calculates the future value of some principal based on a specified series of potentially varying interest rates.",
      a: "Future value of principal from series of rates.",
      m: [2, 2],
      p: [{
        name: "principal",
        detail: "The amount of initial capital or value to compound against.",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "rate_schedule",
        detail: "A series of interest rates to compound against the `principal`.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "YIELD",
      t: 8,
      d: "Calculates the annual yield of a security paying periodic interest, such as a US Treasury Bond, based on price.",
      a: "Annual yield of a security paying periodic interest.",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "YIELDDISC",
      t: 8,
      d: "Calculates the annual yield of a discount (non-interest-bearing) security, based on price.",
      a: "Annual yield of a discount security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NOMINAL",
      t: 8,
      d: "Calculates the annual nominal interest rate given the effective rate and number of compounding periods per year.",
      a: "Annual nominal interest rate.",
      m: [2, 2],
      p: [{
        name: "effective_rate",
        detail: "The effective interest rate per year.",
        example: "0.85",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "periods_per_year",
        detail: "The number of compounding periods per year.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "XIRR",
      t: 8,
      d: "Calculates the internal rate of return of an investment based on a specified series of potentially irregularly spaced cash flows.",
      a: "Internal rate of return given non-periodic cashflows.",
      m: [2, 3],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "cashflow_dates",
        detail: "An array or range with dates corresponding to the cash flows in `cashflow_amounts`.",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the internal rate of return will be.",
        example: "250",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MIRR",
      t: 8,
      d: "Calculates the modified internal rate of return on an investment based on a series of periodic cash flows and the difference between the interest rate paid on financing versus the return received on reinvested income.",
      a: "Modified internal rate of return.",
      m: [3, 3],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "financing_rate",
        detail: "The interest rate paid on funds invested.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "reinvestment_return_rate",
        detail: "The return (as a percentage) earned on reinvestment of income received from the investment.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IRR",
      t: 8,
      d: "Calculates the internal rate of return on an investment based on a series of periodic cash flows.",
      a: "Internal rate of return given periodic cashflows.",
      m: [1, 2],
      p: [{
        name: "cashflow_amounts",
        detail: "An array or range containing the income or payments associated with the investment.",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rate_guess",
        detail: "An estimate for what the internal rate of return will be.",
        example: "200",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPV",
      t: 8,
      d: "Calculates the net present value of an investment based on a series of periodic cash flows and a discount rate.",
      a: "The net present value of an investment based on a series of periodic cash flows and a discount rate.",
      m: [2, 255],
      p: [{
        name: "discount",
        detail: "The discount rate of the investment over one period.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cashflow1",
        detail: "The first future cash flow.",
        example: "200",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "cashflow2",
        detail: "Additional future cash flows.",
        example: "250",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "XNPV",
      t: 8,
      d: "Calculates the net present value of an investment based on a specified series of potentially irregularly spaced cash flows and a discount rate.",
      a: "Net present value given non-periodic cashflows.",
      m: [3, 3],
      p: [{
        name: "discount",
        detail: "The discount rate of the investment over one period.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cashflow_amounts",
        detail: "A range of cells containing the income or payments associated with the investment.",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "cashflow_dates",
        detail: "A range of cells with dates corresponding to the cash flows in `cashflow_amounts`.",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CUMIPMT",
      t: 8,
      d: "Calculates the cumulative interest over a range of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Cumulative interest paid over a set of periods.",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "first_period",
        detail: "The number of the payment period to begin the cumulative calculation.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "last_period",
        detail: "The number of the payment period to end the cumulative calculation.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PMT",
      t: 8,
      d: "Calculates the periodic payment for an annuity investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Periodic payment for an annuity investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: " 100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "D2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IPMT",
      t: 8,
      d: "Calculates the payment on interest for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Payment on interest for an investment.",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The amortization period, in terms of number of periods.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "80000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "E2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PPMT",
      t: 8,
      d: "Calculates the payment on the principal of an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Payment on the principal of an investment.",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "The amortization period, in terms of number of periods.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_periods",
        detail: "The number of payments to be made.",
        example: "3*12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INTRATE",
      t: 8,
      d: "Calculates the effective interest rate generated when an investment is purchased at one price and sold at another with no interest or dividends generated by the investment itself.",
      a: "Calculates effective interest rate.",
      m: [4, 5],
      p: [{
        name: "buy_date",
        detail: "The date of purchase of the investment.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sell_date",
        detail: "The date of sale of the investment.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "buy_price",
        detail: "The price at which the investment was purchased.",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sell_price",
        detail: "The price at which the investment was sold.",
        example: "101200",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICE",
      t: 8,
      d: "Calculates the price of a security paying periodic interest, such as a US Treasury Bond, based on expected yield.",
      a: "Price of a security paying periodic interest.",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.065",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEDISC",
      t: 8,
      d: "Calculates the price of a discount (non-interest-bearing) security, based on expected yield.",
      a: "Price of a discount security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "The discount rate of the security at time of purchase.",
        example: "0.0525",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEMAT",
      t: 8,
      d: "Calculates the price of a security paying interest at maturity, based on expected yield.",
      a: "Price of security paying interest at maturity.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "issue",
        detail: "The date the security was initially issued.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RECEIVED",
      t: 8,
      d: "Calculates the amount received at maturity for an investment in fixed-income securities purchased on a given date.",
      a: "Amount received at maturity for a security.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "The amount invested (irrespective of face value of each security).",
        example: "10000000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "discount",
        detail: "The discount rate of the security invested in.",
        example: "0.0575",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DISC",
      t: 8,
      d: "Calculates the discount rate of a security based on price.",
      a: "The discount rate of a security based on price.",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "price",
        detail: "The price at which the security is bought per 100 face value.",
        example: "97.975",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "The redemption amount per 100 face value, or par.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPER",
      t: 8,
      d: "Calculates the number of payment periods for an investment based on constant-amount periodic payments and a constant interest rate.",
      a: "Number of payment periods for an investment.",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "The interest rate.",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "payment_amount",
        detail: "The amount of each payment made.",
        example: "500",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "present_value",
        detail: "The current value of the annuity.",
        example: "40000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "future_value",
        detail: "The future value remaining after the final payment has been made.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_or_beginning",
        detail: "Whether payments are due at the end (`0`) or beginning (`1`) of each period.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLN",
      t: 8,
      d: "Calculates the depreciation of an asset for one period using the straight-line method.",
      a: "Depreciation of asset using the straight-line method.",
      m: [3, 3],
      p: [{
        name: "cost",
        detail: "The initial cost of the asset.",
        example: "300000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "The value of the asset at the end of depreciation.",
        example: "75000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "The number of periods over which the asset is depreciated.",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DURATION",
      t: 8,
      d: "Calculates the number of compounding periods required for an investment of a specified present value appreciating at a given rate to reach a target value.",
      a: "Number of periods for an investment to reach a value.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MDURATION",
      t: 8,
      d: "Calculates the modified Macaulay duration of a security paying periodic interest, such as a US Treasury Bond, based on expected yield.",
      a: "Modified Macaulay duration.",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "The settlement date of the security, the date after issuance when the security is delivered to the buyer.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "The maturity or end date of the security, when it can be redeemed at face, or par value.",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "The annualized rate of interest.",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yield",
        detail: "The expected annual yield of the security.",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "The number of interest or coupon payments per year (1, 2, or 4).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day_count_convention",
        detail: "An indicator of what day count method to use.",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2DEC",
      t: 9,
      d: "Converts a signed binary number to decimal format.",
      a: "Converts a signed binary number to decimal format.",
      m: [1, 1],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to decimal, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIN2HEX",
      t: 9,
      d: "Converts a signed binary number to signed hexadecimal format.",
      a: "Converts a binary number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to signed hexademical, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2OCT",
      t: 9,
      d: "Converts a signed binary number to signed octal format.",
      a: "Converts a binary number to octal.",
      m: [1, 2],
      p: [{
        name: "signed_binary_number",
        detail: "The signed 10-bit binary value to be converted to signed octal, provided as a string.",
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2BIN",
      t: 9,
      d: "Converts a decimal number to signed binary format.",
      a: "Converts a decimal number to signed binary format.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed binary, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2HEX",
      t: 9,
      d: "Converts a decimal number to signed hexadecimal format.",
      a: "Converts a decimal number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed hexadecimal, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2OCT",
      t: 9,
      d: "Converts a decimal number to signed octal format.",
      a: "Converts a decimal number to signed octal format.",
      m: [1, 2],
      p: [{
        name: "decimal_number",
        detail: "The decimal value to be converted to signed octal, provided as a string.",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2BIN",
      t: 9,
      d: "Converts a signed hexadecimal number to signed binary format.",
      a: "Converts a hexadecimal number to binary.",
      m: [1, 2],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to signed binary, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2DEC",
      t: 9,
      d: "Converts a signed hexadecimal number to decimal format.",
      a: "Converts a hexadecimal number to decimal.",
      m: [1, 1],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to decimal, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HEX2OCT",
      t: 9,
      d: "Converts a signed hexadecimal number to signed octal format.",
      a: "Converts a hexadecimal number to octal.",
      m: [1, 2],
      p: [{
        name: "signed_hexadecimal_number",
        detail: "The signed 40-bit hexadecimal value to be converted to signed octal, provided as a string.",
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2BIN",
      t: 9,
      d: "Converts a signed octal number to signed binary format.",
      a: "Converts an octal number to binary.",
      m: [1, 2],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to signed binary, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2DEC",
      t: 9,
      d: "Converts a signed octal number to decimal format.",
      a: "Converts a signed octal number to decimal format.",
      m: [1, 1],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to decimal, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OCT2HEX",
      t: 9,
      d: "Converts a signed octal number to signed hexadecimal format.",
      a: "Converts an octal number to hexadecimal.",
      m: [1, 2],
      p: [{
        name: "signed_octal_number",
        detail: "The signed 30-bit octal value to be converted to signed hexadecimal, provided as a string.",
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "significant_digits",
        detail: "The number of significant digits to ensure in the result.",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COMPLEX",
      t: 9,
      d: "Creates a complex number given real and imaginary coefficients.",
      a: "Creates a complex number.",
      m: [2, 3],
      p: [{
        name: "real_part",
        detail: "The real coefficient.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "imaginary_part",
        detail: "The imaginary coefficient.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suffix",
        detail: "The suffix for the imaginary coefficient, can only be 'i' or 'j'. If omitted, 'i' will be used.",
        example: '"j"',
        require: "o",
        repeat: "n",
        type: "rangestring"
      }]
    }, {
      n: "IMREAL",
      t: 9,
      d: "Returns the real coefficient of a complex number.",
      a: "The real coefficient of a complex number.",
      m: [1, 1],
      p: [{
        name: "complex_number",
        detail: "The complex number, in the a+bi or a+bj format.",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMAGINARY",
      t: 9,
      d: "Returns the imaginary coefficient of a complex number.",
      a: "The imaginary coefficient of a complex number.",
      m: [1, 1],
      p: [{
        name: "complex_number",
        detail: "The complex number, in the a+bi or a+bj format.",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMCONJUGATE",
      t: 9,
      d: "Returns the complex conjugate of a number.",
      a: "The complex conjugate of a number.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The complex number to calculate the conjugate for.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMABS",
      t: 9,
      d: "Returns absolute value (or modulus) of a complex number.",
      a: "The absolute value of a complex number.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The complex number to calculate the absolute value of.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DELTA",
      t: 9,
      d: "Compare two numeric values, returning 1 if they're equal.",
      a: "Compare two numeric values.",
      m: [1, 2],
      p: [{
        name: "number1",
        detail: "The first number to compare.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number2",
        detail: "The second number to compare.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IMSUM",
      t: 9,
      d: "Returns the sum of a series of complex numbers.",
      a: "Sum of a series of complex numbers.",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "The first complex number or range to add together.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "Additional complex numbers or ranges to add to `value1`.",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMSUB",
      t: 9,
      d: "Returns the difference between two complex numbers.",
      a: "The difference between two complex numbers.",
      m: [2, 2],
      p: [{
        name: "first_number",
        detail: "The complex number to subtract second_number from.",
        example: '"6+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "second_number",
        detail: "The complex number to subtract from first_number.",
        example: '"2+3i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMPRODUCT",
      t: 9,
      d: "Returns the result of multiplying a series of complex numbers together.",
      a: "Result of multiplying a series of complex numbers together.",
      m: [1, 255],
      p: [{
        name: "factor1",
        detail: "The first number or range to calculate for the product.",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "factor2",
        detail: "Additional complex numbers or ranges to calculate for the product.",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMDIV",
      t: 9,
      d: "Returns one complex number divided by another.",
      a: "One complex number divided by another.",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The complex number to be divided.",
        example: '"11+16i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "divisor",
        detail: "The complex number to divide by.",
        example: '"3+2i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOT",
      t: 10,
      d: "Returns the opposite of a logical value - `NOT(TRUE)` returns `FALSE`; `NOT(FALSE)` returns `TRUE`.",
      a: "Returns opposite of provided logical value.",
      m: [1, 1],
      p: [{
        name: "logical_expression",
        detail: "An expression or reference to a cell holding an expression that represents some logical value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRUE",
      t: 10,
      d: "Returns the logical value `TRUE`.",
      a: "Logical value `true`.",
      m: [0, 0],
      p: []
    }, {
      n: "FALSE",
      t: 10,
      d: "Returns the logical value `FALSE`.",
      a: "Logical value `false`.",
      m: [0, 0],
      p: []
    }, {
      n: "AND",
      t: 10,
      d: "Returns true if all of the provided arguments are logically true, and false if any of the provided arguments are logically false.",
      a: "Logical `and` operator.",
      m: [1, 255],
      p: [{
        name: "logical_expression1",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`, or an expression that can be coerced to a logical value.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical_expression2",
        detail: "More expressions that represent logical values.",
        example: 'A3 = "bar"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IFERROR",
      t: 10,
      d: "Returns the first argument if it is not an error value, otherwise returns the second argument if present, or a blank if the second argument is absent.",
      a: "Value if it is not an error, otherwise 2nd argument.",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "The value to return if `value` itself is not an error.",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_error",
        detail: "The value the function returns if `value` is an error.",
        example: '"Error in cell A1"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IF",
      t: 10,
      d: "Returns one value if a logical expression is `TRUE` and another if it is `FALSE`.",
      a: "Returns value depending on logical expression.",
      m: [2, 3],
      p: [{
        name: "logical_expression",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_true",
        detail: "The value the function returns if `logical_expression` is `TRUE`.",
        example: '"A2 is foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_false",
        detail: "The value the function returns if `logical_expression` is `FALSE`.",
        example: '"A2 was false"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OR",
      t: 10,
      d: "Returns true if any of the provided arguments are logically true, and false if all of the provided arguments are logically false.",
      a: "Logical `or` operator.",
      m: [1, 255],
      p: [{
        name: "logical_expression1",
        detail: "An expression or reference to a cell containing an expression that represents some logical value, i.e. `TRUE` or `FALSE`, or an expression that can be coerced to a logical value.",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical_expression2",
        detail: "More expressions that evaluate to logical values.",
        example: ' A3 = "bar"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NE",
      t: 11,
      d: "Returns `TRUE` if two specified values are not equal and `FALSE` otherwise. Equivalent to the `!=` operator.",
      a: "Not equal.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to test against `value1` for inequality.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EQ",
      t: 11,
      d: "Returns `TRUE` if two specified values are equal and `FALSE` otherwise. Equivalent to the `==` operator.",
      a: "Equal.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to test against `value1` for equality.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GT",
      t: 11,
      d: "Returns `TRUE` if the first argument is strictly greater than the second, and `FALSE` otherwise. Equivalent to the `>` operator.",
      a: "Strictly greater than.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being greater than `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GTE",
      t: 11,
      d: "Returns `TRUE` if the first argument is greater than or equal to the second, and `FALSE` otherwise. Equivalent to the `>=` operator.",
      a: "Greater than or equal to.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being greater than or equal to `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LT",
      t: 11,
      d: "Returns `TRUE` if the first argument is strictly less than the second, and `FALSE` otherwise. Equivalent to the `<` operator.",
      a: "Less than.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being less than `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LTE",
      t: 11,
      d: "Returns `TRUE` if the first argument is less than or equal to the second, and `FALSE` otherwise. Equivalent to the `<=` operator.",
      a: "Less than or equal to.",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to test as being less than or equal to `value2`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The second value.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADD",
      t: 11,
      d: "Returns the sum of two numbers. Equivalent to the `+` operator.",
      a: "Sum of two numbers",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The first addend.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "The second addend.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINUS",
      t: 11,
      d: "Returns the difference of two numbers. Equivalent to the `-` operator.",
      a: "Difference of two numbers",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The minuend, or number to be subtracted from.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "The subtrahend, or number to subtract from `value1`.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTIPLY",
      t: 11,
      d: "Returns the product of two numbers. Equivalent to the `*` operator.",
      a: "Product of two numbers",
      m: [2, 2],
      p: [{
        name: "factor1",
        detail: "The first multiplicand.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor2",
        detail: "The second multiplicand.",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DIVIDE",
      t: 11,
      d: "Returns one number divided by another. Equivalent to the `/` operator.",
      a: "One number divided by another",
      m: [2, 2],
      p: [{
        name: "dividend",
        detail: "The number to be divided.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "divisor",
        detail: "The number to divide by.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCAT",
      t: 11,
      d: "Returns the concatenation of two values. Equivalent to the `&` operator.",
      a: "Concatenation of two values",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "The value to which `value2` will be appended.",
        example: '"de"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "The value to append to `value1`.",
        example: '"mystify"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNARY_PERCENT",
      t: 11,
      d: "Returns a value interpreted as a percentage; that is, `UNARY_PERCENT(100)` equals `1`.",
      a: "Value interpreted as a percentage.",
      m: [1, 1],
      p: [{
        name: "percentage",
        detail: "The value to interpret as a percentage.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCATENATE",
      t: 12,
      d: "Appends strings to one another.",
      a: "Appends strings to one another.",
      m: [1, 255],
      p: [{
        name: "string1",
        detail: "The initial string.",
        example: '"Super"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "string2",
        detail: "More strings to append in sequence.",
        example: '"calla"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CODE",
      t: 12,
      d: "Returns the numeric Unicode map value of the first character in the string provided.",
      a: "Numeric unicode map value of character.",
      m: [1, 1],
      p: [{
        name: "string",
        detail: "The string whose first character's Unicode map value will be returned.",
        example: '"a"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CHAR",
      t: 12,
      d: "Convert a number into a character according to the current Unicode table.",
      a: "Gets character associated with number.",
      m: [1, 1],
      p: [{
        name: "table_number",
        detail: "The number of the character to look up from the current Unicode table in decimal format.",
        example: "97",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ARABIC",
      t: 12,
      d: "Computes the value of a Roman numeral.",
      a: "Computes the value of a roman numeral.",
      m: [1, 1],
      p: [{
        name: "roman_numeral",
        detail: "The Roman numeral to format, whose value must be between 1 and 3999, inclusive.",
        example: '"XIV"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROMAN",
      t: 12,
      d: "Formats a number in Roman numerals.",
      a: "Formats a number in Roman numerals.",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "The number to format, between 1 and 3999, inclusive.",
        example: "499",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "REGEXEXTRACT",
      t: 12,
      d: "Extracts matching substrings according to a regular expression.",
      a: "Extracts matching substrings with regular expression.",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "The input text.",
        example: '"Needle in a haystack"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The first part of `text` that matches this expression will be returned.",
        example: '".e{2}dle"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXMATCH",
      t: 12,
      d: "Whether a piece of text matches a regular expression.",
      a: "Whether a piece of text matches regular expression.",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "The text to be tested against the regular expression.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The regular expression to test the text against.",
        example: '"S.r"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXREPLACE",
      t: 12,
      d: "Replaces part of a text string with a different text string using regular expressions.",
      a: "Replaces text with regular expressions.",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "The text, a part of which will be replaced.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "The regular expression.  All matching instances in `text` will be replaced.",
        example: '"S.*d"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replacement",
        detail: "The text which will be inserted into the original text.",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T",
      t: 12,
      d: "Returns string arguments as text, or the empty string if the value is not text.",
      a: "String arguments as text.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument to be converted to text.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIXED",
      t: 12,
      d: "Formats a number with a fixed number of decimal places.",
      a: "Formats number with fixed number of decimal places.",
      m: [1, 3],
      p: [{
        name: "number",
        detail: "The number to format.",
        example: "3.141592653",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_of_places",
        detail: "The number of decimal places to display in the result.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suppress_separator",
        detail: "Whether or not to suppress the thousands separator used in some locales (e.g. `1,000` becomes `1000`). Separators will be present if this value is 0 or omitted, and absent otherwise.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIND",
      t: 12,
      d: "Returns the position at which a string is first found within text where the capitalization of letters matters. Returns `#VALUE!` if the string is not found.",
      a: "First position of string found in text, case-sensitive.",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "14",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FINDB",
      t: 12,
      d: "Returns the position at which a string is first found within text counting each double-character as 2.",
      a: "Position at which a string is first found within text (binary).",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"new"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: '"new year"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "JOIN",
      t: 12,
      d: "Concatenates the elements of one or more one-dimensional arrays using a specified delimiter.",
      a: "Concatenates elements of arrays with delimiter.",
      m: [2, 255],
      p: [{
        name: "delimiter",
        detail: "The character or string to place between each concatenated value.",
        example: '" and-a "',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_or_array1",
        detail: "The value or values to be appended using `delimiter`.",
        example: "{1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_or_array2",
        detail: "More values to be appended using `delimiter`.",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LEFT",
      t: 12,
      d: "Returns a substring from the beginning of a specified string.",
      a: "Substring from beginning of specified string.",
      m: [1, 2],
      p: [{
        name: "string",
        detail: "The string from which the left portion will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_characters",
        detail: "The number of characters to return from the left side of `string`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RIGHT",
      t: 12,
      d: "Returns a substring from the end of a specified string.",
      a: "A substring from the end of a specified string.",
      m: [1, 2],
      p: [{
        name: "string",
        detail: "The string from which the right portion will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_characters",
        detail: "The number of characters to return from the right side of `string`.",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MID",
      t: 12,
      d: "Returns a segment of a string.",
      a: "A segment of a string.",
      m: [3, 3],
      p: [{
        name: "string",
        detail: "The string to extract a segment from.",
        example: '"get this"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The index from the left of `string` from which to begin extracting. The first character in `string` has the index 1.",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "extract_length",
        detail: "The length of the segment to extract.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LEN",
      t: 12,
      d: "Returns the length of a string.",
      a: "Length of a string.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string whose length will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LENB",
      t: 12,
      d: "Returns the length of a string in bytes.",
      a: "Length of a string in bytes.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string whose length will be returned.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOWER",
      t: 12,
      d: "Converts a specified string to lowercase.",
      a: "Converts a specified string to lowercase.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string to convert to lowercase.",
        example: '"LOREM IPSUM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UPPER",
      t: 12,
      d: "Converts a specified string to uppercase.",
      a: "Converts a specified string to uppercase.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string to convert to uppercase.",
        example: '"lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EXACT",
      t: 12,
      d: "Tests whether two strings are identical.",
      a: "Tests whether two strings are identical.",
      m: [2, 2],
      p: [{
        name: "string1",
        detail: "The first string to compare",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "string2",
        detail: "The second string to compare",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPLACE",
      t: 12,
      d: "Replaces part of a text string with a different text string.",
      a: "Replaces part of a text string with different text.",
      m: [4, 4],
      p: [{
        name: "text",
        detail: "The text, a part of which will be replaced.",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "position",
        detail: "The position where the replacement will begin (starting from 1).",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "length",
        detail: "The number of characters in the text to be replaced.",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_text",
        detail: "The text which will be inserted into the original text.",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPT",
      t: 12,
      d: "Returns specified text repeated a number of times.",
      a: "Specified text repeated a number of times.",
      m: [2, 2],
      p: [{
        name: "text_to_repeat",
        detail: "The character or string to repeat.",
        example: '"ha"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_of_repetitions",
        detail: "The number of times `text_to_repeat` should appear in the value returned.",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEARCH",
      t: 12,
      d: "Returns the position at which a string is first found within text and ignores capitalization of letters. Returns `#VALUE!` if the string is not found.",
      a: "First position of string found in text, ignoring case.",
      m: [2, 3],
      p: [{
        name: "search_for",
        detail: "The string to look for within `text_to_search`.",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text_to_search",
        detail: "The text to search for the first occurrence of `search_for`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "starting_at",
        detail: "The character within `text_to_search` at which to start the search.",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUBSTITUTE",
      t: 12,
      d: "Replaces existing text with new text in a string.",
      a: "Replaces existing text with new text in a string.",
      m: [3, 4],
      p: [{
        name: "text_to_search",
        detail: "The text within which to search and replace.",
        example: '"search for it"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "search_for",
        detail: "The string to search for within `text_to_search`.",
        example: '"search for"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replace_with",
        detail: "The string that will replace `search_for`.",
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurrence_number",
        detail: "The instance of `search_for` within `text_to_search` to replace with `replace_with`. By default, all occurrences of `search_for` are replaced; however, if `occurrence_number` is specified, only the indicated instance of `search_for` is replaced.",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CLEAN",
      t: 12,
      d: "Returns the text with the non-printable ASCII characters removed.",
      a: "Removes non-printable characters from a piece of text.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The text whose non-printable characters are to be removed.",
        example: '"AF"&CHAR(31)',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TEXT",
      t: 12,
      d: "Converts a number into text according to a specified format.",
      a: "Formats a number into text.",
      m: [2, 2],
      p: [{
        name: "number",
        detail: "The number, date, or time to format.",
        example: "1.23",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "format",
        detail: "The pattern by which to format the number, enclosed in quotation marks.",
        example: '"$0.00"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRIM",
      t: 12,
      d: "Removes leading, trailing, and repeated spaces in text.",
      a: "Removes space characters.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The text or reference to a cell containing text to be trimmed.",
        example: '" lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "VALUE",
      t: 12,
      d: "Converts a string in any of the date, time or number formats that Google Sheets understands into a number.",
      a: "Converts a date/time/number string into a number.",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "The string containing the value to be converted.",
        example: '"123"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROPER",
      t: 12,
      d: "Capitalizes each word in a specified string.",
      a: "Capitalizes each word in a specified string.",
      m: [1, 1],
      p: [{
        name: "text_to_capitalize",
        detail: "The text which will be returned with the first letter of each word in uppercase and all other letters in lowercase.",
        example: '"united states"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CONVERT",
      t: 13,
      d: "Converts a numeric value to a different unit of measure.",
      a: "Unit conversion for numbers.",
      m: [3, 3],
      p: [{
        name: "value",
        detail: "The numeric value in `start_unit` to convert to `end_unit`.",
        example: "5.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_unit",
        detail: "The starting unit, the unit currently assigned to `value`.",
        example: '"g"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_unit",
        detail: "The unit of measure into which to convert the argument, `value`.",
        example: '"kg"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "SUMX2MY2",
      t: 14,
      d: "Calculates the sum of the differences of the squares of values in two arrays.",
      a: "Sum of the differences of squares.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values whose squares will be reduced by the squares of corresponding entries in `array_y` and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values whose squares will be subtracted from the squares of corresponding entries in `array_x` and added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMX2PY2",
      t: 14,
      d: "Calculates the sum of the sums of the squares of values in two arrays.",
      a: "Sum of the sums of squares.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values whose squares will be added to the squares of corresponding entries in `array_y` and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values whose squares will be added to the squares of corresponding entries in `array_x` and added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMXMY2",
      t: 14,
      d: "Calculates the sum of the squares of differences of values in two arrays.",
      a: "Sum of the squares of differences.",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "The array or range of values that will be reduced by corresponding entries in `array_y`, squared, and added together.",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "The array or range of values that will be subtracted from corresponding entries in `array_x`, the result squared, and all such results added together.",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRANSPOSE",
      t: 14,
      d: "Transposes the rows and columns of an array or range of cells.",
      a: "Transposes the rows and columns of an array.",
      m: [1, 1],
      p: [{
        name: "array_or_range",
        detail: "The array or range whose rows and columns will be swapped.",
        example: "{1,2}",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TREND",
      t: 14,
      d: "Given partial data about a linear trend, fits an ideal linear trend using the least squares method and/or predicts further values.",
      a: "Fits points to linear trend derived via least-squares.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal linear trend.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_data_x",
        detail: "The data points to return the `y` values for on the ideal curve fit.",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general linear form of `y = m*x+b` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `0` and only calculates the `m` values if `FALSE`, i.e. forces the curve fit to pass through the origin.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FREQUENCY",
      t: 14,
      d: "Calculates the frequency distribution of a one-column array into specified classes.",
      a: "The frequency distribution of array.",
      m: [2, 2],
      p: [{
        name: "data",
        detail: "The array or range containing the values to be counted.",
        example: "A2:A40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "classes",
        detail: "The array or range containing the set of classes.",
        example: "B2:B5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GROWTH",
      t: 14,
      d: "Given partial data about an exponential growth trend, fits an ideal exponential growth trend and/or predicts further values.",
      a: "Fits points to exponential growth trend.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal exponential growth curve.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_data_x",
        detail: "The data points to return the `y` values for on the ideal curve fit.",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general exponential form of `y = b*m^x` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `1` and only calculates the `m` values if `FALSE`.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINEST",
      t: 14,
      d: "Given partial data about a linear trend, calculates various parameters about the ideal linear trend using the least-squares method.",
      a: "Best-fit linear trend via least-squares.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal linear trend.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calculate_b",
        detail: "Given a linear form of `y = m*x+b`, calculates the y-intercept (`b`) if `TRUE`. Otherwise, forces `b` to be `0` and only calculates the `m` values if `FALSE`, i.e. forces the curve fit to pass through the origin.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "verbose",
        detail: "A flag specifying whether to return additional regression statistics or only the linear coefficients and the y-intercept (default).",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOGEST",
      t: 14,
      d: "Given partial data about an exponential growth curve, calculates various parameters about the best fit ideal exponential growth curve.",
      a: "Best-fit exponential growth curve.",
      m: [1, 4],
      p: [{
        name: "known_data_y",
        detail: "The array or range containing dependent (y) values that are already known, used to curve fit an ideal exponential growth curve.",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_data_x",
        detail: "The values of the independent variable(s) corresponding with `known_data_y`.",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "b",
        detail: "Given a general exponential form of `y = b*m^x` for a curve fit, calculates `b` if `TRUE` or forces `b` to be `1` and only calculates the `m` values if `FALSE`.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "verbose",
        detail: "A flag specifying whether to return additional regression statistics or only the calculated coefficient and exponents.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MDETERM",
      t: 14,
      d: "Returns the matrix determinant of a square matrix specified as an array or range.",
      a: "Matrix determinant of a square matrix.",
      m: [1, 1],
      p: [{
        name: "square_matrix",
        detail: "An array or range with an equal number of rows and columns representing a matrix whose determinant will be calculated.",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINVERSE",
      t: 14,
      d: "Returns the multiplicative inverse of a square matrix specified as an array or range.",
      a: "Multiplicative inverse of square matrix.",
      m: [1, 1],
      p: [{
        name: "square_matrix",
        detail: "An array or range with an equal number of rows and columns representing a matrix whose multiplicative inverse will be calculated.",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MMULT",
      t: 14,
      d: "Calculates the matrix product of two matrices specified as arrays or ranges.",
      a: "The matrix product of two matrices.",
      m: [2, 2],
      p: [{
        name: "matrix1",
        detail: "The first matrix in the matrix multiplication operation, represented as an array or range.",
        example: "A1:B3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "matrix2",
        detail: "The second matrix in the matrix multiplication operation, represented as an array or range.",
        example: "C1:F2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMPRODUCT",
      t: 14,
      d: "Calculates the sum of the products of corresponding entries in two equal-sized arrays or ranges.",
      a: "Sum of products of elements in two arrays.",
      m: [1, 255],
      p: [{
        name: "array1",
        detail: "The first array or range whose entries will be multiplied with corresponding entries in the second such array or range.",
        example: "A2:C5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "The second array or range whose entries will be multiplied with corresponding entries in the first such array or range.",
        example: "D2:F5",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "ISFORMULA",
      t: 15,
      d: "Checks whether a value is a formula.",
      a: "Whether a value is a formula.",
      m: [1, 1],
      p: [{
        name: "cell",
        detail: "The cell to be verified as containing a formula.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CELL",
      t: 15,
      d: "Returns the requested information about the specified cell.",
      a: "Gets information about a cell.",
      m: [2, 2],
      p: [{
        name: "info_type",
        detail: "The type of information requested (see article for available types)",
        example: '"type"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "reference",
        detail: "The reference to the cell.",
        example: "C2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "NA",
      t: 15,
      d: 'Returns the "value not available" error, `#N/A`.',
      a: "The `#N/A` error.",
      m: [0, 0],
      p: []
    }, {
      n: "ERROR_TYPE",
      t: 15,
      d: "Returns a number corresponding to the error value in a different cell.",
      a: "Error value of cell (as number).",
      m: [1, 1],
      p: [{
        name: "reference",
        detail: "The cell to find the error number for although you can also provide the error value directly.",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISBLANK",
      t: 15,
      d: "Checks whether the referenced cell is empty.",
      a: "Whether the referenced cell is empty.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "Reference to the cell that will be checked for emptiness.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISERR",
      t: 15,
      d: "Checks whether a value is an error other than `#N/A`.",
      a: "Whether a value is an error other than `#n/a`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as an error type other than `#N/A`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISERROR",
      t: 15,
      d: "Checks whether a value is an error.",
      a: "Whether a value is an error.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as an error type.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISLOGICAL",
      t: 15,
      d: "Checks whether a value is `TRUE` or `FALSE`.",
      a: "Whether a value is `true` or `false`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a logical `TRUE` or `FALSE`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNA",
      t: 15,
      d: "Checks whether a value is the error `#N/A`.",
      a: "Whether a value is the error `#n/a`.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be compared with the error value `#N/A`.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNONTEXT",
      t: 15,
      d: "Checks whether a value is non-textual.",
      a: "Whether a value is non-textual.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be checked.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNUMBER",
      t: 15,
      d: "Checks whether a value is a number.",
      a: "Whether a value is a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a number.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISREF",
      t: 15,
      d: "Checks whether a value is a valid cell reference.",
      a: "Whether a value is a valid cell reference.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as a cell reference.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISTEXT",
      t: 15,
      d: "Checks whether a value is text.",
      a: "Whether a value is text.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value to be verified as text.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TYPE",
      t: 15,
      d: "Returns a number associated with the type of data passed into the function.",
      a: "Get the type of a value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The value whose type is to be determined.",
        example: "C4",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "N",
      t: 15,
      d: "Returns the argument provided as a number. Text is converted to 0 and errors are returned as-is.",
      a: "Argument provided as a number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument to be converted to a number.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DATE",
      t: 16,
      d: "Converts a provided number to a date.",
      a: "Converts a provided number to a date.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a date.",
        example: "25405",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PURE_NUMBER",
      t: 16,
      d: "Converts a provided date/time, percentage, currency or other formatted numeric value to a pure number without formatting.",
      a: "Converts any numeric value to a pure number.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a pure number.",
        example: "50%",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_TEXT",
      t: 16,
      d: "Converts a provided numeric value to a text value.",
      a: "Converts a provided numeric value to a text value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to text.",
        example: "24",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DOLLARS",
      t: 16,
      d: "Converts a provided number to a dollar value.",
      a: "Converts a provided number to a dollar value.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a dollar value.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PERCENT",
      t: 16,
      d: "Converts a provided number to a percentage.",
      a: "Converts a provided number to a percentage.",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "The argument or reference to a cell to be converted to a percentage.",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DGET",
      t: 17,
      d: "Returns a single value from a database table-like array or range using a SQL-like query.",
      a: "Single value from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMAX",
      t: 17,
      d: "Returns the maximum value selected from a database table-like array or range using a SQL-like query.",
      a: "Maximum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMIN",
      t: 17,
      d: "Returns the minimum value selected from a database table-like array or range using a SQL-like query.",
      a: "Minimum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DAVERAGE",
      t: 17,
      d: "Returns the average of a set of values selected from a database table-like array or range using a SQL-like query.",
      a: "Average of a set of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNT",
      t: 17,
      d: "Counts numeric values selected from a database table-like array or range using a SQL-like query.",
      a: "Counts values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNTA",
      t: 17,
      d: "Counts values, including text, selected from a database table-like array or range using a SQL-like query.",
      a: "Counts values and text from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DPRODUCT",
      t: 17,
      d: "Returns the product of values selected from a database table-like array or range using a SQL-like query.",
      a: "Product of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEV",
      t: 17,
      d: "Returns the standard deviation of a population sample selected from a database table-like array or range using a SQL-like query.",
      a: "Standard deviation of population sample from table.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEVP",
      t: 17,
      d: "Returns the standard deviation of an entire population selected from a database table-like array or range using a SQL-like query.",
      a: "Standard deviation of entire population from table.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSUM",
      t: 17,
      d: "Returns the sum of values selected from a database table-like array or range using a SQL-like query.",
      a: "Sum of values from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVAR",
      t: 17,
      d: "Returns the variance of a population sample selected from a database table-like array or range using a SQL-like query.",
      a: "Variance of population sample from table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVARP",
      t: 17,
      d: "Returns the variance of an entire population selected from a database table-like array or range using a SQL-like query.",
      a: "Variance of a population from a table-like range.",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "The array or range containing the data to consider, structured in such a way that the first row contains the labels for each column's values.",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "Indicates which column in `database` contains the values to be extracted and operated on.",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "An array or range containing zero or more criteria to filter the `database` values by before operating.",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "AGE_BY_IDCARD",
      t: "3",
      d: "Calculate the age based on the Chinese ID number. Support 15 or 18",
      a: "Get age based on ID number.",
      m: [1, 2],
      p: [{
        name: "ID number",
        example: "A1",
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Deadline",
        example: '"2017-10-01"',
        detail: "The deadline or range of age calculation. The default is the current day.",
        require: "o",
        repeat: "n",
        type: "rangedatetime"
      }]
    }, {
      n: "SEX_BY_IDCARD",
      t: "3",
      d: "Calculate gender based on Chinese ID number. Support 15 or 18",
      a: "Get gender based on ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIRTHDAY_BY_IDCARD",
      t: "3",
      d: "Calculate the birthday based on the Chinese ID number. Support 15 or 18",
      a: "Get the birthday based on the ID number.",
      m: [1, 2],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Birthday format",
        example: "0",
        detail: "Date type, default:0:[1900/01/01], 1:[1900-01-01], 2:[1900年1月1日]",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROVINCE_BY_IDCARD",
      t: "3",
      d: "Calculate the province of birthplace based on the Chinese ID number. Support 15 or 18",
      a: "Get the province of birthplace based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CITY_BY_IDCARD",
      t: "3",
      d: "Calculate the city of birthplace based on the Chinese ID number. Support 15 or 18",
      a: "Get the city of birthplace based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "STAR_BY_IDCARD",
      t: "3",
      d: "Calculate the constellation based on the Chinese ID number. Support 15 or 18",
      a: "Get the constellation based on the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ANIMAL_BY_IDCARD",
      t: "3",
      d: "Calculate the zodiac (rat, ox, tiger, rabbit...) based on the Chinese ID number. Support 15 or 18",
      a: "Get the zodiac according to the ID number.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISIDCARD",
      t: "3",
      d: "Verify that the format of the ID card is correct. Support 15 or 18",
      a: "Verify the correctness of the ID card format.",
      m: [1, 1],
      p: [{
        name: "ID number",
        example: '"31033519900101XXXX"',
        detail: "15-digit or 18-digit ID number or range.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DM_TEXT_CUTWORD",
      t: "4",
      d: "Text segmentation. Split a series of words into a series of individual words",
      a: "Chinese text segmentation.",
      m: [1, 2],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Word segmentation mode",
        example: "0",
        detail: "The default is 0[precision mode], 1[full mode], 2[search engine mode].",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TFIDF",
      t: "4",
      d: "Use tf-idf algorithm for keyword extraction. Identify keywords from a series of text",
      a: "tf-idf keyword recognition.",
      m: [1, 3],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Number of keywords",
        example: "20",
        detail: "The number of keywords returned by the algorithm, the default is 20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Corpus",
        example: "1",
        detail: "Select a corpus in a specific field, the default is 0[General], 1[Finance], 2[Medical]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TEXTRANK",
      t: "4",
      d: "Use TextRank algorithm to extract keywords. Identify keywords from a series of text",
      a: "TextRank keyword recognition.",
      m: [1, 3],
      p: [{
        name: "Text",
        example: '"I came to Beijing Tsinghua University"',
        detail: "Any text that needs word segmentation.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Number of keywords",
        example: "20",
        detail: "The number of keywords returned by the algorithm, the default is 20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Corpus",
        example: "1",
        detail: "Select a corpus in a specific field, the default is 0[General], 1[Finance], 2[Medical]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_CLOSE",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock closing price of A shares.",
      a: "Returns the closing price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_OPEN",
      t: "5",
      d: "According to the stock code and date, return the opening price of stock.",
      a: "Return the opening price of a shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MAX",
      t: "5",
      d: "According to the stock code and date, return the highest price of stock.",
      a: "Return the highest price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MIN",
      t: "5",
      d: "According to the stock code and date, return the lowest price of stock.",
      a: "Returns the lowest price of stock.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_VOLUMN",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock trading volume of A shares.",
      a: "Returns the corresponding stock trading volume of A shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_AMOUNT",
      t: "5",
      d: "According to the stock code and date, return the corresponding stock turnover of A shares.",
      a: "Returns the corresponding stock turnover of A shares.",
      m: [1, 3],
      p: [{
        name: "Stock code",
        example: '"000001"',
        detail: "6-digit stock code, required.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Date",
        example: "2015-01-08",
        detail: "The trading day of the stock, the default is the latest trading day",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "Reversion and exclusion",
        example: "0",
        detail: "Select the ex right restoration type of the stock, default to 0 [former reversion], 1 [original price], 2 [post reversion]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISDATE",
      t: "6",
      d: "Returns whether a value is a date.",
      a: "Whether a value is a date.",
      m: [1, 1],
      p: [{
        name: "value",
        example: '"1990-01-01"',
        detail: "The value to be verified as a date.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINESPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell to describe the continuous trend of data",
      a: "Generate sparklines line chart",
      m: [1, 8],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line thickness",
        example: "1",
        detail: "Line thickness of the line graph, the default is 1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line",
        example: "avg",
        detail: "A horizontal line, which can be min, max, avg, median, range or custom value, default 0 none",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line color",
        example: "#000",
        detail: "Color setting of auxiliary line, same as line color configuration, default #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Maximum mark",
        example: "#fc5c5c",
        detail: "Identifies the maximum value of the line graph, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Minimum mark",
        example: "#fc5c5c",
        detail: "Identify the minimum value of the line graph, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Mark size",
        example: "1.5",
        detail: "The maximum and minimum mark size settings, the default is 1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AREASPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell area chart, generally used to describe the continuous cumulative value trend of the data",
      a: "Generate sparklines area chart",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Fill color",
        example: "#CCF3F4",
        detail: "Form an area chart, the same line color configuration, default 0 does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Line thickness",
        example: "1",
        detail: "Line thickness of the line graph, the default is 1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line",
        example: "avg",
        detail: "A horizontal line, which can be min, max, avg, median, range or custom value, default 0 none",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Auxiliary line color",
        example: "#000",
        detail: "Color setting of auxiliary line, same as line color configuration, default #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the vertical histogram of cells, generally used to describe the size of discrete data",
      a: "Generate sparklines vertical histogram",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the bar chart, used to standardize the length of the bar chart, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKCOLUMNSPLINES",
      t: "3",
      d: "Generate sparklines, a cumulative vertical histogram embedded in a cell, generally used to describe the numerical size of multiple dimensions of discrete data",
      a: "Generate sparklines cumulative vertical histogram",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Stack by column",
        example: "1",
        detail: "If you need to stack by row, set this item to false or 0, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the cumulative bar, used to regulate the length of the bar, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can individually set the bar color of each dimension, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BARSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the size of discrete data",
      a: "Generate sparklines horizontal bar graph",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the bar chart, used to standardize the length of the bar chart, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKBARSPLINES",
      t: "3",
      d: "Generate sparklines, a cumulative horizontal bar graph embedded in a cell, which is generally used to describe the numerical size of multiple dimensions of discrete data",
      a: "Generate sparklines cumulative horizontal bar graph",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Stack by column",
        example: "1",
        detail: "If you need to stack by row, set this item to false or 0, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Max",
        example: "100",
        detail: "The maximum value of the cumulative bar, used to regulate the length of the bar, the default is to automatically calculate false, auto, null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can individually set the bar color of each dimension, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "DISCRETESPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the trend of discrete data",
      a: "Generate sparklines discrete graph",
      m: [1, 4],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Segmentation threshold",
        example: "1",
        detail: "Discrete graph column color distinction, for example: if the value is 0, blue is greater than 0, red is less than 0, and the default is 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Above threshold color",
        example: "#2ec7c9",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Below threshold color",
        example: "#fc5c5c",
        detail: "The color setting of the bar below the threshold, the same as the color above the threshold, default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRISTATESPLINES",
      t: "3",
      d: "Generate sparklines, a three-state graph embedded in the cell, which is generally used to describe the trend of three situations, such as winning, losing, or drawing.",
      a: "Generate sparklines three-state graph",
      m: [1, 6],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar interval",
        example: "1",
        detail: "The distance between bars, the default is 1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Bar color",
        example: "#fc5c5c",
        detail: "The line color of the line graph can be range A1, color table index value or specific color value. Set it to 0 or false to not display it. It supports regx, rgb, rgba, etc. Default #fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Negative bar color",
        example: "#97b552",
        detail: "Negative bar color setting, representing the color of negative value, same as the bar color configuration, default #97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Zero value bar color",
        example: "#999",
        detail: "Zero value bar color setting, representing 0 value color, the same color configuration of the bar, default #999",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color palette can set the color of each bar individually, multiple settings can be set, and two formats are supported: 1 color such as #000, which means that the color of the first bar is black; 2 value range: color, such as -2:# 000 indicates that the bar with a value of -2 is black, 0:5:#000 indicates that the bar with a value of 0-5 is black, and the default is empty",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PIESPLINES",
      t: "3",
      d: "Generate sparklines pie chart embedded in the cell, generally used to describe the proportion of data",
      a: "Generate sparklines pie chart",
      m: [1, 5],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Rotation angle",
        example: "0",
        detail: "The rotation angle of the pie chart, the default is 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "border",
        example: "0",
        detail: "Pie chart border size, default is none 0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Border color",
        example: "#000",
        detail: "The border color of the pie chart, the default is #000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Color palette",
        example: "#97b552",
        detail: "The color of the slice can be set in the palette, which can be set to the range of A1:A10, etc. The default is #2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BOXSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell box plot, generally used to describe the statistical distribution of the data set",
      a: "Generate sparklines box plot",
      m: [1, 4],
      p: [{
        name: "Range",
        example: "A1:A20",
        detail: "Range，Values can be calculated effectively, such as A1:A20, {1,2,3,4,5}, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Outlier ratio",
        example: "1.5",
        detail: "The threshold range of outliers, if it is 0 or false, it will not be displayed, the default is 1.5 times",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Target value",
        example: "10",
        detail: "The target value setting on the box plot, the default is false and does not display",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Point size",
        example: "1.5",
        detail: "The radius of the target point and outlier is set, the default is 1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BULLETSPLINES",
      t: "3",
      d: "Generate sparklines embedded in the cell, generally used to describe the task achievement rate",
      a: "Generating sparklines bullets",
      m: [2, 3],
      p: [{
        name: "Target",
        example: "10",
        detail: "The numerical value can be calculated effectively for the achieved target value, such as A1, 100, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "achieved",
        example: "8",
        detail: "Only when the value is completed can the value be calculated effectively, such as A1, 100, etc.",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "Contrast",
        example: "12",
        detail: "Comparative values, such as excess, minimum, and bottom line for awards, can be effectively calculated, such as A1, 100, etc. You can set up to 9 comparison values",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMPOSESPLINES",
      t: "3",
      d: "Support multiple types of pictures in the same cell, each parameter represents a sparklines diagram",
      a: "Combine sparklines graphs into one cell",
      m: [1, 1],
      p: [{
        name: "config",
        example: "PIESPLINES(A1:A20)",
        detail: "Sparklines chart settings, such as A1:A20, a completed pie chart, line chart settings, etc.",
        require: "m",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SORT",
      t: "14",
      d: "Sorts the rows of a given array or range by the values in one or more columns.",
      a: "Sorts rows of range by specified column.",
      m: [1, 4],
      p: [{
        name: "range",
        detail: "The data to be sorted.",
        example: "A2:A17",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_column",
        detail: "The index of the column in `range` or a range outside of `range` containing the values by which to sort.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "is_ascending",
        detail: "`TRUE` or `FALSE` indicating whether to sort `sort_column` in ascending order. `FALSE` sorts in descending order.",
        example: "-1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_column2",
        detail: "Additional columns.",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FILTER",
      t: "14",
      d: "Returns a filtered version of the source range, returning only rows or columns which meet the specified conditions.",
      a: "Filters a range based off provided conditions.",
      m: [2, 3],
      p: [{
        name: "range",
        detail: "The data to be filtered.",
        example: "A5:D20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "condition1",
        detail: "A column or row containing true or false values corresponding to the first column or row of `range`, or an array formula evaluating to true or false.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "condition2",
        detail: "Additional rows or columns containing boolean values `TRUE` or `FALSE` indicating whether the corresponding row or column in `range` should pass through `FILTER`. Can also contain array formula expressions which evaluate to such rows or columns. All conditions must be of the same type (row or column). Mixing row conditions and column conditions is not permitted.",
        example: '""',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNIQUE",
      t: "14",
      d: "Returns unique rows in the provided source range, discarding duplicates. Rows are returned in the order in which they first appear in the source range.",
      a: "Unique rows in the provided source range.",
      m: [1, 3],
      p: [{
        name: "range",
        detail: "The data to filter by unique entries.",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[Option] - Logical value, indicating how to compare; by row = FALSE() or omitted; by column = TRUE().",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurs_once",
        detail: "[Option] - Logical value, only one occurrence in the unique value is returned = TRUE(); including all unique values = FALSE() or omitted.",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANDARRAY",
      t: "14",
      d: "Returns a grid of random numbers between 0 inclusive and 1 exclusive. The grid size will match the provided rows and columns arguments. If neither rows nor columns are provided, then the grid will be size 1 x 1.",
      a: "Returns a grid of random numbers.",
      m: [0, 2],
      p: [{
        name: "rows",
        detail: "The number of rows to populate with a random number.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "columns",
        detail: "The number of columns to populate with a random number.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEQUENCE",
      t: "14",
      d: "Returns a grid of sequential numbers starting at a specified start value and  increasing by a specified step size. By default, the sequence starts at and  increases by 1.",
      a: "Returns a grid of sequential numbers.",
      m: [1, 4],
      p: [{
        name: "rows",
        detail: "The number of rows in the function's resulting grid.",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "columns",
        detail: "The number of columns in the function's resulting grid. If omitted, the result grid will have 1 column.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start",
        detail: "The number, at which to start the sequence. If omitted, the sequence will start at 1.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "step",
        detail: "The amount each value in the sequence will differ by. If omitted, each value will differ by 1.",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVALUATE",
      t: "3",
      d: "Evaluate a formula or expression expressed in words and return the result",
      a: "Evaluate according to literal formula or expression.",
      m: [1, 1],
      p: [{
        name: "expression",
        example: '"A1+5*2^2"',
        detail: "Formula or expression",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }],
    toolbar: {
      undo: "Deshacer",
      redo: "Rehacer",
      paintFormat: "Clonar formato",
      currencyFormat: "Formato de moneda",
      percentageFormat: "Formato de porcentaje",
      numberDecrease: "Menos decimales",
      numberIncrease: "Más decimales",
      moreFormats: "Más formatos",
      font: "Fuente",
      "font-size": "Tamaño Fuente",
      bold: "Negrita (Ctrl+B)",
      italic: "Itálica (Ctrl+I)",
      strikethrough: "Tachar (Alt+Shift+5)",
      underline: "Guion bajo",
      "font-color": "Color texto",
      chooseColor: "elegir color",
      resetColor: "Reinicializar",
      customColor: "PERSONALIZADO",
      alternatingColors: "Colores alternos",
      confirmColor: "Vale",
      cancelColor: "Cancelar",
      collapse: "Recoger",
      background: "Color de relleno",
      border: "Borde",
      borderStyle: "Estilo Borde",
      "merge-cell": "Juntar celdas",
      chooseMergeType: "Elegir tipo de unión",
      horizontalAlign: "Alineación Horizontal",
      verticalAlign: "Alineación Vertical",
      alignment: "Alineación",
      textWrap: "Ajuste de texto",
      textWrapMode: "Modo de ajuste de texto",
      textRotate: "Rotar texto",
      textRotateMode: "Modo de rotar texto",
      freeze: "Fijar fila superior",
      sort: "Ordenar",
      filter: "Filtrar",
      findAndReplace: "Buscar y reemplazar",
      "formula-sum": "SUMA",
      autoSum: "SUMA automática",
      moreFunction: "Más funciones",
      conditionalFormat: "Formato condicional",
      comment: "Comentario",
      pivotTable: "Tabla Dinámica",
      chart: "Gráfica",
      screenshot: "Captura de pantalla",
      splitColumn: "Separar texto",
      insertImage: "Insertar imagen",
      dataVerification: "Verificación de datos",
      protection: "Proteger la hoja",
      clearText: "Limpiar color",
      noColorSelectedText: "Ningún color seleccionado",
      toolMore: "Más",
      toolLess: "Menos",
      toolClose: "Cerrar",
      toolMoreTip: "Más funcionalidades",
      moreOptions: "Más opciones",
      cellFormat: "Configuración formato de celda",
      print: "Imprimir"
    },
    alternatingColors: {
      applyRange: "Aplicar a rango",
      selectRange: "Seleccionar un rango de datos",
      header: "Cabecera",
      footer: "Pie",
      errorInfo: "No se puede realizar esta operación en varias áreas de selección, selecciona una sola área y vuelve a intentarlo",
      textTitle: "Estilo Formato",
      custom: "PERSONALIZADO",
      close: "cerrar",
      selectionTextColor: "Haz clic para seleccionar el color del texto",
      selectionCellColor: "Haz clic para seleccionar el color de la celda",
      removeColor: "Eliminar colores alternos",
      colorShow: "color",
      currentColor: "Actual",
      tipSelectRange: "Selecciona la gama de colores alternos",
      errorNoRange: "No hay ningún rango seleccionado",
      errorExistColors: "Los colores alternos ya existen y no se pueden editar"
    },
    button: {
      confirm: "Vale",
      cancel: "Cancelar",
      close: "Cerrar",
      update: "Actualizar",
      delete: "Eliminar",
      insert: "Insertar",
      prevPage: "Previous",
      nextPage: "Next",
      total: "total:"
    },
    paint: {
      start: "Inicio clonar formato",
      end: "ESC",
      tipSelectRange: "Selecciona el rango que quieres copiar",
      tipNotMulti: "No se puede realizar esta operación en un rango de selección múltiple"
    },
    format: {
      moreCurrency: "Más formatos de moneda",
      moreDateTime: "Más formatos de fecha y hora",
      moreNumber: "Más formatos de número",
      titleCurrency: "Formatos de moneda",
      decimalPlaces: "Decimales",
      titleDateTime: "Formatos de fecha y hora",
      titleNumber: "Formatos de números"
    },
    info: {
      detailUpdate: "Nuevo abierto",
      detailSave: "Cache local restaurado",
      row: "",
      column: "",
      loading: "Cargando...",
      copy: "Copiar",
      return: "Salir",
      rename: "Renombrar",
      tips: "Renombrar Libro",
      noName: "Hoja sin título",
      wait: "esperando actualización",
      add: "Añadir",
      addLast: "más filas al final",
      backTop: "Volver arriba",
      pageInfo: "Total ${total}，página ${totalPage}，actual ${currentPage}",
      nextPage: "Siguiente",
      tipInputNumber: "Introduce el número",
      tipInputNumberLimit: "El rango de aumento está limitado a 1-100",
      tipRowHeightLimit: "La altura de la fila debe estar entre 0 ~ 545",
      tipColumnWidthLimit: "El ancho de la columna debe estar entre 0 ~ 2038",
      pageInfoFull: "Total ${total}，página ${totalPage}，Se muestran todos los datos"
    },
    currencyDetail: {
      RMB: "RMB",
      USdollar: "Dólar US",
      EUR: "EUR",
      GBP: "GBP",
      HK: "HK",
      JPY: "JPY",
      AlbanianLek: "Albanian Lek",
      AlgerianDinar: "Algerian Dinar",
      Afghani: "Afghani",
      ArgentinePeso: "Argentine Peso",
      UnitedArabEmiratesDirham: "United Arab Emirates Dirham",
      ArubanFlorin: "Aruban Florin",
      OmaniRial: "Omani Rial",
      Azerbaijanimanat: "Azerbaijani manat",
      EgyptianPound: "Egyptian Pound",
      EthiopianBirr: "Ethiopian Birr",
      AngolaKwanza: "Angola Kwanza",
      AustralianDollar: "Australian Dollar",
      Patacas: "Patacas",
      BarbadosDollar: "Barbados Dollar",
      PapuaNewGuineaKina: "Papua New Guinea Kina",
      BahamianDollar: "Bahamian Dollar",
      PakistanRupee: "Pakistan Rupee",
      ParaguayanGuarani: "Paraguayan Guarani",
      BahrainiDinar: "Bahraini Dinar",
      PanamanianBalboa: "Panamanian Balboa",
      Brazilianreal: "Brazilian real",
      Belarusianruble: "Belarusian ruble",
      BermudianDollar: "Bermudian Dollar",
      BulgarianLev: "Bulgarian Lev",
      IcelandKrona: "Iceland Krona",
      BosniaHerzegovinaConvertibleMark: "Bosnia-Herzegovina Convertible Mark",
      PolishZloty: "Polish Zloty",
      Boliviano: "Boliviano",
      BelizeDollar: "Belize Dollar",
      BotswanaPula: "Botswana Pula",
      NotDannuzhamu: "Not Dannuzhamu",
      BurundiFranc: "Burundi Franc",
      NorthKoreanWon: "North Korean Won",
      DanishKrone: "Danish Krone",
      EastCaribbeanDollar: "East Caribbean Dollar",
      DominicaPeso: "Dominica Peso",
      RussianRuble: "Russian Ruble",
      EritreanNakfa: "Eritrean Nakfa",
      CFAfranc: "CFA franc",
      PhilippinePeso: "Philippine Peso",
      FijiDollar: "Fiji Dollar",
      CapeVerdeEscudo: "Cape Verde Escudo",
      FalklandIslandsPound: "Falkland Islands Pound",
      GambianDalasi: "Gambian Dalasi",
      Congolesefranc: "Congolese franc",
      ColombianPeso: "Colombian Peso",
      CostaRicanColon: "Costa Rican Colon",
      CubanPeso: "Cuban Peso",
      Cubanconvertiblepeso: "Cuban convertible peso",
      GuyanaDollar: "Guyana Dollar",
      KazakhstanTenge: "Kazakhstan Tenge",
      Haitiangourde: "Haitian gourde",
      won: "won",
      NetherlandsAntillesGuilder: "Netherlands Antilles Guilder",
      Honduraslempiras: "Honduras lempiras",
      DjiboutiFranc: "Djibouti Franc",
      KyrgyzstanSom: "Kyrgyzstan Som",
      GuineaFranc: "Guinea Franc",
      CanadianDollar: "Canadian Dollar",
      GhanaianCedi: "Ghanaian Cedi",
      Cambodianriel: "Cambodian riel",
      CzechKoruna: "Czech Koruna",
      ZimbabweDollar: "Zimbabwe Dollar",
      QatariRiyal: "Qatari Riyal",
      CaymanIslandsDollar: "Cayman Islands Dollar",
      Comorianfranc: "Comorian franc",
      KuwaitiDinar: "Kuwaiti Dinar",
      CroatianKuna: "Croatian Kuna",
      KenyanShilling: "Kenyan Shilling",
      LesothoLoti: "Lesotho Loti",
      LaoKip: "Lao Kip",
      LebanesePound: "Lebanese Pound",
      Lithuanianlitas: "Lithuanian litas",
      LibyanDinar: "Libyan Dinar",
      LiberianDollar: "Liberian Dollar",
      RwandaFranc: "Rwanda Franc",
      RomanianLeu: "Romanian Leu",
      MalagasyAriary: "Malagasy Ariary",
      MaldivianRufiyaa: "Maldivian Rufiyaa",
      MalawiKwacha: "Malawi Kwacha",
      MalaysianRinggit: "Malaysian Ringgit",
      MacedoniawearingDinar: "Macedonia wearing Dinar",
      MauritiusRupee: "Mauritius Rupee",
      MauritanianOuguiya: "Mauritanian Ouguiya",
      MongolianTugrik: "Mongolian Tugrik",
      BangladeshiTaka: "Bangladeshi Taka",
      PeruvianNuevoSol: "Peruvian Nuevo Sol",
      MyanmarKyat: "Myanmar Kyat",
      MoldovanLeu: "Moldovan Leu",
      MoroccanDirham: "Moroccan Dirham",
      MozambiqueMetical: "Mozambique Metical",
      MexicanPeso: "Mexican Peso",
      NamibianDollar: "Namibian Dollar",
      SouthAfricanRand: "South African Rand",
      SouthSudanesePound: "South Sudanese Pound",
      NicaraguaCordoba: "Nicaragua Cordoba",
      NepaleseRupee: "Nepalese Rupee",
      NigerianNaira: "Nigerian Naira",
      NorwegianKrone: "Norwegian Krone",
      GeorgianLari: "Georgian Lari",
      RMBOffshore: "RMB (Offshore)",
      SwedishKrona: "Swedish Krona",
      SwissFranc: "Swiss Franc",
      SerbianDinar: "Serbian Dinar",
      SierraLeone: "Sierra Leone",
      SeychellesRupee: "Seychelles Rupee",
      SaudiRiyal: "Saudi Riyal",
      SaoTomeDobra: "Sao Tome Dobra",
      SaintHelenapound: "Saint Helena pound",
      SriLankaRupee: "Sri Lanka Rupee",
      SwazilandLilangeni: "Swaziland Lilangeni",
      SudanesePound: "Sudanese Pound",
      Surinamesedollar: "Surinamese dollar",
      SolomonIslandsDollar: "Solomon Islands Dollar",
      SomaliShilling: "Somali Shilling",
      TajikistanSomoni: "Tajikistan Somoni",
      PacificFranc: "Pacific Franc",
      ThaiBaht: "Thai Baht",
      TanzanianShilling: "Tanzanian Shilling",
      TonganPaanga: "Tongan Pa'anga",
      TrinidadandTobagoDollar: "Trinidad and Tobago Dollar",
      TunisianDinar: "Tunisian Dinar",
      TurkishLira: "Turkish Lira",
      VanuatuVatu: "Vanuatu Vatu",
      GuatemalanQuetzal: "Guatemalan Quetzal",
      CommissionBolivar: "Commission Bolivar",
      BruneiDollar: "Brunei Dollar",
      UgandanShilling: "Ugandan Shilling",
      UkrainianHryvnia: "Ukrainian Hryvnia",
      UruguayanPeso: "Uruguayan Peso",
      Uzbekistansom: "Uzbekistan som",
      WesternSamoaTala: "Western Samoa Tala",
      SingaporeDollar: "Singapore Dollar",
      NT: "NT",
      NewZealandDollar: "New Zealand Dollar",
      HungarianForint: "Hungarian Forint",
      SyrianPound: "Syrian Pound",
      JamaicanDollar: "Jamaican Dollar",
      ArmenianDram: "Armenian Dram",
      YemeniRial: "Yemeni Rial",
      IraqiDinar: "Iraqi Dinar",
      IranianRial: "Iranian Rial",
      NewIsraeliShekel: "New Israeli Shekel",
      IndianRupee: "Indian Rupee",
      IndonesianRupiah: "Indonesian Rupiah",
      JordanianDinar: "Jordanian Dinar",
      VND: "VND",
      ZambianKwacha: "Zambian Kwacha",
      GibraltarPound: "Gibraltar Pound",
      ChileanPeso: "Chilean Peso",
      CFAFrancBEAC: "CFA Franc BEAC"
    },
    defaultFmt: [{
      text: "Automático",
      value: "General",
      example: ""
    }, {
      text: "Texto",
      value: "@",
      example: ""
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Número",
      value: "##0.00",
      example: "1000.12"
    }, {
      text: "Porcentaje",
      value: "#0.00%",
      example: "12.21%"
    }, {
      text: "Científico",
      value: "0.00E+00",
      example: "1.01E+5"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Contabilidad",
      value: "¥(0.00)",
      example: "¥(1200.09)"
    }, {
      text: "Moneda",
      value: "¥0.00",
      example: "¥1200.09"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Fecha",
      value: "yyyy-MM-dd",
      example: "2017-11-29"
    }, {
      text: "Hora",
      value: "hh:mm AM/PM",
      example: "3:00 PM"
    }, {
      text: "Hora 24H",
      value: "hh:mm",
      example: "15:00"
    }, {
      text: "Fecha Hora",
      value: "yyyy-MM-dd hh:mm AM/PM",
      example: "2017-11-29 3:00 PM"
    }, {
      text: "Fecha Hora 24 H",
      value: "yyyy-MM-dd hh:mm",
      example: "2017-11-29 15:00"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "Formatos personalizados",
      value: "fmtOtherSelf",
      example: "más"
    }],
    dateFmtList: [{
      name: "1930-08-05",
      value: "yyyy-MM-dd"
    }, {
      name: "1930/8/5",
      value: "yyyy/MM/dd"
    }, {
      name: "08-05",
      value: "MM-dd"
    }, {
      name: "8-5",
      value: "M-d"
    }, {
      name: "13:30:30",
      value: "h:mm:ss"
    }, {
      name: "13:30",
      value: "h:mm"
    }, {
      name: "PM 01:30",
      value: "AM/PM hh:mm"
    }, {
      name: "PM 1:30",
      value: "AM/PM h:mm"
    }, {
      name: "PM 1:30:30",
      value: "AM/PM h:mm:ss"
    }, {
      name: "08-05 PM 01:30",
      value: "MM-dd AM/PM hh:mm"
    }],
    fontFamily: {
      MicrosoftYaHei: "YaHei"
    },
    fontarray: ["Times New Roman", "Arial", "Tahoma", "Verdana"],
    fontjson: {
      "times new roman": 0,
      arial: 1,
      tahoma: 2,
      verdana: 3
    },
    border: {
      borderTop: "borderTop",
      borderBottom: "borderBottom",
      borderLeft: "borderLeft",
      borderRight: "borderRight",
      borderNone: "borderNone",
      borderAll: "borderAll",
      borderOutside: "borderOutside",
      borderInside: "borderInside",
      borderHorizontal: "borderHorizontal",
      borderVertical: "borderVertical",
      borderColor: "borderColor",
      borderSize: "borderSize",
      borderSlash: "borderSlash"
    },
    merge: {
      mergeAll: "Unir todo",
      mergeV: "Verticalmente",
      mergeH: "Horizontalmente",
      mergeCancel: "Separar",
      overlappingError: "No se pueden fusionar áreas superpuestas",
      partiallyError: "No se puede realizar esta operación en celdas parcialmente unidas"
    },
    align: {
      left: "izquierda",
      center: "centro",
      right: "derecha",
      top: "Arriba",
      middle: "Centro",
      bottom: "Abajo"
    },
    textWrap: {
      overflow: "Desbordar",
      wrap: "Ajustar",
      clip: "Cortar"
    },
    rotation: {
      none: "Ninguno",
      angleup: "Ladear Arriba",
      angledown: "Ladear Abajo",
      vertical: "Apilar Verticalmente",
      rotationUp: "Rotar Arriba",
      rotationDown: "Rotar Abajo"
    },
    freezen: {
      default: "Fijar",
      freezenRow: "Primera Fila",
      freezenColumn: "Primera Columna",
      freezenRC: "Ambas",
      freezenRowRange: "Fijar rango filas",
      freezenColumnRange: "Fijar rango columnas",
      freezenRCRange: "Fijar ambos rangos",
      freezenCancel: "Cancelar",
      noSeletionError: "No hay rango para seleccionar",
      rangeRCOverErrorTitle: "Recordatorio de congelación",
      rangeRCOverError: "El panel de congelación excede el rango visible y puede causar que no funcione correctamente. Reinicie el área de congelación."
    },
    sort: {
      asc: "Ascendente ",
      desc: "Descendente ",
      custom: "Ordenación personalizada",
      hasTitle: "Los datos tienen una fila de encabezado",
      sortBy: "Ordenar por",
      addOthers: "Añadir otra columna de ordenación",
      close: "cerrar",
      confirm: "ordenar",
      columnOperation: "Columna",
      secondaryTitle: "y después por",
      sortTitle: "Ordenar rango",
      sortRangeTitle: "Ordenar rango de",
      sortRangeTitleTo: "a",
      noRangeError: "No se puede realizar esta operación en múltiples áreas de selección, selecciona un solo rango e intenta nuevamente",
      mergeError: "Hay celdas combinadas en la selección, ¡esta operación no se puede realizar!"
    },
    filter: {
      filter: "crear filtro",
      sortByAsc: "Ordenar A-Z",
      sortByDesc: "Ordenar Z-A",
      filterByColor: "Filtrar por color",
      filterByCondition: "Filtrar por condición",
      filterByValues: "Filtrar por valores",
      filiterInputNone: "Ninguno",
      filiterInputTip: "Introduce valor de filtro",
      filiterRangeStartTip: "Valor para fórmula",
      filiterRangeEndTip: "Valor para fórmula",
      filterValueByAllBtn: "Seleccionar todos",
      filterValueByClearBtn: "Limpiar",
      filterValueByInverseBtn: "Invertir",
      filterValueByTip: "filtrar por valores",
      filterConform: "Confirmar",
      filterCancel: "Cancelar",
      clearFilter: "Quitar filtro",
      conditionNone: "Ninguno",
      conditionCellIsNull: "Está vacío",
      conditionCellNotNull: "No está vacío",
      conditionCellTextContain: "El texto contiene",
      conditionCellTextNotContain: "El texto no contiene",
      conditionCellTextStart: "El texto empieza con",
      conditionCellTextEnd: "El texto termina con",
      conditionCellTextEqual: "El texto es exactamente",
      conditionCellDateEqual: "La fecha es",
      conditionCellDateBefore: "La fecha es anterior",
      conditionCellDateAfter: "La fecha es posterior",
      conditionCellGreater: "Mayor que",
      conditionCellGreaterEqual: "Mayor o igual que",
      conditionCellLess: "Menor que",
      conditionCellLessEqual: "Menor o igual que",
      conditionCellEqual: "Es igual a",
      conditionCellNotEqual: "No es igual a",
      conditionCellBetween: "Está entre",
      conditionCellNotBetween: "No está entre",
      filiterMoreDataTip: "¡Gran cantidad de datos! por favor espera",
      filiterMonthText: "Mes",
      filiterYearText: "Año",
      filiterByColorTip: "Filtrar por color de celda",
      filiterByTextColorTip: "Filtrar por color de fuente",
      filterContainerOneColorTip: "Esta columna contiene solo un color",
      filterDateFormatTip: "Format fecha",
      valueBlank: "(Nulo)",
      mergeError: "Hay celdas combinadas en la selección del filtro, ¡esta operación no se puede realizar!"
    },
    rightclick: {
      copy: "Copiar",
      copyAs: "Copiar como",
      paste: "Pegar",
      insert: "Insertar",
      image: "Insertar imágenes",
      link: "Insertar enlace",
      delete: "Eliminar",
      deleteCell: "Eliminar celda",
      deleteSelected: "Eliminar seleccionado ",
      hide: "Esconder",
      hideSelected: "Esconder seleccionado ",
      showHide: "Mostrar ocultos ",
      to: "Hacia",
      left: "Izquierda",
      right: "Derecha",
      top: "Arriba",
      bottom: "Abajo",
      moveLeft: "Mover izquierda",
      moveUp: "Mover arriba",
      add: "Añadir",
      row: "Fila",
      column: "Columna",
      width: "Ancho",
      height: "Alto",
      number: "Número",
      confirm: "Confirmar",
      orderAZ: "Ordenar A-Z",
      orderZA: "Ordenar Z-A",
      clearContent: "Limpiar contenido",
      matrix: "Operación de Matriz",
      sortSelection: "Ordenar",
      filterSelection: "Filtrar",
      chartGeneration: "Crear gráfico",
      firstLineTitle: "título primera línea",
      untitled: "sin título",
      array1: "Matriz unidimensional",
      array2: "Matriz bidimensional",
      array3: "Matrices multidimensionales",
      diagonal: "Diagonal",
      antiDiagonal: "Anti-diagonal",
      diagonalOffset: "Desplazamiento Diagonal",
      offset: "Desplazamiento",
      boolean: "Booleana",
      flip: "Voltear",
      upAndDown: "Arriba y abajo",
      leftAndRight: "Izquierda y derecha",
      clockwise: "Sentido horario",
      counterclockwise: "Sentido anti-horario",
      transpose: "Transponer",
      matrixCalculation: "Cálculo de matrices",
      plus: "Suma",
      minus: "Resta",
      multiply: "Multiplicación",
      divided: "División",
      power: "Exponenciación",
      root: "Raíz Cuadrada",
      log: "Logaritmo",
      delete0: "Eliminar valores nulos en ambos extremos",
      removeDuplicate: "Eliminar valores duplicados",
      byRow: "Por fila",
      byCol: "Por columna",
      generateNewMatrix: "Generar nueva matriz",
      noMulti: "No se puede realizar esta operación en varias áreas de selección, selecciona una sola área",
      cannotDeleteAllRow: "No se pueden eliminar todas las filas",
      cannotDeleteAllColumn: "No se pueden eliminar todas las columnas",
      cannotDeleteRowReadOnly: "No se puede eliminar la fila de solo lectura",
      cannotDeleteColumnReadOnly: "No se puede eliminar la columna de solo lectura",
      cannotInsertOnRowReadOnly: "No se puede insertar en una fila de solo lectura",
      cannotInsertOnColumnReadOnly: "No se puede insertar en la columna de solo lectura",
      rowOverLimit: "Límite de 10000 filas excedido",
      columnOverLimit: "Límite de 1000 columnas excedido"
    },
    comment: {
      insert: "Insertar",
      edit: "Editar",
      delete: "Elimiar",
      showOne: "Mostrar/Ocular",
      showAll: "Mostrar/Ocular Todo"
    },
    screenshot: {
      screenshotTipNoSelection: "Selecciona el alcance de la captura de pantalla",
      screenshotTipTitle: "¡Advertencia!",
      screenshotTipHasMerge: "Esta operación no se puede realizar en celdas combinadas",
      screenshotTipHasMulti: "Esta operación no se puede realizar en varios rangos de selección",
      screenshotTipSuccess: "Exitoso",
      screenshotImageName: "Captura de pantalla",
      downLoadClose: "Cerrar",
      downLoadCopy: "Copiar al portapapeles",
      downLoadBtn: "Descargar",
      browserNotTip: "no es compatible con el navegador IE.",
      rightclickTip: 'Haz clic con el botón derecho en la imagen y selecciona "copiar"',
      successTip: 'Con éxito (si falla el pegado, haz clic con el botón derecho en la imagen para "copiar imagen")'
    },
    splitText: {
      splitDelimiters: "Delimitadores",
      splitOther: "Otros",
      splitContinueSymbol: "Los separadores consecutivos se tratan como uno solo",
      splitDataPreview: "Previsualizar",
      splitTextTitle: "Partir texto",
      splitConfirmToExe: "Ya hay datos aquí, ¿quieres reemplazarlos?",
      tipNoMulti: "No se puede realizar esta operación en varias áreas de selección, selecciona una única área y vuelve a intentarlo",
      tipNoMultiColumn: "Solo se puede convertir una columna de datos a la vez. El área seleccionado puede tener varias filas, pero no varias columnas. Vuelve a intentarlo después de seleccionar un solo rango de columnas"
    },
    imageText: {
      imageSetting: "Configuración de imagen",
      close: "Cerrar",
      conventional: "Convencional",
      moveCell1: "Mover y cambiar el tamaño de las celdas",
      moveCell2: "Mover y no cambiar el tamaño de la celda",
      moveCell3: "No mover ni cambiar el tamaño de la celda",
      fixedPos: "Posición fija",
      border: "Borde",
      width: "Ancho",
      radius: "Radio",
      style: "Estilo",
      solid: "Sólido",
      dashed: "Discontinua",
      dotted: "Punteado",
      double: "Doble",
      color: "Color"
    },
    punctuation: {
      tab: "Tabulación",
      semicolon: "punto y coma",
      comma: "coma",
      space: "espacio"
    },
    findAndReplace: {
      find: "Encontrar",
      replace: "Reemplazar",
      goto: "Ir a",
      location: "Ubicación",
      formula: "Fórmula",
      date: "Fecha",
      number: "Número",
      string: "Texto",
      error: "Error",
      condition: "Condición",
      rowSpan: "Intervalo de filas",
      columnSpan: "Intervalo de columnas",
      locationExample: "Ubicación",
      lessTwoRowTip: "Selecciona al menos dos filas",
      lessTwoColumnTip: "Selecciona al menos dos columnas",
      findTextbox: "Encontrar Contenido",
      replaceTextbox: "Reemplazar Contenido",
      regexTextbox: "Expresión Regular",
      wholeTextbox: "Palabra entera",
      distinguishTextbox: "Distingue mayúsculas y minúsculas",
      allReplaceBtn: "Reemplazar Todo",
      replaceBtn: "Reemplazar",
      allFindBtn: "Encontrar Todo",
      findBtn: "Encontrar siguiente",
      noFindTip: "No se encontró el contenido",
      modeTip: "Esta operación no está disponible en este modo",
      searchTargetSheet: "Hoja",
      searchTargetCell: "Celda",
      searchTargetValue: "Valor",
      searchInputTip: "Introduce el contenido de la búsqueda",
      noReplceTip: "No hay nada que reemplazar",
      noMatchTip: "No se encontraron coincidencias",
      successTip: "${xlength} elementos encontrados",
      locationConstant: "Constante",
      locationFormula: "Fórmula",
      locationDate: "Fecha",
      locationDigital: "Número",
      locationString: "Texto",
      locationBool: "Lógicos",
      locationError: "Error",
      locationNull: "Nulo",
      locationCondition: "Formato condicional",
      locationRowSpan: "Intervalo fila",
      locationColumnSpan: "Intervalo columna",
      locationTiplessTwoRow: "Selecciona al menos dos filas",
      locationTiplessTwoColumn: "Selecciona al menos dos columnas",
      locationTipNotFindCell: "Celda no encontrada"
    },
    sheetconfig: {
      delete: "Eliminar",
      copy: "Copiar",
      rename: "Renombrar",
      changeColor: "Cambiar color",
      hide: "Ocultar",
      unhide: "Mostrar",
      moveLeft: "Mover izquierda",
      moveRight: "Mover derecja",
      resetColor: "Reiniciar color",
      cancelText: "Cancelar",
      chooseText: "Confirmar color",
      focus: "Enfocar",
      tipNameRepeat: "¡El nombre de la página de la pestaña no se puede repetir! Revísalo",
      noMoreSheet: "El libro de trabajo contiene al menos una hoja de trabajo visual. Para eliminar la hoja de trabajo seleccionada, inserta una nueva hoja de trabajo o muestra una hoja de trabajo oculta",
      confirmDelete: "¿Estás seguro de eliminar",
      redoDelete: "Se puede deshacer con Ctrl+Z",
      noHide: "No se puede ocultar, al menos conserva una etiqueta de hoja",
      chartEditNoOpt: "¡Esta operación no está permitida en el modo de edición de gráficos!",
      sheetNameSpecCharError: `El nombre no puede contener:[ ] :  ? * / ' "`,
      sheetNamecannotIsEmptyError: "El nombre de la hoja no puede estar vacío"
    },
    conditionformat: {
      conditionformat_greaterThan: "Conditionformat-GreaterThan",
      conditionformat_greaterThan_title: "Dar formato a celdas mayores que",
      conditionformat_lessThan: "Conditionformat-LessThan",
      conditionformat_lessThan_title: "Dar formato a celdas más pequeñas que",
      conditionformat_between: "Conditionformat-Betweenness",
      conditionformat_between_title: "Dar formato a celdas con valores entre",
      conditionformat_equal: "Conditionformat-Equal",
      conditionformat_equal_title: "Dar formato a celdas iguales a",
      conditionformat_textContains: "Conditionformat-TextContains",
      conditionformat_textContains_title: "Dar formato a las celdas que contienen el siguiente texto",
      conditionformat_occurrenceDate: "Conditionformat-OccurrenceDate",
      conditionformat_occurrenceDate_title: "Dar formato a celdas que contienen las siguientes fechas",
      conditionformat_duplicateValue: "Conditionformat-DuplicateValue",
      conditionformat_duplicateValue_title: "Dar formato a celdas que contienen los siguientes tipos de valores",
      conditionformat_top10: "Conditionformat-Top10",
      conditionformat_top10_percent: "Conditionformat-Top10%",
      conditionformat_top10_title: "Formatea las celdas con el valor más alto",
      conditionformat_last10: "Conditionformat-Last10",
      conditionformat_last10_percent: "Conditionformat-Last10%",
      conditionformat_last10_title: "Formatea las celdas con el valor más pequeño",
      conditionformat_aboveAverage: "Conditionformat-AboveAverage",
      conditionformat_aboveAverage_title: "Dar formato a celdas por encima del promedio",
      conditionformat_belowAverage: "Conditionformat-SubAverage",
      conditionformat_belowAverage_title: "Dar formato a celdas por debajo del promedio",
      rule: "Regla",
      newRule: "Nueva regla",
      editRule: "Editar regla",
      deleteRule: "Eliminar regla",
      deleteCellRule: "Eliminar regla de celda",
      deleteSheetRule: "Eliminar regla de hoja",
      manageRules: "Reglas administración",
      showRules: "Muestra sus reglas de formato",
      highlightCellRules: "Resaltar reglas de celda",
      itemSelectionRules: "Reglas de selección de elementos",
      conditionformatManageRules: "Administrador de reglas de formato condicional",
      format: "Formatear",
      setFormat: "Establecer formato",
      setAs: "Establecer como",
      setAsByArea: "Para el área seleccionada, establecer",
      applyRange: "Aplicar rango",
      selectRange: "Seleccionar rango de aplicación",
      selectRange_percent: "Porcentaje del rango seleccionado",
      selectRange_average: "Valor promedio del rango seleccionado",
      selectRange_value: "Valor en el rango seleccionado",
      pleaseSelectRange: "Selecciona el rango de aplicación",
      selectDataRange: "Seleccionar rango de datos",
      selectCell: "seleccionar celda",
      pleaseSelectCell: "Selecciona una celda",
      pleaseSelectADate: "Selecciona una fecha",
      pleaseEnterInteger: "Introduzca un número entero entre 1 y 1000",
      onlySingleCell: "Solo se puede hacer referencia a una sola celda",
      conditionValueCanOnly: "El valor de la condición solo puede ser un número o una sola celda",
      ruleTypeItem1: "Aplicar formato a todas las celdas según sus valores respectivos",
      ruleTypeItem2: "Solo formatear celdas que contengan",
      ruleTypeItem2_title: "Solo para celdas que cumplan las siguientes condiciones",
      ruleTypeItem3: "Aplicar formato solo a los números superiores o inferiores",
      ruleTypeItem3_title: "Es el valor en la siguiente clasificación",
      ruleTypeItem4: "Aplicar formato solo a los valores superiores o inferiores al promedio",
      ruleTypeItem4_title: "Es un valor que cumple las siguientes condiciones",
      ruleTypeItem5: "Aplicar formato solo a valores únicos o repetidos",
      ruleTypeItem6: "Use fórmulas para determinar qué celdas formatear",
      formula: "fórmula",
      textColor: "Color Texto",
      cellColor: "Color Celda",
      confirm: "Confirma",
      confirmColor: "Confirma color",
      cancel: "Cancela",
      close: "Cierra",
      clearColorSelect: "Limpiar selección de color",
      sheet: "Hoja",
      currentSheet: "Hoja actual",
      dataBar: "Barra de datos",
      dataBarColor: "Color barra de datos",
      gradientDataBar_1: "Barra de datos de degradado azul-blanco",
      gradientDataBar_2: "Barra de datos de degradado verde-blanco",
      gradientDataBar_3: "Barra de datos de degradado rojo-blanco",
      gradientDataBar_4: "Rayas de degradado de color naranja-blanco",
      gradientDataBar_5: "Rayas de degradado azul claro-blancas",
      gradientDataBar_6: "Barra de datos de degradado púrpura-blanco",
      solidColorDataBar_1: "Barra de datos azul",
      solidColorDataBar_2: "Barra de datos verde",
      solidColorDataBar_3: "Barra de datos roja",
      solidColorDataBar_4: "Barra de datos naranja",
      solidColorDataBar_5: "Barra de datos azul claro",
      solidColorDataBar_6: "Barra de datos púrpura",
      colorGradation: "Degradado de color",
      colorGradation_1: "Gradación de color verde-amarillo-rojo",
      colorGradation_2: "Gradación de color rojo-amarillo-verde",
      colorGradation_3: "Gradación de color verde-blanco-rojo",
      colorGradation_4: "Gradación de color rojo-blanco-verde",
      colorGradation_5: "Gradación de color azul-blanco-rojo",
      colorGradation_6: "Gradación de color rojo-blanco-azul",
      colorGradation_7: "Gradación de color blanco-rojo",
      colorGradation_8: "Gradación de color rojo-blanco",
      colorGradation_9: "Gradación de color verde-blanco",
      colorGradation_10: "Gradación de color blanco-verde",
      colorGradation_11: "Gradación de color verde-amarillo",
      colorGradation_12: "Gradación de color amarillo-verde",
      icons: "iconos",
      pleaseSelectIcon: "Haz clic para seleccionar un grupo de iconos:",
      cellValue: "Valor de celda",
      specificText: "Texto específico",
      occurrenceDate: "Fecha",
      greaterThan: "Mayor que",
      lessThan: "Menor que",
      between: "Entre",
      equal: "Igual",
      in: "En",
      between2: "",
      contain: "Contiene",
      textContains: "Texto contiene",
      duplicateValue: "Valor duplicado",
      uniqueValue: "Valor Unico",
      top: "Mejor",
      top10: "10 mejores",
      top10_percent: "10% mejores",
      last: "Ultimo",
      last10: "Ultimos 10",
      last10_percent: "Ultimos 10%",
      oneself: "",
      above: "Encima",
      aboveAverage: "Encima media",
      below: "Debajo",
      belowAverage: "Debajo media",
      all: "Todos",
      yesterday: "Año a fecha",
      today: "Hoy",
      tomorrow: "Mañana",
      lastWeek: "Ultima semana",
      thisWeek: "Esta semana",
      lastMonth: "Ultimo mes",
      thisMonth: "Este mes",
      lastYear: "Ultimo año",
      thisYear: "Este año",
      last7days: "Ultimos 7 días",
      last30days: "Ultimos 30 días",
      next7days: "Siguientes 7 días",
      next30days: "Siguientes 30 días",
      next60days: "Siguientes 60 días",
      chooseRuleType: "Elige el tipo de regla",
      editRuleDescription: "Editar descripción de regla",
      newFormatRule: "Nueva regla de formato",
      editFormatRule: "Editar regla de formato",
      formatStyle: "Estilo",
      fillType: "Rellenar",
      color: "Color",
      twocolor: "Dos colores",
      tricolor: "Tricolor",
      multicolor: "Multi color",
      grayColor: "Color gris",
      gradient: "Gradiente",
      solid: "Sólido",
      maxValue: "Valor máximo",
      medianValue: "Valor mediano",
      minValue: "Valor mínimo",
      direction: "Dirección",
      threeWayArrow: "Flecha de tres direcciones",
      fourWayArrow: "Flecha de cuatro direcciones",
      fiveWayArrow: "Flecha de cinco direcciones",
      threeTriangles: "Tres triángulos",
      shape: "Forma",
      threeColorTrafficLight: "Semáforo de tres colores",
      fourColorTrafficLight: "Semáforo de cuatro colores",
      threeSigns: "Tres signos",
      greenRedBlackGradient: "Gradiente verde-rojo-negro",
      rimless: "Sin aros",
      bordered: "Bordeado",
      mark: "Marcar",
      threeSymbols: "Tres símbolos",
      tricolorFlag: "Bandera tricolor",
      circled: "Rodeado",
      noCircle: "Sin círculo",
      grade: "Grado",
      grade4: "4 Grado",
      grade5: "5 Grado",
      threeStars: "3 Estrellas",
      fiveQuadrantDiagram: "Diagrama de cinco cuadrantes",
      fiveBoxes: "5 Cajas"
    },
    dataVerification: {
      cellRange: "Rango celdas",
      selectCellRange: "Haz clic para seleccionar un rango de celdas",
      selectCellRange2: "Selecciona un rango de celdas",
      verificationCondition: "Condición de verificación",
      allowMultiSelect: "Permitir selección múltiple",
      dropdown: "lista desplegable",
      checkbox: "Casilla de verificación",
      number: "Número",
      number_integer: "Número entero",
      number_decimal: "Número decimal",
      text_content: "Contenido texto",
      text_length: "Longitud texto",
      date: "Fecha",
      validity: "Eficacia",
      placeholder1: "Introduce las opciones, separadas por comas, como 1,2,3,4,5",
      placeholder2: "Introduce contenido",
      placeholder3: "Valor numérico, como 10",
      placeholder4: "Introduce el texto especificado",
      placeholder5: "Introduce el mensaje que se muestra cuando se selecciona la celda",
      selected: "Seleccionado",
      notSelected: "No seleccionado",
      between: "Entre",
      notBetween: "No entre",
      equal: "Iqual",
      notEqualTo: "No iqual a",
      moreThanThe: "Más que el",
      lessThan: "Menos que",
      greaterOrEqualTo: "Mayor o igual a",
      lessThanOrEqualTo: "Menor o igual a",
      include: "Incluir",
      exclude: "Excluir",
      earlierThan: "Antes de",
      noEarlierThan: "No antes de",
      laterThan: "Después de",
      noLaterThan: "No después de",
      identificationNumber: "Número de identificación",
      phoneNumber: "Número de teléfono",
      remote: "Opción de adquisición remota automática",
      prohibitInput: "Prohibir la entrada cuando los datos de entrada no son válidos",
      hintShow: "Mostrar mensaje cuando se selecciona la celda",
      deleteVerification: "Eliminar verificación",
      tooltipInfo1: "La opción de la lista desplegable no puede estar vacía",
      tooltipInfo2: "El contenido de la casilla de verificación no puede estar vacío",
      tooltipInfo3: "El valor ingresado no es un tipo numérico",
      tooltipInfo4: "El segundo valor no puede ser menor que el primero",
      tooltipInfo5: "El contenido del texto no puede estar vacío",
      tooltipInfo6: "El valor ingresado no es una fecha",
      tooltipInfo7: "La segunda fecha no puede ser menor que la primera",
      textlengthInteger: "La longitud del texto debe ser un entero mayor o igual a 0"
    },
    formula: {
      sum: "Suma",
      average: "Media",
      count: "Contar",
      max: "Máx",
      min: "Mín",
      ifGenerate: "Generador de fórmula SI",
      find: "Aprender más",
      tipNotBelongToIf: "¡Esta función de celda no pertenece a la fórmula SI!",
      tipSelectCell: "Selecciona la celda para insertar la función",
      ifGenCompareValueTitle: "Valor de comparación",
      ifGenSelectCellTitle: "Haz click para seleccionar una celda",
      ifGenRangeTitle: "Rango",
      ifGenRangeTo: "a",
      ifGenRangeEvaluate: "Evaluar rango",
      ifGenSelectRangeTitle: "Haz click para seleccionar rango",
      ifGenCutWay: "Forma particionado",
      ifGenCutSame: "Mismo valor de particionado",
      ifGenCutNpiece: "Particionar por N",
      ifGenCutCustom: "Personalizado",
      ifGenCutConfirm: "Confirma",
      ifGenTipSelectCell: "Selecciona celdas",
      ifGenTipSelectCellPlace: "Por favor selecciona celdas",
      ifGenTipSelectRange: "Selecciona rango",
      ifGenTipSelectRangePlace: "Por favor selecciona rango",
      ifGenTipNotNullValue: "El valor de comparación no puede ser vacío!",
      ifGenTipLableTitile: "Etiqueta",
      ifGenTipRangeNotforNull: "El rango no puede quedar vacío!",
      ifGenTipCutValueNotforNull: "El valor de partición no puede ser vacío!",
      ifGenTipNotGenCondition: "No hay condiciones disponibles para la generación!"
    },
    formulaMore: {
      valueTitle: "Valor",
      tipSelectDataRange: "Selecciona rango de datos",
      tipDataRangeTile: "Rango de datos",
      findFunctionTitle: "Función de búsqueda",
      tipInputFunctionName: "Nombre o breve descripción de la función",
      Array: "Vector",
      Database: "Base de datos",
      Date: "Fecha",
      Engineering: "Ingeniería",
      Filter: "Filtro",
      Financial: "Financiero",
      luckysheet: "Luckysheet",
      other: "Otro",
      Logical: "Lógica",
      Lookup: "Búsqueda",
      Math: "Matemático",
      Operator: "Operadores",
      Parser: "Compilador",
      Statistical: "Estadístico",
      Text: "Texto",
      dataMining: "Minería de datos",
      selectFunctionTitle: "Selecciona una función",
      calculationResult: "Resultado",
      tipSuccessText: "Exito",
      tipParamErrorText: "Parámetro erróneo",
      helpClose: "Cerrar",
      helpCollapse: "Recoger",
      helpExample: "Ejemplo",
      helpAbstract: "Resumen",
      execfunctionError: "Error en la fórmula",
      execfunctionSelfError: "La fórmula no puede hacer referencia a su propia celda",
      execfunctionSelfErrorResult: "La fórmula no puede hacer referencia a su propia celda, lo que dará lugar a resultados de cálculo inexactos",
      allowRepeatText: "Repetir",
      allowOptionText: "Opción",
      selectCategory: "O selecciona una categoría"
    },
    drag: {
      noMerge: "No se puede realizar esta operación en celdas combinadas",
      afectarPivot: "¡Este cambio no se puede realizar en la celda seleccionada porque afectará a la tabla dinámica!",
      noMulti: "No se puede realizar esta operación en varias áreas de selección, selecciona una sola área",
      noPaste: "No se puede pegar este contenido aquí, selecciona una celda en el área de pegado e intenta pegar nuevamente",
      noPartMerge: "No se puede realizar esta operación en celdas parcialmente fusionadas",
      inputCorrect: "Introduce el valor correcto",
      notLessOne: "El número de filas y columnas no puede ser inferior a 1",
      offsetColumnLessZero: "¡La columna de desplazamiento no puede ser negativa!",
      pasteMustKeybordAlert: "在表格中进行复制粘贴: Ctrl + C 进行复制, Ctrl + V 进行粘贴, Ctrl + X 进行剪切",
      pasteMustKeybordAlertHTMLTitle: "在表格中进行复制粘贴",
      pasteMustKeybordAlertHTML: "<span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + C</span>&nbsp;&nbsp;进行复制<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + V</span>&nbsp;&nbsp;进行粘贴<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + X</span>&nbsp;&nbsp;进行剪切"
    },
    pivotTable: {
      title: "Tabla Dinámica",
      closePannel: "Cerrar",
      editRange: "Rango",
      tipPivotFieldSelected: "Selecciona los campos",
      tipClearSelectedField: "Limpiar todos los campos",
      btnClearSelectedField: "Limpiar",
      btnFilter: "Filtrar",
      titleRow: "Fila",
      titleColumn: "Columna",
      titleValue: "Valor",
      tipShowColumn: "Los campos de estadísticas se muestran como columnas",
      tipShowRow: "Los campos de estadísticas se muestran como filas",
      titleSelectionDataRange: "Selecciona rango",
      titleDataRange: "Rango de datos",
      valueSum: "SUMA",
      valueStatisticsSUM: "Suma",
      valueStatisticsCOUNT: "Contar",
      valueStatisticsCOUNTA: "Contar A",
      valueStatisticsCOUNTUNIQUE: "Contar Distintos",
      valueStatisticsAVERAGE: "Media",
      valueStatisticsMAX: "Máx",
      valueStatisticsMIN: "Mín",
      valueStatisticsMEDIAN: "Mediana",
      valueStatisticsPRODUCT: "Producto",
      valueStatisticsSTDEV: "Desviación Estándar",
      valueStatisticsSTDEVP: "Stdevp",
      valueStatisticslet: "Varianza",
      valueStatisticsVARP: "VarP",
      errorNotAllowEdit: "¡Esta operación está prohibida en el modo sin edición!",
      errorNotAllowMulti: "No se puede realizar esta operación en varias áreas de selección, selecciona un solo rango y vuelve a intentarlo",
      errorSelectRange: "Seleccione el rango de la nueva tabla dinámica",
      errorIsDamage: "¡Los datos de origen de esta tabla dinámica están dañados!",
      errorNotAllowPivotData: "¡No se puede seleccionar la tabla dinámica como datos de origen!",
      errorSelectionRange: "¡La selección falló, rango de entrada incorrecto!",
      errorIncreaseRange: "¡Por favor, expande el rango seleccionado!",
      titleAddColumn: "Añadir columna a la tabla dinámica",
      titleMoveColumn: "Muever la columna a la celda en blanco de abajo",
      titleClearColumnFilter: "Quitar el filtro de esta columna",
      titleFilterColumn: "Filtro",
      titleSort: "Ordenar",
      titleNoSort: "No Ordenar",
      titleSortAsc: "ASC",
      titleSortDesc: "DESC",
      titleSortBy: "Ordenar por",
      titleShowSum: "Mostrar total",
      titleStasticTrue: "Sí",
      titleStasticFalse: "No"
    },
    dropCell: {
      copyCell: "Copiar",
      sequence: "Secuencia",
      onlyFormat: "Solo formato",
      noFormat: "Sin formato",
      day: "Día",
      workDay: "Día Laborable",
      month: "Mes",
      year: "Año",
      chineseNumber: "Números Chinos"
    },
    imageCtrl: {
      borderTile: "Color de borde de imagen",
      borderCur: "Color"
    },
    protection: {
      protectiontTitle: "Protección",
      enterPassword: "Introduce una contraseña (opcional)",
      enterHintTitle: "Preguntar cuando la edición está prohibida (opcional)",
      enterHint: "La celda o el gráfico que estás intentando cambiar se encuentra en una hoja de trabajo protegida. Si quieres cambiarlo, desprotege la hoja de trabajo. Es posible que tengas que ingresar una contraseña",
      swichProtectionTip: "Protege la hoja y el contenido de las celdas bloqueadas",
      authorityTitle: "Permitir a los usuarios de esta hoja:",
      selectLockedCells: "Selecciona celdas bloqueadas",
      selectunLockedCells: "Selecciona celdas desbloqueadas",
      formatCells: "Formatear celdas",
      formatColumns: "Formatear columnas",
      formatRows: "Formatear filas",
      insertColumns: "Insertar columnas",
      insertRows: "Insertar filas",
      insertHyperlinks: "Insertar enlaces",
      deleteColumns: "Eliminar columnas",
      deleteRows: "Eliminar filas",
      sort: "Ordenar",
      filter: "Filtrar",
      usePivotTablereports: "Usar informes de tabla dinámica",
      editObjects: "Editar objetos",
      editScenarios: "Editar escenarios",
      allowRangeTitle: "Permitir a los usuarios del rango:",
      allowRangeAdd: "Nuevo...",
      allowRangeAddTitle: "Título",
      allowRangeAddSqrf: "Referencia",
      selectCellRange: "Haz clic para seleccionar un rango de celdas",
      selectCellRangeHolder: "Rango de celdas",
      allowRangeAddTitlePassword: "Contraseña",
      allowRangeAddTitleHint: "Pregunta",
      allowRangeAddTitleHintTitle: "Preguntar cuando hay una contraseña (opcional)",
      allowRangeAddtitleDefault: "Nombre del rango de entrada",
      rangeItemDblclick: "Haz doble clic para editar",
      rangeItemHasPassword: "Tiene contraseña",
      rangeItemErrorTitleNull: "El título es nulo",
      rangeItemErrorRangeNull: "La referencia es nula",
      rangeItemErrorRange: "La reference tiene un error",
      validationTitle: "Validación de contraseña",
      validationTips: "Hay que ingresar una contraseña para desbloquear la protección de la hoja de trabajo",
      validationInputHint: "Introduce una contraseña",
      checkPasswordNullalert: "Contraseña requerida!",
      checkPasswordWrongalert: "¡Contraseña incorrecta. Por favor, prueba de nuevo!",
      checkPasswordSucceedalert: "Desbloqueo conseguido!",
      defaultRangeHintText: "La celda está protegida con contraseña.",
      defaultSheetHintText: "La celda o el gráfico están en una hoja de trabajo protegida. Para realizar cambios, desprotege la hoja de trabajo. Es posible que tengas que ingresar una contraseña"
    },
    cellFormat: {
      cellFormatTitle: "Formatear celdas",
      protection: "Protección",
      locked: "Bloqueado",
      hidden: "Escondido",
      protectionTips: "Para bloquear celdas u ocultar fórmulas, protege la hoja de trabajo. En la barra de herramientas, haz clic en el botón Proteger hoja",
      tipsPart: "Comprobado parcial",
      tipsAll: "Todo seleccionado",
      selectionIsNullAlert: "Se requiere una selección!",
      sheetDataIsNullAlert: "error, no hay datos!"
    },
    print: {
      normalBtn: "Normal",
      layoutBtn: "Disposición de página",
      pageBtn: "Previsualización de saltos de página",
      menuItemPrint: "Imprimir (Ctrl+P)",
      menuItemAreas: "Imprimir áreas",
      menuItemRows: "Imprimir títulos de filas",
      menuItemColumns: "Imprimir títulos de columnas"
    },
    edit: {
      typing: "mecanografía"
    },
    websocket: {
      success: "Éxito de la conexión de WebSocket",
      refresh: "Se produjo un error en la conexión de WebSocket, ¡actualice la página!",
      wait: "Se produjo un error en la conexión de WebSocket, ¡tenga paciencia!",
      close: "Conexión WebSocket cerrada",
      contact: "Ocurrió un error de comunicación con el servidor, actualice la página y vuelva a intentarlo; de lo contrario, comuníquese con el administrador.",
      support: "El navegador actual no es compatible con WebSocket"
    }
  };
  var zh_tw = {
    generalDialog: {
      partiallyError: "無法對部分合併儲存格執行此操作",
      readOnlyError: "無法對只讀模式執行此操作",
      dataNullError: "無法對不存在的數據執行此操作",
      noSeletionError: "還未進行選區操作",
      cannotSelectMultiple: "無法選擇多選區"
    },
    functionlist: [{
      n: "SUMIF",
      t: 0,
      d: "對範圍中符合指定條件的值求和。",
      a: "對範圍中符合指定條件的值求和。",
      m: [2, 3],
      p: [{
        name: "範圍",
        detail: "要根據條件進行檢測的範圍。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "條件",
        detail: "要應用於範圍的模式或測試條件。\n\n如果範圍包含的是要檢測的文字,則條件必須為字串。條件可以包含萬用字元,包括用於匹配單個字元的？或用於匹配零個或連續多個字元的*。要匹配問號星號本身,請在該字元前面加上波浪號（~）首碼（即~？和~*）。字串條件必須用引號括起來。函數會檢查範圍中的每個儲存格與條件是否相等或匹配（如果使用了萬用字元）。\n\n如果範圍包含的是要檢測的數位,則條件可以是字串也可以是數位。如果給定的條件是一個數位,則檢查範圍中的每個儲存格是否等於條件。另外,條件也可能是包含數位的字串（也將對其進行相等檢測）,或者帶有以下首碼的數位:=（檢查是否相等）、>（檢查範圍儲存格的值是否大於條件值）或<（檢查範圍儲存格的值是否小於條件值）",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "求和範圍",
        detail: "要求和的範圍（如果與範圍不同）。",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TAN",
      t: 0,
      d: "返回已知角度的正切值。",
      a: "返回已知角度的正切值。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要求其正切值的角度,以弧度表示。",
        example: "45*PI()/180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TANH",
      t: 0,
      d: "返回給定實數的雙曲正切值。",
      a: "返回給定實數的雙曲正切值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其雙曲正切值的實數。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CEILING",
      t: 0,
      d: "將數值向上取整為最接近的指定因數的倍數。",
      a: "將數值向上取整為最接近的指定因數的倍數。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要向上舍入的數值。",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因數",
        detail: "要將值舍入到此數的整數倍。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN",
      t: 0,
      d: "返回數值的反正切值,以弧度表示。",
      a: "返回數值的反正切值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反正切值的數值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ASINH",
      t: 0,
      d: "返回數值的反雙曲正弦值。",
      a: "返回數值的反雙曲正弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反雙曲正弦值的數值。",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ABS",
      t: 0,
      d: "返回數值的絕對值。",
      a: "返回數值的絕對值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要返回其絕對值的數。",
        example: "-2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOS",
      t: 0,
      d: "返回數值的反余弦值,以弧度表示。",
      a: "返回數值的反余弦值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反余弦值的數值。必須介於-1和1之間,包括兩端值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACOSH",
      t: 0,
      d: "返回數值的反雙曲余弦值。",
      a: "返回數值的反雙曲余弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反雙曲余弦值的數值。必須大於等於1。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTINOMIAL",
      t: 0,
      d: "返回參數和的階乘除以各參數階乘的乘積後得到的值。",
      a: "返回參數和的階乘除以各參數階乘的乘積後得到的值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "用於計算的第一項數值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "用於計算的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "ATANH",
      t: 0,
      d: "返回數值的反雙曲正切值。",
      a: "返回數值的反雙曲正切值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反雙曲正切值的數值。必須介於-1和1之間（不包括-1和1）。",
        example: "0.9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ATAN2",
      t: 0,
      d: "以弧度為組織返回x軸與從原點（0,0）到指定座標點（`x`,`y`）之間連線的夾角。",
      a: "以弧度為組織返回x軸與從原點（0,0）到指定座標點（`x`,`y`）之間連線的夾角。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "要計算其與x軸夾角大小的線段的終點x座標。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "y",
        detail: "要計算其與x軸夾角大小的線段的終點y座標。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTBLANK",
      t: 1,
      d: "返回給定範圍內的空儲存格數。",
      a: "返回給定範圍內的空儲存格數。",
      m: [1, 1],
      p: [{
        name: "範圍",
        detail: "要統計空白儲存格數量的範圍。",
        example: "A2:C100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "COSH",
      t: 0,
      d: "返回給定實數的雙曲余弦值。",
      a: "返回給定實數的雙曲余弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其雙曲余弦值的實數值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INT",
      t: 0,
      d: "數值向下取整為小於或等於該數的最接近的整數。",
      a: "數值向下取整為小於或等於該數的最接近的整數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向下取整為最接近的整數的數值。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISEVEN",
      t: 0,
      d: "檢查所提供的數值是否為偶數。",
      a: "檢查所提供的數值是否為偶數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要驗證其是否為偶數的數值。\n\n如果值為偶數或指向包含偶數的儲存格的引用,ISEVEN將返回TRUE,否則返回FALSE。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISODD",
      t: 0,
      d: "檢查所提供的數值是否為奇數。",
      a: "檢查所提供的數值是否為奇數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要驗證其是否為奇數的數值。\n\n如果值為奇數或指向包含奇數的儲存格,ISODD將返回TRUE,否則返回FALSE。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LCM",
      t: 0,
      d: "返回一個或多個整數的最小公倍數。",
      a: "返回一個或多個整數的最小公倍數。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要在求最小公倍數數的計算中檢查其因數的第一項數值或範圍。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可選] - 在求最小公倍數時要考慮其因數的其他數值或範圍。",
        example: "3",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LN",
      t: 0,
      d: "返回數值以e（歐拉數）為底的對數。",
      a: "返回數值以e（歐拉數）為底的對數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要以e為底數計算其對數的值。\n\n值必須為正數。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG",
      t: 0,
      d: "根據指定底數返回數位的對數。",
      a: "根據指定底數返回數位的對數。",
      m: [1, 2],
      p: [{
        name: "值",
        detail: "想要計算其對數的正實數。",
        example: "128",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "底數",
        detail: "[可選] - 對數的底數。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOG10",
      t: 0,
      d: "返回數值以10為底的對數。",
      a: "返回數值以10為底的對數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其以10為底的對數的數值。\n\n值必須為正值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MOD",
      t: 0,
      d: "返回兩數相除的餘數,結果的符號與除數相同。",
      a: "返回兩數相除的餘數。",
      m: [2, 2],
      p: [{
        name: "被除數",
        detail: "要將其相除以得到餘數的數值。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "除數",
        detail: "用於除其他數的數值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MROUND",
      t: 0,
      d: "將數值取整為另一整數最接近的整數倍。",
      a: "將數值取整為另一整數最接近的整數倍。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要取整為另一整數最接近的整數倍的數值。",
        example: "21",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因數",
        detail: "值將取此因數的整數倍。",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ODD",
      t: 0,
      d: "將數值向上取整為最接近的奇整數。",
      a: "將數值向上取整為最接近的奇整數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向上取整的數值,取整值為大於此值的最接近的奇數。\n\n如果值為負數,則將其取整為絕對值大於該值的相鄰負奇數",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMSQ",
      t: 0,
      d: "返回一組數值和/或儲存格的平方總和。",
      a: "返回一組數值和/或儲存格的平方總和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要將其平方相加的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 要將其平方與值1的平方相加的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMBIN",
      t: 0,
      d: "給定集合中的對象總數和要選擇的對象數量,返回共有多少種不同選擇管道。",
      a: "給定集合中的對象總數和要選擇的對象數量",
      m: [2, 2],
      p: [{
        name: "n",
        detail: "要從中進行選擇的對象集合的大小。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "要選擇的對象數量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUM",
      t: 0,
      d: "返回一組數值和/或儲存格的總和。",
      a: "返回一組數值和/或儲存格的總和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要相加的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可選] - 要相加的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SUBTOTAL",
      t: 0,
      d: "使用指定的匯總函數,返回一系列縱向儲存格的分類匯總。",
      a: "使用指定的匯總函數",
      m: [2, 256],
      p: [{
        name: "函數程式碼",
        detail: "用於計算分類匯總的函數。\n\n1代表AVERAGE\n\n2代表COUNT\n\n3代表COUNTA\n\n4代表MAX\n\n5代表MIN\n\n6代表PRODUCT\n\n7代表STDEV\n\n8代表STDEVP\n\n9代表SUM\n\n10代表VAR\n\n11代表VARP\n\n通過在這些2位程式碼前附加10（對於1位程式碼）或1（對於2位程式碼）,可以將隱藏值忽略。例如,102代表忽略隱藏儲存格的COUNT,而110則代表忽略隱藏值的VAR。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "範圍1",
        detail: "要計算分類匯總的第一個範圍。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "範圍2",
        detail: "[可選] - 要計算分類匯總的其他範圍。",
        example: "B2:B8",
        require: "o",
        repeat: "y",
        type: "range"
      }]
    }, {
      n: "ASIN",
      t: 0,
      d: "返回數值的反正弦值,以弧度表示。",
      a: "返回數值的反正弦值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其反正弦值的數值。必須介於-1和1之間,包括兩端值。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUNTIF",
      t: 1,
      d: "返回範圍內滿足某個條件的儲存格的數量。",
      a: "返回範圍內滿足某個條件的儲存格的數量。",
      m: [2, 2],
      p: [{
        name: "範圍",
        detail: "要根據條件進行檢測的範圍。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "條件",
        detail: "要應用於範圍的模式或測試條件。\n\n如果範圍包含的是要檢測的文字,則條件必須為字串。條件可以包含萬用字元,包括用於匹配單個字元的？或用於匹配零個或連續多個字元的*。要匹配問號星號本身,請在該字元前面加上波浪號（~）首碼（即~？和~*）。字串條件必須用引號括起來。函數會檢查範圍中的每個儲存格與條件是否相等或匹配（如果使用了萬用字元）。\n\n如果範圍包含的是要檢測的數位,則條件可以是字串也可以是數位。如果給定的條件是一個數位,則檢查範圍中的每個儲存格是否等於條件。另外,條件也可能是包含數位的字串（也將對其進行相等檢測）,或者帶有以下首碼的數位:=、>、>=、<或<=,這些條件將分別用於檢查範圍中的儲存格是否等於、大於、大於等於、小於、小於等於條件值。",
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RADIANS",
      t: 0,
      d: "將以度表示的角度值轉換為弧度。",
      a: "將以度表示的角度值轉換為弧度。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要從度轉換為弧度的角度。",
        example: "180",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RAND",
      t: 0,
      d: "返回一個介於0和1之間（包括0但不包括1）的亂數。",
      a: "返回一個介於0和1之間（包括0但不包括1）的亂數。",
      m: [0, 0],
      p: []
    }, {
      n: "COUNTUNIQUE",
      t: 0,
      d: "計算一列指定值和範圍中不重複數值的個數。",
      a: "計算一列指定值和範圍中不重複數值的個數。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要檢查其是否唯一的第一個值或範圍。",
        example: "A1:C100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可選] - 要檢查是否唯一的其他值或範圍。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DEGREES",
      t: 0,
      d: "將以弧度表示的角度值轉換為度。",
      a: "將以弧度表示的角度值轉換為度。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要從弧度轉換為度的角度。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ERFC",
      t: 9,
      d: "返回數值的互補高斯誤差函數。",
      a: "返回數值的互補高斯誤差函數。",
      m: [1, 1],
      p: [{
        name: "z",
        detail: "要為其計算互補高斯誤差函數的數值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVEN",
      t: 0,
      d: "將數值向上取整為最接近的偶整數。",
      a: "將數值向上取整為最接近的偶整數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要向上取整的數值,取整值為大於此值的最接近的偶數。\n\n如果值為負數,則將其取整為絕對值大於該值的相鄰負偶數。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EXP",
      t: 0,
      d: "返回歐拉數e（~2.718）的指定次幂。",
      a: "返回歐拉數e（~2.718）的指定次幂。",
      m: [1, 1],
      p: [{
        name: "指數",
        detail: "指定e的自乘幂次值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACT",
      t: 0,
      d: "返回數值的階乘。",
      a: "返回數值的階乘。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算並返回其階乘的數位或對數位（所在儲存格）的引用。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FACTDOUBLE",
      t: 0,
      d: '返回數值的"雙階乘"。',
      a: '返回數值的"雙階乘"。',
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算並返回其雙階乘的數位或對數位（所在儲存格）的引用。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PI",
      t: 0,
      d: "返回帶有14位小數的PI值。",
      a: "返回帶有14位小數的PI值。",
      m: [0, 0],
      p: []
    }, {
      n: "FLOOR",
      t: 0,
      d: "將數值向下取整為指定因數的最接近的整數倍。",
      a: "將數值向下取整為指定因數的最接近的整數倍。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要向下舍入為因數的最接近整數倍的數值。",
        example: "23.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "因數",
        detail: "要將值舍入到此數的整數倍。\n\n因數不得為0。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GCD",
      t: 0,
      d: "返回一個或多個整數的最大公約數。",
      a: "返回一個或多個整數的最大公約數。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "要在查找最大公約數的計算中檢查其因數的第一項數值或範圍。",
        example: "A2:A5",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2",
        detail: "[可選] - 在求最大公約數時要考慮其因數的其他數值或範圍。",
        example: "96",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANDBETWEEN",
      t: 0,
      d: "返回介於兩個整數之間（包括這兩個整數）的亂數。",
      a: "返回介於兩個整數之間（包括這兩個整數）的亂數。",
      m: [2, 2],
      p: [{
        name: "下界",
        detail: "隨機值範圍的下界。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "上界",
        detail: "隨機值範圍的上界。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUND",
      t: 0,
      d: "將數位四捨五入到指定的位數。",
      a: "將數位四捨五入到指定的位數。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要四捨五入的數位。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位數",
        detail: "要進行四捨五入運算的位數。\n\n位數可以取負值,在這種情況下會將值的小數點左側部分舍入到指定的位數。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDDOWN",
      t: 0,
      d: "朝著零的方向將數位進行向下舍入。",
      a: "朝著零的方向將數位進行向下舍入。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "需要向下舍入的任意實數。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位數",
        detail: "要通過舍入達到的小數位數。\n\n位數可以取負值,在這種情況下會將值的小數點左側部分舍入到指定的位數。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ROUNDUP",
      t: 0,
      d: "朝著遠離0（零）的方向將數位進行向上舍入。",
      a: "朝著遠離0（零）的方向將數位進行向上舍入。",
      m: [2, 2],
      p: [{
        name: "值",
        detail: "要將其舍入為位數位數位的值,始終向上舍入。",
        example: "99.44",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位數",
        detail: "要通過舍入達到的小數位數。\n\n位數可以取負值,在這種情況下會將值的小數點左側部分舍入到指定的位數。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SERIESSUM",
      t: 0,
      d: "給定參數x、n、m和a,返回幂級數的和a1xn + a2x（n+m）+…+ aix（n+（i-1）m）,其中i為範圍a中的項數。",
      a: "給定參數x、n、m和a",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "幂級數的輸入值。隨相應的近似類型而變,有可能為角度、指數或其他一些值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "在幂級數中x的初始自乘幂次。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "m",
        detail: "x的幂次中的附加增量。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "a",
        detail: "包含幂級數係數的數組或範圍。",
        example: "{FACT(0)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIGN",
      t: 0,
      d: "給定輸入數值,如果為負返回-1；如果為正返回1；如果為零則返回0。",
      a: "給定輸入數值",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要返回其符號的數值。",
        example: "-42",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SIN",
      t: 0,
      d: "給定角度（以弧度表示）,返回其正弦值。",
      a: "給定角度（以弧度表示）",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要返回其正弦值的角度,以弧度表示。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SINH",
      t: 0,
      d: "返回給定實數的雙曲正弦值。",
      a: "返回給定實數的雙曲正弦值。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其雙曲正弦值的實數值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRT",
      t: 0,
      d: "返回一個正數的正平方根。",
      a: "返回一個正數的正平方根。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要計算其正平方根的數值。\n\n值必須為正數；如果為負,SQRT將返回#NUM！錯誤。",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SQRTPI",
      t: 0,
      d: "返回PI與給定正數乘積的正平方根。",
      a: "返回PI與給定正數乘積的正平方根。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "要將其與PI相乘並返回該乘積的平方根的數值\n\n值必須為正數；如果為負數,SQRTPI將返回#NUM！錯誤。",
        example: "9",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GAMMALN",
      t: 1,
      d: "返回指定伽瑪函數的以e（歐拉數）為底的對數。",
      a: "返回指定伽瑪函數的以e（歐拉數）為底的對數。",
      m: [1, 1],
      p: [{
        name: "值",
        detail: "伽瑪函數的輸入值。返回的將是伽瑪（值）的自然對數。\n\n值必須為正數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COS",
      t: 0,
      d: "返回給定角度的余弦值（角度以弧度表示）。",
      a: "返回給定角度的余弦值（角度以弧度表示）。",
      m: [1, 1],
      p: [{
        name: "角度",
        detail: "要取其余弦值的角度,以弧度表示。",
        example: "PI()",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRUNC",
      t: 0,
      d: "除指定有效位之外的部分,取數據的指定有效位。",
      a: "除指定有效位之外的部分",
      m: [1, 2],
      p: [{
        name: "值",
        detail: "要截取的數據。",
        example: "3.141592654",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "位數",
        detail: '[可選 - 預設值為0] - 小數點右側要保留的有效位數。\n\n如果位數大於值中的有效位數,則將"值"原樣返回。\n\n位數可以取負值,在這種情況下會將小數點左側指定位數的值更改為零。小數點右側的所有位數都會被捨棄。如果值的所有位都被更改為零,則TRUNC會返回0。',
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUOTIENT",
      t: 0,
      d: "返回以一個數除以另一個數所得的結果,不包含餘數。",
      a: "返回以一個數除以另一個數所得的結果",
      m: [2, 2],
      p: [{
        name: "被除數",
        detail: "要被除的數值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "除數",
        detail: "用於除其他數的數值。\n\n除數不得為0",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POWER",
      t: 0,
      d: "返回數值的指定次幂。",
      a: "返回數值的指定次幂。",
      m: [2, 2],
      p: [{
        name: "底數",
        detail: "要計算其指數次幂的數值。\n\n如果底數為負,則指數必須為整數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "指數",
        detail: "指定底數的自乘幂次值。",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMIFS",
      t: 0,
      d: "根據多項條件返回範圍之和。",
      a: "根據多項條件返回範圍之和。",
      m: [3, 257],
      p: [{
        name: "求和範圍",
        detail: "要對其求和的範圍。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "條件範圍1",
        detail: "要在哪個範圍內檢查條件1。",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "條件1",
        detail: "要應用於條件範圍1的模式或測試條件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "條件範圍2,條件2…",
        detail: "[ 可選 ] - 要檢查的其他範圍和條件。",
        example: " C1:C10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTIFS",
      t: 1,
      d: "根據多項條件返回範圍中的儲存格數量。",
      a: "根據多項條件返回範圍中的儲存格數量。",
      m: [2, 256],
      p: [{
        name: "條件範圍1",
        detail: "要在哪個範圍內檢查條件1。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "條件1",
        detail: "要應用於條件範圍1的模式或測試條件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "條件範圍2,條件2…",
        detail: "[ 可選 ] - 要檢查的其他範圍和條件,可重複。",
        example: " B1:B10",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PRODUCT",
      t: 0,
      d: "返回將一組數相乘所得的結果。",
      a: "返回將一組數相乘所得的結果。",
      m: [1, 255],
      p: [{
        name: "乘數1",
        detail: "用於計算乘積的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "乘數2 ... 乘數30",
        detail: "[可選] - 要相乘的其他數值",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HARMEAN",
      t: 1,
      d: "計算數據集的調和平均值。",
      a: "計算數據集的調和平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "HYPGEOMDIST",
      t: 1,
      d: "返回超幾何分佈。如果已知樣本量、總體成功次數和總體大小,則 HYPGEOM.DIST 返回樣本取得已知成功次數的概率。",
      a: "返回超幾何分佈。",
      m: [5, 5],
      p: [{
        name: "Sample_s",
        detail: "樣本中成功的次數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Number_sample",
        detail: "樣本量。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Population_s",
        detail: "總體中成功的次數。",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "Number_pop",
        detail: "總體大小。",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函數形式的邏輯值。\n\n如果cumulative為TRUE（）,則HYPGEOM.DIST返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INTERCEPT",
      t: 1,
      d: "計算數據集的線性回歸方程直線與 Y 軸的相交點（x=0）的y值。",
      a: "計算數據集的線性回歸方程直線與 Y 軸的相交點（x=0）的y值。",
      m: [2, 2],
      p: [{
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "KURT",
      t: 1,
      d: "計算數據集的峭度,該名額訓示數據集（分佈）的形態,尤其是該形態的陡峭程度。",
      a: "計算數據集的峭度",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "數據集中的第一個值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LARGE",
      t: 1,
      d: "返回數據集中第 n 個最大元素,n 由用戶指定。",
      a: "返回數據集中第 n 個最大元素",
      m: [2, 2],
      p: [{
        name: "數據",
        detail: "包含相關數據集的數組或範圍。",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "n",
        detail: "要返回的元素的排行位置（從大到小順序）。\n\n例如,將n設為4將使LARGE返回數據中排名第4的最大元素。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVA",
      t: 1,
      d: "基於樣本計算標準差,將文字取值為0。",
      a: "基於樣本計算標準差",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2,…",
        detail: "[可選] - 樣本中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STDEVP",
      t: 1,
      d: "基於樣本總體計算標準差。",
      a: "基於樣本總體計算標準差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "數據集中的第一個值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "GEOMEAN",
      t: 1,
      d: "計算數據集的幾何平均值。",
      a: "計算數據集的幾何平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "RANK_EQ",
      t: 1,
      d: "返回指定值在數據集中的排名。如果相同的值在數據集中存在多項,則返回其中的最高排名。",
      a: "返回指定值在數據集中的排名。如果相同的值在數據集中存在多項,則返回其中的最高排名。",
      m: [2, 3],
      p: [{
        name: "number",
        detail: "要確定其排名的值。",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "ref",
        detail: "包含相關數據集的數組或範圍。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "order",
        detail: '[可選-默認為按降序（FALSE（））] - 要按昇冪還是按降序考慮"data"中的值。',
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANK_AVG",
      t: 1,
      d: "返回指定值在數據集中的排名。如果相同的值在數據集中存在多項,則返回這些項排名的平均值。",
      a: "返回指定值在數據集中的排名。如果相同的值在數據集中存在多項,則返回這些項排名的平均值。",
      m: [2, 3],
      p: [{
        name: "number",
        detail: "要確定其排名的值。",
        example: "A10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "ref",
        detail: "包含相關數據集的數組或範圍。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "order",
        detail: '[可選-默認為按降序（FALSE（））] - 要按昇冪還是按降序考慮"data"中的值。',
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERCENTRANK_EXC",
      t: 1,
      d: "以百分數形式返回指定值在給定數據集中的百分比排名（介於0和1之間,不包括兩端值）。",
      a: "以百分數形式返回指定值在給定數據集中的百分比排名（介於0和1之間,不包括兩端值）。",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "包含相關數據集的數組或範圍。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "x",
        detail: "要確定其百分比排位的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significance",
        detail: "[可選-預設值為3] - 要在計算中使用的有效位數。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTRANK_INC",
      t: 1,
      d: "以百分比形式返回指定值在給定數據集中的百分比排名（介於0和1之間,包括兩端值）。",
      a: "以百分比形式返回指定值在給定數據集中的百分比排名（介於0和1之間,包括兩端值）。",
      m: [2, 3],
      p: [{
        name: "data",
        detail: "包含相關數據集的數組或範圍。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "x",
        detail: "要確定其百分比排位的值。",
        example: " A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "significance",
        detail: "[可選-預設值為3] - 要在計算中使用的有效位數。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FORECAST",
      t: 1,
      d: "基於數據集的線性回歸,計算指定 x 的預期 y 值。",
      a: "基於數據集的線性回歸",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "x軸上用於預測的值。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHERINV",
      t: 1,
      d: "返回指定數值的 Fisher 逆變換。",
      a: "返回指定數值的 Fisher 逆變換。",
      m: [1, 1],
      p: [{
        name: "y",
        detail: "要計算其Fisher逆變換的數值。",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FISHER",
      t: 1,
      d: "返回指定數值的 Fisher 變換。",
      a: "返回指定數值的 Fisher 變換。",
      m: [1, 1],
      p: [{
        name: "x",
        detail: "要計算其Fisher變換的數值。",
        example: "0.962",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MODE_SNGL",
      t: 1,
      d: "返回數據集中出現次數最多的值。",
      a: "返回數據集中出現次數最多的值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算模式時要檢查的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計算模式時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "WEIBULL_DIST",
      t: 1,
      d: "給定形狀和尺度,返回韋伯分佈函數（或韋伯累積分佈函數）的值。",
      a: "給定形狀和尺度",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "WEIBULL 分佈函數的輸入值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "alpha",
        detail: "Weibull 分佈函數的形狀參數。\n\n alpha值必須大於0。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "beta",
        detail: "Weibull 分佈函數的尺度參數。\n\n beta值必須大於0。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "TRUE（）表示使用累積分佈函數,FALSE（）則表示使用概率密度函數。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COUNT",
      t: 1,
      d: "返回數據集中數值的個數。",
      a: "返回數據集中數值的個數。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計數時要檢查的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計數時要檢查的其他值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COUNTA",
      t: 1,
      d: "返回數據集中值的數量。",
      a: "返回數據集中值的數量。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計數時要檢查的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計數時要檢查的其他值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVEDEV",
      t: 1,
      d: "計算數據與數據集平均值之間的偏差大小的平均值。",
      a: "計算數據與數據集平均值之間的偏差大小的平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 樣本中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "AVERAGE",
      t: 1,
      d: "返回數據集的算術平均值,對文字忽略不計。",
      a: "返回數據集的算術平均值",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算平均值時用到的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計算平均值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEA",
      t: 1,
      d: "返回數據集的算術平均值。",
      a: "返回數據集的算術平均值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算平均值時用到的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計算平均值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_DIST",
      t: 1,
      d: "返回一元二項式分佈的概率。",
      a: "返回一元二項式分佈的概率。",
      m: [4, 4],
      p: [{
        name: "number_s",
        detail: "試驗的成功次數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "trials",
        detail: "獨立檢驗的次數。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一給定檢驗的成功概率。",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "是否使用二項式累積分佈。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BINOM_INV",
      t: 1,
      d: "計算累積二項式分佈大於或等於指定條件的最小值。",
      a: "計算累積二項式分佈大於或等於指定條件的最小值。",
      m: [3, 3],
      p: [{
        name: "trials",
        detail: "貝努利試驗次數。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一次給定檢驗的成功概率。",
        example: "0.005",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "alpha",
        detail: "期望的臨界概率。",
        example: "0.8",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONFIDENCE_NORM",
      t: 1,
      d: "計算常态分配的置信區間的一半寬度。",
      a: "計算常态分配的置信區間的一半寬度。",
      m: [3, 3],
      p: [{
        name: "alpha",
        detail: "用來計算置信水准的顯著性水准。\n\n置信水准等於100*（1 - alpha）%,亦即,如果 alpha 為0.05,則置信水准為 95%。",
        example: "0.05",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "數據區域的總體標準差。",
        example: "1.6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "size",
        detail: "樣本總量的大小。",
        example: "250",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CORREL",
      t: 1,
      d: "計算給定數據集的皮爾遜積矩相關係數 r。",
      a: "計算給定數據集的皮爾遜積矩相關係數 r。",
      m: [2, 2],
      p: [{
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_P",
      t: 1,
      d: "計算數據集的總體協方差。",
      a: "計算數據集的總體協方差。",
      m: [2, 2],
      p: [{
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COVARIANCE_S",
      t: 1,
      d: "計算數據集的樣本協方差。",
      a: "計算數據集的樣本協方差。",
      m: [2, 2],
      p: [{
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEVSQ",
      t: 1,
      d: "基於樣本計算其偏差的平方和。",
      a: "基於樣本計算其偏差的平方和。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 樣本中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "EXPON_DIST",
      t: 1,
      d: "返回帶有指定 Lambda 和指定值的指數分佈函數的值。",
      a: "返回帶有指定 Lambda 和指定值的指數分佈函數的值。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "指數分佈函數的輸入值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "lambda",
        detail: "用於指定指數分佈函數的 lambda 值。",
        example: "0.5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "是否使用指數累積分佈。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIF",
      t: 1,
      d: "根據條件返回範圍的平均值。",
      a: "根據條件返回範圍的平均值。",
      m: [2, 3],
      p: [{
        name: "criteria_range",
        detail: "要對其檢查 criterion 的範圍。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion",
        detail: '要應用於criteria_range的模式或測試條件。\n\n等於:"文字" 或 1 或 "=文字" 或 "=1"\n\n大於:">1"\n\n大於等於:">=1"\n\n小於:"<1"\n\n小於等於:"<=1"\n\n不等於:"<>1"或"<>文字"',
        example: '">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "average_range",
        detail: "[可選] - 要計算平均值的範圍。如果未提供此參數,則改用criteria_range來計算平均值。",
        example: "B1:B10",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AVERAGEIFS",
      t: 1,
      d: "根據多項條件返回範圍的平均值。",
      a: "根據多項條件返回範圍的平均值。",
      m: [2, 255],
      p: [{
        name: "average_range",
        detail: "要計算平均值的範圍。",
        example: "A1:A10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range1",
        detail: "要對其檢查 criterion1 的範圍。",
        example: " B1:B10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criterion1",
        detail: "要應用於criteria_range1的模式或測試條件。",
        example: ' ">20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria_range2, criterion2, ...",
        detail: "[可選] - 要檢查的其他範圍和條件。",
        example: " C1:C10",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PERMUT",
      t: 1,
      d: "返回可從數位對象中選擇的給定數目對象的排列數。",
      a: "返回可從數位對象中選擇的給定數目對象的排列數。",
      m: [2, 2],
      p: [{
        name: "number",
        detail: "表示對象個數的整數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_chosen",
        detail: "表示每個排列中對象個數的整數。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRIMMEAN",
      t: 1,
      d: "在排除數據集高低兩端的部分數據之後計算所得的平均值。",
      a: "在排除數據集高低兩端的部分數據之後計算所得的平均值。",
      m: [2, 2],
      p: [{
        name: "數據",
        detail: "包含相關數據集的數組或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "排除比例",
        detail: "要從數據集的極值部分排除的數據占數據集的比例。\n\n排除比例必須大於等於0且小於1。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_EXC",
      t: 1,
      d: "返回數組的 K 百分點值,K 介於0到1之間,不含0與1。",
      a: "返回數組的 K 百分點值,K 介於0到1之間,不含0與1。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "定義相對位置的數組或數據區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "0 到 1 之間的百分點值,不包含 0 和 1。",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PERCENTILE_INC",
      t: 1,
      d: "返回數組的 K 百分點值,K 介於 0 到 1 之間,包含 0 與 1。",
      a: "返回數組的 K 百分點值,K 介於 0 到 1 之間,包含 0 與 1。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "定義相對位置的數組或數據區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "k",
        detail: "0 到 1 之間的百分點值,包含 0 和 1。",
        example: "0.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PEARSON",
      t: 1,
      d: "回皮爾生（Pearson）乘積矩相關係數 r。",
      a: "回皮爾生（Pearson）乘積矩相關係數 r。",
      m: [2, 2],
      p: [{
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_INV",
      t: 1,
      d: "返回標準正態累積分佈函數的反函數值。該分佈的平均值為0,標準差為1。",
      a: "返回標準正態累積分佈函數的反函數值。該分佈的平均值為0,標準差為1。",
      m: [1, 1],
      p: [{
        name: "probability",
        detail: "對應於常态分配的概率。",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_S_DIST",
      t: 1,
      d: "返回標準常态分配函數（該分佈的平均值為0,標準差為1）。",
      a: "返回標準常态分配函數（該分佈的平均值為0,標準差為1）。",
      m: [2, 2],
      p: [{
        name: "z",
        detail: "需要計算其分佈的數值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函數形式的邏輯值。\n\n如果為TRUE（）,則返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NORM_INV",
      t: 1,
      d: "返回指定平均值和標準差的正態累積分佈函數的反函數值。",
      a: "返回指定平均值和標準差的正態累積分佈函數的反函數值。",
      m: [3, 3],
      p: [{
        name: "probability",
        detail: "對應於常态分配的概率。",
        example: "0.75",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分佈的算術平均值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分佈的標準差。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NORM_DIST",
      t: 1,
      d: "返回指定平均值和標準差的常态分配函數。",
      a: "返回指定平均值和標準差的常态分配函數。",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "需要計算其分佈的數值。",
        example: "2.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分佈的算術平均值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分佈的標準差。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函數形式的邏輯值。\n\n如果為TRUE（）,則返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NEGBINOM_DIST",
      t: 1,
      d: "返回負二項式分佈。",
      a: "返回負二項式分佈。",
      m: [4, 4],
      p: [{
        name: "number_f",
        detail: "要類比的失敗次數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number_s",
        detail: "要類比的成功次數。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "probability_s",
        detail: "任一次給定檢驗的成功概率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函數形式的邏輯值。\n\n如果為TRUE（）,則返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINA",
      t: 1,
      d: "返回數據集中的最小數值。",
      a: "返回數據集中的最小數值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算最小值時所用的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可選] - 在計算最小值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MIN",
      t: 1,
      d: "返回數值數據集中的最小值。",
      a: "返回數值數據集中的最小值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算最小值時所用的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可選] - 在計算最小值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MEDIAN",
      t: 1,
      d: "返回數值數據集中的中值。",
      a: "返回數值數據集中的中值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算中值時所用的第一個數值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可選] - 在計算中值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAXA",
      t: 1,
      d: "返回數據集中的最大數值。",
      a: "返回數據集中的最大數值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算最大值時所用的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 在計算最大值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "MAX",
      t: 1,
      d: "返回數值數據集中的最大值。",
      a: "返回數值數據集中的最大值。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "計算最大值時所用的第一個值或範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2",
        detail: "[可選] - 在計算最大值時要考慮的其他數值或範圍。",
        example: "B2:B100",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_INV",
      t: 1,
      d: "返回 x 的對數累積分佈函數的反函數值。",
      a: "返回 x 的對數累積分佈函數的反函數值。",
      m: [3, 3],
      p: [{
        name: "probability",
        detail: "與對數分佈相關的概率,介於0與1之間（不含0與1）。",
        example: "0.4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "ln(x) 的平均值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "ln(x) 的標準差,正數。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LOGNORM_DIST",
      t: 1,
      d: "返回 x 的對數分佈函數。",
      a: "返回 x 的對數分佈函數。",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "用來計算函數的值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "ln(x) 的平均值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "ln(x) 的標準差,正數。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "决定函數形式的邏輯值。\n\n如果為TRUE（）,則返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "Z_TEST",
      t: 1,
      d: "返回 z 檢驗的單尾 P 值。",
      a: "返回 z 檢驗的單尾 P 值。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "用來檢驗 x 的數組或數據區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "x",
        detail: "要測試的值。",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sigma",
        detail: "[可選] - 總體（已知）標準差。如果省略,則使用樣本標準差。",
        example: "3",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PROB",
      t: 1,
      d: "返回區域中的數值落在指定區間內的概率。",
      a: "返回區域中的數值落在指定區間內的概率。",
      m: [3, 4],
      p: [{
        name: "x_range",
        detail: "具有各自相應概率值的 x 數值區域。",
        example: "A3:A6",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "prob_range",
        detail: "與 x_range 中的值相關聯的一組概率值。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "lower_limit",
        detail: "要計算其概率的數值下界。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "upper_limit",
        detail: "[可選 - 預設值為下界] - 要計算其概率的可選數值上界。\n\n如果省略上界,PROB則計算隨機選取相應值的次數恰好等於下界的概率。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_EXC",
      t: 1,
      d: "基於 0 到 1 之間（不包括 0 和 1）的百分點值返回數據集的四分位數。",
      a: "基於 0 到 1 之間（不包括 0 和 1）的百分點值返回數據集的四分位數。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "要求得四分位數值的數組或數字型儲存格區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quart",
        detail: "要返回第幾個四分位值。\n\n1返回數據中最靠近第一個四分位值的值（25%標記）。\n\n2返回數據中最接近中值的值（50%標記）。\n\n3返回數據中最接近第三個四分位值的值（75%標記）。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "QUARTILE_INC",
      t: 1,
      d: "根據 0 到 1 之間的百分點值（包含 0 和 1）返回數據集的四分位數。",
      a: "根據 0 到 1 之間的百分點值（包含 0 和 1）返回數據集的四分位數。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "要求得四分位數值的數組或數字型儲存格區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "quart",
        detail: "要返回第幾個四分位值。\n\n0返回數據中的最小值（0%標記）。\n\n1返回數據中最靠近第一個四分位值的值（25%標記）。\n\n2返回數據中最接近中值的值（50%標記）。\n\n3返回數據中最接近第三個四分位值的值（75%標記）。\n\n4返回數據中的最大值（100%標記）。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "POISSON_DIST",
      t: 1,
      d: "返回泊松分布。",
      a: "返回泊松分布。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "事件數。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "期望值。非負數",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "一 邏輯值,確定所返回的概率分佈的形式。\n\n如果為TRUE（）,則返回發生的隨機事件數在零（含零）和x（含x）之間的累積泊松概率；\n\n如果為FALSE（）,則返回發生的事件數正好是x的泊松概率密度函數。",
        example: "FALSE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RSQ",
      t: 1,
      d: "返回皮爾生(Pearson)乘積矩相關係數r的平方。",
      a: "返回皮爾生(Pearson)乘積矩相關係數r的平方。",
      m: [2, 2],
      p: [{
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST",
      t: 1,
      d: "返回學生的左尾 t 分佈。",
      a: "返回學生的左尾 t 分佈。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "T-分佈函數的輸入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度數值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "决定函數形式的邏輯值。\n\n如果cumulative為TRUE（）,則HYPGEOM.DIST返回累積分佈函數；\n\n如果為FALSE（）,則返回概率密度函數。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T_DIST_2T",
      t: 1,
      d: "返回學生的雙尾 t 分佈。",
      a: "返回學生的雙尾 t 分佈。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "T-分佈函數的輸入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度數值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_DIST_RT",
      t: 1,
      d: "返回學生的右尾 t 分佈。",
      a: "返回學生的右尾 t 分佈。",
      m: [2, 2],
      p: [{
        name: "x",
        detail: "T-分佈函數的輸入。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom",
        detail: "自由度數值。",
        example: "30",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV",
      t: 1,
      d: "返回學生的 t 分佈的左尾反函數。",
      a: "返回學生的 t 分佈的左尾反函數。",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "與學生的 t 分佈相關的概率。\n\n必須大於 0 且小於 1。",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "deg_freedom",
        detail: "自由度數值。\n\n如果所提供的參數不是整數,將截取其整數部分。\n\n必須大於等於1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_INV_2T",
      t: 1,
      d: "返回學生 t 分佈的雙尾反函數。",
      a: "返回學生 t 分佈的雙尾反函數。",
      m: [2, 2],
      p: [{
        name: "probability",
        detail: "與學生的t分佈相關的概率。\n\n必須大於 0 且小於 1。",
        example: "0.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "deg_freedom",
        detail: "自由度數值。\n\n如果所提供的參數不是整數,將截取其整數部分。\n\n必須大於等於1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "T_TEST",
      t: 1,
      d: "返回與t-檢驗相關的概率。用於判斷兩個樣本是否可能是出自平均值相同的兩個樣本總體。",
      a: "返回與t-檢驗相關的概率。用於判斷兩個樣本是否可能是出自平均值相同的兩個樣本總體。",
      m: [4, 4],
      p: [{
        name: "array1",
        detail: "將用於t檢驗的第一個數據樣本或第一組儲存格。",
        example: "A1:A4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "將用於t檢驗的第二個數據樣本或第二組儲存格。",
        example: "B1:B4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "tails",
        detail: "指定分佈的尾數。\n\n如果為 1:使用單尾分佈。\n\n如果為 2:使用雙尾分佈。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定t檢驗的類型。\n\n如果為 1:執行配對檢驗。\n\n如果為 2:執行雙樣本等方差（同方差）檢驗。\n\n如果為 3:執行雙樣本不等方差（异方差）檢驗。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "F_DIST",
      t: 1,
      d: "給定輸入值 x,計算兩個數據集的左尾 F 概率分佈（差异程度）。此分佈也稱為 Fisher-Snedecor 分佈或Snedecor F 分佈。",
      a: "給定輸入值 x",
      m: [4, 4],
      p: [{
        name: "x",
        detail: "用來計算函數的值。",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "分子自由度。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "分母自由度。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cumulative",
        detail: "用於確定函數形式的邏輯值。預設值為 FALSE。\n\n如果為 TRUE（）:F.DIST將返回累積分佈函數值。\n\n如果為FALSE（）:F.DIST將返回概率密度函數值。",
        example: "TRUE()",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "F_DIST_RT",
      t: 1,
      d: "給定輸入x,計算兩個數據集的右尾F概率分佈（差异程度）。此分佈也稱為Fisher-Snedecor分佈或Snedecor F分佈。",
      a: "給定輸入 x",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "用來計算函數的值。",
        example: "15.35",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom1",
        detail: "分子自由度。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "degrees_freedom2",
        detail: "分母自由度。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_P",
      t: 1,
      d: "基於樣本總體計算方差。",
      a: "基於樣本總體計算方差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "數據集中的第一個值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, …",
        detail: "[可選] - 數據集中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VAR_S",
      t: 1,
      d: "基於樣本計算方差。",
      a: "基於樣本計算方差。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, …",
        detail: "[可選] - 樣本中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARA",
      t: 1,
      d: "基于样本计算方差,将文本取值为0。",
      a: "基于样本计算方差",
      m: [1, 255],
      p: [{
        name: "value1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2, ...",
        detail: "[可選] - 樣本中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "VARPA",
      t: 1,
      d: "基於樣本總體計算方差,將文字取值為0。",
      a: "基於樣本總體計算方差",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "樣本中的第一項值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他數值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "STEYX",
      t: 1,
      d: "返回通過線性回歸法預測每個 x 的 y 值時所產生的標準誤差。",
      a: "返回通過線性回歸法預測每個 x 的 y 值時所產生的標準誤差。",
      m: [2, 2],
      p: [{
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "STANDARDIZE",
      t: 1,
      d: "給定分佈的平均值和標準差,計算一個隨機變數正態化的相應值。",
      a: "給定分佈的平均值和標準差,計算一個隨機變數正態化的相應值。",
      m: [3, 3],
      p: [{
        name: "x",
        detail: "要正態化的隨機變數值。",
        example: "96",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "mean",
        detail: "分佈的平均值。",
        example: "80",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "standard_dev",
        detail: "分佈的標準差。",
        example: "6.7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SMALL",
      t: 1,
      d: "返回數據集中的第k個最小值。",
      a: "返回數據集中的第k個最小值。",
      m: [2, 2],
      p: [{
        name: "array",
        detail: "需要找到第k個最小值的數組或數值數據區域。",
        example: "A2:B100",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "k",
        detail: "要返回的數據在數組或數據區域裏的位置（從小到大）。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLOPE",
      t: 1,
      d: "計算通過數據集的線性回歸得到的直線的斜率。",
      a: "計算通過數據集的線性回歸得到的直線的斜率。",
      m: [2, 2],
      p: [{
        name: "數據_y",
        detail: "代表因變數數據數組或矩陣的範圍。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "數據_x",
        detail: "代表引數數據數組或矩陣的範圍。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SKEW",
      t: 1,
      d: "返回分佈的偏斜度。偏斜度表明分佈相對於平均值的不對稱程度。正偏斜度表明分佈的不對稱尾部趨向於更多正值。負偏斜度表明分佈的不對稱尾部趨向於更多負值。",
      a: "返回分佈的偏斜度。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "數據集中的第一個值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SKEW_P",
      t: 1,
      d: "返回基於樣本總體的分佈不對稱度:表明分佈相對於平均值的不對稱程度。",
      a: "返回基於樣本總體的分佈不對稱度:表明分佈相對於平均值的不對稱程度。",
      m: [1, 255],
      p: [{
        name: "值1",
        detail: "數據集中的第一個值或範圍。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "值2, ...",
        detail: "[可選] - 數據集中包含的其他值或範圍。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "VLOOKUP",
      t: 2,
      d: "縱向查找。在範圍的第一列中自上而下蒐索某個鍵值,並返回所找到的行中指定儲存格的值。",
      a: "縱向查找。在範圍的第一列中自上而下蒐索某個鍵值",
      m: [3, 4],
      p: [{
        name: "蒐索鍵值",
        detail: '要蒐索的值,如 42、"Cats" 或 I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "範圍",
        detail: "要進行蒐索的範圍。VLOOKUP 將在該範圍的第一列中蒐索蒐索鍵值中指定的鍵值。",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "索引",
        detail: "要返回的值的列索引,範圍中的第一列編號為1。\n\n如果索引不是介於1和範圍中的列數之間,將返回#VALUE！。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "已排序",
        detail: "[預設值為TRUE()] -訓示要蒐索的列（指定範圍的第一列）是否已排序。大多數情况下,建議設為FALSE（）。\n\n建議將已排序設為FALSE。如果設為FALSE,將返回完全匹配項。如果存在多個匹配值,將返回找到的第一個值對應的儲存格的內容,如果找不到匹配值,則返回#N/A。\n\n如果將已排序設為TRUE或省略,將返回（小於或等於蒐索鍵值的）最接近的匹配項。如果蒐索的列中所有的值均大於蒐索鍵值,則返回#N/A。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HLOOKUP",
      t: 2,
      d: "橫向查找。在範圍的第一行中蒐索某個鍵值,並返回所找到的列中指定儲存格的值。",
      a: "橫向查找。在範圍的第一行中蒐索某個鍵值",
      m: [3, 4],
      p: [{
        name: "蒐索鍵值",
        detail: '要蒐索的值。例如,42、"Cats"或I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "範圍",
        detail: "要進行蒐索的範圍。將在該範圍的第一行中蒐索在蒐索鍵值中指定的鍵值。",
        example: "A2:Z6",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "索引",
        detail: "要返回的值的行索引,範圍中的第一行編號為1。\n\n如果索引不是介於1和範圍中的行數之間,將返回#VALUE！。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "已排序",
        detail: "[可選 - 預設值為TRUE()] - 訓示要蒐索的行（指定範圍的第一行）是否已排序。\n\n如果將已排序設為TRUE或省略,將返回最接近的匹配值（小於或等於蒐索鍵值）。如果在蒐索的行中所有的值均大於蒐索鍵值,則返回#N/A。\n\n如果將已排序設為TRUE或將其省略,而範圍的首行並非處於已排序狀態,則返回值可能會是錯誤的。\n\n如果將已排序設為FALSE,則僅返回完全匹配。如果存在多個匹配值,將返回與找到的第一個值對應的儲存格的內容,如果找不到匹配值則返回#N/A。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOOKUP",
      t: 2,
      d: "在行或列中查找相應鍵,並將相應儲存格的值返回到與蒐索行或列所在位置相同的結果範圍中。",
      a: "在行或列中查找相應鍵",
      m: [2, 3],
      p: [{
        name: "蒐索鍵值",
        detail: '要在行或列中蒐索的值。例如,42、"Cats" 或 I24。',
        example: "10003",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "搜索範圍 | 搜索結果數組",
        detail: "使用LOOKUP的一種方法是給定單行或單列形式的搜索範圍進行蒐索查找,這種管道要用到另一個參數結果範圍。另一種管道是將這兩個參數合併為一個搜索結果數組,其中第一行或第一列用於蒐索,並將返回值放在該數組的最後一行或最後一列中。",
        example: "A1:A100",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "結果範圍",
        detail: "[ 可選 ] - 用於存放返回結果的範圍。返回值對應於在搜索範圍中找到蒐索鍵值的位置。此範圍必須僅為單行或單列,而如果您使用的是搜索結果數組管道,則不應提供此參數。",
        example: "B1:B100",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADDRESS",
      t: 2,
      d: "返回字串形式的儲存格引用。",
      a: "返回字串形式的儲存格引用。",
      m: [2, 5],
      p: [{
        name: "row_num",
        detail: "一個數值,指定要在儲存格引用中使用的行號。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column_num",
        detail: "一個數值,指定要在儲存格引用中使用的列號（而非名稱）。A列的編號為1。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "abs_num",
        detail: "[可選 - 預設值為1] - 一個數值,指定要返回的參考類型。\n\n1表示行列均採用絕對值（例如$A$1）；\n\n2表示採用絕對行號,相對列標（例如A$1）；\n\n3表示採用相對行號,絕對列標（例如$A1）；\n\n4表示行列均採用相對值（例如A1）。",
        example: "4",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "A1",
        detail: "[可選 - 預設值為TRUE（）] - 一個布林值,訓示採用A1標記形式（TRUE）還是R1C1標記形式（FALSE）。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "sheet_text",
        detail: "[可選 - 默認預設] - 用於指定地址所指向的工作表名稱。",
        example: '"Sheet2"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "INDIRECT",
      t: 2,
      d: "返回以字串指定的儲存格引用。",
      a: "返回以字串指定的儲存格引用。",
      m: [1, 2],
      p: [{
        name: "ref_text",
        detail: "以帶引號的字串形式提供的儲存格引用。",
        example: '"Sheet2!"&B10',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "A1",
        detail: "[可選 - 預設值為TRUE（）] - 一個布林值,訓示採用A1標記形式（TRUE）還是R1C1標記形式（FALSE）。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROW",
      t: 2,
      d: "返回指定儲存格的行號",
      a: "返回指定儲存格的行號",
      m: [0, 1],
      p: [{
        name: "reference",
        detail: "[可選 - 默認為此公式所在的儲存格] - 要返回其行號的儲存格。\n\n如果儲存格引用指向的範圍其寬度大於一個儲存格,而此公式不是用作數組公式的,這時會僅返回儲存格引用中首行的編號值。",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROWS",
      t: 2,
      d: "返回指定數組或範圍中的行數。",
      a: "返回指定數組或範圍中的行數。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要返回其行數的範圍。",
        example: "A9:A62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COLUMN",
      t: 2,
      d: "按照 `A=1` 的規則返回指定儲存格的列號。",
      a: "按照 `A=1` 的規則返回指定儲存格的列號。",
      m: [0, 1],
      p: [{
        name: "reference",
        detail: "[可選 - 默認為包含此公式的儲存格] - 要返回其列號的儲存格。A列對應的編號為1。\n\n如果儲存格引用是寬度超過一個儲存格的範圍,而此公式不是作為數組公式來使用的,囙此將返回儲存格引用中的第一列的位置。",
        example: "A9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNS",
      t: 2,
      d: "返回指定數組或範圍中的列數。",
      a: "返回指定數組或範圍中的列數。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要返回其列數的範圍。",
        example: "A9:W62",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OFFSET",
      t: 2,
      d: "給定某範圍的起始儲存格引用以及該範圍涵蓋的行列數量,返回該範圍的引用。",
      a: "給定某範圍的起始儲存格引用以及該範圍涵蓋的行列數量,返回該範圍的引用。",
      m: [3, 5],
      p: [{
        name: "reference",
        detail: "用於計算行列偏移量的起點。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "rows",
        detail: "要偏移的行數。\n\n行偏移量必須是整數,但也可以是負數。如果提供的參數帶有小數,小數部分將被截去。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "要偏移的列數。\n\n列偏移量必須是整數,但也可以是負數。如果提供的參數帶有小數,小數部分將被截去。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "height",
        detail: "[可選] - 要從偏移目標開始返回的範圍的高度。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "width",
        detail: "[可選] - 要從偏移目標開始返回的範圍的寬度。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MATCH",
      t: 2,
      d: "在儲存格中蒐索指定項,然後返回該項在儲存格區域中的相對位置。",
      a: "在儲存格中蒐索指定項,然後返回該項在儲存格區域中的相對位置。",
      m: [2, 3],
      p: [{
        name: "lookup_value",
        detail: "要在 lookup_array 中匹配的值。",
        example: '"Sunday"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "lookup_array",
        detail: "要蒐索的儲存格區域。\n\n如果所用的範圍的高度和寬度均大於1,MATCH將返回#N/A！。",
        example: "A2:A9",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "match_type",
        detail: "[可選 - 預設值為1] - 要採用的蒐索管道。\n\n1為默認類型,此時MATCH會假設範圍已按昇冪排序,並返回小於等於蒐索鍵值的最大值。\n\n0表示完全匹配,在範圍未排序的情况下需要使用此管道。\n\n-1讓MATCH假設範圍是按降序排序的,並返回大於等於蒐索鍵值的最小值。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INDEX",
      t: 2,
      d: "返回表格或中的元素值,此元素由行號和列號的索引值給定。",
      a: "返回表格或中的元素值,此元素由行號和列號的索引值給定。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "儲存格區域或數組常數。",
        example: "A1:C20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "row_num",
        detail: "選擇數組中的某行,函數從該行返回數值。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "column_num",
        detail: "選擇數組中的某列,函數從該列返回數值。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GETPIVOTDATA",
      t: 2,
      d: "從與指定行和列標題對應的數據透視錶中選取匯總值。",
      a: "從與指定行和列標題對應的數據透視錶中選取匯總值。",
      m: [2, 254],
      p: [{
        name: "data_field",
        detail: '您想從數據透視錶中獲取其數據的值名稱。\n值名稱必須括在引號中或是指向包含相關文字的任何儲存格的引用。\n如果有多個值欄位,則必須使用數據透視錶中顯示的確切名稱（如"銷售總額"）。',
        example: '"SUM of number of units"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pivot_table",
        detail: "目標數據透視錶中的任何儲存格的引用（推薦位於頂角的儲存格）。",
        example: "'Pivot table'!A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "field1",
        detail: "[可選] - 源數據集（不是數據透視錶）中列的名稱。",
        example: '"division"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }, {
        name: "item1",
        detail: "[可選] - 數據透視錶中顯示的與您要檢索的欄位名稱1相對應的行或列的名稱。",
        example: '"east"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CHOOSE",
      t: 2,
      d: "基於索引返回選項清單中的元素。",
      a: "基於索引返回選項清單中的元素。",
      m: [2, 255],
      p: [{
        name: "index_num",
        detail: "指定要返回哪一項。\n\n如果索引為零、負值或大於提供的選擇數量,將返回#VALUE！錯誤。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value1",
        detail: "一項可能的返回值。必須提供。可以是儲存格引用或單獨的值。",
        example: '"A"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "[可選] - 其他可以選擇的值。選擇",
        example: '"B"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "HYPERLINK",
      t: 2,
      d: "在儲存格內創建一個超連結。",
      a: "在儲存格內創建一個超連結。",
      p: [{
        name: "網址",
        detail: "以引號括住的連結位置的完整網址,或對包含這種網址的儲存格的引用。\n\n僅允許某些連結類型。其中包括:http://、https://、mailto:、aim:、ftp://、gopher://、telnet://和news://,明確禁用使用其他協定。如果指定的是其他協定,將會在儲存格中顯示連結標籤,但該標籤不會以連結形式呈現。\n\n如果未指定協定,則假設使用http://,並將其作為網址的首碼。",
        example: '"http://www.google.com/"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "連結標籤",
        detail: '[可選-默認為網址] - 要在儲存格中作為連結顯示的文字（用引號括起來的）,或者指向包含這種標籤的儲存格的引用。\n\n如果連結標籤是指向某個空儲存格的引用,如果網址有效,就將其作為連結顯示,否則作為純文字顯示。\n\n如果連結標籤為空字串常數（""）,所在儲存格顯示的內容將為空白,但通過點擊該儲存格或轉入該儲存格仍然可以訪問連結。',
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TIME",
      t: 6,
      d: "將給定的小時、分鐘和秒轉換為時間。",
      a: "將給定的小時、分鐘和秒轉換為時間。",
      m: [3, 3],
      p: [{
        name: "小時",
        detail: "0（零）到 32767 之間的數位,代表小時。\n\n任何大於 23 的值都會除以24,餘數將作為小時值。",
        example: "11",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "分鐘",
        detail: "0（零）到 32767 之間的數位,代表分鐘。\n\n任何大於 59 的值將轉換為小時和分鐘。",
        example: "40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "秒",
        detail: "0（零）到 32767 之間的數位,代表秒。\n\n任何大於 59 的值將轉換為小時、分鐘和秒。",
        example: "59",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TIMEVALUE",
      t: 6,
      d: "按一天24小時返回該時間的分數表示。",
      a: "按一天24小時返回該時間的分數表示。",
      m: [1, 1],
      p: [{
        name: "time_text",
        detail: "用於表示時間的字串。",
        example: '"2:15 PM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EOMONTH",
      t: 6,
      d: "返回某個月份最後一天的序號,該月份在另一個日期之前或之後的數個月（月數由參數指定）。",
      a: "返回某個月份最後一天的序號",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "用於計算結果的參照日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "用於計算的起始日期之前（負）或之後（正）的月數。返回的是計算所得月份的最後那天。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EDATE",
      t: 6,
      d: "返回表示某個日期的序號,該日期在另一個日期的數月之前/之後。",
      a: "返回表示某個日期的序號",
      m: [2, 2],
      p: [{
        name: "start_date",
        detail: "用於計算結果的參照日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "months",
        detail: "用於計算的起始日期之前（負）或之後（正）的月數。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SECOND",
      t: 6,
      d: "返回時間值的秒數。秒數是0（零）到59範圍內的整數。",
      a: "返回時間值的秒數。秒數是0（零）到59範圍內的整數。",
      m: [1, 1],
      p: [{
        name: "時間",
        detail: "用於計算秒鐘部分的時間。必須為以下值之一:指向包含日期/時間值的儲存格的引用、返回日期/時間的函數或者數位。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MINUTE",
      t: 6,
      d: "以數位格式返回特定時間的分鐘部分。",
      a: "以數位格式返回特定時間的分鐘部分。",
      m: [1, 1],
      p: [{
        name: "時間",
        detail: "用於計算分鐘部分的時間。必須為以下值之一:指向包含日期/時間值的儲存格的引用、返回日期/時間的函數或者數位。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HOUR",
      t: 6,
      d: "以數位格式返回特定時間的小時部分。",
      a: "以數位格式返回特定時間的小時部分。",
      m: [1, 1],
      p: [{
        name: "時間",
        detail: "用於計算小時部分的時間。必須為以下值之一:指向包含日期/時間值的儲存格的引用、返回日期/時間的函數或者數位。",
        example: "TIME(11",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOW",
      t: 6,
      d: "以日期值格式返回當前日期和時間。",
      a: "以日期值格式返回當前日期和時間。",
      m: [0, 0],
      p: []
    }, {
      n: "NETWORKDAYS",
      t: 6,
      d: "返回所提供的兩個日期之間的淨工作日天數。",
      a: "返回所提供的兩個日期之間的淨工作日天數。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "用於計算淨工作日天數的時間段開始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "用於計算淨工作日天數的時間段結束日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[可選] - 一個範圍或數組常數,其中包含作為節假日的日期序號。\n\n在節假日數組中提供的值必須是日期序號值（例如由N所返回的值）或日期值（例如由DATE、DATEVALUE或TO_DATE返回的值）。由範圍指定的值應該是標準的日期值或日期序數值。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NETWORKDAYS_INTL",
      t: 6,
      d: "返回給定的兩個日期之間的淨工作日天數（排除指定的週末和節假日）。",
      a: "返回給定的兩個日期之間的淨工作日天數（排除指定的週末和節假日）。",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "用於計算淨工作日天數的時間段開始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "用於計算淨工作日天數的時間段結束日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "weekend",
        detail: '[可選-預設值為1] - 用於表示哪些天為週末的數位或字串。\n字串管道:可以使用由0和1組成的字串來指定週末,串中的第一個數位字元代表週一,最後一個則代表周日。零表示這一天是工作日,1 表示這一天為週末。例如,"0000011"表示將週六和周日作為週末。\n數位管道:這種管道不使用上述字串形式,而是使用一個數位。1 =週六/周日為週末,2 =周日/週一為週末,依此類推則7 =週五/週六。11 =周日為唯一週末,12 =週一為唯一週末,依此類推則17 =週六為唯一週末。',
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[可選] - 這是一個範圍或數組常數,其中包含作為節假日的日期。\n在節假日數組內提供的值必須為日期序數值（例如N的返回值）或日期值（例如DATE、DATEVALUE或TO_DATE的返回值）。由範圍指定的值應該是標準的日期值或日期序數值。",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISOWEEKNUM",
      t: 6,
      d: "返回給定日期在全年中的 ISO 周數。",
      a: "返回給定日期在全年中的 ISO 周數。",
      m: [1, 1],
      p: [{
        name: "date",
        detail: "用於日期和時間計算的日期-時間程式碼。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WEEKNUM",
      t: 6,
      d: "返回特定日期的周數。",
      a: "返回特定日期的周數。",
      m: [1, 2],
      p: [{
        name: "serial_number",
        detail: "要確定其位於第幾周的日期,必須是對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "return_type",
        detail: "[可選-預設值為1 ] - 代表一周起始日的數位,系統也使用該數位來確定一年的第一周（1=周日,2=週一）。",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "WEEKDAY",
      t: 6,
      d: "返回一個數位,對應於給定日期所在的星期幾。",
      a: "返回一個數位,對應於給定日期所在的星期幾。",
      m: [1, 2],
      p: [{
        name: "serial_number",
        detail: "要為其確定星期幾的日期。必須是對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "return_type",
        detail: "[可選-預設值為1] -以數位訓示使用哪種編號順序來表示星期幾。默認情况下,按星期日（= 1）開始計算。\n\n如果類型為1,則星期值將從星期日開始算起,並且星期日的值為1,囙此星期六的值就是7。\n\n如果類型為2,則星期值將從星期一開始算起,並且星期一的值為1,囙此星期日的值就是7。\n\n如果類型為3,則星期值將從星期一算起,並且星期一的值為0,囙此星期日的值就是6。",
        example: "7",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DAY",
      t: 6,
      d: "以數位格式返回特定日期所在的當月幾號。",
      a: "以數位格式返回特定日期所在的當月幾號。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "要從中選取具體幾號的日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS",
      t: 6,
      d: "返回兩個日期之間的天數。",
      a: "返回兩個日期之間的天數。",
      m: [2, 2],
      p: [{
        name: "end_date",
        detail: "計算中要使用的結束日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "2011-3-15",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_date",
        detail: "計算中要使用的開始日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "2011-2-1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DAYS360",
      t: 6,
      d: "按照每年360天,返回兩個日期之間的差（用於計算利息）。",
      a: "按照每年360天,返回兩個日期之間的差（用於計算利息）。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "計算中要使用的開始日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "計算中要使用的結束日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "method",
        detail: "[可選 - 默認為FALSE（）] - 訓示要使用哪種天數計算方法。\n\nFALSE -採用美國（NASD）方法時,如果起始日期為某月的最後一天,為便於計算,會將起始日期的當月幾號更改為30。此外,如果結束日期是所在月份的最後一天,而且起始日期在其所在月的30號之前,則將結束日期更改為結束日期之後那個月的第一天,否則將結束日期更改為該月的30號。\n\nTRUE -採用歐洲方法時,會將所有日期在31號的起始日期或結束日期更改為當月的30號。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATE",
      t: 6,
      d: "將提供的年、月、日轉換為日期。",
      a: "將提供的年、月、日轉換為日期。",
      m: [3, 3],
      p: [{
        name: "year",
        detail: "日期的年份部分,包含一到四位數位。\n\n介於0（零）到 1899 之間,會將該值與 1900 相加來計算年份；\n\n介於 1900 到 9999 之間,將使用該數值作為年份；\n\n小於0或大於等於 10000,返回錯誤值#NUM！。",
        example: "1969",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "日期的月份部分,一個正整數或負整數。\n\n如果 month 大於 12,則 month 會將該月份數與指定年中的第一個月相加。\n\n如果 month 小於 1,month 則從指定年份的一月份開始遞減該月份數,然後再加上 1 個月。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "day",
        detail: "日期的日部分,一個正整數或負整數。\n\n如果 day 大於月中指定的天數,則 day 會將天數與該月中的第一天相加。\n\n如果 day 小於1,則 day 從指定月份的第一天開始遞減該天數,然後再加上 1 天。",
        example: "20",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATEVALUE",
      t: 6,
      d: "將提供的日期字串轉換為日期的序號。",
      a: "將提供的日期字串轉換為日期的序號。",
      m: [1, 1],
      p: [{
        name: "date_text",
        detail: "表示日期的字串。",
        example: '"1969-7-20"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DATEDIF",
      t: 6,
      d: "計算兩個日期之間的天數、月數或年數。",
      a: "計算兩個日期之間的天數、月數或年數。",
      m: [3, 3],
      p: [{
        name: "起始日期",
        detail: "計算中要使用的開始日期。必須是對包含DATE值的儲存格的引用、返回DATE類型的函數或數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "結束日期",
        detail: "計算中要使用的結束日期。必須是對包含DATE值的儲存格的引用、返回DATE類型的函數或數位。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "組織",
        detail: '時間組織的縮寫文字。例如"M"代表月。有效值包括:"Y"、"M"、"D"、"MD"、"YM"和"YD"。\n\n"Y":返回起始日期和結束日期之間的整年數。\n\n"M":返回起始日期和結束日期之間的整月數。\n\n"D":返回起始日期和結束日期之間的天數。\n\n"MD":返回起始日期和結束日期之間的天數（不計整月數）。\n\n"YM":返回起始日期和結束日期之間的整月數（不計整年數）。\n\n"YD":返回起始日期和結束日期之間的天數（假設起始日期和結束日期的間隔不超過一年）。',
        example: "16)",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY",
      t: 6,
      d: "指定工作日天數,計算結束日期。",
      a: "指定工作日天數,計算結束日期。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "計算的開始日期。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "days",
        detail: "start_date之前或之後不含週末及節假日的天數。\n\n為正值將生成未來日期；\n\n為負值生成過去日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "holidays",
        detail: "[可選] - 一個範圍或數組常數,其中包含作為節假日的日期序號。\n\n在節假日數組中提供的值必須是日期序號值（例如由N所返回的值）或日期值（例如由DATE、DATEVALUE或TO_DATE返回的值）。由範圍指定的值應該是標準的日期值或日期序數值。",
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "WORKDAY_INTL",
      t: 6,
      d: "返回指定的若干個工作日之前或之後的日期的序號（使用自定義週末參數）。 ",
      a: "返回指定的若干個工作日之前或之後的日期的序號（使用自定義週末參數）。 ",
      m: [2, 4],
      p: [{
        name: "start_date",
        detail: "開始日期（將被截尾取整）。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "days",
        detail: "start_date之前或之後的工作日的天數。\n\n正值表示未來日期；\n\n負值表示過去日期；\n\n零值表示開始日期。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "weekend",
        detail: '[可選 - 預設值為1] - 用於表示哪些天為週末的數位或字串。\n字串管道:可以使用由0和1組成的字串來指定週末,串中的第一個數位字元代表週一,最後一個則代表周日。零表示這一天是工作日,1表示這一天為週末。例如,"0000011"表示將週六和周日作為週末。\n數位管道:這種管道不使用上述字串形式,而是使用一個數位。1 =週六/周日為週末,2 =周日/週一為週末,依此類推則7 =週五/週六。11 =周日為唯一週末,12 =週一為唯一週末,依此類推則17 =週六為唯一週末。',
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "holidays",
        detail: "[可選] - 這是一個範圍或數組常數,其中包含作為節假日的日期。\n在節假日數組內提供的值必須為日期序數值（例如N的返回值）或日期值（例如DATE、DATEVALUE或TO_DATE的返回值）。由範圍指定的值應該是標準的日期值或日期序數值。",
        example: "DATE(1969",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEAR",
      t: 6,
      d: "返回對應於某個日期的年份。Year作為 1900 - 9999 之間的整數返回。",
      a: "返回對應於某個日期的年份。Year作為 1900 - 9999 之間的整數返回。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "用於計算年份的日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "YEARFRAC",
      t: 6,
      d: "返回 start_date 和 end_date 之間的天數占全年天數的百分比。",
      a: "返回 start_date 和 end_date 之間的天數占全年天數的百分比。",
      m: [2, 3],
      p: [{
        name: "start_date",
        detail: "計算中要使用的開始日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "end_date",
        detail: "計算中要使用的結束日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "7",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 要使用的日計數基準類型。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "16)",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TODAY",
      t: 6,
      d: "以日期值格式返回當前日期。",
      a: "以日期值格式返回當前日期。",
      m: [0, 0],
      p: []
    }, {
      n: "MONTH",
      t: 6,
      d: "返回日期（以序列數表示）中的月份。月份是介於1（一月）到12（十二月）之間的整數。",
      a: "返回日期（以序列數表示）中的月份。月份是介於1（一月）到12（十二月）之間的整數。",
      m: [1, 1],
      p: [{
        name: "serial_number",
        detail: "要從中選取月份的日期。必須是以下一種:對包含日期的儲存格的引用、返回日期類型的函數或者數位。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EFFECT",
      t: 8,
      d: "根據名義利率及每年的複利計息期數來計算實際年利率。",
      a: "根據名義利率及每年的複利計息期數來計算實際年利率。",
      m: [2, 2],
      p: [{
        name: "nominal_rate",
        detail: "每年的名義利率。",
        example: "0.99",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "npery",
        detail: "每年的複利計算期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLAR",
      t: 12,
      d: "將數位格式設定為與語言區域相對應的貨幣格式。",
      a: "將數位格式設定為與語言區域相對應的貨幣格式。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: "要設定格式的值。",
        example: "1.2351",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "decimals",
        detail: "[可選 - 預設值為2] - 要顯示的小數位數。\n\n如果這是負數,則將數位四捨五入到小數點左側。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARDE",
      t: 8,
      d: "將以整數部分和分數部分轉換為以小數部分表示的金額數位",
      a: "將以整數部分和分數部分轉換為以小數部分表示的金額數位",
      m: [2, 2],
      p: [{
        name: "fractional_dollar",
        detail: "以整數部份和分數部分表示的數位,用小數點隔開。",
        example: "100.10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fraction",
        detail: "用作分數中的分母的整數。",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DOLLARFR",
      t: 8,
      d: "將小數轉換為分數表示的金額數位。",
      a: "將小數轉換為分數表示的金額數位。",
      m: [2, 2],
      p: [{
        name: "decimal_dollar",
        detail: "小數。",
        example: "100.125",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fraction",
        detail: "用作分數中的分母的整數。",
        example: "32",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DB",
      t: 8,
      d: "使用固定餘額遞減法,返回指定期間內某項固定資產的折舊值。",
      a: "使用固定餘額遞減法,返回指定期間內某項固定資產的折舊值。",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "資產原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折舊末尾時的值（有時也稱為資產殘值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "資產的折舊期數（有時也稱作資產的使用壽命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限內要計算折舊的折舊期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "month",
        detail: "[可選 - 預設值為12] - 折舊第一年中的月數。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DDB",
      t: 8,
      d: "用雙倍餘額遞減法,返回指定期間內某項固定資產的折舊值。",
      a: "用雙倍餘額遞減法,返回指定期間內某項固定資產的折舊值。",
      m: [4, 5],
      p: [{
        name: "cost",
        detail: "资产原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折舊末尾時的值（有時也稱為資產殘值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "資產的折舊期數（有時也稱作資產的使用壽命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限內要計算折舊的折舊期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "factor",
        detail: "[可選 - 預設值為2] - 折舊的遞減係數。",
        example: "2.25",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RATE",
      t: 8,
      d: "返回年金每期的利率。",
      a: "返回年金每期的利率。",
      m: [3, 6],
      p: [{
        name: "nper",
        detail: "年金的付款總期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "每期的付款金額,在年金週期內不能更改。",
        example: "-100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值即一系列未來付款當前值的總和。",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選 - 預設值為0] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "guess",
        detail: "[可選 - 預設值為0.1] - 預期利率。",
        example: "0.1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CUMPRINC",
      t: 8,
      d: "基於等額分期付款和固定利率,計算投資在多個付款期內的累計本金償還額。",
      a: "基於等額分期付款和固定利率,計算投資在多個付款期內的累計本金償還額。",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "總付款期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "年金的現值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_period",
        detail: "開始累計計算的付款期序號。\n\n首期必須大於等於1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_period",
        detail: "結束累計計算的付款期序號。\n\n末期必須大於首期。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNUM",
      t: 8,
      d: "返回在結算日和到期日之間的付息次數，向上舍入到最近的整數",
      a: "返回在結算日和到期日之間的付息次數，向上舍入到最近的整數",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "02",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SYD",
      t: 8,
      d: "返回在指定期間內資產按年限總和折舊法計算的折舊。",
      a: "返回在指定期間內資產按年限總和折舊法計算的折舊。",
      m: [4, 4],
      p: [{
        name: "cost",
        detail: "資產原值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折舊末尾時的值（有時也稱為資產殘值）。",
        example: "50",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "資產的折舊期數（有時也稱作資產的使用壽命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "period",
        detail: "在使用期限內要計算折舊的折舊期。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLEQ",
      t: 8,
      d: "基於貼現率計算美國政府短期債券的等效年化收益率。",
      a: "基於貼現率計算美國政府短期債券的等效年化收益率。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "債券的結算日期,此日期為債券發行後交付給買家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "債券的到期或結束日期,届時可將其以面值或票面價值贖回。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "債券購買時的貼現率。",
        example: "2)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLYIELD",
      t: 8,
      d: "基於價格計算美國政府短期債券的收益率。",
      a: "基於價格計算美國政府短期債券的收益率。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "債券的結算日期,此日期為債券發行後交付給買家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "債券的到期或結束日期,届時可將其以面值或票面價值贖回。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "債券的購買價格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TBILLPRICE",
      t: 8,
      d: "基於貼現率計算美國政府短期債券的價格。",
      a: "基於貼現率計算美國政府短期債券的價格。",
      m: [3, 3],
      p: [{
        name: "settlement",
        detail: "債券的結算日期,此日期為債券發行後交付給買家的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "債券的到期或結束日期,届時可將其以面值或票面價值贖回。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "債券購買時的貼現率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PV",
      t: 8,
      d: "基於等額分期付款和固定利率,計算年金投資的現值。",
      a: "基於等額分期付款和固定利率,計算年金投資的現值。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款總期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "每期的付款金額,在年金週期內不能更改。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "D2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ACCRINT",
      t: 8,
      d: "返回定期付息證券的應計利息。",
      a: "返回定期付息證券的應計利息。",
      m: [6, 8],
      p: [{
        name: "issue",
        detail: "有價證券的發行日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "first_interest",
        detail: "有價證券的首次計息日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有價證券的年息票利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "par",
        detail: "證券的票面值。",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示""歐洲30/360"方法"-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "calc_method",
        detail: "[可選 - 默認為TRUE（）] - 一個邏輯值,指定當結算日期晚於首次計息日期時用於計算總應計利息的方法。\n\n如果值為TRUE,則返回從發行日到結算日的總應計利息。\n\n如果值為FALSE,則返回從首次計息日到結算日的應計利息。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ACCRINTM",
      t: 8,
      d: "返回在到期日支付利息的有價證券的應計利息。",
      a: "返回在到期日支付利息的有價證券的應計利息。",
      m: [4, 5],
      p: [{
        name: "issue",
        detail: "有價證券的發行日。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "settlement",
        detail: "有價證券的到期日。",
        example: "DATE(1969",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有價證券的年息票利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "par",
        detail: "證券的票面值。",
        example: "1000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYBS",
      t: 8,
      d: "返回從付息期開始到結算日的天數。",
      a: "返回從付息期開始到結算日的天數。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYS",
      t: 8,
      d: "返回結算日所在的付息期的天數。",
      a: "返回結算日所在的付息期的天數。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] -訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPDAYSNC",
      t: 8,
      d: "返回從結算日到下一票息支付日之間的天數。",
      a: "返回從結算日到下一票息支付日之間的天數。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法  - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPNCD",
      t: 8,
      d: "計算結算日之後的下一票息或利息派發日期。",
      a: "計算結算日之後的下一票息或利息派發日期。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COUPPCD",
      t: 8,
      d: "計算結算日之前的最後一個票息或利息支付日。",
      a: "計算結算日之前的最後一個票息或利息支付日。",
      m: [3, 4],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4 。",
        example: "01)",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "DATE(2019",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FV",
      t: 8,
      d: "基於等額分期付款和固定利率,計算年金投資的未來價值。",
      a: "基於等額分期付款和固定利率,計算年金投資的未來價值。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款總期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "各期所應支付的金額,在整個年金期間保持不變。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "[可選 - 預設值為0 ] - 現值,或一系列未來付款的當前值的累積和。",
        example: "400",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0 ] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FVSCHEDULE",
      t: 8,
      d: "返回應用一系列複利率計算的初始本金的未來值。",
      a: "返回應用一系列複利率計算的初始本金的未來值。",
      m: [2, 2],
      p: [{
        name: "principal",
        detail: "現值。",
        example: "10000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "schedule",
        detail: "用於計算本金複利的一組利率。\n\n利率錶必須是範圍或數組,其中包含要用於計算複利的一組利率。這些利率值應該以十進位小數形式表示,或者使用UNARY_PERCENT以百分比形式表示,即表示為0.09或UNARY_PERCENT（9）,而不要表示為9。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "YIELD",
      t: 8,
      d: "返回定期支付利息的債券的收益率。",
      a: "返回定期支付利息的債券的收益率。",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有價證券的年息票利率。",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pr",
        detail: "有價證券的價格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有價證券的清償價值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法 - 此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "YIELDDISC",
      t: 8,
      d: "基於價格計算折價發行的（不帶息）債券的年收益率。",
      a: "基於價格計算折價發行的（不帶息）債券的年收益率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "有價證券的價格。",
        example: "95",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有價證券的清償價值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法 - 此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NOMINAL",
      t: 8,
      d: "基於給定的實際利率和年複利期數,返回名義年利率。",
      a: "基於給定的實際利率和年複利期數,返回名義年利率。",
      m: [2, 2],
      p: [{
        name: "effect_rate",
        detail: "每年的實際利率。",
        example: "0.85",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "npery",
        detail: "每年的複利期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "XIRR",
      t: 8,
      d: "返回一組不一定定期發生的現金流的內部收益率。",
      a: "返回一組不一定定期發生的現金流的內部收益率。",
      m: [2, 3],
      p: [{
        name: "values",
        detail: "其中含有投資相關收益或支出的數組或範圍。\n\n現金流數額中必須至少包含一項負的和一項正的現金流金額才能計算回報率。",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "dates",
        detail: "與現金流數額參數中的現金流對應的日期數組或範圍。",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "guess",
        detail: "[可選 - 預設值為0.1] - 對內部回報率的估算值。",
        example: "250",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MIRR",
      t: 8,
      d: "返回一系列定期現金流的修改後內部收益率。",
      a: "返回一系列定期現金流的修改後內部收益率。",
      m: [3, 3],
      p: [{
        name: "values",
        detail: "其中含有投資相關收益或支出的數組或範圍。\n\n現金流數額中必須至少包含一項負的和一項正的現金流金額才能計算回報率。",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "finance_rate",
        detail: "現金流中使用的資金支付的利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "reinvest_rate",
        detail: "將現金流再投資的收益率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IRR",
      t: 8,
      d: "返回由值中的數位表示的一系列現金流的內部收益率。 ",
      a: "返回由值中的數位表示的一系列現金流的內部收益率。 ",
      m: [1, 2],
      p: [{
        name: "values",
        detail: "其中含有投資相關收益或支出的數組或範圍。\n\n現金流數額中必須至少包含一項負的和一項正的現金流金額才能計算回報率。",
        example: "A2:A25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "guess",
        detail: "[可選 - 默認為0.1] - 內部收益率的估值。",
        example: "200",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPV",
      t: 8,
      d: "使用貼現率和一系列未來支出（負值）和收益（正值）來計算一項投資的淨現值。",
      a: "使用貼現率和一系列未來支出（負值）和收益（正值）來計算一項投資的淨現值。",
      m: [2, 255],
      p: [{
        name: "rate",
        detail: "某一期間的貼現率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value1",
        detail: "第一筆支出（負值）和收益（正值）。",
        example: "200",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2, ...",
        detail: "[可選] - 其他支出（負值）和收益（正值）。",
        example: "250",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "XNPV",
      t: 8,
      d: "返回一組現金流的淨現值,這些現金流不一定定期發生。",
      a: "返回一組現金流的淨現值,這些現金流不一定定期發生。",
      m: [3, 3],
      p: [{
        name: "rate",
        detail: "應用於現金流的貼現率。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "values",
        detail: "與dates中的支付時間相對應的一系列現金流。",
        example: "B2:B25",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "dates",
        detail: "與現金流支付相對應的支付日期錶。",
        example: "C2:C25",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CUMIPMT",
      t: 8,
      d: "基於等額分期付款和固定利率,計算投資在一系列付款期內的累計利息。",
      a: "基於等額分期付款和固定利率,計算投資在一系列付款期內的累計利息。",
      m: [6, 6],
      p: [{
        name: "rate",
        detail: "利息率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "總付款期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start_period",
        detail: "開始累計計算的付款期序號。\n\n首期必須大於等於1。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "end_period",
        detail: "結束累計計算的付款期序號。\n\n末期必須大於首期。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "0",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PMT",
      t: 8,
      d: "用於根據固定付款額和固定利率計算貸款的付款額。",
      a: "用於根據固定付款額和固定利率計算貸款的付款額。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "貸款利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "該項貸款的付款總數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值,或一系列未來付款額現在所值的總額,也叫本金。",
        example: " 100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選 - 預設值為0] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "D2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IPMT",
      t: 8,
      d: "基於固定利率及等額分期付款管道,返回給定期數內對投資的利息償還額。",
      a: "基於固定利率及等額分期付款管道,返回給定期數內對投資的利息償還額。",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "per",
        detail: "用於計算其利息數額的期數,必須在1到nper之間。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款總期數。",
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值,或一系列未來付款的當前值的累積和。",
        example: "80000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選 - 預設值為0] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "E2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PPMT",
      t: 8,
      d: "返回根據定期固定付款和固定利率而定的投資在已知期間內的本金償付額。",
      a: "返回根據定期固定付款和固定利率而定的投資在已知期間內的本金償付額。",
      m: [4, 6],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "per",
        detail: "指定期數,該值必須在 1 到 nper 範圍內。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "nper",
        detail: "年金的付款總期數。",
        example: "3*12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值即一系列未來付款當前值的總和。",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選 - 預設值為0] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "INTRATE",
      t: 8,
      d: "返回完全投資型證券的利率。",
      a: "返回完全投資型證券的利率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "有價證券的投資額。",
        example: "100000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "有價證券到期時的兌換值。",
        example: "101200",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法-此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法 - 此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法-此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICE",
      t: 8,
      d: "返回定期付息的面值￥100的有價證券的價格。",
      a: "返回定期付息的面值￥100的有價證券的價格。",
      m: [6, 7],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有價證券的年息票利率。",
        example: "0.057",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有價證券的年收益率。",
        example: "0.065",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值￥100的有價證券的清償價值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEDISC",
      t: 8,
      d: "返回折價發行的面值￥100的有價證券的價格。",
      a: "返回折價發行的面值￥100的有價證券的價格。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "discount",
        detail: "有价证券的贴现率。",
        example: "0.0525",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值￥100的有價證券的清償價值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "PRICEMAT",
      t: 8,
      d: "返回到期付息的面值￥100的有價證券的價格。",
      a: "返回到期付息的面值￥100的有價證券的價格。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "issue",
        detail: "有價證券的發行日。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "rate",
        detail: "有價證券在發行日的利率。",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有價證券的年收益率。",
        example: "0.061",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RECEIVED",
      t: 8,
      d: "返回一次性付息的有價證券到期收回的金額。",
      a: "返回一次性付息的有價證券到期收回的金額。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "investment",
        detail: "有價證券的投資額。",
        example: "10000000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "discount",
        detail: "有價證券的貼現率。",
        example: "0.0575",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DISC",
      t: 8,
      d: "返回有價證券的貼現率。",
      a: "返回有價證券的貼現率。",
      m: [4, 5],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "pr",
        detail: "有價證券的價格（按面值為￥100計算）。",
        example: "97.975",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "redemption",
        detail: "面值￥100的有價證券的清償價值。",
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "12",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "NPER",
      t: 8,
      d: "基於固定利率及等額分期付款管道,返回某項投資的總期數。",
      a: "基於固定利率及等額分期付款管道,返回某項投資的總期數。",
      m: [3, 5],
      p: [{
        name: "rate",
        detail: "各期利率。",
        example: "0.12",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pmt",
        detail: "各期所應支付的金額,在整個年金期間保持不變。",
        example: "500",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "pv",
        detail: "現值,或一系列未來付款的當前值的累積和。",
        example: "40000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "fv",
        detail: "[可選 - 預設值為0] - 未來值,或在最後一次付款後希望得到的現金餘額。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "type",
        detail: "[可選 - 預設值為0] - 指定各期的付款時間是在期初還是期末。\n\n0表示期末；\n\n1表示期初。",
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SLN",
      t: 8,
      d: "返回一個期間內的資產的直線折舊。",
      a: "返回一個期間內的資產的直線折舊。",
      m: [3, 3],
      p: [{
        name: "cost",
        detail: "資產原值。",
        example: "300000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "salvage",
        detail: "折舊末尾時的值（有時也稱為資產殘值）。",
        example: "75000",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "life",
        detail: "資產的折舊期數（有時也稱作資產的使用壽命）。",
        example: "10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DURATION",
      t: 8,
      d: "返回假設面值￥100的定期付息有價證券的修正期限。",
      a: "返回假設面值￥100的定期付息有價證券的修正期限。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "coupon",
        detail: "有價證券的年息票利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有價證券的年收益率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MDURATION",
      t: 8,
      d: "返回假設面值￥100的有價證券的Macauley修正期限。",
      a: "返回假設面值￥100的有價證券的Macauley修正期限。",
      m: [5, 6],
      p: [{
        name: "settlement",
        detail: "有價證券的結算日。有價證券結算日是在發行日之後,有價證券賣給購買者的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "maturity",
        detail: "有價證券的到期日。到期日是有價證券有效期截止時的日期。",
        example: "DATE(2010",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "coupon",
        detail: "有價證券的年息票利率。",
        example: "0.08",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "yld",
        detail: "有價證券的年收益率。",
        example: "0.09",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "frequency",
        detail: "年付息次數。\n\n如果按年支付,frequency = 1；\n\n按半年期支付,frequency = 2；\n\n按季支付,frequency = 4。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "basis",
        detail: '[可選 - 默認為0] - 訓示要使用哪種天數計算方法。\n\n0表示"美國（NASD）30/360"方法 - 此方法按照美國全國證券交易商協會標準,假設每月30天、每年360天,並對所輸入的月末日期進行具體調整。\n\n1表示"實際/實際"方法-此方法計算基於指定日期之間的實際天數和所涉及的年份中的實際天數進行計算。此方法用於美國長期債券,也是在非財經用途方面使用最多的方法。\n\n2表示"實際/360"方法 - 此方法基於指定日期之間的實際天數進行計算, 但假定每年為360天。\n\n3表示"實際/365"方法 - 此方法基於指定日期之間的實際天數進行計算,但假定每年為365天。\n\n4表示"歐洲30 / 360"方法-類似於0,此方法基於每月30天、每年360天進行計算,但按照歐洲金融慣例對月末日期進行調整。',
        example: "0",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2DEC",
      t: 9,
      d: "將二進位數轉換為十進位數。",
      a: "將二進位數轉換為十進位數。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要轉換為十進位數的帶符號的10位二進位數值（以字串形式提供）。\n\n帶符號的二進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n對於此函數,最大的正數輸入值為0111111111,最小的負數輸入值為1000000000。\n\n如果所提供的帶符號的二進位數是有效的二進位數,會自動將其轉換為相應的字串輸入。例如,BIN2DEC（100）和BIN2DEC（"100"）得出的結果相同,均為4。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIN2HEX",
      t: 9,
      d: "將二進位數轉換為十六進位數。",
      a: "將二進位數轉換為十六進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的十六進位數的帶符號的10位二進位數值（以字串形式提供）。\n\n帶符號的二進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n對於此函數,最大的正數輸入值為0111111111,最小的負數輸入值為1000000000。\n\n如果所提供的帶符號的二進位數是有效的二進位數,會自動將其轉換為相應的字串輸入。例如,BIN2HEX（11111）和BIN2HEX（"11111"）得出的結果相同,均為1F。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: '[ 可選 ] -結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。例如,BIN2HEX（"11111",8）所得的結果值為0000001F。\n\n如果帶符號的二進位數的最高位為1,則忽略此值；即當提供的帶符號的二進位數大於等於1000000000時忽略此值。',
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "BIN2OCT",
      t: 9,
      d: "二進位數轉換為八進制數。",
      a: "二進位數轉換為八進制數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的八進制數的帶符號的10位二進位數值（以字串形式提供）。\n\n帶符號的二進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n對於此函數,最大的正數輸入值為0111111111,最小的負數輸入值為1000000000。\n\n如果所提供的帶符號的二進位數是有效的二進位數,會自動將其轉換為相應的字串輸入。例如,BIN2OCT（11111）和BIN2OCT（"11111"）得出的結果相同,均為37。',
        example: "101",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: '[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。例如,BIN2OCT（"11111"）得到的結果值為00000037。\n\n如果帶符號的二進位數的最高位為1,則忽略此值；即當提供的帶符號的二進位數大於等於1000000000時忽略此值。',
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2BIN",
      t: 9,
      d: "將十進位數轉換為二進位數。",
      a: "將十進位數轉換為二進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的二進位數的十進位數值（以字串形式提供）。\n\n對於此函數,最大的正數輸入值為511,最小的負數輸入值為-512。\n\n如果所提供的十進位數是有效的十進位數,會自動將其轉換為相應的字串輸入。例如,DEC2BIN（199）和DEC2BIN（"199"）得出的結果相同,均為11000111。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果十進位數為負數,則忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2HEX",
      t: 9,
      d: "將十進位數轉換為十六進位數。",
      a: "將十進位數轉換為十六進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的十六進位數的十進位數值（以字串形式提供）。\n\n此函數可接受的最大正數值為549755813887,最小負數值為-549755814888。\n\n如果所提供的十進位數是有效的十進位數,會自動將其轉換為相應的字串輸入。例如,DEC2HEX（100）和DEC2HEX（"100"）得出的結果相同,均為64。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果十進位數為負數,則忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DEC2OCT",
      t: 9,
      d: "將十進位數轉換為八進制數。",
      a: "將十進位數轉換為八進制數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的八進制數的十進位數值（以字串形式提供）。\n\n此函數可接受的最大正數值為536870911,最小負數值為-53687092。\n\n如果所提供的十進位數是有效的十進位數,會自動將其轉換為相應的字串輸入。例如,DEC2OCT（199）和DEC2OCT（"199"）得出的結果相同,均為307。',
        example: "100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "places",
        detail: "[ 可選 ] -結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果十進位數為負數,則忽略此值 。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2BIN",
      t: 9,
      d: "將十六進位數轉換為二進位數。",
      a: "將十六進位數轉換為二進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的二進位數的帶符號的40位十六進位數值（以字串形式提供）。\n\n帶符號的十六進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為1FF,最小負數值為FFFFFFFE00。\n\n如果所提供的帶符號的十六進位數是有效的十六進位數,函數會自動將其轉換為相應的字串輸入。例如,HEX2BIN（199）和HEX2BIN（"199"）得出的結果相同,均為110011001。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果帶符號的十六進位數的最高位為1,則忽略此值；即當提供的帶符號的十六進位數大於等於8000000000時忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "HEX2DEC",
      t: 9,
      d: "將十六進位數轉換為十進位數。",
      a: "將十六進位數轉換為十進位數。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要轉換為十進位數的帶符號的40位十六進位數值（以字串形式提供）。\n\n帶符號的十六進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為7fffffffff,最小負數值為8000000000。\n\n如果所提供的帶符號的十六進位數是有效的十六進位數,函數會自動將其轉換為相應的字串輸入。例如,HEX2DEC（199）和HEX2DEC（"199"）得出的結果相同,均為409 。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "HEX2OCT",
      t: 9,
      d: "將十六進位數轉換為八進制數。",
      a: "將十六進位數轉換為八進制數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的八進制數的帶符號的40位十六進位數值（以字串形式提供）。\n\n帶符號的十六進位數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為1FFFFFFF,最小負數值為FFE0000000。\n\n如果所提供的帶符號的十六進位數是有效的十六進位數,函數會自動將其轉換為相應的字串輸入。例如,HEX2OCT（199）和HEX2OCT（"199"）得出的結果相同,均為631。',
        example: '"f3"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果帶符號的十六進位數的最高位為1,則忽略此值；即當給定的帶符號的十六進位數大於等於8000000000時忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2BIN",
      t: 9,
      d: "將八進制數轉換為二進位數。",
      a: "將八進制數轉換為二進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的二進位數的帶符號的30位八進制數值（以字串形式提供）。\n\n帶符號的八進制數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為777,最小負數值為7777777000。\n\n如果所提供的帶符號的八進制數是有效的八進制數,函數會自動將其轉換為相應的字串輸入。例如,OCT2BIN（177）和OCT2BIN（"177"）得出的結果相同,均為1111111。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果帶符號的八進制數的最高位為1,則忽略此值；即當給定的帶符號的八進制數大於等於4000000000時忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "OCT2DEC",
      t: 9,
      d: "將八進制數轉換為十進位數。",
      a: "將八進制數轉換為十進位數。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: '要轉換為十進位數的帶符號的30位八進制數值（以字串形式提供）。\n\n帶符號的ba進制數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為3777777777,最小負數值為4000000000。\n\n如果所提供的帶符號的八進制數是有效的八進制數,函數會自動將其轉換為相應的字串輸入。例如,OCT2DEC（177）和OCT2DEC（"177"）得出的結果相同,均為127。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OCT2HEX",
      t: 9,
      d: "將八進制數轉換為十六進位數。",
      a: "將八進制數轉換為十六進位數。",
      m: [1, 2],
      p: [{
        name: "number",
        detail: '要轉換為帶符號的十六進位數的帶符號的30位八進制數值（以字串形式提供）。\n\n帶符號的ba進制數的最高位是符號位；也就是說,負數是以二的補數形式表示的。\n\n此函數可接受的最大正數值為3777777777,最小負數值為4000000000。\n\n如果所提供的帶符號的八進制數是有效的八進制數,函數會自動將其轉換為相應的字串輸入。例如,OCT2HEX（177）和OCT2HEX（"177"）得出的結果相同,均為7F。',
        example: "37",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "places",
        detail: "[ 可選 ] - 結果中要確保的有效位數。\n\n如果設定的有效位數大於結果中的有效位數,則在結果的左側填充0,使總有效位數達到有效位數。\n\n如果帶符號的八進制數的最高位為1,則忽略此值；即當給定的帶符號的八進制數大於等於4000000000時忽略此值。",
        example: "8",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "COMPLEX",
      t: 9,
      d: "將實係數及虛係數轉換為 x+yi 或 x+yj 形式的複數。",
      a: "將實係數及虛係數轉換為 x+yi 或 x+yj 形式的複數。",
      m: [2, 3],
      p: [{
        name: "real_num",
        detail: "複數的實係數。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "i_num",
        detail: "複數的虛係數。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "suffix",
        detail: '[可選 - 默認為"i"] - 複數中虛係數的尾碼。',
        example: '"j"',
        require: "o",
        repeat: "n",
        type: "rangestring"
      }]
    }, {
      n: "IMREAL",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的複數的實係數。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的複數的實係數。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要計算其實係數的複數。",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMAGINARY",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的複數的虛係數。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的複數的虛係數。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要計算其虛係數的複數。",
        example: '"4+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMCONJUGATE",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的複數的共軛複數。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的複數的共軛複數。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "需要計算其共軛數的複數。",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMABS",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的複數的絕對值（模）。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的複數的絕對值（模）。",
      m: [1, 1],
      p: [{
        name: "inumber",
        detail: "要計算其絕對值的複數。",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DELTA",
      t: 9,
      d: "檢驗兩個值是否相等。如果 number1=number2,則返回1；否則返回0。",
      a: "檢驗兩個值是否相等。如果 number1=number2,則返回1；否則返回0。",
      m: [1, 2],
      p: [{
        name: "number1",
        detail: "第一個數位。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "number2",
        detail: "[可選 - 默認為0] - 第二個數位。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "IMSUM",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 個複數的和。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 個複數的和。",
      m: [1, 255],
      p: [{
        name: "inumber1",
        detail: "要相加的第一個複數",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2, …",
        detail: "[可選] -要與值1相加的其他複數",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMSUB",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的兩個複數的差。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的兩個複數的差。",
      m: [2, 2],
      p: [{
        name: "inumber1",
        detail: "從（複）數中减去 inumber2。",
        example: '"6+5i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2",
        detail: "從 inumber1 中减（複）數。",
        example: '"2+3i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IMPRODUCT",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 個複數的乘積。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的 1 至 255 個複數的乘積。",
      m: [1, 255],
      p: [{
        name: "inumber1",
        detail: "用於計算乘積的第一個複數",
        example: '"3+4i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2, …",
        detail: "[可選] -要相乘的其他複數。",
        example: '"5-3i"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IMDIV",
      t: 9,
      d: "返回以 x+yi 或 x+yj 文本格式表示的兩個複數的商。",
      a: "返回以 x+yi 或 x+yj 文本格式表示的兩個複數的商。",
      m: [2, 2],
      p: [{
        name: "inumber1",
        detail: "複數分子或被除數。",
        example: '"11+16i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "inumber2",
        detail: "複數分母或除數。",
        example: '"3+2i"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NOT",
      t: 10,
      d: '返回某個邏輯值的相反值-"NOT（TRUE（））"將返回FALSE；"NOT（FALSE（））"將返回TRUE。',
      a: '返回某個邏輯值的相反值-"NOT（TRUE（））"將返回FALSE；"NOT（FALSE（））"將返回TRUE。',
      m: [1, 1],
      p: [{
        name: "logical",
        detail: "計算結果為TRUE或FALSE的任何值或運算式。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRUE",
      t: 10,
      d: "返回邏輯值 TRUE。",
      a: "返回邏輯值 TRUE。",
      m: [0, 0],
      p: []
    }, {
      n: "FALSE",
      t: 10,
      d: "返回邏輯值 FALSE。",
      a: "返回邏輯值 FALSE。",
      m: [0, 0],
      p: []
    }, {
      n: "AND",
      t: 10,
      d: "所有參數的計算結果為TRUE時,返回TRUE；只要有一個參數的計算結果為FALSE,即返回FALSE。",
      a: "所有參數的計算結果為TRUE時,返回TRUE；只要有一個參數的計算結果為FALSE,即返回FALSE。",
      m: [1, 255],
      p: [{
        name: "logical1",
        detail: "要測試的第一個條件,其計算結果可以為TRUE或FALSE。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "logical2,...",
        detail: "[可選] - 要測試的其他條件,其計算結果可以為TRUE或FALSE,最多可包含255個條件。",
        example: 'A3 = "bar"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "IFERROR",
      t: 10,
      d: "如果第一個參數不是錯誤值,就返回第一個參數；否則,返回第二個參數。",
      a: "如果第一個參數不是錯誤值",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "檢查是否存在錯誤的參數。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_error",
        detail: "公式的計算結果錯誤時返回的值。計算以下錯誤類型:#N/A、#VALUE！、#REF！、#DIV/0！、#NUM！、#NAME？或#NULL！。",
        example: '"Error in cell A1"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "IF",
      t: 10,
      d: "當邏輯運算式的值為TRUE時返回一個值,而當其為FALSE時返回另一個值。",
      a: "當邏輯運算式的值為TRUE時返回一個值,而當其為FALSE時返回另一個值。",
      m: [2, 3],
      p: [{
        name: "logical_test",
        detail: "一個運算式或對包含運算式的儲存格的引用,該運算式代表某種邏輯值（即TRUE或FALSE）。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_true",
        detail: "當邏輯運算式為TRUE時的返回值。",
        example: '"A2 is foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value_if_false",
        detail: "[可選 - 默認為空白] - 當邏輯運算式等於FALSE時的函數返回值。",
        example: '"A2 was false"',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "OR",
      t: 10,
      d: "只要有一個參數的計算結果為TRUE時,返回TRUE；所有參數的計算結果為FALSE,即返回FALSE。",
      a: "只要有一個參數的計算結果為TRUE時,返回TRUE；所有參數的計算結果為FALSE,即返回FALSE。",
      m: [1, 255],
      p: [{
        name: "logical1",
        detail: "要測試的第一個條件,其計算結果可以為TRUE或FALSE。",
        example: 'A2 = "foo"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "邏輯運算式2",
        detail: "[可選] - 其他運算式或對包含運算式的儲存格的引用,這些運算式代表某種邏輯值（即TRUE或FALSE）或者可以強制轉換為邏輯值。",
        example: ' A3 = "bar"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "NE",
      t: 11,
      d: '如果指定的值不相等,則返回"TRUE"；否則返回"FALSE"。相當於"<>"運算子。',
      a: '如果指定的值不相等,則返回"TRUE"；否則返回"FALSE"。相當於"<>"運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一個值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要檢查是否與 value1 不相等的值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EQ",
      t: 11,
      d: '如果指定的值相等,則返回"TRUE"；否則返回"FALSE"。相當於"="運算子。',
      a: '如果指定的值相等,則返回"TRUE"；否則返回"FALSE"。相當於"="運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一個值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要檢查是否與value1相等的值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GT",
      t: 11,
      d: "如果第一個參數嚴格大於第二個，則返回TRUE；否則返回FALSE。相當於" > "運算子。",
      a: "如果第一個參數嚴格大於第二個，則返回TRUE；否則返回FALSE。相當於" > "運算子。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要測試其是否大於 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二個值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "GTE",
      t: 11,
      d: '如果第一個參數大於或等於第二個，則返回TRUE；否則返回FALSE。相當於">="運算子。',
      a: '如果第一個參數大於或等於第二個，則返回TRUE；否則返回FALSE。相當於">="運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否大于等于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二個值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LT",
      t: 11,
      d: '如果第一個參數嚴格小於第二個，則返回TRUE；否則返回FALSE。相當於"<"運算子。',
      a: '如果第一個參數嚴格小於第二個，則返回TRUE；否則返回FALSE。相當於"<"運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否小于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二個值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LTE",
      t: 11,
      d: '如果第一個參數小於或等於第二個，則返回TRUE；否則返回FALSE。相當於"<="運算子。',
      a: '如果第一個參數小於或等於第二個，則返回TRUE；否則返回FALSE。相當於"<="運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要测试其是否小于等于 value2 的值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "第二個值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ADD",
      t: 11,
      d: '返回兩個數值之和。相當於"+"運算子。',
      a: '返回兩個數值之和。相當於"+"運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一個加數。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "第二個加數。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINUS",
      t: 11,
      d: '返回兩個數值之差。相當於"-"運算子。',
      a: '返回兩個數值之差。相當於"-"運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "被減數,即要對其計减的數值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "減數,即要從value1中减除的數值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MULTIPLY",
      t: 11,
      d: '返回兩個數的乘積。相當於"*"運算子。',
      a: '返回兩個數的乘積。相當於"*"運算子。',
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "第一個乘數。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "第二個乘數。",
        example: "B2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DIVIDE",
      t: 11,
      d: "返回兩個參數相除所得的結果。相當於`/`運算子。",
      a: "返回兩個參數相除所得的結果。相當於`/`運算子。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "要被除的數值。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "value2",
        detail: "用於除其他數的數值。\n\n除數不得為0。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCAT",
      t: 11,
      d: "返回兩個值的串聯。相當於`&`運算子。",
      a: "返回兩個值的串聯。相當於`&`運算子。",
      m: [2, 2],
      p: [{
        name: "value1",
        detail: "value2 將附於其後的值。",
        example: '"de"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "value2",
        detail: "要附於 value1 之後的值。",
        example: '"mystify"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNARY_PERCENT",
      t: 11,
      d: '返回按百分比解釋的數值。例如,"UNARY_PERCENT（100）"等於1。',
      a: '返回按百分比解釋的數值。例如,"UNARY_PERCENT（100）"等於1。',
      m: [1, 1],
      p: [{
        name: "number",
        detail: "要作為百分比解釋的數值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CONCATENATE",
      t: 12,
      d: "將兩個或多個文字字串聯接為一個字串。",
      a: "將兩個或多個文字字串聯接為一個字串。",
      m: [1, 255],
      p: [{
        name: "text1",
        detail: "初始字串。",
        example: '"Super"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text2…",
        detail: "[可選] - 要按順序連接在一起的其他字串。",
        example: '"calla"',
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "CODE",
      t: 12,
      d: "返回所提供的字串中首字元的Unicode映射值。",
      a: "返回所提供的字串中首字元的Unicode映射值。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其首字元的Unicode映射值的字串。",
        example: '"a"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CHAR",
      t: 12,
      d: "按照當前Unicode編碼表,將數位轉換為對應的字元。",
      a: "按照當前Unicode編碼表,將數位轉換為對應的字元。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "介於1到255之間的數位。",
        example: "97",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ARABIC",
      t: 12,
      d: "將羅馬數字轉換為阿拉伯數字。",
      a: "將羅馬數字轉換為阿拉伯數字。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要轉換格式的羅馬數字",
        example: '"XIV"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ROMAN",
      t: 12,
      d: "將數位格式設定為羅馬數字形式。",
      a: "將數位格式設定為羅馬數字形式。",
      m: [1, 1],
      p: [{
        name: "number",
        detail: "要設定格式的數位,介於1到3999之間（包括這兩個數位）。",
        example: "499",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "REGEXEXTRACT",
      t: 12,
      d: "按照規則運算式選取匹配的子串。",
      a: "按照規則運算式選取匹配的子串。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "輸入文字。",
        example: '"Needle in a haystack"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "此函數將返回文字中符合此運算式的第一個子串。",
        example: '".e{2}dle"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXMATCH",
      t: 12,
      d: "判斷一段文字是否與規則運算式相匹配。",
      a: "判斷一段文字是否與規則運算式相匹配。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "要用規則運算式測試的文字。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "用來測試文字的規則運算式。",
        example: '"S.r"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REGEXREPLACE",
      t: 12,
      d: "使用規則運算式將文字字串中的一部分替換為其他文字字串。",
      a: "使用規則運算式將文字字串中的一部分替換為其他文字字串。",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "要對其局部進行替換操作的文字。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "regular_expression",
        detail: "規則運算式。text中所有匹配的實例都將被替換。",
        example: '"S.*d"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "replacement",
        detail: "要插入到原有文字中的文字。",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "T",
      t: 12,
      d: "返回文本格式的字串參數。",
      a: "返回文本格式的字串參數。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為文字的參數。\n\n如果值為文字,T將返回值本身。\n\n如果值為指向包含文字的儲存格的引用,T將返回值中的內容。\n\n如果值為錯誤值或包含錯誤值的儲存格,T將返回該錯誤值。\n\n對於所有其他情况,T將返回空串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIXED",
      t: 12,
      d: "以固定的小數位數設定數位的格式。",
      a: "以固定的小數位數設定數位的格式。",
      m: [1, 3],
      p: [{
        name: "number",
        detail: "要進行舍入並轉換為文字的數位。",
        example: "3.141592653",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "decimals",
        detail: "[可選-預設值為2] - 結果中要顯示的小數位數。\n\n如果數值的有效位數小於小數位數,將以零填充。如果數值的有效位數大於小數位數,則將其舍入到所需的小數位數而不是將其截斷。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "no_commas",
        detail: "[可選-預設值為FALSE（）] - 一個邏輯值,如果為TRUE（）,則會禁止FIXED在返回的文字中包含逗號。",
        example: "FALSE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FIND",
      t: 12,
      d: "返回字串在文字中首次出現的位置（區分大小寫）。",
      a: "返回字串在文字中首次出現的位置（區分大小寫）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要蒐索的文字中查找的字串。",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中蒐索蒐索字串的首次出現位置的文字。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[可選-預設值為1] - 要在要蒐索的文字中開始蒐索的字元位置。",
        example: "14",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "FINDB",
      t: 12,
      d: "返回某個字串在文字中首次出現的位置（每個雙位元組字元占兩個位置）。",
      a: "返回某個字串在文字中首次出現的位置（每個雙位元組字元占兩個位置）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要蒐索的文字中查找的字串。",
        example: '"新"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中蒐索蒐索字串的首次出現位置的文字。",
        example: '"農曆新年"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[可選-預設值為1] - 要在要蒐索的文字中開始蒐索的字元位置。",
        example: "2",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "JOIN",
      t: 12,
      d: "將一個或多個使用指定定界符的一維數組的元素連接到一起。",
      a: "將一個或多個使用指定定界符的一維數組的元素連接到一起。",
      m: [2, 255],
      p: [{
        name: "separator",
        detail: "置於相互連接的值之間的字元或字串。\n\n定界符可以為空,例如JOIN（,{1,2,3}）。",
        example: '"and-a"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "array1",
        detail: "要使用定界符連接的一個或多個值。",
        example: "{1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "array2,…",
        detail: "[可選] - 要使用定界符連接的其他值或數組。",
        example: "2",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "LEFT",
      t: 12,
      d: "從文字字串的第一個字元開始返回指定個數的字元。",
      a: "從文字字串的第一個字元開始返回指定個數的字元。",
      m: [1, 2],
      p: [{
        name: "text",
        detail: "包含要選取的字元的文字字串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_chars",
        detail: "[可選-預設值為1] - 指定要由LEFT選取的字元的數量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "RIGHT",
      t: 12,
      d: "根據所指定的字元數返回文字字串中最後一個或多個字元。",
      a: "根據所指定的字元數返回文字字串中最後一個或多個字元。",
      m: [1, 2],
      p: [{
        name: "text",
        detail: "包含要選取的字元的文字字串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "num_chars",
        detail: "[可選-預設值為1] - 指定要由RIGHT選取的字元的數量。",
        example: "2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MID",
      t: 12,
      d: "返回文字字串中從指定位置開始的特定數目的字元。",
      a: "返回文字字串中從指定位置開始的特定數目的字元。",
      m: [3, 3],
      p: [{
        name: "text",
        detail: "包含要選取的字元的文字字串。",
        example: '"get this"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "要從字串中開始選取的位置。字串中第一個字元的索引為1。",
        example: "5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_chars",
        detail: "指定要由MID選取的字元的數量。\n\n如果選取的字元數尚不足選取長度個字元時就到達了字串尾部,則MID返回從開始位置到字串尾部的字元。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "LEN",
      t: 12,
      d: "返回給定字串的長度。",
      a: "返回給定字串的長度。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其長度的字串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LENB",
      t: 12,
      d: "返回文字中所包含的字元數。與雙位元組字元集（DBCS）一起使用。",
      a: "返回文字中所包含的字元數。與雙位元組字元集（DBCS）一起使用。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要返回其位元組數的字串。（一個漢字為兩個位元組數）",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOWER",
      t: 12,
      d: "將指定字串中的字母轉換為小寫。",
      a: "將指定字串中的字母轉換為小寫。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要轉換為小寫的字串。",
        example: '"LOREM IPSUM"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UPPER",
      t: 12,
      d: "將指定字串中的字母轉換為大寫。",
      a: "將指定字串中的字母轉換為大寫。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要轉換為大寫的字串。",
        example: '"lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "EXACT",
      t: 12,
      d: "比較兩個字串是否相同。",
      a: "比較兩個字串是否相同。",
      m: [2, 2],
      p: [{
        name: "text1",
        detail: "要比較的第一個字串。",
        example: "A1",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "text2",
        detail: "要比較的第二個字串。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPLACE",
      t: 12,
      d: "將文字字串的一部分替換為其他文字字串。",
      a: "將文字字串的一部分替換為其他文字字串。",
      m: [4, 4],
      p: [{
        name: "old_text",
        detail: "要對其局部進行替換操作的文字。",
        example: '"Spreadsheets"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "開始進行替換操作的位置（文字開頭位置為1）。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "num_chars",
        detail: "要在文字中替換的字元個數。",
        example: "6",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_text",
        detail: "要插入到原有文字中的文字。",
        example: '"Bed"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "REPT",
      t: 12,
      d: "返回指定文字的多次重複。",
      a: "返回指定文字的多次重複。",
      m: [2, 2],
      p: [{
        name: "text",
        detail: "要重複的字元或字串。",
        example: '"ha"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "number_times",
        detail: "要重複的文字要在返回值中出現的次數。\n\n最大重複次數為100。即使重複次數大於100,REPT也僅將相應文字重複100次。",
        example: "4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEARCH",
      t: 12,
      d: "返回字串在文字中首次出現的位置（不區分大小寫）。",
      a: "返回字串在文字中首次出現的位置（不區分大小寫）。",
      m: [2, 3],
      p: [{
        name: "find_text",
        detail: "要在要蒐索的文字中查找的字串。",
        example: '"n"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "within_text",
        detail: "要在其中蒐索蒐索字串的首次出現位置的文字。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "start_num",
        detail: "[可選-預設值為1 ] - 要在要蒐索的文字中開始蒐索的字元位置。",
        example: "14",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUBSTITUTE",
      t: 12,
      d: "在文字字串中用new_text替換old_text。",
      a: "在文字字串中用new_text替換old_text。",
      m: [3, 4],
      p: [{
        name: "text",
        detail: "需要替換其中字元的文字,或對含有文字（需要替換其中字元）的儲存格的引用。",
        example: '"search for it"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "old_text",
        detail: "需要替換的文字。",
        example: '"search for"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "new_text",
        detail: "用於替換old_text的文字。",
        example: '"Google"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "instance_num",
        detail: "[可選] - 指定要用new_text替換old_text的事件。如果指定了instance_num,則只有滿足要求的old_text被替換。否則,文字中出現的所有old_text都會更改為new_text。",
        example: "3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "CLEAN",
      t: 12,
      d: "移除文字中的不可列印ASCII字元後將其返回。",
      a: "移除文字中的不可列印ASCII字元後將其返回。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要移除其中不可列印字元的文字。",
        example: '"AF"&amp;CHAR（31）',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TEXT",
      t: 12,
      d: "按照指定格式將數位轉換為文字。",
      a: "按照指定格式將數位轉換為文字。",
      m: [2, 2],
      p: [{
        name: "value",
        detail: "要設定格式的數位、日期或時間。",
        example: "1.23",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "format_text",
        detail: '以括弧括起來的模式串,將按該模式設定數位的格式。\n\n0表示在數值位數少於格式指定的位數時必定以零填充。例如,TEXT（12.3,“000.00"）將返回012.30。當數值的小數位數超過模式指定的小數位數時,四捨五入為指定的小數位數。例如,TEXT（12.305,“00.00"）將返回12.31。\n\n#類似於0,但並不是在小數點的兩側都以零填充。例如,TEXT（12.3,“###.##"）將返回12.3。',
        example: '"$0.00"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRIM",
      t: 12,
      d: "删除指定字串前後的空格。",
      a: "删除指定字串前後的空格。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要修剪的字串或指向包含該字串的儲存格的引用。",
        example: '"lorem ipsum"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "VALUE",
      t: 12,
      d: "將可識別的任何日期、時間或數位格式的字串轉換為數位。",
      a: "將可識別的任何日期、時間或數位格式的字串轉換為數位。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "包含要轉換的值的字串。",
        example: '"123"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROPER",
      t: 12,
      d: "將指定字串中每個單詞的首字母轉為大寫。",
      a: "將指定字串中每個單詞的首字母轉為大寫。",
      m: [1, 1],
      p: [{
        name: "text",
        detail: "要轉換的文字,其中每個單詞的首字母都將轉為大寫,所有其他字母則轉為小寫。",
        example: '"united states"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CONVERT",
      t: 13,
      d: "將數位從一種度量系統轉換為另一種度量系統。",
      a: "將數位從一種度量系統轉換為另一種度量系統。",
      m: [3, 3],
      p: [{
        name: "number",
        detail: "是以from_unit為組織的需要進行轉換的數值。",
        example: "5.1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "from_unit",
        detail: "是數值的組織。",
        example: '"g"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "to_unit",
        detail: "是結果的組織。",
        example: '"kg"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "SUMX2MY2",
      t: 14,
      d: "返回兩數組中對應數值的平方差之和。",
      a: "返回兩數組中對應數值的平方差之和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一個數組或數值區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二個數組或數值區域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMX2PY2",
      t: 14,
      d: "返回兩數組中對應數值的平方和之和。",
      a: "返回兩數組中對應數值的平方和之和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一個數組或數值區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二個數組或數值區域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMXMY2",
      t: 14,
      d: "返回兩數組中對應數值之差的平方和。",
      a: "返回兩數組中對應數值之差的平方和。",
      m: [2, 2],
      p: [{
        name: "array_x",
        detail: "第一個數組或數值區域。",
        example: "A2:A100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array_y",
        detail: "第二個數組或數值區域。",
        example: "B2:B100",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TRANSPOSE",
      t: 14,
      d: "將數組或儲存格範圍的行列轉置。",
      a: "將數組或儲存格範圍的行列轉置。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "要將其行列互換的數組或範圍。",
        example: "{1,2}",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "TREND",
      t: 14,
      d: "返回線性趨勢值。",
      a: "返回線性趨勢值。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "關係運算式y = mx + b 中已知的y值集合。\n\n如果known_y為二維陣列或範圍,則known_x的維數必須與之相同,或者省略此參數。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可選-默認該數組為{1,2,3,…},其大小與known_y相同] -關係運算式y = mx + b 中已知的可選x值集合。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_x",
        detail: "[可選 - 默認與known_x相同] - 需要函數TREND返回對應y值的新x值。",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可選 - 預設值為TRUE（）] - 一個邏輯值,用於指定是否將常數b強制設為0。\n\nTRUE（）表示b將按正常計算；\n\nFALSE（）表示b將被設為0（零）,m 將被調整以使y = mx。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FREQUENCY",
      t: 14,
      d: "計算數值在某個區域內的出現頻率,然後返回一個垂直數組。",
      a: "計算數值在某個區域內的出現頻率,然後返回一個垂直數組。",
      m: [2, 2],
      p: [{
        name: "data_array",
        detail: "要對其頻率進行計數的一組數值或對這組數值的引用。",
        example: "A2:A40",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "bins_array",
        detail: "要將data_array中的值插入到的間隔數組或對間隔的引用。\n\n為清晰起見,應將類別排序,但如果未排序,FREQUENCY會在內部對這些指定的值進行排序並返回正確結果。",
        example: "B2:B5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "GROWTH",
      t: 14,
      d: "使用現有數據計算預測的指數等比。",
      a: "使用現有數據計算預測的指數等比。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "關係運算式y = b*m^x 中已知的y值集合。\n\n如果已知數據_y為二維陣列或範圍,則已知數據_x的維數必須與之相同,或者省略此參數。\n\n如果已知數據_y為一維數組或範圍,已知數據_x則可代表二維陣列或範圍中的多個引數。也就是說,如果已知數據_y為單行,則將已知數據_x中的每行解釋為各自獨立的值,類似情况也適用於已知數據_y為單列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可選 - 默認該數組為{1,2,3,…},其大小與known_y相同] - 關係運算式y = b*m^x 中已知的可選x值集合。\n\n如果已知數據_y為一維數組或範圍,已知數據_x則可代表二維陣列或範圍中的多個引數。也就是說,如果已知數據_y為單行,則將已知數據_x中的每行解釋為各自獨立的值,類似情况也適用於已知數據_y為單列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "new_x",
        detail: "[可選 - 默認與known_x相同] - 需要函數GROWTH返回對應y值的新x值。",
        example: "A11:A13",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可選 - 預設值為TRUE（）] - 一個邏輯值,用於指定是否將常數b強制設為1。\n\nTRUE（）表示b將按正常計算；\n\nFALSE（）表示b將被設為1,m將被調整以使y = m^x。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINEST",
      t: 14,
      d: "可通過使用最小二乘法計算與現有數據最佳擬合的直線,來計算某直線的統計值,然後返回描述此直線的數組。",
      a: "可通過使用最小二乘法計算與現有數據最佳擬合的直線,來計算某直線的統計值,然後返回描述此直線的數組。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "關係運算式y = mx + b 中已知的y值集合。\n\n如果known_y為二維陣列或範圍,則known_x的維數必須與之相同,或者省略此參數。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可選 - 默認該數組為{1,2,3,…},其大小與known_y相同] - 關係運算式y = mx + b中已知的可選x值集合。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可選 - 預設值為TRUE（）] - 一個邏輯值,用於指定是否將常數b強制設為0。\n\nTRUE（）表示b將按正常計算；\n\nFALSE（）表示b將被設為0（零）,m將被調整以使y = mx。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "stats",
        detail: "[可選 - 預設值為FALSE（）] - 一個邏輯值,用於指定是否返回附加回歸統計值。\n\n如果詳細為TRUE,除了對應於每個引數的一組線性係數和y截距之外,LINEST還返回以下資訊:\n\n每項係數和截距的標準誤差、\n\n限定係數（介於0和1之間,1表示完全相關）、\n\n因變數值的標准誤差、\n\nF統計或F觀測值,訓示所觀測到的因變數和引數變數之間的關係是隨機的還是線性的、\n\n自由度,用於在參照錶中查找F統計值以估算可信度、\n\n回歸平方和,以及\n\n殘差平方和。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LOGEST",
      t: 14,
      d: "在回歸分析中,計算最符合數據的指數回歸擬合曲線,並返回描述該曲線的數值數組。",
      a: "在回歸分析中,計算最符合數據的指數回歸擬合曲線,並返回描述該曲線的數值數組。",
      m: [1, 4],
      p: [{
        name: "known_y",
        detail: "關係運算式y = mx + b 中已知的y值集合。\n\n如果known_y為二維陣列或範圍,則known_x的維數必須與之相同,或者省略此參數。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "B2:B10",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "known_x",
        detail: "[可選 - 默認該數組為{1,2,3,…},其大小與known_y相同] - 關係運算式y = mx + b中已知的可選x值集合。\n\n如果known_y為一維數組或範圍,known_x則可代表二維陣列或範圍中的多個引數。也就是說,如果known_y為單行,則將known_x中的每行解釋為各自獨立的值,類似情况也適用於known_y為單列的情况。",
        example: "A2:A10",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "const",
        detail: "[可選 - 預設值為TRUE（）] - 一個邏輯值,用於指定是否將常數b強制設為0。\n\nTRUE（）表示b將按正常計算；\n\nFALSE（）表示b將被設為0（零）,m將被調整以使y = mx。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "stats",
        detail: "[可選 - 預設值為FALSE（）] - 一個邏輯值,用於指定是否返回附加回歸統計值。\n\n如果詳細為TRUE,則除了為每個引數和係數b返回一組指數值之外,LOGEST還將返回以下數據:\n\n每項指數和係數的標準誤差、\n\n限定係數（介於0和1之間,1表示完全相關）、\n\n因變數值的標准誤差、\n\nF統計或F觀測值,訓示所觀測到的因變數和引數之間的關係是隨機的還是指數的、\n\n自由度-用於在參照錶中查找F統計值以估算可信度、\n\n回歸平方和,以及\n\n殘差平方和。",
        example: "TRUE（）",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "MDETERM",
      t: 14,
      d: "返回一個數組的矩陣行列式的值。",
      a: "返回一個數組的矩陣行列式的值。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "行數和列數相等的數值數組。",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MINVERSE",
      t: 14,
      d: "返回數組中存儲的矩陣的逆矩陣。",
      a: "返回數組中存儲的矩陣的逆矩陣。",
      m: [1, 1],
      p: [{
        name: "array",
        detail: "行數和列數相等的數值數組。",
        example: "A1:D4",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "MMULT",
      t: 14,
      d: "返回兩個數組的矩陣乘積。結果矩陣的行數與array1的行數相同,矩陣的列數與array2的列數相同。",
      a: "返回兩個數組的矩陣乘積。結果矩陣的行數與array1的行數相同,矩陣的列數與array2的列數相同。",
      m: [2, 2],
      p: [{
        name: "array1",
        detail: "要進行矩陣乘法運算的第一個矩陣數組。\n\narray1列數必須與array2的行數相同",
        example: "A1:B3",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "要進行矩陣乘法運算的第二個矩陣數組。\n\narray2的行數必須與array1列數相同",
        example: "C1:F2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SUMPRODUCT",
      t: 14,
      d: "在給定的幾組數組中,將數組間對應的元素相乘,並返回乘積之和。",
      a: "在給定的幾組數組中,將數組間對應的元素相乘,並返回乘積之和。",
      m: [1, 255],
      p: [{
        name: "array1",
        detail: "其相應元素需要進行相乘並求和的第一個數組參數。",
        example: "A2:C5",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "array2",
        detail: "[可選] - 其相應元素需要進行相乘並求和的其它數組參數。",
        example: "D2:F5",
        require: "o",
        repeat: "y",
        type: "rangenumber"
      }]
    }, {
      n: "ISFORMULA",
      t: 15,
      d: "檢查公式是否位於引用的儲存格中。",
      a: "檢查公式是否位於引用的儲存格中。",
      m: [1, 1],
      p: [{
        name: "cell",
        detail: "要檢查是否存在公式的儲存格。\n\n如果 cell 為包含公式的儲存格,則 ISFORMULA 將返回TRUE。如果 cell 為相應儲存格範圍,則當該範圍內的首個儲存格包含公式時,系統會返回TRUE。如果是任何其他值,系統都將返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "CELL",
      t: 15,
      d: "返回有關儲存格的格式、位置或內容的資訊。",
      a: "返回有關儲存格的格式、位置或內容的資訊。",
      m: [2, 2],
      p: [{
        name: "info_type",
        detail: "一個文字值,指定要返回的儲存格資訊的類型。",
        example: '"type"',
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "reference",
        detail: "需要其相關資訊的儲存格。",
        example: "C2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "NA",
      t: 15,
      d: "返回錯誤值#N/A。",
      a: "返回錯誤值#N/A。",
      m: [0, 0],
      p: []
    }, {
      n: "ERROR_TYPE",
      t: 15,
      d: "返回與其他儲存格中的錯誤值相對應的數位。",
      a: "返回與其他儲存格中的錯誤值相對應的數位。",
      m: [1, 1],
      p: [{
        name: "error_val",
        detail: "用於查找錯誤號的儲存格,雖然您也可以直接提供錯誤值。",
        example: "A3",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISBLANK",
      t: 15,
      d: "檢查所引用的儲存格是否為空。",
      a: "檢查所引用的儲存格是否為空。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "對要檢查其是否為空的儲存格的引用。\n\n如果是空儲存格,則TRUE；否則返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISERR",
      t: 15,
      d: "檢查某個值是否為#N/A以外的錯誤值。",
      a: "檢查某個值是否為#N/A以外的錯誤值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其是否為#N/A以外的錯誤類型的值。\n\n如果值是除#N/A之外的任何錯誤（包括#DIV/0！、#NAME？、#NULL！、#NUM！、#VALUE！和#REF！）,ISERR將返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISERROR",
      t: 15,
      d: "檢查某個值是否為錯誤值。",
      a: "檢查某個值是否為錯誤值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其是否為錯誤類型的值。\n\n只要值是某種錯誤值（包括#DIV/0！、#N/A、#NAME？、#NULL！、#NUM！、#VALUE！和#REF！）,ISERROR就會返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISLOGICAL",
      t: 15,
      d: "檢查某個值是TRUE還是FALSE。",
      a: "檢查某個值是TRUE還是FALSE。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其為邏輯 TRUE 還是邏輯 FALSE 的值。\n\n*如果值為TRUE或FALSE,或為指向值為TRUE或FALSE的儲存格的引用,ISLOGICAL將返回TRUE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNA",
      t: 15,
      d: "檢查某個值是否為錯誤值#N/A。",
      a: "檢查某個值是否為錯誤值#N/A。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要與錯誤值#N/A進行比較的值。\n\n*如果值為#N/A或指向包含#N/A的儲存格的引用,則ISNA將返回TRUE,否則返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNONTEXT",
      t: 15,
      d: "檢查某個值是否為非文字。",
      a: "檢查某個值是否為非文字。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要檢查的文字。\n\n*如果參數為文字值或指向包含文字的儲存格的引用,ISNONTEXT將返回FALSE,否則返回TRUE。\n\n當值為指向空儲存格的引用時,ISNONTEXT會返回TRUE。\n\n當值為空字串時,ISNONTEXT將返回FALSE,因為空串被視作文字。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISNUMBER",
      t: 15,
      d: "檢查某個值是否為數位。",
      a: "檢查某個值是否為數位。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其是否為數位的值。\n\n*如果參數為數位或指向內容為數位值的儲存格的引用,ISNUMBER將返回TRUE,否則返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISREF",
      t: 15,
      d: "檢查某個值是否為有效的儲存格引用。",
      a: "檢查某個值是否為有效的儲存格引用。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其是否為儲存格引用的值。\n\n*如果參數是有效的儲存格引用,ISREF將返回TRUE,否則返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "ISTEXT",
      t: 15,
      d: "檢查某個值是否為文字。",
      a: "檢查某個值是否為文字。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要驗證其是否為文字的值。\n\n如果參數為文字值或指向包含文字值的儲存格的引用,ISTEXT將返回TRUE,否則返回FALSE。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TYPE",
      t: 15,
      d: "返回數值的類型。",
      a: "返回數值的類型。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要確定其類型的數據。\n\n數位返回1；\n\n文字返回2；\n\n邏輯值返回4；\n\n錯誤值返回16；\n\n數組返回64；",
        example: "C4",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "N",
      t: 15,
      d: "返回轉化為數值後的值。",
      a: "返回轉化為數值後的值。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為數位的參數。\n\n如果值為數位,則返回該數位。\n\n如果值為日期,則返回該日期的序號。\n\n如果值為TRUE,則返回1。\n\n如果值為FALSE,則返回0。\n\n如果值為錯誤值,則返回錯誤值。\n\n如果值為其他值,則返回0。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DATE",
      t: 16,
      d: "將指定的數位轉換為日期。",
      a: "將指定的數位轉換為日期。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為日期的參數或其儲存格引用。\n\n如果值為數位或指向內容為數值的儲存格的引用,TO_DATE會將值轉換為相應的日期並返回,值代表從十二月30日到對應的日期之間的天數,\n\n負值表示對應的日期在十二月30日之前,而小數值則代表一天中從午夜算起的時間。\n如果值不是數位或指向內容為數值的儲存格的引用,則TO_DATE將在不做任何修改的情况下返回值。",
        example: "25405",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PURE_NUMBER",
      t: 16,
      d: "將給定的日期/時間、百分比、貨幣金額或其他格式的數值轉換為不帶格式的純數位。",
      a: "將給定的日期/時間、百分比、貨幣金額或其他格式的數值轉換為不帶格式的純數位。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為純數位的參數或其儲存格引用。\n\n如果值為數位或指向包含數值的儲存格的引用,TO_PURE_NUMBER將以不帶任何格式與解釋的形式返回值。\n\n如果值不是數位或指向內容為數值的儲存格的引用,則TO_PERCENT將在不做任何修改的情况下返回值。",
        example: "50%",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_TEXT",
      t: 16,
      d: "將給定的數位值轉換為文本格式。",
      a: "將給定的數位值轉換為文本格式。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為文字的參數或其儲存格引用。\n\n如果值為數位或指向包含數值的儲存格的引用,TO_TEXT將返回字串形式的值,並保持現有格式。即原為貨幣的仍為貨幣,原為十進位數的仍為十進位數,原為百分比的仍為百分比,原為日期的仍為日期。\n\n如果值不是數位或指向內容為數值的儲存格的引用,則TO_TEXT將在不做任何修改的情况下返回值。",
        example: "24",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TO_DOLLARS",
      t: 16,
      d: "將指定的數位轉換為美元金額。",
      a: "將指定的數位轉換為美元金額。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為美元金額的參數或其儲存格引用。\n\n如果值不是數位或指向內容為數值的儲存格的引用,則TO_DOLLARS將在不做任何修改的情况下返回值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "TO_PERCENT",
      t: 16,
      d: "將指定的數位轉換為百分比。",
      a: "將指定的數位轉換為百分比。",
      m: [1, 1],
      p: [{
        name: "value",
        detail: "要轉換為百分比的參數或其儲存格引用。\n\n如果值為數位或指向包含數值的儲存格的引用,TO_PERCENT會以1 = 100%為標準,將值轉換為百分比。\n\n如果值不是數位或指向內容為數值的儲存格的引用,則TO_PERCENT將在不做任何修改的情况下返回值。",
        example: "A2",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DGET",
      t: 17,
      d: "使用SQL式査詢,從清單或資料庫的列中選取符合指定條件的單個值。",
      a: "使用SQL式査詢,從清單或資料庫的列中選取符合指定條件的單個值。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMAX",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的最大數位。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的最大數位。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DMIN",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的最小數位。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的最小數位。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DAVERAGE",
      t: 17,
      d: "使用SQL式査詢,對清單或資料庫中滿足指定條件的記錄欄位（列）中的數值求平均值。",
      a: "使用SQL式査詢,對清單或資料庫中滿足指定條件的記錄欄位（列）中的數值求平均值。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNT",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中包含數位的儲存格的個數。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中包含數位的儲存格的個數。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DCOUNTA",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的非空儲存格的個數。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的非空儲存格的個數。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DPRODUCT",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的數值的乘積。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的數值的乘積。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEV",
      t: 17,
      d: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為一個樣本估算出的總體標準差。",
      a: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為一個樣本估算出的總體標準差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSTDEVP",
      t: 17,
      d: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為樣本總體計算出的總體標準差。",
      a: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為樣本總體計算出的總體標準差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DSUM",
      t: 17,
      d: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的數位之和。",
      a: "使用SQL式査詢,返回列表或資料庫中滿足指定條件的記錄欄位（列）中的數位之和。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVAR",
      t: 17,
      d: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為一個樣本估算出的總體方差。",
      a: "使用SQL式査詢,返回利用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位作為一個樣本估算出的總體方差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "DVARP",
      t: 17,
      d: "使用SQL式査詢,通過使用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位計算樣本總體的樣本總體方差。",
      a: "使用SQL式査詢,通過使用清單或資料庫中滿足指定條件的記錄欄位（列）中的數位計算樣本總體的樣本總體方差。",
      m: [3, 3],
      p: [{
        name: "database",
        detail: "構成清單或資料庫的儲存格區域,清單的第一行包含每一列的標籤。",
        example: "A2:F20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "field",
        detail: "指定database中的哪一列包含要選取和用於計算的值。\n\nfield可以是與database第一行中某個列標題對應的文字標籤,也可以是指定相關列的數位索引,第一列的索引值為1。",
        example: "G2",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "criteria",
        detail: "包含所指定條件的儲存格區域。計算之前將使用這些條件來過濾database中的值。",
        example: "A22:D23",
        require: "m",
        repeat: "n",
        type: "range"
      }]
    }, {
      n: "AGE_BY_IDCARD",
      t: "3",
      d: "據中國身份證號計算出年齡。支持15位或18位身份證",
      a: "據中國身份證號計算出年齡",
      m: [1, 2],
      p: [{
        name: "身份證號",
        example: "A1",
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "截止日期",
        example: '"2017-10-01"',
        detail: "年齡計算的截止日期或範圍,默認為當日。",
        require: "o",
        repeat: "n",
        type: "rangedatetime"
      }]
    }, {
      n: "SEX_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出性別。支持15位或18位身份證",
      a: "根據身份證號得到性別。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BIRTHDAY_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出生日。支持15位或18位身份證",
      a: "根據身份證號得到生日。",
      m: [1, 2],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "生日格式",
        example: "0",
        detail: "日期類型,默認0:[1900/01/01],1:[1900-01-01],2:[1900年1月1日]",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "PROVINCE_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出籍貫的省份。支持15位或18位身份證",
      a: "根據身份證號得到籍貫的省份。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "CITY_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出籍貫的都市。支持15位或18位身份證",
      a: "根據身份證號得到籍貫的都市。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "STAR_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出星座。支持15位或18位身份證",
      a: "根據身份證號得到星座。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ANIMAL_BY_IDCARD",
      t: "3",
      d: "根據中國身份證號計算出生肖（鼠、牛、虎、兔…）。支持15位或18位身份證",
      a: "根據身份證號得到生肖。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "ISIDCARD",
      t: "3",
      d: "驗證身份證的格式是否正確。支持15位或18位身份證",
      a: "驗證身份證格式正確性。",
      m: [1, 1],
      p: [{
        name: "身份證號",
        example: '"31033519900101XXXX"',
        detail: "15位或者18位的身份證號或範圍。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "DM_TEXT_CUTWORD",
      t: "4",
      d: "文字分詞。把一連串文字折開為一系列單獨詞語",
      a: "中文文字分詞。",
      m: [1, 2],
      p: [{
        name: "文字",
        example: '"我來到北京清華大學"',
        detail: "任意需要分詞的文字。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "分詞模式",
        example: "0",
        detail: "默認為0[精確模式]，1[全模式]，2[搜尋引擎模式]。",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TFIDF",
      t: "4",
      d: "採用tf-idf算灋進行關鍵字選取。從一連串文字中識別關鍵字",
      a: "tf-idf關鍵字識別。",
      m: [1, 3],
      p: [{
        name: "文字",
        example: '"我來到北京清華大學"',
        detail: "任意需要分詞的文字。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "關鍵字個數",
        example: "20",
        detail: "算灋返回的關鍵字個數，默認20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "語料庫",
        example: "1",
        detail: "選擇特定領域的語料庫，默認0[通用]，1[金融]，2[醫療]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DM_TEXT_TEXTRANK",
      t: "4",
      d: "採用TextRank算灋進行關鍵字選取。從一連串文字中識別關鍵字",
      a: "TextRank關鍵字識別。",
      m: [1, 3],
      p: [{
        name: "文字",
        example: '"我來到北京清華大學"',
        detail: "任意需要分詞的文字。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "關鍵字個數",
        example: "20",
        detail: "算灋返回的關鍵字個數，默認20",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "語料庫",
        example: "1",
        detail: "選擇特定領域的語料庫，默認0[通用]，1[金融]，2[醫療]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_CLOSE",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票收盤價。",
      a: "返回A股對應股票收盤價。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默認為最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_OPEN",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票開盤價。",
      a: "返回A股對應股票開盤價。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默認為最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MAX",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票最高價。",
      a: "返回A股對應股票最高價。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默認為最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_MIN",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票最低價。",
      a: "返回A股對應股票最低價。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日,默认为最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_VOLUMN",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票成交量。",
      a: "返回A股對應股票成交量。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默認為最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "DATA_CN_STOCK_AMOUNT",
      t: "5",
      d: "根據股票代碼和日期，返回A股對應股票成交額。",
      a: "返回A股對應股票成交額。",
      m: [1, 3],
      p: [{
        name: "股票代碼",
        example: '"000001"',
        detail: "6位股票代碼，必填項。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "日期",
        example: "2015-01-08",
        detail: "股票的交易日，默認為最新交易日",
        require: "o",
        repeat: "n",
        type: "rangedate"
      }, {
        name: "複權除權",
        example: "0",
        detail: "選擇股票的除權複權類型，默認0[前複權]，1[原始價格]，2[後複權]",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "ISDATE",
      t: "6",
      d: "驗證日期的格式是否正確。支持多種日期格式",
      a: "驗證日期格式正確性。",
      m: [1, 1],
      p: [{
        name: "日期",
        example: '"1990-01-01"',
        detail: "日期值,例如1990/01/01, 1990年1月1日等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "LINESPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的折線圖sparklines，用於描述數據的連續走勢",
      a: "生成儲存格折線圖",
      m: [1, 8],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍，數值才能被有效計算，例如A1:A20，{1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "線條顏色",
        example: "#2ec7c9",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "線條粗細",
        example: "1",
        detail: "折線圖線段粗細，默認為1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "輔助線",
        example: "avg",
        detail: "一條橫線，可以是min、max、avg、median、範圍或自定義數值，默認0無",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "輔助線顏色",
        example: "#000",
        detail: "輔助線的顏色設定，同線條顏色配寘，默認#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值標識",
        example: "#fc5c5c",
        detail: "標識線圖最大值，同線條顏色配寘，默認0不顯示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最小值標識",
        example: "#fc5c5c",
        detail: "標識線圖最小值，同線條顏色配寘，默認0不顯示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "標識大小",
        example: "1.5",
        detail: "最大值和最小值的標識大小設定，默認為1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "AREASPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的面積圖sparklines，一般用於描述數據的連續累積值走勢",
      a: "生成儲存格面積圖",
      m: [1, 5],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍，數值才能被有效計算，例如A1:A20，{1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "線條顏色",
        example: "#2ec7c9",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "填充顏色",
        example: "#CCF3F4",
        detail: "形成面積圖，同線條顏色配寘，默認0不顯示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "線條粗細",
        example: "1",
        detail: "折線圖線段粗細，默認為1px",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "輔助線",
        example: "avg",
        detail: "一條橫線，可以是min、max、avg、median、範圍或自定義數值，默認0無",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "輔助線顏色",
        example: "#000",
        detail: "輔助線的顏色設定，同線條顏色配寘，默認#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "COLUMNSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的垂直柱狀圖sparklines，一般用於描述離散數據之間的大小情况",
      a: "生成儲存格垂直柱狀圖",
      m: [1, 6],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍，數值才能被有效計算，例如A1:A20，{1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條間隔",
        example: "1",
        detail: "柱條之間的間隔距離，默認為1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條顏色",
        example: "#fc5c5c",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "負向柱條顏色",
        example: "#97b552",
        detail: "負向柱條顏色設定，代表負值的顏色，同柱條顏色配寘，默認#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "柱圖最大值，用於規範柱圖長度，默認為自動計算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "調色板可以單獨設定每個柱條的顏色，可設定多個，支持兩種格式:1顏色例如#000，代表第一個柱的顏色是黑色；2數值範圍:顏色，例如-2:#000表示數值為-2的柱為黑色，0:5:#000表示數值0-5的柱為黑色，默認為空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKCOLUMNSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的累積垂直柱狀圖sparklines，一般用於描述離散數據多個維度的數值大小",
      a: "生成儲存格累積垂直柱狀圖",
      m: [1, 5],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍，數值才能被有效計算，例如A1:A20，{1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "按列堆積",
        example: "1",
        detail: "如果需要按行堆積則本項設為false或0，默認為是1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條間隔",
        example: "1",
        detail: "柱條之間的間隔距離，默認為1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "累積柱圖最大值，用於規範柱圖長度，默認為自動計算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "累積色板",
        example: "#97b552",
        detail: "調色板可以單獨設定每個維度的柱條顏色，可設定為A1:A10等範圍，默認為#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BARSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的橫向條形圖sparklines，一般用於描述離散數據之間的大小情况",
      a: "生成儲存格橫向條形圖",
      m: [1, 6],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條間隔",
        example: "1",
        detail: "柱條之間的間隔距離，默認為1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條顏色",
        example: "#fc5c5c",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "負向柱條顏色",
        example: "#97b552",
        detail: "負向柱條顏色設定，代表負值的顏色，同柱條顏色配寘，默認#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "柱圖最大值，用於規範柱圖長度，默認為自動計算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "調色板可以單獨設定每個柱條的顏色，可設定多個，支持兩種格式:1顏色例如#000，代表第一個柱的顏色是黑色；2數值範圍:顏色，例如-2:#000表示數值為-2的柱為黑色，0:5:#000表示數值0-5的柱為黑色，默認為空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "STACKBARSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的累積橫向條形圖sparklines，一般用於描述離散數據多個維度的數值大小",
      a: "生成儲存格累積橫向條形圖",
      m: [1, 5],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "按列堆積",
        example: "1",
        detail: "如果需要按行堆積則本項設為false或0，默認為是1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條間隔",
        example: "1",
        detail: "柱條之間的間隔距離，默認為1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "最大值",
        example: "100",
        detail: "累積柱圖最大值，用於規範柱圖長度，默認為自動計算false、auto、null",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "累積色板",
        example: "#97b552",
        detail: "調色板可以單獨設定每個維度的柱條顏色，可設定為A1:A10等範圍，默認為#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "DISCRETESPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的離散圖sparklines，一般用於描述離散數據走勢",
      a: "生成儲存格離散圖",
      m: [1, 4],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "分割閾值",
        example: "1",
        detail: "離散圖柱形顏色的區分，例如:該值為0，則大於0為藍色，小於0為紅色，默認為0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "閾值以上顏色",
        example: "#2ec7c9",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#2ec7c9",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "閾值以下顏色",
        example: "#fc5c5c",
        detail: "閾值以下柱條顏色設定，同閾值以上顏色，默認#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "TRISTATESPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的三態圖sparklines，一般用於描述三種態勢的走勢例如勝負平",
      a: "生成儲存格三態圖",
      m: [1, 6],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條間隔",
        example: "1",
        detail: "柱條之間的間隔距離，默認為1",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "柱條顏色",
        example: "#fc5c5c",
        detail: "線圖的線條顏色，可以是否個範圍A1、色錶索引數值或者具體顏色值，設定為0或false則不顯示，支持regx、rgb、rgba等。默認#fc5c5c",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "负向柱條顏色",
        example: "#97b552",
        detail: "負向柱條顏色設定，代表負值的顏色，同柱條顏色配寘，默認#97b552",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "零值柱條顏色",
        example: "#999",
        detail: "零值柱條顏色設定，代表0值顏色，同柱條顏色配寘，默認#999",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "色板",
        example: "#97b552",
        detail: "調色板可以單獨設定每個柱條的顏色，可設定多個，支持兩種格式:1顏色例如#000，代表第一個柱的顏色是黑色；2數值範圍:顏色，例如-2:#000表示數值為-2的柱為黑色，0-5:#000表示數值0-5的柱為黑色，默認為空",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "PIESPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的餅圖sparklines，一般用於描述數據占比",
      a: "生成儲存格餅圖",
      m: [1, 5],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "旋轉角度",
        example: "0",
        detail: "餅圖的旋轉角度，默認為0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "餅圖邊框",
        example: "0",
        detail: "餅圖邊框大小，默認為無0",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "邊框顏色",
        example: "#000",
        detail: "餅圖邊框顏色，默認為#000",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "餅圖色板",
        example: "#97b552",
        detail: "調色板可以設定切片的顏色，可設定為A1:A10等範圍，默認為#2ec7c9, #fc5c5c, #5ab1ef, #ffb980...",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "BOXSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的箱線圖sparklines，一般用於描述數據集的統計分佈",
      a: "生成儲存格箱線圖",
      m: [1, 4],
      p: [{
        name: "數據範圍",
        example: "A1:A20",
        detail: "數據範圍,數值才能被有效計算，例如A1:A20, {1,2,3,4,5}等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "離群點比例",
        example: "1.5",
        detail: "離群點的閾值範圍，如果為0或false則不顯示，默認為1.5倍",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "目標點值",
        example: "10",
        detail: "箱線圖上的目標值設定，默認為false不顯示",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "數據點大小",
        example: "1.5",
        detail: "目標點和離群點的半徑大小設定，默認為1.5",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "BULLETSPLINES",
      t: "3",
      d: "生成嵌入在儲存格內的子彈圖sparklines，一般用於描述任務達成率",
      a: "生成儲存格子彈圖",
      m: [2, 3],
      p: [{
        name: "目標",
        example: "10",
        detail: "達成的目標值，數值才能被有效計算，例如A1，100等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "實際完成",
        example: "8",
        detail: "現時完成值，數值才能被有效計算，例如A1，100等。",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "對比值",
        example: "12",
        detail: "對比值，例如超額、最低、獲獎底線等，數值才能被有效計算，例如A1，100等。可以設定最多9個對比值",
        require: "o",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "COMPOSESPLINES",
      t: "3",
      d: "支持多個類型的圖畫在同一個儲存格，每個參數代表一個sparklines圖",
      a: "組合sparklines圖到一個儲存格",
      m: [1, 1],
      p: [{
        name: "圖設定",
        example: "PIESPLINES(A1:A20)",
        detail: "sparklines圖設定，例如A1:A20，一個完成的餅圖、線圖設定等。",
        require: "m",
        repeat: "y",
        type: "rangeall"
      }]
    }, {
      n: "SORT",
      t: "14",
      d: "返回數組中元素的排序數組。返回的數組與提供的數組參數形狀相同。",
      a: "返回數組中元素的排序數組。返回的數組與提供的數組參數形狀相同。",
      m: [1, 4],
      p: [{
        name: "array",
        detail: "要排序的範圍或數組。",
        example: "A2:A17",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_index",
        detail: "[可選] - 表示要排序的行或列的數位。（默認row1/col1）",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "sort_order",
        detail: "[可選] - 表示所需排序順序的數位；1表示昇冪（默認），-1表示降序。",
        example: "-1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[可選] - 表示所需排序方向的邏輯值；按行排序為FALSE（）（默認），按列排序為TRUE（）。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "FILTER",
      t: "14",
      d: "基於一個布林（真/假）數組過濾一個數組。",
      a: "基於一個布林（真/假）數組過濾一個數組。",
      m: [2, 3],
      p: [{
        name: "array",
        detail: "要篩選的數組或範圍。",
        example: "A5:D20",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "include",
        detail: "布林數組，其高度或寬度與數組相同",
        example: "1",
        require: "m",
        repeat: "n",
        type: "range"
      }, {
        name: "if_empty",
        detail: "[可選] - 如果包含數組中的所有值都為空（filter不返回任何值），則返回的值。",
        example: '""',
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "UNIQUE",
      t: "14",
      d: "返回列表或區域中的唯一值的清單。",
      a: "返回列表或區域中的唯一值的清單。",
      m: [1, 3],
      p: [{
        name: "array",
        detail: "從其返回唯一值的數組或區域。",
        example: "A2:B26",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "by_col",
        detail: "[可選] - 邏輯值，訓示如何比較；按行= FALSE（）或省略；按列= TRUE（）。",
        example: "TRUE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }, {
        name: "occurs_once",
        detail: "[可選] - 邏輯值，僅返回唯一值中出現一次= TRUE（）；包括所有唯一值= FALSE（）或省略。",
        example: "FALSE()",
        require: "o",
        repeat: "n",
        type: "rangeall"
      }]
    }, {
      n: "RANDARRAY",
      t: "14",
      d: "返回0到1之間的隨機數位數組。",
      a: "返回0到1之間的隨機數位數組",
      m: [0, 2],
      p: [{
        name: "rows",
        detail: "[可選] - 要返回的行數。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "[可選] - 要返回的列數。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "SEQUENCE",
      t: "14",
      d: "生成數位序列的清單。",
      a: "生成數位序列的清單。",
      m: [1, 4],
      p: [{
        name: "rows",
        detail: "要返回的行數。",
        example: "1",
        require: "m",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "cols",
        detail: "[可選] - 要返回的列數。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "start",
        detail: "[可選] - 序列中的第一個數位。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }, {
        name: "step",
        detail: "[可選] -序列中每個序列值的增量。",
        example: "1",
        require: "o",
        repeat: "n",
        type: "rangenumber"
      }]
    }, {
      n: "EVALUATE",
      t: "3",
      d: "對以文字表示的公式或者表達式求值，並返回結果。",
      a: "根據文字公式或者表達式求值。",
      m: [1, 1],
      p: [{
        name: "公式",
        example: '"A1+5*2^2"',
        detail: "公式或表達式",
        require: "m",
        repeat: "n",
        type: "rangeall"
      }]
    }],
    toolbar: {
      undo: "撤銷",
      redo: "重做",
      paintFormat: "格式刷",
      currencyFormat: "貨幣格式",
      percentageFormat: "百分比格式",
      numberDecrease: "减少小數位數",
      numberIncrease: "新增小數位數",
      moreFormats: "更多格式",
      font: "字體",
      "font-size": "字型大小",
      bold: "粗體（Ctrl+B）",
      italic: "斜體（Ctrl+I）",
      strikethrough: "删除線（Alt+Shift+5）",
      underline: "底線",
      "font-color": "文字顏色",
      chooseColor: "顏色選擇",
      resetColor: "重置顏色",
      customColor: "自定義",
      alternatingColors: "交替顏色",
      confirmColor: "確定顏色",
      cancelColor: "取消",
      collapse: "收起",
      background: "儲存格顏色",
      border: "邊框",
      borderStyle: "邊框類型",
      "merge-cell": "合併儲存格",
      chooseMergeType: "選擇合併類型",
      horizontalAlign: "水准對齊",
      verticalAlign: "垂直對齊",
      alignment: "對齊管道",
      textWrap: "文字換行",
      textWrapMode: "換行管道",
      textRotate: "文字旋轉",
      textRotateMode: "旋轉管道",
      freeze: "凍結",
      sort: "排序",
      filter: "篩選",
      findAndReplace: "查找替換",
      "formula-sum": "求和",
      autoSum: "自動求和",
      moreFunction: "更多函數",
      conditionalFormat: "條件格式",
      comment: "批註",
      pivotTable: "數據透視錶",
      chart: "圖表",
      screenshot: "截圖",
      splitColumn: "分列",
      insertImage: "插入圖片",
      insertLink: "插入連結",
      dataVerification: "數據驗證",
      protection: "保護工作表內容",
      clearText: "清除顏色選擇",
      noColorSelectedText: "沒有顏色被選擇",
      toolMore: "更多",
      toolLess: "少於",
      toolClose: "收起",
      toolMoreTip: "更多功能",
      moreOptions: "更多選項",
      cellFormat: "設定儲存格格式",
      print: "列印"
    },
    alternatingColors: {
      applyRange: "應用範圍",
      selectRange: "選擇應用範圍",
      header: "頁眉",
      footer: "頁腳",
      errorInfo: "不能對多重選擇區域執行此操作,請選擇單個區域,然後再試",
      textTitle: "格式樣式",
      custom: "自定義",
      close: "關閉",
      selectionTextColor: "選擇文字顏色",
      selectionCellColor: "選擇儲存格顏色",
      removeColor: "移除交替顏色",
      colorShow: "顏色",
      currentColor: "當前顏色",
      tipSelectRange: "請選擇交替顏色應用範圍",
      errorNoRange: "您選擇的應用範圍不是選區！",
      errorExistColors: "您選擇的應用範圍已存在交替顏色且不屬於你要編輯的應用範圍！"
    },
    button: {
      confirm: "確定",
      cancel: "取消",
      close: "關閉",
      update: "Update",
      delete: "Delete",
      insert: "新建",
      prevPage: "上一頁",
      nextPage: "下一頁",
      total: "總共："
    },
    paint: {
      start: "格式刷開啟",
      end: "ESC鍵退出",
      tipSelectRange: "請選擇需要複製格式的區域",
      tipNotMulti: "無法對多重選擇區域執行此操作"
    },
    format: {
      moreCurrency: "更多貨幣格式",
      moreDateTime: "更多日期與時間格式",
      moreNumber: "更多數位格式",
      titleCurrency: "貨幣格式",
      decimalPlaces: "小數位數",
      titleDateTime: "日期與時間格式",
      titleNumber: "數位格式"
    },
    info: {
      detailUpdate: "新打開",
      detailSave: "已恢復本地緩存",
      row: "行",
      column: "列",
      loading: "加载中···",
      copy: "副本",
      return: "返回",
      rename: "重命名",
      tips: "表格重命名",
      noName: "無標題的試算表",
      wait: "待更新",
      add: "添加",
      addLast: "在底部添加",
      backTop: "回到頂部",
      pageInfo: "共${total}條,${totalPage}頁,當前已顯示${currentPage}頁",
      nextPage: "下一頁",
      tipInputNumber: "請輸入數位",
      tipInputNumberLimit: "新增範圍限制在1-100",
      tipRowHeightLimit: "行高必須在0 ~ 545之間",
      tipColumnWidthLimit: "列寬必須在0 ~ 2038之間",
      pageInfoFull: "共${total}條,${totalPage}頁,已顯示全部數據"
    },
    currencyDetail: {
      RMB: "人民幣",
      USdollar: "美元",
      EUR: "歐元",
      GBP: "英鎊",
      HK: "港元",
      JPY: "日元",
      AlbanianLek: "阿爾巴尼亞列克",
      AlgerianDinar: "阿爾及利亞第納爾",
      Afghani: "阿富汗尼",
      ArgentinePeso: "阿根廷比索",
      UnitedArabEmiratesDirham: "阿拉伯聯合大公國迪拉姆",
      ArubanFlorin: "阿魯巴弗羅林",
      OmaniRial: "阿曼裡亞爾",
      Azerbaijanimanat: "阿塞拜疆馬納特",
      EgyptianPound: "埃及鎊",
      EthiopianBirr: "衣索比亞比爾",
      AngolaKwanza: "安哥拉寬紮",
      AustralianDollar: "澳大利亞元",
      Patacas: "澳門元",
      BarbadosDollar: "巴巴多斯元",
      PapuaNewGuineaKina: "巴布亞新幾內亞基那",
      BahamianDollar: "巴哈馬元",
      PakistanRupee: "巴基斯坦盧比",
      ParaguayanGuarani: "巴拉圭瓜拉尼",
      BahrainiDinar: "巴林第納爾",
      PanamanianBalboa: "巴拿馬巴波亞",
      Brazilianreal: "巴西裏亞伊",
      Belarusianruble: "白俄羅斯盧布",
      BermudianDollar: "百慕大元",
      BulgarianLev: "保加利亞列弗",
      IcelandKrona: "冰島克朗",
      BosniaHerzegovinaConvertibleMark: "波黑可兌換馬克",
      PolishZloty: "波蘭茲羅提",
      Boliviano: "玻利維亞諾",
      BelizeDollar: "貝裡斯元",
      BotswanaPula: "波劄那普拉",
      NotDannuzhamu: "不丹努紮姆",
      BurundiFranc: "布隆迪法郎",
      NorthKoreanWon: "朝鮮圓",
      DanishKrone: "丹麥克朗",
      EastCaribbeanDollar: "東加勒比元",
      DominicaPeso: "多明尼加比索",
      RussianRuble: "俄國盧布",
      EritreanNakfa: "厄利垂亞納克法",
      CFAfranc: "非洲金融共同體法郎",
      PhilippinePeso: "菲律賓比索",
      FijiDollar: "斐濟元",
      CapeVerdeEscudo: "佛得角埃斯庫多",
      FalklandIslandsPound: "福克蘭群島鎊",
      GambianDalasi: "岡比亞達拉西",
      Congolesefranc: "剛果法郎",
      ColombianPeso: "哥倫比亞比索",
      CostaRicanColon: "哥斯大黎加科朗",
      CubanPeso: "古巴比索",
      Cubanconvertiblepeso: "古巴可兌換比索",
      GuyanaDollar: "蓋亞那元",
      KazakhstanTenge: "哈薩克共和國堅戈",
      Haitiangourde: "海地古德",
      won: "韓元",
      NetherlandsAntillesGuilder: "荷屬安的列斯盾",
      Honduraslempiras: "洪都拉斯拉倫皮拉",
      DjiboutiFranc: "吉布提法郎",
      KyrgyzstanSom: "吉爾吉斯斯坦索姆",
      GuineaFranc: "幾內亞法郎",
      CanadianDollar: "加拿大元",
      GhanaianCedi: "加納塞地",
      Cambodianriel: "高棉瑞爾",
      CzechKoruna: "捷克克朗",
      ZimbabweDollar: "辛巴威元",
      QatariRiyal: "卡塔爾裡亞爾",
      CaymanIslandsDollar: "開曼群島元",
      Comorianfranc: "科摩羅法郎",
      KuwaitiDinar: "科威特第納爾",
      CroatianKuna: "克羅地亞庫納",
      KenyanShilling: "肯雅先令",
      LesothoLoti: "萊索托洛蒂",
      LaoKip: "老撾基普",
      LebanesePound: "黎巴嫩鎊",
      Lithuanianlitas: "立陶宛立特",
      LibyanDinar: "利比亞第納爾",
      LiberianDollar: "利比亞元",
      RwandaFranc: "盧安達法郎",
      RomanianLeu: "羅馬尼亞列伊",
      MalagasyAriary: "馬拉加西阿裏亞裏",
      MaldivianRufiyaa: "瑪律地夫拉菲亞",
      MalawiKwacha: "馬拉威克瓦查",
      MalaysianRinggit: "馬來西亞林吉特",
      MacedoniawearingDinar: "馬其頓戴第納爾",
      MauritiusRupee: "模裡西斯盧比",
      MauritanianOuguiya: "茅利塔尼亞烏吉亞",
      MongolianTugrik: "蒙古圖格裡克",
      BangladeshiTaka: "孟加拉塔卡",
      PeruvianNuevoSol: "秘魯新索爾",
      MyanmarKyat: "緬甸開亞特",
      MoldovanLeu: "莫爾達瓦列伊",
      MoroccanDirham: "摩洛哥迪拉姆",
      MozambiqueMetical: "莫三比克梅蒂卡爾",
      MexicanPeso: "墨西哥比索",
      NamibianDollar: "納米比亞元",
      SouthAfricanRand: "南非蘭特",
      SouthSudanesePound: "南蘇丹鎊",
      NicaraguaCordoba: "尼加拉瓜科多巴",
      NepaleseRupee: "尼泊爾盧比",
      NigerianNaira: "奈及利亞奈拉",
      NorwegianKrone: "挪威克朗",
      GeorgianLari: "喬治亞拉瑞",
      RMBOffshore: "人民幣（離岸）",
      SwedishKrona: "瑞典克朗",
      SwissFranc: "瑞士法郎",
      SerbianDinar: "塞爾維亞第納爾",
      SierraLeone: "塞拉里昂利昂",
      SeychellesRupee: "塞舌耳盧比",
      SaudiRiyal: "沙特裡亞爾",
      SaoTomeDobra: "聖多美多布拉",
      SaintHelenapound: "聖赫倫那群島磅",
      SriLankaRupee: "斯里蘭卡盧比",
      SwazilandLilangeni: "史瓦濟蘭裏蘭吉尼",
      SudanesePound: "蘇丹鎊",
      Surinamesedollar: "蘇利南元",
      SolomonIslandsDollar: "所羅門群島元",
      SomaliShilling: "索馬利亞先令",
      TajikistanSomoni: "塔吉克共和國索莫尼",
      PacificFranc: "太平洋法郎",
      ThaiBaht: "泰國銖",
      TanzanianShilling: "坦尚尼亞先令",
      TonganPaanga: "東加潘加",
      TrinidadandTobagoDollar: "千裡達托貝哥元",
      TunisianDinar: "突尼斯第納爾",
      TurkishLira: "土耳其里拉",
      VanuatuVatu: "瓦努阿圖瓦圖",
      GuatemalanQuetzal: "瓜地馬拉格查爾",
      CommissionBolivar: "委內瑞拉博利瓦",
      BruneiDollar: "汶萊元",
      UgandanShilling: "烏干達先令",
      UkrainianHryvnia: "烏克蘭格裡夫尼亞",
      UruguayanPeso: "烏拉圭比索",
      Uzbekistansom: "烏茲別克蘇姆",
      WesternSamoaTala: "薩摩亞塔拉",
      SingaporeDollar: "新加坡元",
      NT: "新臺幣",
      NewZealandDollar: "新西蘭元",
      HungarianForint: "匈牙利福林",
      SyrianPound: "敘利亞鎊",
      JamaicanDollar: "牙買加元",
      ArmenianDram: "亞美尼亞德拉姆",
      YemeniRial: "葉門裡亞爾",
      IraqiDinar: "伊拉克第納爾",
      IranianRial: "伊朗裡亞爾",
      NewIsraeliShekel: "以色列新謝克爾",
      IndianRupee: "印度盧比",
      IndonesianRupiah: "印尼盧比",
      JordanianDinar: "約旦第納爾",
      VND: "越南盾",
      ZambianKwacha: "尚比亞克瓦查",
      GibraltarPound: "直布羅陀鎊",
      ChileanPeso: "智利比索",
      CFAFrancBEAC: "中非金融合作法郎"
    },
    defaultFmt: [{
      text: "自動",
      value: "General",
      example: ""
    }, {
      text: "純文字",
      value: "@",
      example: ""
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "數位",
      value: "##0.00",
      example: "1000.12"
    }, {
      text: "百分比",
      value: "#0.00%",
      example: "12.21%"
    }, {
      text: "科學計數",
      value: "0.00E+00",
      example: "1.01E+5"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "會計",
      value: "¥(0.00)",
      example: "¥(1200.09)"
    }, {
      text: "萬元",
      value: "w",
      example: "1亿2000万2500"
    }, {
      text: "貨幣",
      value: "¥0.00",
      example: "¥1200.09"
    }, {
      text: "萬元2位小數",
      value: "w0.00",
      example: "2万2500.55"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "日期",
      value: "yyyy-MM-dd",
      example: "2017-11-29"
    }, {
      text: "時間",
      value: "hh:mm AM/PM",
      example: "3:00 PM"
    }, {
      text: "時間24H",
      value: "hh:mm",
      example: "15:00"
    }, {
      text: "日期時間",
      value: "yyyy-MM-dd hh:mm AM/PM",
      example: "2017-11-29 3:00 PM"
    }, {
      text: "日期時間24H",
      value: "yyyy-MM-dd hh:mm",
      example: "2017-11-29 15:00"
    }, {
      text: "",
      value: "split",
      example: ""
    }, {
      text: "自定義格式",
      value: "fmtOtherSelf",
      example: "more"
    }],
    dateFmtList: [{
      name: "1930-08-05",
      value: "yyyy-MM-dd"
    }, {
      name: "1930/8/5",
      value: "yyyy/MM/dd"
    }, {
      name: "1930年8月5日",
      value: 'yyyy"年"M"月"d"日"'
    }, {
      name: "08-05",
      value: "MM-dd"
    }, {
      name: "8-5",
      value: "M-d"
    }, {
      name: "8月5日",
      value: 'M"月"d"日"'
    }, {
      name: "13:30:30",
      value: "h:mm:ss"
    }, {
      name: "13:30",
      value: "h:mm"
    }, {
      name: "下午01:30",
      value: "上午/下午 hh:mm"
    }, {
      name: "下午1:30",
      value: "上午/下午 h:mm"
    }, {
      name: "下午1:30:30",
      value: "上午/下午 h:mm:ss"
    }, {
      name: "08-05 下午01:30",
      value: "MM-dd 上午/下午 hh:mm"
    }],
    fontFamily: {
      MicrosoftYaHei: "Microsoft YaHei"
    },
    fontarray: ["Times New Roman", "Arial", "Tahoma", "Verdana", "微軟雅黑", "宋體", "黑體", "楷體", "仿宋", "新宋體", "華文新魏", "華文行楷", "華文隸書"],
    fontjson: {
      "times new roman": 0,
      arial: 1,
      tahoma: 2,
      verdana: 3,
      微軟雅黑: 4,
      "microsoft yahei": 4,
      宋體: 5,
      simsun: 5,
      黑體: 6,
      simhei: 6,
      楷體: 7,
      kaiti: 7,
      仿宋: 8,
      fangsong: 8,
      新宋體: 9,
      nsimsun: 9,
      華文新魏: 10,
      stxinwei: 10,
      華文行楷: 11,
      stxingkai: 11,
      華文隸書: 12,
      stliti: 12
    },
    border: {
      borderTop: "上框線",
      borderBottom: "下框線",
      borderLeft: "左框線",
      borderRight: "右框線",
      borderNone: "無",
      borderAll: "所有",
      borderOutside: "外側",
      borderInside: "內側",
      borderHorizontal: "內側橫線",
      borderVertical: "內側分隔號",
      borderColor: "邊框顏色",
      borderSize: "邊框粗細",
      borderSlash: "邊框斜線"
    },
    merge: {
      mergeAll: "全部合併",
      mergeV: "垂直合併",
      mergeH: "水平合併",
      mergeCancel: "取消合併",
      overlappingError: "不能合併重疊區域",
      partiallyError: "無法對部分合併儲存格執行此操作"
    },
    align: {
      left: "左對齊",
      center: "中間對齊",
      right: "右對齊",
      top: "頂部對齊",
      middle: "居中對齊",
      bottom: "底部對齊"
    },
    textWrap: {
      overflow: "溢出",
      wrap: "自動換行",
      clip: "截斷"
    },
    rotation: {
      none: "無旋轉",
      angleup: "向上傾斜",
      angledown: "向下傾斜",
      vertical: "豎排文字",
      rotationUp: "向上90°",
      rotationDown: "向下90°"
    },
    freezen: {
      default: "凍結第一行",
      freezenRow: "凍結第一行",
      freezenColumn: "凍結第A列",
      freezenRC: "凍結行列",
      freezenRowRange: "凍結至當前行",
      freezenColumnRange: "凍結至當前列",
      freezenRCRange: "凍結至當前行列",
      freezenCancel: "取消凍結",
      noSeletionError: "没有選區",
      rangeRCOverErrorTitle: "凍結提醒",
      rangeRCOverError: "凍結窗格超過可見範圍，會導致無法正常操作，請重新設定凍結區域。"
    },
    sort: {
      asc: "昇冪",
      desc: "降序",
      custom: "自定義排序",
      hasTitle: "數據具有標題行",
      sortBy: "排序依據",
      addOthers: "添加其他排序列",
      close: "關閉",
      confirm: "排序",
      columnOperation: "列",
      secondaryTitle: "次要排序",
      sortTitle: "排序範圍",
      sortRangeTitle: "排序範圍從",
      sortRangeTitleTo: "到",
      noRangeError: "不能對多重選擇區域執行此操作,請選擇單個區域,然後再試",
      mergeError: "選區有合併儲存格,無法執行此操作！"
    },
    filter: {
      filter: "篩選",
      clearFilter: "清除篩選",
      sortByAsc: "升序排列",
      sortByDesc: "降序排列",
      filterByColor: "按顏色篩選",
      filterByCondition: "按條件過濾",
      filterByValues: "按值過濾",
      filiterInputNone: "無",
      filiterInputTip: "輸入篩選值",
      filiterRangeStartTip: "範圍開始",
      filiterRangeEndTip: "範圍结束",
      filterValueByAllBtn: "全選",
      filterValueByClearBtn: "清除",
      filterValueByInverseBtn: "反選",
      filterValueByTip: "按照值進行篩選",
      filterConform: "確 認",
      filterCancel: "取 消",
      conditionNone: "無",
      conditionCellIsNull: "儲存格為空",
      conditionCellNotNull: "儲存格有數據",
      conditionCellTextContain: "文字包含",
      conditionCellTextNotContain: "文字不包含",
      conditionCellTextStart: "文字開頭為",
      conditionCellTextEnd: "文字結尾為",
      conditionCellTextEqual: "文字等於",
      conditionCellDateEqual: "日期等於",
      conditionCellDateBefore: "日期早於",
      conditionCellDateAfter: "日期晚於",
      conditionCellGreater: "大於",
      conditionCellGreaterEqual: "大於等於",
      conditionCellLess: "小於",
      conditionCellLessEqual: "小于等於",
      conditionCellEqual: "等於",
      conditionCellNotEqual: "不等於",
      conditionCellBetween: "介於",
      conditionCellNotBetween: "不在其中",
      filiterMoreDataTip: "數據量大！請稍後",
      filiterMonthText: "月",
      filiterYearText: "年",
      filiterByColorTip: "按儲存格顏色篩選",
      filiterByTextColorTip: "按儲存格字體顏色篩選",
      filterContainerOneColorTip: "本列僅包含一種顏色",
      filterDateFormatTip: "日期格式",
      valueBlank: "(空白)",
      mergeError: "篩選選區有合併儲存格,無法執行此操作！"
    },
    rightclick: {
      copy: "複製",
      copyAs: "複製為",
      paste: "粘貼",
      insert: "插入",
      image: "插入圖片",
      link: "插入連結",
      delete: "删除",
      deleteCell: "删除儲存格",
      deleteSelected: "删除選中",
      hide: "隱藏",
      hideSelected: "隱藏選中",
      showHide: "顯示隱藏",
      to: "向",
      left: "左",
      right: "右",
      top: "上",
      bottom: "下",
      moveLeft: "左移",
      moveUp: "上移",
      add: "新增",
      row: "行",
      column: "列",
      width: "寬",
      height: "高",
      number: "數位",
      confirm: "確認",
      orderAZ: "升序排列",
      orderZA: "降序排列",
      clearContent: "清除內容",
      matrix: "矩陣操作選區",
      sortSelection: "排序選區",
      filterSelection: "篩選選區",
      chartGeneration: "圖表生成",
      firstLineTitle: "首行為標題",
      untitled: "無標題",
      array1: "一維數組",
      array2: "二維陣列",
      array3: "多元數組",
      diagonal: "對角線",
      antiDiagonal: "反對角線",
      diagonalOffset: "對角偏移",
      offset: "偏移量",
      boolean: "布林值",
      flip: "翻轉",
      upAndDown: "上下",
      leftAndRight: "左右",
      clockwise: "順時針",
      counterclockwise: "逆時針",
      transpose: "轉置",
      matrixCalculation: "矩陣計算",
      plus: "加",
      minus: "减",
      multiply: "乘",
      divided: "除",
      power: "次方",
      root: "次方根",
      log: "log",
      delete0: "删除兩端0值",
      removeDuplicate: "删除重複值",
      byRow: "按行",
      byCol: "按列",
      generateNewMatrix: "生成新矩陣",
      noMulti: "無法對多重選擇區域執行此操作,請選擇單個區域",
      cannotDeleteAllRow: "無法刪除所有行",
      cannotDeleteAllColumn: "無法刪除所有列",
      cannotDeleteRowReadOnly: "無法刪除只讀行",
      cannotDeleteColumnReadOnly: "無法刪除只讀列",
      cannotInsertOnRowReadOnly: "無法對只讀行插入",
      cannotInsertOnColumnReadOnly: "無法對只讀列插入",
      rowOverLimit: "超出10000行限制",
      columnOverLimit: "超出1000列限制"
    },
    comment: {
      insert: "新建批註",
      edit: "編輯批註",
      delete: "删除",
      showOne: "顯示/隱藏批註",
      showAll: "顯示/隱藏所有批註"
    },
    screenshot: {
      screenshotTipNoSelection: "請框選需要截圖的範圍",
      screenshotTipTitle: "提示！",
      screenshotTipHasMerge: "無法對合併儲存格執行此操作",
      screenshotTipHasMulti: "無法對多重選擇區域執行此操作",
      screenshotTipSuccess: "截取成功",
      screenshotImageName: "截圖",
      downLoadClose: "關閉",
      downLoadCopy: "複製到剪切板",
      downLoadBtn: "下載",
      browserNotTip: "下載功能IE瀏覽器不支持！",
      rightclickTip: "請在圖片上右鍵點擊'複製'",
      successTip: "已成功複製（如果粘貼失敗,請在圖片上右鍵點擊'複製圖片'）"
    },
    splitText: {
      splitDelimiters: "分割符號",
      splitOther: "其它",
      splitContinueSymbol: "連續分隔符號視為單個處理",
      splitDataPreview: "數據預覽",
      splitTextTitle: "文字分列",
      splitConfirmToExe: "此處已有數據,是否替換它？",
      splitSymbols: [{
        name: "Tab鍵",
        value: "Tab"
      }, {
        name: "分號",
        value: "semicolon"
      }, {
        name: "逗號",
        value: "comma"
      }, {
        name: "空格",
        value: "space"
      }],
      tipNoMulti: "能對多重選擇區域執行此操作,請選擇單個區域,然後再試",
      tipNoMultiColumn: "一次只能轉換一列數據,選定區域可以有多行,但不能有多列,請在選定單列區域以後再試",
      tipNoSelect: "沒有選擇儲存格不能進行分列"
    },
    imageText: {
      imageSetting: "圖片設定",
      close: "關閉",
      conventional: "常規",
      moveCell1: "移動並調整儲存格大小",
      moveCell2: "移動並且不調整儲存格的大小",
      moveCell3: "不要移動儲存格並調整其大小",
      fixedPos: "固定位置",
      border: "邊框",
      width: "寬度",
      radius: "半徑",
      style: "樣式",
      solid: "實線",
      dashed: "虛線",
      dotted: "點狀",
      double: "雙線",
      color: "顏色"
    },
    punctuation: {
      tab: "Tab 鍵",
      semicolon: "分號",
      comma: "逗號",
      space: "空格"
    },
    findAndReplace: {
      find: "查找",
      replace: "替換",
      goto: "轉到",
      location: "定位條件",
      formula: "公式",
      date: "日期",
      number: "數位",
      string: "字元",
      error: "錯誤",
      condition: "條件格式",
      rowSpan: "間隔行",
      columnSpan: "間隔列",
      locationExample: "定位",
      lessTwoRowTip: "請選擇最少兩行",
      lessTwoColumnTip: "請選擇最少兩行",
      findTextbox: "查找内容",
      replaceTextbox: "替換內容",
      regexTextbox: "規則運算式匹配",
      wholeTextbox: "整詞匹配",
      distinguishTextbox: "區分大小寫匹配",
      allReplaceBtn: "全部替換",
      replaceBtn: "替換",
      allFindBtn: "查找全部",
      findBtn: "查找下一個",
      noFindTip: "沒有查找到該內容",
      modeTip: "該模式下不可進行此操作",
      searchTargetSheet: "工作表",
      searchTargetCell: "儲存格",
      searchTargetValue: "值",
      searchInputTip: "請輸入查找內容",
      noReplceTip: "沒有可替換的內容",
      noMatchTip: "找不到匹配項",
      successTip: "已經幫您蒐索並進行了${xlength}處替換",
      locationConstant: "常數",
      locationFormula: "公式",
      locationDate: "日期",
      locationDigital: "數位",
      locationString: "字元",
      locationBool: "邏輯值",
      locationError: "錯誤",
      locationNull: "空值",
      locationCondition: "條件格式",
      locationRowSpan: "間隔行",
      locationColumnSpan: "間隔列",
      locationTiplessTwoRow: "請選擇最少兩行",
      locationTiplessTwoColumn: "請選擇最少兩列",
      locationTipNotFindCell: "未找到儲存格"
    },
    sheetconfig: {
      delete: "删除",
      copy: "複製",
      rename: "重命名",
      changeColor: "更改顏色",
      hide: "隱藏",
      unhide: "取消隱藏",
      moveLeft: "向左移",
      moveRight: "向右移",
      resetColor: "重置顏色",
      cancelText: "取消",
      chooseText: "確定顏色",
      focus: "聚焦",
      tipNameRepeat: "籤頁的名稱不能重複！請重新修改",
      noMoreSheet: "工作薄內至少含有一張可視工作表。若需删除選定的工作表,請先插入一張新工作表或顯示一張隱藏的工作表。。",
      confirmDelete: "是否删除",
      redoDelete: "可以通過Ctrl+Z撤銷删除",
      noHide: "不能隱藏,至少保留一個sheet標籤",
      chartEditNoOpt: "圖表編輯模式下不允許該操作！",
      sheetNameSpecCharError: `名稱不能包含:[ ] :  ? * / ' "`,
      sheetNamecannotIsEmptyError: "名稱不能為空"
    },
    conditionformat: {
      conditionformat_greaterThan: "條件格式——大於",
      conditionformat_greaterThan_title: "為大於以下值的儲存格設定格式",
      conditionformat_lessThan: "條件格式——小於",
      conditionformat_lessThan_title: "為小於以下值的儲存格設定格式",
      conditionformat_between: "條件格式——介於",
      conditionformat_between_title: "為介於以下值的儲存格設定格式",
      conditionformat_equal: "條件格式——等於",
      conditionformat_equal_title: "為等於以下值的儲存格設定格式",
      conditionformat_textContains: "條件格式——文字包含",
      conditionformat_textContains_title: "為包含以下文字的儲存格設定格式",
      conditionformat_occurrenceDate: "條件格式——發生日期",
      conditionformat_occurrenceDate_title: "為包含以下日期的儲存格設定格式",
      conditionformat_duplicateValue: "條件格式——重複值",
      conditionformat_duplicateValue_title: "為包含以下類型值的儲存格設定格式",
      conditionformat_top10: "條件格式——前10項",
      conditionformat_top10_percent: "條件格式——前10%",
      conditionformat_top10_title: "為值最大的那些儲存格設定格式",
      conditionformat_last10: "條件格式——最後10項",
      conditionformat_last10_percent: "條件格式——最後10%",
      conditionformat_last10_title: "為值最小的那些儲存格設定格式",
      conditionformat_aboveAverage: "條件格式——高於平均值",
      conditionformat_aboveAverage_title: "為高於平均值的儲存格設定格式",
      conditionformat_belowAverage: "條件格式——低於平均值",
      conditionformat_belowAverage_title: "為低於平均值的儲存格設定格式",
      rule: "規則",
      newRule: "新建規則",
      editRule: "編輯規則",
      deleteRule: "删除規則",
      deleteCellRule: "清除所選儲存格的規則",
      deleteSheetRule: "清除整個工作表的規則",
      manageRules: "管理規則",
      showRules: "顯示其格式規則",
      highlightCellRules: "突出顯示儲存格規則",
      itemSelectionRules: "項目選取規則",
      conditionformatManageRules: "條件格式規則管理器",
      format: "格式",
      setFormat: "設定格式",
      setAs: "設定為",
      setAsByArea: "針對選定區域,設定為",
      applyRange: "應用範圍",
      selectRange: "點擊選擇應用範圍",
      selectRange_percent: "所選範圍的百分比",
      selectRange_average: "選定範圍的平均值",
      selectRange_value: "選定範圍中的數值",
      pleaseSelectRange: "請選擇應用範圍",
      selectDataRange: "點擊選擇數據範圍",
      selectCell: "選擇儲存格",
      pleaseSelectCell: "請選擇儲存格",
      pleaseSelectADate: "請選擇日期",
      pleaseEnterInteger: "請輸入一個介於1和1000之間的整數",
      onlySingleCell: "只能對單個儲存格進行引用",
      conditionValueCanOnly: "條件值只能是數位或者單個儲存格",
      ruleTypeItem1: "基於各自值設定所有儲存格的格式",
      ruleTypeItem2: "只為包含以下內容的儲存格設定格式",
      ruleTypeItem2_title: "只為滿足以下條件的儲存格",
      ruleTypeItem3: "僅對排名靠前或靠後的數值設定格式",
      ruleTypeItem3_title: "為以下排名內的值",
      ruleTypeItem4: "僅對高於或低於平均值的數值設定格式",
      ruleTypeItem4_title: "為滿足以下條件的值",
      ruleTypeItem5: "僅對唯一值或重複值設定格式",
      ruleTypeItem6: "使用公式確定要設置格式的單元格",
      formula: "公式",
      textColor: "文字顏色",
      cellColor: "儲存格顏色",
      confirm: "確定",
      confirmColor: "確定顏色",
      cancel: "取消",
      close: "關閉",
      clearColorSelect: "清除顏色選擇",
      sheet: "錶",
      currentSheet: "當前工作表",
      dataBar: "數據條",
      dataBarColor: "數據條顏色",
      gradientDataBar_1: "藍-白漸變數據條",
      gradientDataBar_2: "綠-白漸變數據條",
      gradientDataBar_3: "紅-白漸變數據條",
      gradientDataBar_4: "柳丁-白漸變數據條",
      gradientDataBar_5: "淺藍-白漸變數據條",
      gradientDataBar_6: "紫-白漸變數據條",
      solidColorDataBar_1: "藍色數據條",
      solidColorDataBar_2: "綠色數據條",
      solidColorDataBar_3: "紅色數據條",
      solidColorDataBar_4: "橙色數據條",
      solidColorDataBar_5: "淺藍色數據條",
      solidColorDataBar_6: "紫色數據條",
      colorGradation: "色階",
      colorGradation_1: "綠-黃-紅色階",
      colorGradation_2: "紅-黃-綠色階",
      colorGradation_3: "綠-白-紅色階",
      colorGradation_4: "紅-白-綠色階",
      colorGradation_5: "藍-白-紅色階",
      colorGradation_6: "紅-白-藍色階",
      colorGradation_7: "白-紅色階",
      colorGradation_8: "紅-白色階",
      colorGradation_9: "綠-白色階",
      colorGradation_10: "白-綠色階",
      colorGradation_11: "綠-黃色階",
      colorGradation_12: "黃-綠色階",
      icons: "圖標集",
      pleaseSelectIcon: "請點擊選擇一組圖標:",
      cellValue: "儲存格值",
      specificText: "特定文字",
      occurrenceDate: "發生日期",
      greaterThan: "大於",
      lessThan: "小於",
      between: "介於",
      equal: "等於",
      in: "和",
      to: "到",
      between2: "之間",
      contain: "包含",
      textContains: "文字包含",
      duplicateValue: "重複值",
      uniqueValue: "唯一值",
      top: "前",
      top10: "前10項",
      top10_percent: "前10%",
      last: "後",
      last10: "後10項",
      last10_percent: "後10%",
      oneself: "個",
      above: "高於",
      aboveAverage: "高於平均值",
      below: "低於",
      belowAverage: "低於平均值",
      all: "全部",
      yesterday: "昨天",
      today: "今天",
      tomorrow: "明天",
      lastWeek: "上周",
      thisWeek: "本周",
      lastMonth: "上月",
      thisMonth: "本月",
      lastYear: "去年",
      thisYear: "本年",
      last7days: "最近7天",
      last30days: "最近30天",
      next7days: "未來7天",
      next30days: "未來30天",
      next60days: "未來60天",
      chooseRuleType: "選擇規則類型",
      editRuleDescription: "編輯規則說明",
      newFormatRule: "新建格式規則",
      editFormatRule: "編輯格式規則",
      formatStyle: "格式樣式",
      fillType: "填充類型",
      color: "顏色",
      twocolor: "雙色",
      tricolor: "三色",
      multicolor: "彩色",
      grayColor: "灰色",
      gradient: "漸變",
      solid: "實心",
      maxValue: "最大值",
      medianValue: "中間值",
      minValue: "最小值",
      direction: "方向",
      threeWayArrow: "三向箭頭",
      fourWayArrow: "四向箭頭",
      fiveWayArrow: "五向箭頭",
      threeTriangles: "3個三角形",
      shape: "形狀",
      threeColorTrafficLight: "三色交通燈",
      fourColorTrafficLight: "四色交通燈",
      threeSigns: "三標誌",
      greenRedBlackGradient: "綠-紅-黑漸變",
      rimless: "無邊框",
      bordered: "有邊框",
      mark: "標記",
      threeSymbols: "三個符號",
      tricolorFlag: "三色旗",
      circled: "有圓圈",
      noCircle: "無圓圈",
      grade: "等級",
      grade4: "四等級",
      grade5: "五等級",
      threeStars: "3個星形",
      fiveQuadrantDiagram: "五象限圖",
      fiveBoxes: "5個框"
    },
    insertLink: {
      linkText: "文字",
      linkType: "連結類型",
      external: "外部連結",
      internal: "内部連結",
      linkAddress: "連結地址",
      linkSheet: "工作表",
      linkCell: "儲存格引用",
      linkTooltip: "提示",
      placeholder1: "請輸入網頁連結位址",
      placeholder2: "請輸入要引用的儲存格,例A1",
      placeholder3: "請輸入提示內容",
      tooltipInfo1: "請輸入有效的連結",
      tooltipInfo2: "請輸入正確的儲存格引用"
    },
    dataVerification: {
      cellRange: "儲存格範圍",
      selectCellRange: "點擊選擇儲存格範圍",
      selectCellRange2: "請選擇儲存格範圍",
      verificationCondition: "驗證條件",
      allowMultiSelect: "是否允許多選",
      dropdown: "下拉清單",
      checkbox: "核取方塊",
      number: "數位",
      number_integer: "數位-整數",
      number_decimal: "數位-小數",
      text_content: "文字-內容",
      text_length: "文字-長度",
      date: "日期",
      validity: "有效性",
      placeholder1: "請輸入選項,以英文逗號分隔,如1,2,3,4,5",
      placeholder2: "請輸入內容",
      placeholder3: "數值,如10",
      placeholder4: "請輸入指定的文字",
      placeholder5: "請輸入選中儲存格時顯示的提示語",
      selected: "選擇時",
      notSelected: "未選擇",
      between: "介於",
      notBetween: "不介於",
      equal: "等於",
      notEqualTo: "不等於",
      moreThanThe: "大於",
      lessThan: "小於",
      greaterOrEqualTo: "大於等於",
      lessThanOrEqualTo: "小於等於",
      include: "包括",
      exclude: "不包括",
      earlierThan: "早於",
      noEarlierThan: "不早於",
      laterThan: "晚於",
      noLaterThan: "不晚於",
      identificationNumber: "身份證號碼",
      phoneNumber: "手機號",
      remote: "自動遠程獲取選項",
      prohibitInput: "輸入數據無效時禁止輸入",
      hintShow: "選中儲存格時顯示提示語",
      deleteVerification: "删除驗證",
      tooltipInfo1: "下拉清單選項不可為空",
      tooltipInfo2: "核取方塊內容不可為空",
      tooltipInfo3: "輸入的值不是數值類型",
      tooltipInfo4: "數值2不能小於數值1",
      tooltipInfo5: "文字內容不能為空",
      tooltipInfo6: "輸入的值不是日期類型",
      tooltipInfo7: "日期2不能小於日期1",
      textlengthInteger: "文字長度必須是大於等於0的整數"
    },
    formula: {
      sum: "求和",
      average: "平均值",
      count: "計數",
      max: "最大值",
      min: "最小值",
      ifGenerate: "if公式生成器",
      find: "更多函數",
      tipNotBelongToIf: "該儲存格函數不屬於if公式!",
      tipSelectCell: "請選擇儲存格插入函數",
      ifGenCompareValueTitle: "比较值",
      ifGenSelectCellTitle: "點擊選擇儲存格",
      ifGenRangeTitle: "範圍",
      ifGenRangeTo: "至",
      ifGenRangeEvaluate: "範圍評估",
      ifGenSelectRangeTitle: "點擊選擇範圍",
      ifGenCutWay: "劃分管道",
      ifGenCutSame: "劃分值相同",
      ifGenCutNpiece: "劃分为N份",
      ifGenCutCustom: "自定義輸入",
      ifGenCutConfirm: "生成",
      ifGenTipSelectCell: "選擇儲存格",
      ifGenTipSelectCellPlace: "請選擇儲存格",
      ifGenTipSelectRange: "選擇單範圍",
      ifGenTipSelectRangePlace: "請選擇範圍",
      ifGenTipNotNullValue: "比較值不能為空!",
      ifGenTipLableTitile: "標籤",
      ifGenTipRangeNotforNull: "範圍不能為空!",
      ifGenTipCutValueNotforNull: "劃分值不能為空！",
      ifGenTipNotGenCondition: "沒有生成可用的條件！"
    },
    formulaMore: {
      valueTitle: "值",
      tipSelectDataRange: "選取數據範圍",
      tipDataRangeTile: "數據範圍",
      findFunctionTitle: "查找函數",
      tipInputFunctionName: "請輸入您要查找的函數名稱或函數功能的簡要描述",
      Array: "數組",
      Database: "資料來源",
      Date: "日期",
      Engineering: "工程計算",
      Filter: "篩檢程式",
      Financial: "財務",
      luckysheet: "Luckysheet內寘",
      other: "其它",
      Logical: "邏輯",
      Lookup: "查找",
      Math: "數學",
      Operator: "運算子",
      Parser: "轉換工具",
      Statistical: "統計",
      Text: "文字",
      dataMining: "資料挖掘",
      selectFunctionTitle: "選擇函數",
      calculationResult: "計算結果",
      tipSuccessText: "成功",
      tipParamErrorText: "參數類型錯誤",
      helpClose: "關閉",
      helpCollapse: "收起",
      helpExample: "示例",
      helpAbstract: "摘要",
      execfunctionError: '提示", "公式存在錯誤',
      execfunctionSelfError: "公式不可引用其本身的儲存格",
      execfunctionSelfErrorResult: "公式不可引用其本身的儲存格,會導致計算結果不準確",
      allowRepeatText: "可重複",
      allowOptionText: "可選",
      selectCategory: "或選擇類別"
    },
    drag: {
      noMerge: "無法對合併儲存格執行此操作",
      affectPivot: "無法對所選儲存格進行此更改,因為它會影響數據透視錶！",
      noMulti: "無法對多重選擇區域執行此操作,請選擇單個區域",
      noPaste: "無法在此處粘貼此內容,請選擇粘貼區域的一個儲存格,然後再次嘗試粘貼",
      noPartMerge: "無法對部分合併儲存格執行此操作",
      inputCorrect: "請輸入正確的數值",
      notLessOne: "行列數不能小於1",
      offsetColumnLessZero: "偏移列不能為負數！",
      pasteMustKeybordAlert: "Copy and paste in the Sheet: Ctrl + C to copy, Ctrl + V to paste, Ctrl + X to cut",
      pasteMustKeybordAlertHTMLTitle: "Copy and paste in the Sheet",
      pasteMustKeybordAlertHTML: "<span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + C</span>&nbsp;&nbsp;to copy<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + V</span>&nbsp;&nbsp;to paste<br/><span style='line-height: 1.0;font-size:36px;font-weight: bold;color:#666;'>Ctrl + X</span>&nbsp;&nbsp;to cut"
    },
    pivotTable: {
      title: "數據透視錶",
      closePannel: "關閉",
      editRange: "編輯範圍",
      tipPivotFieldSelected: "選擇需要添加到數據透視錶的欄位",
      tipClearSelectedField: "清除所有已選欄位",
      btnClearSelectedField: "清除",
      btnFilter: "篩選",
      titleRow: "行",
      titleColumn: "列",
      titleValue: "數值",
      tipShowColumn: "統計欄位顯示為列",
      tipShowRow: "統計欄位顯示為行",
      titleSelectionDataRange: "選取數據範圍",
      titleDataRange: "數據範圍",
      valueSum: "總計",
      valueStatisticsSUM: "求和",
      valueStatisticsCOUNT: "數值計數",
      valueStatisticsCOUNTA: "計數",
      valueStatisticsCOUNTUNIQUE: "去重計數",
      valueStatisticsAVERAGE: "平均值",
      valueStatisticsMAX: "最大值",
      valueStatisticsMIN: "最小值",
      valueStatisticsMEDIAN: "中位數",
      valueStatisticsPRODUCT: "乘積",
      valueStatisticsSTDEV: "標準差",
      valueStatisticsSTDEVP: "整體標準差",
      valueStatisticslet: "方差",
      valueStatisticsVARP: "整體方差",
      errorNotAllowEdit: "非編輯模式下禁止該操作!",
      errorNotAllowMulti: "不能對多重選擇區域執行此操作,請選擇單個區域,然後再試",
      errorSelectRange: "請選擇新建透視錶的區域",
      errorIsDamage: "此數據透視錶的源數據已損壞！",
      errorNotAllowPivotData: "不可選擇數據透視錶為源數據!",
      errorSelectionRange: "選擇失敗,輸入範圍錯誤！",
      errorIncreaseRange: "請擴大選擇的數據範圍!",
      titleAddColumn: "添加列到數據透視錶",
      titleMoveColumn: "移動該列到下方白框",
      titleClearColumnFilter: "清除該列的篩選條件",
      titleFilterColumn: "篩選該列",
      titleSort: "排序",
      titleNoSort: "無排序",
      titleSortAsc: "昇冪",
      titleSortDesc: "降序",
      titleSortBy: "排序依據",
      titleShowSum: "顯示總計",
      titleStasticTrue: "是",
      titleStasticFalse: "否"
    },
    dropCell: {
      copyCell: "複製儲存格",
      sequence: "填充序列",
      onlyFormat: "僅填充格式",
      noFormat: "不帶格式填充",
      day: "以天數填充",
      workDay: "以工作日填充",
      month: "以月填充",
      year: "以年填充",
      chineseNumber: "以中文小寫數位填充"
    },
    imageCtrl: {
      borderTile: "圖片邊框顏色選擇",
      borderCur: "當前顏色"
    },
    protection: {
      protectiontTitle: "保護工作表",
      enterPassword: "請輸入密碼（可留空）",
      enterHint: "您試圖更改的儲存格或圖表位於受保護的工作表中。若要更改,請取消工作表保護。您可能需要輸入密碼",
      swichProtectionTip: "保護工作表及鎖定的儲存格內容",
      authorityTitle: "允許此工作表的用戶進行:",
      selectLockedCells: "定鎖定儲存格",
      selectunLockedCells: "選定解除鎖定的儲存格",
      formatCells: "設定儲存格格式",
      formatColumns: "設定列格式",
      formatRows: "設定行格式",
      insertColumns: "插入列",
      insertRows: "插入行",
      insertHyperlinks: "插入超連結",
      deleteColumns: "删除列",
      deleteRows: "删除行",
      sort: "排序",
      filter: "使用自動篩選",
      usePivotTablereports: "使用數據透視錶和報表",
      editObjects: "編輯對象",
      editScenarios: "編輯方案",
      allowRangeTitle: "允許用戶編輯區域",
      allowRangeAdd: "新建...",
      allowRangeAddTitle: "標題",
      allowRangeAddSqrf: "引用儲存格",
      selectCellRange: "點擊選擇儲存格範圍",
      selectCellRangeHolder: "請輸入儲存格範圍",
      allowRangeAddTitlePassword: "密碼",
      allowRangeAddTitleHint: "提示",
      allowRangeAddTitleHintTitle: "設置密碼後,提示用戶輸入密碼（可留空）",
      allowRangeAddtitleDefault: "請輸入區域名稱",
      rangeItemDblclick: "按兩下進行編輯",
      rangeItemHasPassword: "已設置密碼",
      rangeItemErrorTitleNull: "標題不能為空",
      rangeItemErrorRangeNull: "儲存格範圍不能為空",
      rangeItemErrorRange: "儲存格範圍格式錯誤",
      validationTitle: "驗證提示",
      validationTips: "需要輸入密碼來撤銷工作表的保護",
      validationInputHint: "請輸入密碼",
      checkPasswordNullalert: "密碼不能為空!",
      checkPasswordWrongalert: "密碼錯誤,請重試！",
      checkPasswordSucceedalert: "解鎖成功,可以編輯該區域!",
      defaultRangeHintText: "該儲存格正在受密碼保護",
      defaultSheetHintText: "該儲存格或圖表位於受保護的工作表中,若要進行更改,請取消工作表保護,您可能需要輸入密碼。"
    },
    cellFormat: {
      cellFormatTitle: "設定儲存格格式",
      protection: "保護",
      locked: "鎖定儲存格",
      hidden: "隱藏公式",
      protectionTips: "只有保護工作表功能（在功能表列點擊保護工作表按鈕進行設定）開啟後,鎖定儲存格或隱藏公式才能生效",
      tipsPart: "部分選中",
      tipsAll: "全部選中",
      selectionIsNullAlert: "請選擇一個範圍！",
      sheetDataIsNullAlert: "數據為空無法設定！"
    },
    print: {
      normalBtn: "常規視圖",
      layoutBtn: "頁面佈局",
      pageBtn: "分頁預覽",
      menuItemPrint: "列印(Ctrl+P)",
      menuItemAreas: "列印區域",
      menuItemRows: "列印標題行",
      menuItemColumns: "列印標題列"
    },
    edit: {
      typing: "正在輸入"
    },
    websocket: {
      success: "WebSocket連接成功",
      refresh: "WebSocket連接發生錯誤,請刷新頁面！",
      wait: "WebSocket連接發生錯誤,請耐心等待！",
      close: "WebSocket連接關閉",
      contact: "服務器通信發生錯誤,請刷新頁面後再試,如若不行請聯系管理員！",
      support: "當前瀏覽器不支持WebSocket"
    }
  };
  var localeObj = {
    en: en$1,
    zh,
    es,
    "zh-TW": zh_tw
  };
  function locale(ctx) {
    var _ctx$lang;
    var langsToTry = [ctx.lang || "", ((_ctx$lang = ctx.lang) === null || _ctx$lang === void 0 ? void 0 : _ctx$lang.split("-")[0]) || ""];
    for (var i2 = 0; i2 < langsToTry.length; i2 += 1) {
      if (langsToTry[i2] in localeObj) {
        return localeObj[langsToTry[i2]];
      }
    }
    return localeObj.en;
  }
  function getBorderInfoComputeRange(ctx, dataset_row_st, dataset_row_ed, dataset_col_st, dataset_col_ed, sheetId) {
    var borderInfoCompute = {};
    var flowdata = getFlowdata(ctx);
    var cfg;
    var data;
    if (!sheetId) {
      cfg = ctx.config;
      data = flowdata;
    } else {
      var index2 = getSheetIndex(ctx, sheetId);
      if (!_$1.isNil(index2)) {
        cfg = ctx.luckysheetfile[index2].config;
        data = ctx.luckysheetfile[index2].data;
      } else {
        return borderInfoCompute;
      }
    }
    if (!data || !cfg) return borderInfoCompute;
    var _cfg = cfg, borderInfo = _cfg.borderInfo;
    if (!borderInfo || _$1.isEmpty(borderInfo)) return borderInfoCompute;
    for (var i2 = 0; i2 < borderInfo.length; i2 += 1) {
      var rangeType = borderInfo[i2].rangeType;
      if (rangeType === "range") {
        var borderType = borderInfo[i2].borderType;
        var borderColor = borderInfo[i2].color;
        var borderStyle = borderInfo[i2].style;
        var borderRange = borderInfo[i2].range;
        var _loop = function _loop2(j3) {
          var bd_r1 = borderRange[j3].row[0];
          var bd_r2 = borderRange[j3].row[1];
          var bd_c1 = borderRange[j3].column[0];
          var bd_c2 = borderRange[j3].column[1];
          if (bd_r1 < dataset_row_st) {
            bd_r1 = dataset_row_st;
          }
          if (bd_r2 > dataset_row_ed) {
            bd_r2 = dataset_row_ed;
          }
          if (bd_c1 < dataset_col_st) {
            bd_c1 = dataset_col_st;
          }
          if (bd_c2 > dataset_col_ed) {
            bd_c2 = dataset_col_ed;
          }
          if (borderType === "border-slash") {
            var bd_r3 = borderRange[0].row_focus;
            var bd_c3 = borderRange[0].column_focus;
            if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[bd_r3])) {
              return "continue";
            }
            if (bd_c3 < dataset_col_st || bd_c3 > dataset_col_ed) return "continue";
            if (bd_r3 < dataset_row_st || bd_r3 > dataset_row_ed) return "continue";
            if (borderInfoCompute["".concat(bd_r3, "_").concat(bd_c3)] === void 0) {
              borderInfoCompute["".concat(bd_r3, "_").concat(bd_c3)] = {};
            }
            borderInfoCompute["".concat(bd_r3, "_").concat(bd_c3)].s = {
              color: borderColor,
              style: borderStyle
            };
          }
          if (borderType === "border-left") {
            var _loop22 = function _loop23(_bd_r9) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r9])) {
                return "continue";
              }
              if (borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c1)] === void 0) {
                borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c1)] = {};
              }
              borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c1)].l = {
                color: borderColor,
                style: borderStyle
              };
              var bd_c_left3 = bd_c1 - 1;
              if (bd_c_left3 >= 0 && borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c_left3)]) {
                var _data$_bd_r, _data$_bd_r$bd_c_left;
                if (!_$1.isNil((_data$_bd_r = data[_bd_r9]) === null || _data$_bd_r === void 0 ? void 0 : (_data$_bd_r$bd_c_left = _data$_bd_r[bd_c_left3]) === null || _data$_bd_r$bd_c_left === void 0 ? void 0 : _data$_bd_r$bd_c_left.mc)) {
                  var _cfg$merge, _cell_left$mc, _cell_left$mc2;
                  var cell_left3 = data[_bd_r9][bd_c_left3];
                  var _mc = (_cfg$merge = cfg.merge) === null || _cfg$merge === void 0 ? void 0 : _cfg$merge["".concat(cell_left3 === null || cell_left3 === void 0 ? void 0 : (_cell_left$mc = cell_left3.mc) === null || _cell_left$mc === void 0 ? void 0 : _cell_left$mc.r, "_").concat(cell_left3 === null || cell_left3 === void 0 ? void 0 : (_cell_left$mc2 = cell_left3.mc) === null || _cell_left$mc2 === void 0 ? void 0 : _cell_left$mc2.c)];
                  if (_mc && _mc.c + _mc.cs - 1 === bd_c_left3) {
                    borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c_left3)].r = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c_left3)].r = {
                    color: borderColor,
                    style: borderStyle
                  };
                }
              }
              var mc4 = cfg.merge || {};
              Object.keys(mc4).forEach(function(key) {
                var _mc$key = mc4[key], c2 = _mc$key.c, r2 = _mc$key.r, cs = _mc$key.cs, rs = _mc$key.rs;
                if (bd_c1 <= c2 + cs - 1 && bd_c1 > c2 && _bd_r9 >= r2 && _bd_r9 <= r2 + rs - 1) {
                  borderInfoCompute["".concat(_bd_r9, "_").concat(bd_c1)].l = null;
                }
              });
            };
            for (var _bd_r = bd_r1; _bd_r <= bd_r2; _bd_r += 1) {
              var _ret2 = _loop22(_bd_r);
              if (_ret2 === "continue") continue;
            }
          } else if (borderType === "border-right") {
            var _loop3 = function _loop32(_bd_r22) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r22])) {
                return "continue";
              }
              if (borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c2)] === void 0) {
                borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c2)] = {};
              }
              borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c2)].r = {
                color: borderColor,
                style: borderStyle
              };
              var bd_c_right3 = bd_c2 + 1;
              if (bd_c_right3 < data[0].length && borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c_right3)]) {
                var _data$_bd_r2, _data$_bd_r2$bd_c_rig;
                if (!_$1.isNil((_data$_bd_r2 = data[_bd_r22]) === null || _data$_bd_r2 === void 0 ? void 0 : (_data$_bd_r2$bd_c_rig = _data$_bd_r2[bd_c_right3]) === null || _data$_bd_r2$bd_c_rig === void 0 ? void 0 : _data$_bd_r2$bd_c_rig.mc)) {
                  var _cfg$merge2, _cell_right$mc, _cell_right$mc2;
                  var cell_right3 = data[_bd_r22][bd_c_right3];
                  var _mc2 = (_cfg$merge2 = cfg.merge) === null || _cfg$merge2 === void 0 ? void 0 : _cfg$merge2["".concat(cell_right3 === null || cell_right3 === void 0 ? void 0 : (_cell_right$mc = cell_right3.mc) === null || _cell_right$mc === void 0 ? void 0 : _cell_right$mc.r, "_").concat(cell_right3 === null || cell_right3 === void 0 ? void 0 : (_cell_right$mc2 = cell_right3.mc) === null || _cell_right$mc2 === void 0 ? void 0 : _cell_right$mc2.c)];
                  if (_mc2 && _mc2.c === bd_c_right3) {
                    borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c_right3)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c_right3)].l = {
                    color: borderColor,
                    style: borderStyle
                  };
                }
              }
              var mc4 = cfg.merge || {};
              Object.keys(mc4).forEach(function(key) {
                var _mc$key2 = mc4[key], c2 = _mc$key2.c, r2 = _mc$key2.r, cs = _mc$key2.cs, rs = _mc$key2.rs;
                if (bd_c2 < c2 + cs - 1 && bd_c2 >= c2 && _bd_r22 >= r2 && _bd_r22 <= r2 + rs - 1) {
                  borderInfoCompute["".concat(_bd_r22, "_").concat(bd_c2)].r = null;
                }
              });
            };
            for (var _bd_r2 = bd_r1; _bd_r2 <= bd_r2; _bd_r2 += 1) {
              var _ret3 = _loop3(_bd_r2);
              if (_ret3 === "continue") continue;
            }
          } else if (borderType === "border-top") {
            if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[bd_r1])) {
              return "continue";
            }
            var _loop4 = function _loop42(_bd_c9) {
              if (borderInfoCompute["".concat(bd_r1, "_").concat(_bd_c9)] === void 0) {
                borderInfoCompute["".concat(bd_r1, "_").concat(_bd_c9)] = {};
              }
              borderInfoCompute["".concat(bd_r1, "_").concat(_bd_c9)].t = {
                color: borderColor,
                style: borderStyle
              };
              var bd_r_top3 = bd_r1 - 1;
              if (bd_r_top3 >= 0 && borderInfoCompute["".concat(bd_r_top3, "_").concat(_bd_c9)]) {
                var _data$bd_r_top, _data$bd_r_top$_bd_c;
                if (!_$1.isNil((_data$bd_r_top = data[bd_r_top3]) === null || _data$bd_r_top === void 0 ? void 0 : (_data$bd_r_top$_bd_c = _data$bd_r_top[_bd_c9]) === null || _data$bd_r_top$_bd_c === void 0 ? void 0 : _data$bd_r_top$_bd_c.mc)) {
                  var _cfg$merge3, _cell_top$mc, _cell_top$mc2;
                  var cell_top3 = data[bd_r_top3][_bd_c9];
                  var _mc3 = (_cfg$merge3 = cfg.merge) === null || _cfg$merge3 === void 0 ? void 0 : _cfg$merge3["".concat(cell_top3 === null || cell_top3 === void 0 ? void 0 : (_cell_top$mc = cell_top3.mc) === null || _cell_top$mc === void 0 ? void 0 : _cell_top$mc.r, "_").concat(cell_top3 === null || cell_top3 === void 0 ? void 0 : (_cell_top$mc2 = cell_top3.mc) === null || _cell_top$mc2 === void 0 ? void 0 : _cell_top$mc2.c)];
                  if (_mc3 && _mc3.r + _mc3.rs - 1 === bd_r_top3) {
                    borderInfoCompute["".concat(bd_r_top3, "_").concat(_bd_c9)].b = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r_top3, "_").concat(_bd_c9)].b = {
                    color: borderColor,
                    style: borderStyle
                  };
                }
              }
              var mc4 = cfg.merge || {};
              Object.keys(mc4).forEach(function(key) {
                var _mc$key3 = mc4[key], c2 = _mc$key3.c, r2 = _mc$key3.r, cs = _mc$key3.cs, rs = _mc$key3.rs;
                if (bd_r1 <= r2 + rs - 1 && bd_r1 > r2 && _bd_c9 >= c2 && _bd_c9 <= c2 + cs - 1) {
                  borderInfoCompute["".concat(bd_r1, "_").concat(_bd_c9)].t = null;
                }
              });
            };
            for (var _bd_c = bd_c1; _bd_c <= bd_c2; _bd_c += 1) {
              _loop4(_bd_c);
            }
          } else if (borderType === "border-bottom") {
            if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[bd_r2])) {
              return "continue";
            }
            var _loop5 = function _loop52(_bd_c22) {
              if (borderInfoCompute["".concat(bd_r2, "_").concat(_bd_c22)] === void 0) {
                borderInfoCompute["".concat(bd_r2, "_").concat(_bd_c22)] = {};
              }
              borderInfoCompute["".concat(bd_r2, "_").concat(_bd_c22)].b = {
                color: borderColor,
                style: borderStyle
              };
              var bd_r_bottom3 = bd_r2 + 1;
              if (bd_r_bottom3 < data.length && borderInfoCompute["".concat(bd_r_bottom3, "_").concat(_bd_c22)]) {
                var _data$bd_r_bottom, _data$bd_r_bottom$_bd;
                if (!_$1.isNil((_data$bd_r_bottom = data[bd_r_bottom3]) === null || _data$bd_r_bottom === void 0 ? void 0 : (_data$bd_r_bottom$_bd = _data$bd_r_bottom[_bd_c22]) === null || _data$bd_r_bottom$_bd === void 0 ? void 0 : _data$bd_r_bottom$_bd.mc)) {
                  var _cfg$merge4, _cell_bottom$mc, _cell_bottom$mc2;
                  var cell_bottom3 = data[bd_r_bottom3][_bd_c22];
                  var _mc4 = (_cfg$merge4 = cfg.merge) === null || _cfg$merge4 === void 0 ? void 0 : _cfg$merge4["".concat(cell_bottom3 === null || cell_bottom3 === void 0 ? void 0 : (_cell_bottom$mc = cell_bottom3.mc) === null || _cell_bottom$mc === void 0 ? void 0 : _cell_bottom$mc.r, "_").concat(cell_bottom3 === null || cell_bottom3 === void 0 ? void 0 : (_cell_bottom$mc2 = cell_bottom3.mc) === null || _cell_bottom$mc2 === void 0 ? void 0 : _cell_bottom$mc2.c)];
                  if ((_mc4 === null || _mc4 === void 0 ? void 0 : _mc4.r) === bd_r_bottom3) {
                    borderInfoCompute["".concat(bd_r_bottom3, "_").concat(_bd_c22)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r_bottom3, "_").concat(_bd_c22)].t = {
                    color: borderColor,
                    style: borderStyle
                  };
                }
              }
              var mc4 = cfg.merge || {};
              Object.keys(mc4).forEach(function(key) {
                var _mc$key4 = mc4[key], c2 = _mc$key4.c, r2 = _mc$key4.r, cs = _mc$key4.cs, rs = _mc$key4.rs;
                if (bd_r2 < r2 + rs - 1 && bd_r2 >= r2 && _bd_c22 >= c2 && _bd_c22 <= c2 + cs - 1) {
                  borderInfoCompute["".concat(bd_r2, "_").concat(_bd_c22)].b = null;
                }
              });
            };
            for (var _bd_c2 = bd_c1; _bd_c2 <= bd_c2; _bd_c2 += 1) {
              _loop5(_bd_c2);
            }
          } else if (borderType === "border-all") {
            for (var _bd_r3 = bd_r1; _bd_r3 <= bd_r2; _bd_r3 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r3])) {
                continue;
              }
              for (var _bd_c3 = bd_c1; _bd_c3 <= bd_c2; _bd_c3 += 1) {
                var _data$_bd_r3, _data$_bd_r3$_bd_c;
                if (!_$1.isNil((_data$_bd_r3 = data[_bd_r3]) === null || _data$_bd_r3 === void 0 ? void 0 : (_data$_bd_r3$_bd_c = _data$_bd_r3[_bd_c3]) === null || _data$_bd_r3$_bd_c === void 0 ? void 0 : _data$_bd_r3$_bd_c.mc)) {
                  var _cfg$merge5, _cell$mc, _cell$mc2;
                  var cell2 = data[_bd_r3][_bd_c3];
                  var mc3 = (_cfg$merge5 = cfg.merge) === null || _cfg$merge5 === void 0 ? void 0 : _cfg$merge5["".concat(cell2 === null || cell2 === void 0 ? void 0 : (_cell$mc = cell2.mc) === null || _cell$mc === void 0 ? void 0 : _cell$mc.r, "_").concat(cell2 === null || cell2 === void 0 ? void 0 : (_cell$mc2 = cell2.mc) === null || _cell$mc2 === void 0 ? void 0 : _cell$mc2.c)];
                  if ((mc3 === null || mc3 === void 0 ? void 0 : mc3.r) === _bd_r3) {
                    if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] === void 0) {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                  if (mc3 && mc3.r + mc3.rs - 1 === _bd_r3) {
                    if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] === void 0) {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].b = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                  if ((mc3 === null || mc3 === void 0 ? void 0 : mc3.c) === _bd_c3) {
                    if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] === void 0) {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                  if (mc3 && mc3.c + mc3.cs - 1 === _bd_c3) {
                    if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] === void 0) {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].r = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] === void 0) {
                    borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)] = {};
                  }
                  borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].l = {
                    color: borderColor,
                    style: borderStyle
                  };
                  borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].r = {
                    color: borderColor,
                    style: borderStyle
                  };
                  borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].t = {
                    color: borderColor,
                    style: borderStyle
                  };
                  borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].b = {
                    color: borderColor,
                    style: borderStyle
                  };
                }
                if (_bd_r3 === bd_r1) {
                  var bd_r_top2 = bd_r1 - 1;
                  if (bd_r_top2 >= 0 && borderInfoCompute["".concat(bd_r_top2, "_").concat(_bd_c3)]) {
                    var _data$bd_r_top2, _data$bd_r_top2$_bd_c;
                    if (!_$1.isNil((_data$bd_r_top2 = data[bd_r_top2]) === null || _data$bd_r_top2 === void 0 ? void 0 : (_data$bd_r_top2$_bd_c = _data$bd_r_top2[_bd_c3]) === null || _data$bd_r_top2$_bd_c === void 0 ? void 0 : _data$bd_r_top2$_bd_c.mc)) {
                      var _cfg$merge6, _cell_top$mc3, _cell_top$mc4;
                      var cell_top2 = data[bd_r_top2][_bd_c3];
                      var _mc5 = (_cfg$merge6 = cfg.merge) === null || _cfg$merge6 === void 0 ? void 0 : _cfg$merge6["".concat(cell_top2 === null || cell_top2 === void 0 ? void 0 : (_cell_top$mc3 = cell_top2.mc) === null || _cell_top$mc3 === void 0 ? void 0 : _cell_top$mc3.r, "_").concat(cell_top2 === null || cell_top2 === void 0 ? void 0 : (_cell_top$mc4 = cell_top2.mc) === null || _cell_top$mc4 === void 0 ? void 0 : _cell_top$mc4.c)];
                      if (_mc5 && _mc5.r + _mc5.rs - 1 === bd_r_top2) {
                        borderInfoCompute["".concat(bd_r_top2, "_").concat(_bd_c3)].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(bd_r_top2, "_").concat(_bd_c3)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_r3 === bd_r2) {
                  var bd_r_bottom2 = bd_r2 + 1;
                  if (bd_r_bottom2 < data.length && borderInfoCompute["".concat(bd_r_bottom2, "_").concat(_bd_c3)]) {
                    var _data$bd_r_bottom2, _data$bd_r_bottom2$_b;
                    if (!_$1.isNil((_data$bd_r_bottom2 = data[bd_r_bottom2]) === null || _data$bd_r_bottom2 === void 0 ? void 0 : (_data$bd_r_bottom2$_b = _data$bd_r_bottom2[_bd_c3]) === null || _data$bd_r_bottom2$_b === void 0 ? void 0 : _data$bd_r_bottom2$_b.mc)) {
                      var _cfg$merge7, _cell_bottom$mc3, _cell_bottom$mc4;
                      var cell_bottom2 = data[bd_r_bottom2][_bd_c3];
                      var _mc6 = (_cfg$merge7 = cfg.merge) === null || _cfg$merge7 === void 0 ? void 0 : _cfg$merge7["".concat(cell_bottom2 === null || cell_bottom2 === void 0 ? void 0 : (_cell_bottom$mc3 = cell_bottom2.mc) === null || _cell_bottom$mc3 === void 0 ? void 0 : _cell_bottom$mc3.r, "_").concat(cell_bottom2 === null || cell_bottom2 === void 0 ? void 0 : (_cell_bottom$mc4 = cell_bottom2.mc) === null || _cell_bottom$mc4 === void 0 ? void 0 : _cell_bottom$mc4.c)];
                      if ((_mc6 === null || _mc6 === void 0 ? void 0 : _mc6.r) === bd_r_bottom2) {
                        borderInfoCompute["".concat(bd_r_bottom2, "_").concat(_bd_c3)].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(bd_r_bottom2, "_").concat(_bd_c3)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_c3 === bd_c1) {
                  var bd_c_left2 = bd_c1 - 1;
                  if (bd_c_left2 >= 0 && borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_left2)]) {
                    var _data$_bd_r4, _data$_bd_r4$bd_c_lef;
                    if (!_$1.isNil((_data$_bd_r4 = data[_bd_r3]) === null || _data$_bd_r4 === void 0 ? void 0 : (_data$_bd_r4$bd_c_lef = _data$_bd_r4[bd_c_left2]) === null || _data$_bd_r4$bd_c_lef === void 0 ? void 0 : _data$_bd_r4$bd_c_lef.mc)) {
                      var _cfg$merge8, _cell_left$mc3, _cell_left$mc4;
                      var cell_left2 = data[_bd_r3][bd_c_left2];
                      var _mc7 = (_cfg$merge8 = cfg.merge) === null || _cfg$merge8 === void 0 ? void 0 : _cfg$merge8["".concat(cell_left2 === null || cell_left2 === void 0 ? void 0 : (_cell_left$mc3 = cell_left2.mc) === null || _cell_left$mc3 === void 0 ? void 0 : _cell_left$mc3.r, "_").concat(cell_left2 === null || cell_left2 === void 0 ? void 0 : (_cell_left$mc4 = cell_left2.mc) === null || _cell_left$mc4 === void 0 ? void 0 : _cell_left$mc4.c)];
                      if (_mc7 && _mc7.c + _mc7.cs - 1 === bd_c_left2) {
                        borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_left2)].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_left2)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_c3 === bd_c2) {
                  var bd_c_right2 = bd_c2 + 1;
                  if (bd_c_right2 < data[0].length && borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_right2)]) {
                    var _data$_bd_r5, _data$_bd_r5$bd_c_rig;
                    if (!_$1.isNil((_data$_bd_r5 = data[_bd_r3]) === null || _data$_bd_r5 === void 0 ? void 0 : (_data$_bd_r5$bd_c_rig = _data$_bd_r5[bd_c_right2]) === null || _data$_bd_r5$bd_c_rig === void 0 ? void 0 : _data$_bd_r5$bd_c_rig.mc)) {
                      var _cfg$merge9, _cell_right$mc3, _cell_right$mc4;
                      var cell_right2 = data[_bd_r3][bd_c_right2];
                      var _mc8 = (_cfg$merge9 = cfg.merge) === null || _cfg$merge9 === void 0 ? void 0 : _cfg$merge9["".concat(cell_right2 === null || cell_right2 === void 0 ? void 0 : (_cell_right$mc3 = cell_right2.mc) === null || _cell_right$mc3 === void 0 ? void 0 : _cell_right$mc3.r, "_").concat(cell_right2 === null || cell_right2 === void 0 ? void 0 : (_cell_right$mc4 = cell_right2.mc) === null || _cell_right$mc4 === void 0 ? void 0 : _cell_right$mc4.c)];
                      if ((_mc8 === null || _mc8 === void 0 ? void 0 : _mc8.c) === bd_c_right2) {
                        borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_right2)].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r3, "_").concat(bd_c_right2)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
              }
            }
          } else if (borderType === "border-outside") {
            for (var _bd_r4 = bd_r1; _bd_r4 <= bd_r2; _bd_r4 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r4])) {
                continue;
              }
              for (var _bd_c4 = bd_c1; _bd_c4 <= bd_c2; _bd_c4 += 1) {
                if (!(_bd_r4 === bd_r1 || _bd_r4 === bd_r2 || _bd_c4 === bd_c1 || _bd_c4 === bd_c2)) {
                  continue;
                }
                if (_bd_r4 === bd_r1) {
                  if (borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] === void 0) {
                    borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] = {};
                  }
                  borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)].t = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var _bd_r_top = bd_r1 - 1;
                  if (_bd_r_top >= 0 && borderInfoCompute["".concat(_bd_r_top, "_").concat(_bd_c4)]) {
                    var _data$_bd_r_top, _data$_bd_r_top$_bd_c;
                    if (!_$1.isNil((_data$_bd_r_top = data[_bd_r_top]) === null || _data$_bd_r_top === void 0 ? void 0 : (_data$_bd_r_top$_bd_c = _data$_bd_r_top[_bd_c4]) === null || _data$_bd_r_top$_bd_c === void 0 ? void 0 : _data$_bd_r_top$_bd_c.mc)) {
                      var _cfg$merge10, _cell_top$mc5, _cell_top$mc6;
                      var _cell_top = data[_bd_r_top][_bd_c4];
                      var _mc9 = (_cfg$merge10 = cfg.merge) === null || _cfg$merge10 === void 0 ? void 0 : _cfg$merge10["".concat(_cell_top === null || _cell_top === void 0 ? void 0 : (_cell_top$mc5 = _cell_top.mc) === null || _cell_top$mc5 === void 0 ? void 0 : _cell_top$mc5.r, "_").concat(_cell_top === null || _cell_top === void 0 ? void 0 : (_cell_top$mc6 = _cell_top.mc) === null || _cell_top$mc6 === void 0 ? void 0 : _cell_top$mc6.c)];
                      if (_mc9 && _mc9.r + _mc9.rs - 1 === _bd_r_top) {
                        borderInfoCompute["".concat(_bd_r_top, "_").concat(_bd_c4)].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r_top, "_").concat(_bd_c4)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_r4 === bd_r2) {
                  if (borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] === void 0) {
                    borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] = {};
                  }
                  borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)].b = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var _bd_r_bottom = bd_r2 + 1;
                  if (_bd_r_bottom < data.length && borderInfoCompute["".concat(_bd_r_bottom, "_").concat(_bd_c4)]) {
                    var _data$_bd_r_bottom, _data$_bd_r_bottom$_b;
                    if (!_$1.isNil((_data$_bd_r_bottom = data[_bd_r_bottom]) === null || _data$_bd_r_bottom === void 0 ? void 0 : (_data$_bd_r_bottom$_b = _data$_bd_r_bottom[_bd_c4]) === null || _data$_bd_r_bottom$_b === void 0 ? void 0 : _data$_bd_r_bottom$_b.mc)) {
                      var _cfg$merge11, _cell_bottom$mc5, _cell_bottom$mc6;
                      var _cell_bottom = data[_bd_r_bottom][_bd_c4];
                      var _mc10 = (_cfg$merge11 = cfg.merge) === null || _cfg$merge11 === void 0 ? void 0 : _cfg$merge11["".concat(_cell_bottom === null || _cell_bottom === void 0 ? void 0 : (_cell_bottom$mc5 = _cell_bottom.mc) === null || _cell_bottom$mc5 === void 0 ? void 0 : _cell_bottom$mc5.r, "_").concat(_cell_bottom === null || _cell_bottom === void 0 ? void 0 : (_cell_bottom$mc6 = _cell_bottom.mc) === null || _cell_bottom$mc6 === void 0 ? void 0 : _cell_bottom$mc6.c)];
                      if ((_mc10 === null || _mc10 === void 0 ? void 0 : _mc10.r) === _bd_r_bottom) {
                        borderInfoCompute["".concat(_bd_r_bottom, "_").concat(_bd_c4)].t = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r_bottom, "_").concat(_bd_c4)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_c4 === bd_c1) {
                  if (borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] === void 0) {
                    borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] = {};
                  }
                  borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)].l = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var _bd_c_left = bd_c1 - 1;
                  if (_bd_c_left >= 0 && borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_left)]) {
                    var _data$_bd_r6, _data$_bd_r6$_bd_c_le;
                    if (!_$1.isNil((_data$_bd_r6 = data[_bd_r4]) === null || _data$_bd_r6 === void 0 ? void 0 : (_data$_bd_r6$_bd_c_le = _data$_bd_r6[_bd_c_left]) === null || _data$_bd_r6$_bd_c_le === void 0 ? void 0 : _data$_bd_r6$_bd_c_le.mc)) {
                      var _cfg$merge12, _cell_left$mc5, _cell_left$mc6;
                      var _cell_left = data[_bd_r4][_bd_c_left];
                      var _mc11 = (_cfg$merge12 = cfg.merge) === null || _cfg$merge12 === void 0 ? void 0 : _cfg$merge12["".concat(_cell_left === null || _cell_left === void 0 ? void 0 : (_cell_left$mc5 = _cell_left.mc) === null || _cell_left$mc5 === void 0 ? void 0 : _cell_left$mc5.r, "_").concat(_cell_left === null || _cell_left === void 0 ? void 0 : (_cell_left$mc6 = _cell_left.mc) === null || _cell_left$mc6 === void 0 ? void 0 : _cell_left$mc6.c)];
                      if (_mc11 && _mc11.c + _mc11.cs - 1 === _bd_c_left) {
                        borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_left)].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_left)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
                if (_bd_c4 === bd_c2) {
                  if (borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] === void 0) {
                    borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)] = {};
                  }
                  borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c4)].r = {
                    color: borderColor,
                    style: borderStyle
                  };
                  var _bd_c_right = bd_c2 + 1;
                  if (_bd_c_right < data[0].length && borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_right)]) {
                    var _data$_bd_r7, _data$_bd_r7$_bd_c_ri;
                    if (!_$1.isNil((_data$_bd_r7 = data[_bd_r4]) === null || _data$_bd_r7 === void 0 ? void 0 : (_data$_bd_r7$_bd_c_ri = _data$_bd_r7[_bd_c_right]) === null || _data$_bd_r7$_bd_c_ri === void 0 ? void 0 : _data$_bd_r7$_bd_c_ri.mc)) {
                      var _cfg$merge13, _cell_right$mc5, _cell_right$mc6;
                      var _cell_right = data[_bd_r4][_bd_c_right];
                      var _mc12 = (_cfg$merge13 = cfg.merge) === null || _cfg$merge13 === void 0 ? void 0 : _cfg$merge13["".concat(_cell_right === null || _cell_right === void 0 ? void 0 : (_cell_right$mc5 = _cell_right.mc) === null || _cell_right$mc5 === void 0 ? void 0 : _cell_right$mc5.r, "_").concat(_cell_right === null || _cell_right === void 0 ? void 0 : (_cell_right$mc6 = _cell_right.mc) === null || _cell_right$mc6 === void 0 ? void 0 : _cell_right$mc6.c)];
                      if ((_mc12 === null || _mc12 === void 0 ? void 0 : _mc12.c) === _bd_c_right) {
                        borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_right)].l = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    } else {
                      borderInfoCompute["".concat(_bd_r4, "_").concat(_bd_c_right)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
              }
            }
          } else if (borderType === "border-inside") {
            for (var _bd_r5 = bd_r1; _bd_r5 <= bd_r2; _bd_r5 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r5])) {
                continue;
              }
              for (var _bd_c5 = bd_c1; _bd_c5 <= bd_c2; _bd_c5 += 1) {
                if (_bd_r5 === bd_r1 && _bd_c5 === bd_c1) {
                  var _data$_bd_r8, _data$_bd_r8$_bd_c;
                  if (!_$1.isNil((_data$_bd_r8 = data[_bd_r5]) === null || _data$_bd_r8 === void 0 ? void 0 : (_data$_bd_r8$_bd_c = _data$_bd_r8[_bd_c5]) === null || _data$_bd_r8$_bd_c === void 0 ? void 0 : _data$_bd_r8$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                } else if (_bd_r5 === bd_r2 && _bd_c5 === bd_c1) {
                  var _data$_bd_r9, _data$_bd_r9$_bd_c;
                  if (!_$1.isNil((_data$_bd_r9 = data[_bd_r5]) === null || _data$_bd_r9 === void 0 ? void 0 : (_data$_bd_r9$_bd_c = _data$_bd_r9[_bd_c5]) === null || _data$_bd_r9$_bd_c === void 0 ? void 0 : _data$_bd_r9$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else if (_bd_r5 === bd_r1 && _bd_c5 === bd_c2) {
                  var _data$_bd_r10, _data$_bd_r10$_bd_c;
                  if (!_$1.isNil((_data$_bd_r10 = data[_bd_r5]) === null || _data$_bd_r10 === void 0 ? void 0 : (_data$_bd_r10$_bd_c = _data$_bd_r10[_bd_c5]) === null || _data$_bd_r10$_bd_c === void 0 ? void 0 : _data$_bd_r10$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                } else if (_bd_r5 === bd_r2 && _bd_c5 === bd_c2) {
                  var _data$_bd_r11, _data$_bd_r11$_bd_c;
                  if (!_$1.isNil((_data$_bd_r11 = data[_bd_r5]) === null || _data$_bd_r11 === void 0 ? void 0 : (_data$_bd_r11$_bd_c = _data$_bd_r11[_bd_c5]) === null || _data$_bd_r11$_bd_c === void 0 ? void 0 : _data$_bd_r11$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else if (_bd_r5 === bd_r1) {
                  var _data$_bd_r12, _data$_bd_r12$_bd_c;
                  if (!_$1.isNil((_data$_bd_r12 = data[_bd_r5]) === null || _data$_bd_r12 === void 0 ? void 0 : (_data$_bd_r12$_bd_c = _data$_bd_r12[_bd_c5]) === null || _data$_bd_r12$_bd_c === void 0 ? void 0 : _data$_bd_r12$_bd_c.mc)) {
                    var _cfg$merge14, _cell$mc3, _cell$mc4;
                    var _cell = data[_bd_r5][_bd_c5];
                    var _mc13 = (_cfg$merge14 = cfg.merge) === null || _cfg$merge14 === void 0 ? void 0 : _cfg$merge14["".concat(_cell === null || _cell === void 0 ? void 0 : (_cell$mc3 = _cell.mc) === null || _cell$mc3 === void 0 ? void 0 : _cell$mc3.r, "_").concat(_cell === null || _cell === void 0 ? void 0 : (_cell$mc4 = _cell.mc) === null || _cell$mc4 === void 0 ? void 0 : _cell$mc4.c)];
                    if ((_mc13 === null || _mc13 === void 0 ? void 0 : _mc13.c) === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc13 && _mc13.c + _mc13.cs - 1 === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_r5 === bd_r2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                } else if (_bd_r5 === bd_r2) {
                  var _data$_bd_r13, _data$_bd_r13$_bd_c;
                  if (!_$1.isNil((_data$_bd_r13 = data[_bd_r5]) === null || _data$_bd_r13 === void 0 ? void 0 : (_data$_bd_r13$_bd_c = _data$_bd_r13[_bd_c5]) === null || _data$_bd_r13$_bd_c === void 0 ? void 0 : _data$_bd_r13$_bd_c.mc)) {
                    var _cfg$merge15, _cell2$mc, _cell2$mc2;
                    var _cell2 = data[_bd_r5][_bd_c5];
                    var _mc14 = (_cfg$merge15 = cfg.merge) === null || _cfg$merge15 === void 0 ? void 0 : _cfg$merge15["".concat(_cell2 === null || _cell2 === void 0 ? void 0 : (_cell2$mc = _cell2.mc) === null || _cell2$mc === void 0 ? void 0 : _cell2$mc.r, "_").concat(_cell2 === null || _cell2 === void 0 ? void 0 : (_cell2$mc2 = _cell2.mc) === null || _cell2$mc2 === void 0 ? void 0 : _cell2$mc2.c)];
                    if ((_mc14 === null || _mc14 === void 0 ? void 0 : _mc14.c) === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc14 && _mc14.c + _mc14.cs - 1 === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_r5 === bd_r2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else if (_bd_c5 === bd_c1) {
                  var _data$_bd_r14, _data$_bd_r14$_bd_c;
                  if (!_$1.isNil((_data$_bd_r14 = data[_bd_r5]) === null || _data$_bd_r14 === void 0 ? void 0 : (_data$_bd_r14$_bd_c = _data$_bd_r14[_bd_c5]) === null || _data$_bd_r14$_bd_c === void 0 ? void 0 : _data$_bd_r14$_bd_c.mc)) {
                    var _cfg$merge16, _cell3$mc, _cell3$mc2;
                    var _cell3 = data[_bd_r5][_bd_c5];
                    var _mc15 = (_cfg$merge16 = cfg.merge) === null || _cfg$merge16 === void 0 ? void 0 : _cfg$merge16["".concat(_cell3 === null || _cell3 === void 0 ? void 0 : (_cell3$mc = _cell3.mc) === null || _cell3$mc === void 0 ? void 0 : _cell3$mc.r, "_").concat(_cell3 === null || _cell3 === void 0 ? void 0 : (_cell3$mc2 = _cell3.mc) === null || _cell3$mc2 === void 0 ? void 0 : _cell3$mc2.c)];
                    if ((_mc15 === null || _mc15 === void 0 ? void 0 : _mc15.r) === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc15 && _mc15.r + _mc15.rs - 1 === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_c5 === bd_c2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                } else if (_bd_c5 === bd_c2) {
                  var _data$_bd_r15, _data$_bd_r15$_bd_c;
                  if (!_$1.isNil((_data$_bd_r15 = data[_bd_r5]) === null || _data$_bd_r15 === void 0 ? void 0 : (_data$_bd_r15$_bd_c = _data$_bd_r15[_bd_c5]) === null || _data$_bd_r15$_bd_c === void 0 ? void 0 : _data$_bd_r15$_bd_c.mc)) {
                    var _cfg$merge17, _cell4$mc, _cell4$mc2;
                    var _cell4 = data[_bd_r5][_bd_c5];
                    var _mc16 = (_cfg$merge17 = cfg.merge) === null || _cfg$merge17 === void 0 ? void 0 : _cfg$merge17["".concat(_cell4 === null || _cell4 === void 0 ? void 0 : (_cell4$mc = _cell4.mc) === null || _cell4$mc === void 0 ? void 0 : _cell4$mc.r, "_").concat(_cell4 === null || _cell4 === void 0 ? void 0 : (_cell4$mc2 = _cell4.mc) === null || _cell4$mc2 === void 0 ? void 0 : _cell4$mc2.c)];
                    if ((_mc16 === null || _mc16 === void 0 ? void 0 : _mc16.r) === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc16 && _mc16.r + _mc16.rs - 1 === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_c5 === bd_c2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                } else {
                  var _data$_bd_r16, _data$_bd_r16$_bd_c;
                  if (!_$1.isNil((_data$_bd_r16 = data[_bd_r5]) === null || _data$_bd_r16 === void 0 ? void 0 : (_data$_bd_r16$_bd_c = _data$_bd_r16[_bd_c5]) === null || _data$_bd_r16$_bd_c === void 0 ? void 0 : _data$_bd_r16$_bd_c.mc)) {
                    var _cfg$merge18, _cell5$mc, _cell5$mc2;
                    var _cell5 = data[_bd_r5][_bd_c5];
                    var _mc17 = (_cfg$merge18 = cfg.merge) === null || _cfg$merge18 === void 0 ? void 0 : _cfg$merge18["".concat(_cell5 === null || _cell5 === void 0 ? void 0 : (_cell5$mc = _cell5.mc) === null || _cell5$mc === void 0 ? void 0 : _cell5$mc.r, "_").concat(_cell5 === null || _cell5 === void 0 ? void 0 : (_cell5$mc2 = _cell5.mc) === null || _cell5$mc2 === void 0 ? void 0 : _cell5$mc2.c)];
                    if ((_mc17 === null || _mc17 === void 0 ? void 0 : _mc17.r) === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc17 && _mc17.r + _mc17.rs - 1 === _bd_r5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_c5 === bd_c2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                    if ((_mc17 === null || _mc17 === void 0 ? void 0 : _mc17.c) === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc17 && _mc17.c + _mc17.cs - 1 === _bd_c5) {
                      if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                      }
                      if (!_bd_r5 === bd_r2) {
                        borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                          color: borderColor,
                          style: borderStyle
                        };
                      }
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] === void 0) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_r5 === bd_r2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                    borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                    if (!_bd_c5 === bd_c2) {
                      borderInfoCompute["".concat(_bd_r5, "_").concat(_bd_c5)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  }
                }
              }
            }
          } else if (borderType === "border-horizontal") {
            for (var _bd_r6 = bd_r1; _bd_r6 <= bd_r2; _bd_r6 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r6])) {
                continue;
              }
              for (var _bd_c6 = bd_c1; _bd_c6 <= bd_c2; _bd_c6 += 1) {
                if (_bd_r6 === bd_r1) {
                  var _data$_bd_r17, _data$_bd_r17$_bd_c;
                  if (!_$1.isNil((_data$_bd_r17 = data[_bd_r6]) === null || _data$_bd_r17 === void 0 ? void 0 : (_data$_bd_r17$_bd_c = _data$_bd_r17[_bd_c6]) === null || _data$_bd_r17$_bd_c === void 0 ? void 0 : _data$_bd_r17$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] === void 0) {
                      borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].b = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else if (_bd_r6 === bd_r2) {
                  var _data$_bd_r18, _data$_bd_r18$_bd_c;
                  if (!_$1.isNil((_data$_bd_r18 = data[_bd_r6]) === null || _data$_bd_r18 === void 0 ? void 0 : (_data$_bd_r18$_bd_c = _data$_bd_r18[_bd_c6]) === null || _data$_bd_r18$_bd_c === void 0 ? void 0 : _data$_bd_r18$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] === void 0) {
                      borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  var _data$_bd_r19, _data$_bd_r19$_bd_c;
                  if (!_$1.isNil((_data$_bd_r19 = data[_bd_r6]) === null || _data$_bd_r19 === void 0 ? void 0 : (_data$_bd_r19$_bd_c = _data$_bd_r19[_bd_c6]) === null || _data$_bd_r19$_bd_c === void 0 ? void 0 : _data$_bd_r19$_bd_c.mc)) {
                    var _cfg$merge19, _cell6$mc, _cell6$mc2;
                    var _cell6 = data[_bd_r6][_bd_c6];
                    var _mc18 = (_cfg$merge19 = cfg.merge) === null || _cfg$merge19 === void 0 ? void 0 : _cfg$merge19["".concat(_cell6 === null || _cell6 === void 0 ? void 0 : (_cell6$mc = _cell6.mc) === null || _cell6$mc === void 0 ? void 0 : _cell6$mc.r, "_").concat(_cell6 === null || _cell6 === void 0 ? void 0 : (_cell6$mc2 = _cell6.mc) === null || _cell6$mc2 === void 0 ? void 0 : _cell6$mc2.c)];
                    if ((_mc18 === null || _mc18 === void 0 ? void 0 : _mc18.r) === _bd_r6) {
                      if (borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] === void 0) {
                        borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].t = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc18 && _mc18.r + _mc18.rs - 1 === _bd_r6) {
                      if (borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] === void 0) {
                        borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].b = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] === void 0) {
                      borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].t = {
                      color: borderColor,
                      style: borderStyle
                    };
                    borderInfoCompute["".concat(_bd_r6, "_").concat(_bd_c6)].b = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                }
              }
            }
          } else if (borderType === "border-vertical") {
            for (var _bd_r7 = bd_r1; _bd_r7 <= bd_r2; _bd_r7 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r7])) {
                continue;
              }
              for (var _bd_c7 = bd_c1; _bd_c7 <= bd_c2; _bd_c7 += 1) {
                if (_bd_c7 === bd_c1) {
                  var _data$_bd_r20, _data$_bd_r20$_bd_c;
                  if (!_$1.isNil((_data$_bd_r20 = data[_bd_r7]) === null || _data$_bd_r20 === void 0 ? void 0 : (_data$_bd_r20$_bd_c = _data$_bd_r20[_bd_c7]) === null || _data$_bd_r20$_bd_c === void 0 ? void 0 : _data$_bd_r20$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] === void 0) {
                      borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].r = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else if (_bd_c7 === bd_c2) {
                  var _data$_bd_r21, _data$_bd_r21$_bd_c;
                  if (!_$1.isNil((_data$_bd_r21 = data[_bd_r7]) === null || _data$_bd_r21 === void 0 ? void 0 : (_data$_bd_r21$_bd_c = _data$_bd_r21[_bd_c7]) === null || _data$_bd_r21$_bd_c === void 0 ? void 0 : _data$_bd_r21$_bd_c.mc)) ;
                  else {
                    if (borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] === void 0) {
                      borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                } else {
                  var _data$_bd_r22, _data$_bd_r22$_bd_c;
                  if (!_$1.isNil((_data$_bd_r22 = data[_bd_r7]) === null || _data$_bd_r22 === void 0 ? void 0 : (_data$_bd_r22$_bd_c = _data$_bd_r22[_bd_c7]) === null || _data$_bd_r22$_bd_c === void 0 ? void 0 : _data$_bd_r22$_bd_c.mc)) {
                    var _cfg$merge20, _cell7$mc, _cell7$mc2;
                    var _cell7 = data[_bd_r7][_bd_c7];
                    var _mc19 = (_cfg$merge20 = cfg.merge) === null || _cfg$merge20 === void 0 ? void 0 : _cfg$merge20["".concat(_cell7 === null || _cell7 === void 0 ? void 0 : (_cell7$mc = _cell7.mc) === null || _cell7$mc === void 0 ? void 0 : _cell7$mc.r, "_").concat(_cell7 === null || _cell7 === void 0 ? void 0 : (_cell7$mc2 = _cell7.mc) === null || _cell7$mc2 === void 0 ? void 0 : _cell7$mc2.c)];
                    if ((_mc19 === null || _mc19 === void 0 ? void 0 : _mc19.c) === _bd_c7) {
                      if (borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] === void 0) {
                        borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].l = {
                        color: borderColor,
                        style: borderStyle
                      };
                    } else if (_mc19 && _mc19.c + _mc19.cs - 1 === _bd_c7) {
                      if (borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] === void 0) {
                        borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] = {};
                      }
                      borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].r = {
                        color: borderColor,
                        style: borderStyle
                      };
                    }
                  } else {
                    if (borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] === void 0) {
                      borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)] = {};
                    }
                    borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].l = {
                      color: borderColor,
                      style: borderStyle
                    };
                    borderInfoCompute["".concat(_bd_r7, "_").concat(_bd_c7)].r = {
                      color: borderColor,
                      style: borderStyle
                    };
                  }
                }
              }
            }
          } else if (borderType === "border-none") {
            for (var _bd_r8 = bd_r1; _bd_r8 <= bd_r2; _bd_r8 += 1) {
              if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[_bd_r8])) {
                continue;
              }
              for (var _bd_c8 = bd_c1; _bd_c8 <= bd_c2; _bd_c8 += 1) {
                if (!_$1.isNil(borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c8)])) {
                  delete borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c8)];
                }
                if (_bd_r8 === bd_r1) {
                  var _bd_r_top2 = bd_r1 - 1;
                  if (_bd_r_top2 >= 0 && borderInfoCompute["".concat(_bd_r_top2, "_").concat(_bd_c8)]) {
                    delete borderInfoCompute["".concat(_bd_r_top2, "_").concat(_bd_c8)].b;
                  }
                }
                if (_bd_r8 === bd_r2) {
                  var _bd_r_bottom2 = bd_r2 + 1;
                  if (_bd_r_bottom2 < data.length && borderInfoCompute["".concat(_bd_r_bottom2, "_").concat(_bd_c8)]) {
                    delete borderInfoCompute["".concat(_bd_r_bottom2, "_").concat(_bd_c8)].t;
                  }
                }
                if (_bd_c8 === bd_c1) {
                  var _bd_c_left2 = bd_c1 - 1;
                  if (_bd_c_left2 >= 0 && borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c_left2)]) {
                    delete borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c_left2)].r;
                  }
                }
                if (_bd_c8 === bd_c2) {
                  var _bd_c_right2 = bd_c2 + 1;
                  if (_bd_c_right2 < data[0].length && borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c_right2)]) {
                    delete borderInfoCompute["".concat(_bd_r8, "_").concat(_bd_c_right2)].l;
                  }
                }
              }
            }
          }
        };
        for (var j2 = 0; j2 < borderRange.length; j2 += 1) {
          var _ret = _loop(j2);
          if (_ret === "continue") continue;
        }
      } else if (rangeType === "cell") {
        var value = borderInfo[i2].value;
        var bd_r = value.row_index;
        var bd_c = value.col_index;
        if (bd_r < dataset_row_st || bd_r > dataset_row_ed || bd_c < dataset_col_st || bd_c > dataset_col_ed) {
          continue;
        }
        if (!_$1.isNil(cfg.rowhidden) && !_$1.isNil(cfg.rowhidden[bd_r])) {
          continue;
        }
        if (!_$1.isNil(value.l) || !_$1.isNil(value.r) || !_$1.isNil(value.t) || !_$1.isNil(value.b)) {
          var _data$bd_r, _data$bd_r$bd_c;
          if (borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] === void 0) {
            borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] = {};
          }
          if (!_$1.isNil((_data$bd_r = data[bd_r]) === null || _data$bd_r === void 0 ? void 0 : (_data$bd_r$bd_c = _data$bd_r[bd_c]) === null || _data$bd_r$bd_c === void 0 ? void 0 : _data$bd_r$bd_c.mc)) {
            var _cfg$merge21, _cell$mc5, _cell$mc6;
            var cell = data[bd_r][bd_c];
            var mc2 = (_cfg$merge21 = cfg.merge) === null || _cfg$merge21 === void 0 ? void 0 : _cfg$merge21["".concat(cell === null || cell === void 0 ? void 0 : (_cell$mc5 = cell.mc) === null || _cell$mc5 === void 0 ? void 0 : _cell$mc5.r, "_").concat(cell === null || cell === void 0 ? void 0 : (_cell$mc6 = cell.mc) === null || _cell$mc6 === void 0 ? void 0 : _cell$mc6.c)];
            if (!_$1.isNil(value.l) && bd_c === (mc2 === null || mc2 === void 0 ? void 0 : mc2.c)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l = {
                color: value.l.color,
                style: value.l.style
              };
              var bd_c_left = bd_c - 1;
              if (bd_c_left >= 0 && borderInfoCompute["".concat(bd_r, "_").concat(bd_c_left)]) {
                var _data$bd_r2, _data$bd_r2$bd_c_left;
                if (!_$1.isNil((_data$bd_r2 = data[bd_r]) === null || _data$bd_r2 === void 0 ? void 0 : (_data$bd_r2$bd_c_left = _data$bd_r2[bd_c_left]) === null || _data$bd_r2$bd_c_left === void 0 ? void 0 : _data$bd_r2$bd_c_left.mc)) {
                  var _cfg$merge22, _cell_left$mc7, _cell_left$mc8;
                  var cell_left = data[bd_r][bd_c_left];
                  var mc_l = (_cfg$merge22 = cfg.merge) === null || _cfg$merge22 === void 0 ? void 0 : _cfg$merge22["".concat(cell_left === null || cell_left === void 0 ? void 0 : (_cell_left$mc7 = cell_left.mc) === null || _cell_left$mc7 === void 0 ? void 0 : _cell_left$mc7.r, "_").concat(cell_left === null || cell_left === void 0 ? void 0 : (_cell_left$mc8 = cell_left.mc) === null || _cell_left$mc8 === void 0 ? void 0 : _cell_left$mc8.c)];
                  if (mc_l && mc_l.c + mc_l.cs - 1 === bd_c_left) {
                    borderInfoCompute["".concat(bd_r, "_").concat(bd_c_left)].r = {
                      color: value.l.color,
                      style: value.l.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r, "_").concat(bd_c_left)].r = {
                    color: value.l.color,
                    style: value.l.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l = null;
            }
            if (!_$1.isNil(value.r) && mc2 && bd_c === mc2.c + mc2.cs - 1) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r = {
                color: value.r.color,
                style: value.r.style
              };
              var bd_c_right = bd_c + 1;
              if (bd_c_right < data[0].length && borderInfoCompute["".concat(bd_r, "_").concat(bd_c_right)]) {
                var _data$bd_r3, _data$bd_r3$bd_c_righ;
                if (!_$1.isNil((_data$bd_r3 = data[bd_r]) === null || _data$bd_r3 === void 0 ? void 0 : (_data$bd_r3$bd_c_righ = _data$bd_r3[bd_c_right]) === null || _data$bd_r3$bd_c_righ === void 0 ? void 0 : _data$bd_r3$bd_c_righ.mc)) {
                  var _cfg$merge23, _cell_right$mc7, _cell_right$mc8;
                  var cell_right = data[bd_r][bd_c_right];
                  var mc_r = (_cfg$merge23 = cfg.merge) === null || _cfg$merge23 === void 0 ? void 0 : _cfg$merge23["".concat(cell_right === null || cell_right === void 0 ? void 0 : (_cell_right$mc7 = cell_right.mc) === null || _cell_right$mc7 === void 0 ? void 0 : _cell_right$mc7.r, "_").concat(cell_right === null || cell_right === void 0 ? void 0 : (_cell_right$mc8 = cell_right.mc) === null || _cell_right$mc8 === void 0 ? void 0 : _cell_right$mc8.c)];
                  if ((mc_r === null || mc_r === void 0 ? void 0 : mc_r.c) === bd_c_right) {
                    borderInfoCompute["".concat(bd_r, "_").concat(bd_c_right)].l = {
                      color: value.r.color,
                      style: value.r.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r, "_").concat(bd_c_right)].l = {
                    color: value.r.color,
                    style: value.r.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r = null;
            }
            if (!_$1.isNil(value.t) && bd_r === (mc2 === null || mc2 === void 0 ? void 0 : mc2.r)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t = {
                color: value.t.color,
                style: value.t.style
              };
              var bd_r_top = bd_r - 1;
              if (bd_r_top >= 0 && borderInfoCompute["".concat(bd_r_top, "_").concat(bd_c)]) {
                var _data$bd_r_top3, _data$bd_r_top3$bd_c;
                if (!_$1.isNil((_data$bd_r_top3 = data[bd_r_top]) === null || _data$bd_r_top3 === void 0 ? void 0 : (_data$bd_r_top3$bd_c = _data$bd_r_top3[bd_c]) === null || _data$bd_r_top3$bd_c === void 0 ? void 0 : _data$bd_r_top3$bd_c.mc)) {
                  var _cfg$merge24, _cell_top$mc7, _cell_top$mc8;
                  var cell_top = data[bd_r_top][bd_c];
                  var mc_t = (_cfg$merge24 = cfg.merge) === null || _cfg$merge24 === void 0 ? void 0 : _cfg$merge24["".concat(cell_top === null || cell_top === void 0 ? void 0 : (_cell_top$mc7 = cell_top.mc) === null || _cell_top$mc7 === void 0 ? void 0 : _cell_top$mc7.r, "_").concat(cell_top === null || cell_top === void 0 ? void 0 : (_cell_top$mc8 = cell_top.mc) === null || _cell_top$mc8 === void 0 ? void 0 : _cell_top$mc8.c)];
                  if (mc_t && mc_t.r + mc_t.rs - 1 === bd_r_top) {
                    borderInfoCompute["".concat(bd_r_top, "_").concat(bd_c)].b = {
                      color: value.t.color,
                      style: value.t.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r_top, "_").concat(bd_c)].b = {
                    color: value.t.color,
                    style: value.t.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t = null;
            }
            if (!_$1.isNil(value.b) && mc2 && bd_r === mc2.r + mc2.rs - 1) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b = {
                color: value.b.color,
                style: value.b.style
              };
              var bd_r_bottom = bd_r + 1;
              if (bd_r_bottom < data.length && borderInfoCompute["".concat(bd_r_bottom, "_").concat(bd_c)]) {
                var _data$bd_r_bottom3, _data$bd_r_bottom3$bd;
                if (!_$1.isNil((_data$bd_r_bottom3 = data[bd_r_bottom]) === null || _data$bd_r_bottom3 === void 0 ? void 0 : (_data$bd_r_bottom3$bd = _data$bd_r_bottom3[bd_c]) === null || _data$bd_r_bottom3$bd === void 0 ? void 0 : _data$bd_r_bottom3$bd.mc)) {
                  var _cfg$merge25, _cell_bottom$mc7, _cell_bottom$mc8;
                  var cell_bottom = data[bd_r_bottom][bd_c];
                  var mc_b = (_cfg$merge25 = cfg.merge) === null || _cfg$merge25 === void 0 ? void 0 : _cfg$merge25["".concat(cell_bottom === null || cell_bottom === void 0 ? void 0 : (_cell_bottom$mc7 = cell_bottom.mc) === null || _cell_bottom$mc7 === void 0 ? void 0 : _cell_bottom$mc7.r, "_").concat(cell_bottom === null || cell_bottom === void 0 ? void 0 : (_cell_bottom$mc8 = cell_bottom.mc) === null || _cell_bottom$mc8 === void 0 ? void 0 : _cell_bottom$mc8.c)];
                  if ((mc_b === null || mc_b === void 0 ? void 0 : mc_b.r) === bd_r_bottom) {
                    borderInfoCompute["".concat(bd_r_bottom, "_").concat(bd_c)].t = {
                      color: value.b.color,
                      style: value.b.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r_bottom, "_").concat(bd_c)].t = {
                    color: value.b.color,
                    style: value.b.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b = null;
            }
          } else {
            if (!_$1.isNil(value.l)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l = {
                color: value.l.color,
                style: value.l.style
              };
              var _bd_c_left3 = bd_c - 1;
              if (_bd_c_left3 >= 0 && borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_left3)]) {
                var _data$bd_r4, _data$bd_r4$_bd_c_lef;
                if (!_$1.isNil((_data$bd_r4 = data[bd_r]) === null || _data$bd_r4 === void 0 ? void 0 : (_data$bd_r4$_bd_c_lef = _data$bd_r4[_bd_c_left3]) === null || _data$bd_r4$_bd_c_lef === void 0 ? void 0 : _data$bd_r4$_bd_c_lef.mc)) {
                  var _cfg$merge26, _cell_left2$mc, _cell_left2$mc2;
                  var _cell_left2 = data[bd_r][_bd_c_left3];
                  var _mc_l = (_cfg$merge26 = cfg.merge) === null || _cfg$merge26 === void 0 ? void 0 : _cfg$merge26["".concat(_cell_left2 === null || _cell_left2 === void 0 ? void 0 : (_cell_left2$mc = _cell_left2.mc) === null || _cell_left2$mc === void 0 ? void 0 : _cell_left2$mc.r, "_").concat(_cell_left2 === null || _cell_left2 === void 0 ? void 0 : (_cell_left2$mc2 = _cell_left2.mc) === null || _cell_left2$mc2 === void 0 ? void 0 : _cell_left2$mc2.c)];
                  if (_mc_l && _mc_l.c + _mc_l.cs - 1 === _bd_c_left3) {
                    borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_left3)].r = {
                      color: value.l.color,
                      style: value.l.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_left3)].r = {
                    color: value.l.color,
                    style: value.l.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l = null;
            }
            if (!_$1.isNil(value.r)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r = {
                color: value.r.color,
                style: value.r.style
              };
              var _bd_c_right3 = bd_c + 1;
              if (_bd_c_right3 < data[0].length && borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_right3)]) {
                var _data$bd_r5, _data$bd_r5$_bd_c_rig;
                if (!_$1.isNil(data[bd_r]) && _$1.isPlainObject(data[bd_r][_bd_c_right3]) && !_$1.isNil((_data$bd_r5 = data[bd_r]) === null || _data$bd_r5 === void 0 ? void 0 : (_data$bd_r5$_bd_c_rig = _data$bd_r5[_bd_c_right3]) === null || _data$bd_r5$_bd_c_rig === void 0 ? void 0 : _data$bd_r5$_bd_c_rig.mc)) {
                  var _cfg$merge27, _cell_right2$mc, _cell_right2$mc2;
                  var _cell_right2 = data[bd_r][_bd_c_right3];
                  var _mc_r = (_cfg$merge27 = cfg.merge) === null || _cfg$merge27 === void 0 ? void 0 : _cfg$merge27["".concat(_cell_right2 === null || _cell_right2 === void 0 ? void 0 : (_cell_right2$mc = _cell_right2.mc) === null || _cell_right2$mc === void 0 ? void 0 : _cell_right2$mc.r, "_").concat(_cell_right2 === null || _cell_right2 === void 0 ? void 0 : (_cell_right2$mc2 = _cell_right2.mc) === null || _cell_right2$mc2 === void 0 ? void 0 : _cell_right2$mc2.c)];
                  if ((_mc_r === null || _mc_r === void 0 ? void 0 : _mc_r.c) === _bd_c_right3) {
                    borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_right3)].l = {
                      color: value.r.color,
                      style: value.r.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(bd_r, "_").concat(_bd_c_right3)].l = {
                    color: value.r.color,
                    style: value.r.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r = null;
            }
            if (!_$1.isNil(value.t)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t = {
                color: value.t.color,
                style: value.t.style
              };
              var _bd_r_top3 = bd_r - 1;
              if (_bd_r_top3 >= 0 && borderInfoCompute["".concat(_bd_r_top3, "_").concat(bd_c)]) {
                var _data$_bd_r_top2, _data$_bd_r_top2$bd_c;
                if (!_$1.isNil((_data$_bd_r_top2 = data[_bd_r_top3]) === null || _data$_bd_r_top2 === void 0 ? void 0 : (_data$_bd_r_top2$bd_c = _data$_bd_r_top2[bd_c]) === null || _data$_bd_r_top2$bd_c === void 0 ? void 0 : _data$_bd_r_top2$bd_c.mc)) {
                  var _cfg$merge28, _cell_top2$mc, _cell_top2$mc2;
                  var _cell_top2 = data[_bd_r_top3][bd_c];
                  var _mc_t = (_cfg$merge28 = cfg.merge) === null || _cfg$merge28 === void 0 ? void 0 : _cfg$merge28["".concat(_cell_top2 === null || _cell_top2 === void 0 ? void 0 : (_cell_top2$mc = _cell_top2.mc) === null || _cell_top2$mc === void 0 ? void 0 : _cell_top2$mc.r, "_").concat(_cell_top2 === null || _cell_top2 === void 0 ? void 0 : (_cell_top2$mc2 = _cell_top2.mc) === null || _cell_top2$mc2 === void 0 ? void 0 : _cell_top2$mc2.c)];
                  if (_mc_t && _mc_t.r + _mc_t.rs - 1 === _bd_r_top3) {
                    borderInfoCompute["".concat(_bd_r_top3, "_").concat(bd_c)].b = {
                      color: value.t.color,
                      style: value.t.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(_bd_r_top3, "_").concat(bd_c)].b = {
                    color: value.t.color,
                    style: value.t.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t = null;
            }
            if (!_$1.isNil(value.b)) {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b = {
                color: value.b.color,
                style: value.b.style
              };
              var _bd_r_bottom3 = bd_r + 1;
              if (_bd_r_bottom3 < data.length && borderInfoCompute["".concat(_bd_r_bottom3, "_").concat(bd_c)]) {
                var _data$_bd_r_bottom2, _data$_bd_r_bottom2$b;
                if (!_$1.isNil((_data$_bd_r_bottom2 = data[_bd_r_bottom3]) === null || _data$_bd_r_bottom2 === void 0 ? void 0 : (_data$_bd_r_bottom2$b = _data$_bd_r_bottom2[bd_c]) === null || _data$_bd_r_bottom2$b === void 0 ? void 0 : _data$_bd_r_bottom2$b.mc)) {
                  var _cfg$merge29, _cell_bottom2$mc, _cell_bottom2$mc2;
                  var _cell_bottom2 = data[_bd_r_bottom3][bd_c];
                  var _mc_b = (_cfg$merge29 = cfg.merge) === null || _cfg$merge29 === void 0 ? void 0 : _cfg$merge29["".concat(_cell_bottom2 === null || _cell_bottom2 === void 0 ? void 0 : (_cell_bottom2$mc = _cell_bottom2.mc) === null || _cell_bottom2$mc === void 0 ? void 0 : _cell_bottom2$mc.r, "_").concat(_cell_bottom2 === null || _cell_bottom2 === void 0 ? void 0 : (_cell_bottom2$mc2 = _cell_bottom2.mc) === null || _cell_bottom2$mc2 === void 0 ? void 0 : _cell_bottom2$mc2.c)];
                  if ((_mc_b === null || _mc_b === void 0 ? void 0 : _mc_b.r) === _bd_r_bottom3) {
                    borderInfoCompute["".concat(_bd_r_bottom3, "_").concat(bd_c)].t = {
                      color: value.b.color,
                      style: value.b.style
                    };
                  }
                } else {
                  borderInfoCompute["".concat(_bd_r_bottom3, "_").concat(bd_c)].t = {
                    color: value.b.color,
                    style: value.b.style
                  };
                }
              }
            } else {
              borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b = null;
            }
          }
        } else {
          delete borderInfoCompute["".concat(bd_r, "_").concat(bd_c)];
        }
      }
    }
    return borderInfoCompute;
  }
  function getBorderInfoCompute(ctx, sheetId) {
    var borderInfoCompute = {};
    var flowdata = getFlowdata(ctx);
    var data = {};
    if (sheetId === void 0) {
      data = flowdata;
    } else {
      var index2 = getSheetIndex(ctx, sheetId);
      if (!_$1.isNil(index2)) {
        data = ctx.luckysheetfile[index2].data;
      } else {
        return borderInfoCompute;
      }
    }
    borderInfoCompute = getBorderInfoComputeRange(ctx, 0, data.length, 0, data[0].length, sheetId);
    return borderInfoCompute;
  }
  function moveToEnd(obj) {
    if (document.createRange) {
      if (obj.innerHTML !== obj.innerText || obj.innerHTML === "") {
        obj.focus();
        var range = window.getSelection();
        range === null || range === void 0 ? void 0 : range.selectAllChildren(obj);
        range === null || range === void 0 ? void 0 : range.collapseToEnd();
      } else {
        var len = obj.innerText.length;
        var _range = document.createRange();
        _range.selectNodeContents(obj);
        _range.setStart(obj.childNodes[0], len);
        _range.collapse(true);
        var selection = window.getSelection();
        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        selection === null || selection === void 0 ? void 0 : selection.addRange(_range);
      }
    } else if (document.selection) {
      var _range2 = document.body.createTextRange();
      _range2.moveToElementText(obj);
      _range2.collapse(false);
      _range2.select();
    }
  }
  function isInPage(node) {
    return node === document.body ? false : document.body.contains(node);
  }
  function selectTextContent(ele) {
    if (window.getSelection) {
      var range = document.createRange();
      var content = ele.firstChild;
      if (content) {
        range.setStart(content, 0);
        range.setEnd(content, content.length);
        if (range.startContainer && isInPage(range.startContainer)) {
          var _window$getSelection, _window$getSelection2;
          (_window$getSelection = window.getSelection()) === null || _window$getSelection === void 0 ? void 0 : _window$getSelection.removeAllRanges();
          (_window$getSelection2 = window.getSelection()) === null || _window$getSelection2 === void 0 ? void 0 : _window$getSelection2.addRange(range);
        }
      }
    } else if (document.selection) {
      var _range3 = document.body.createTextRange();
      _range3.moveToElementText(ele);
      _range3.select();
    }
  }
  function selectTextContentCross(sEle, eEle) {
    if (window.getSelection) {
      var range = document.createRange();
      var sContent = sEle.firstChild;
      var eContent = eEle.firstChild;
      if (sContent && eContent) {
        range.setStart(sContent, 0);
        range.setEnd(eContent, eContent.length);
        if (range.startContainer && isInPage(range.startContainer)) {
          var _window$getSelection3, _window$getSelection4;
          (_window$getSelection3 = window.getSelection()) === null || _window$getSelection3 === void 0 ? void 0 : _window$getSelection3.removeAllRanges();
          (_window$getSelection4 = window.getSelection()) === null || _window$getSelection4 === void 0 ? void 0 : _window$getSelection4.addRange(range);
        }
      }
    }
  }
  var attrToCssName = {
    bl: "font-weight",
    it: "font-style",
    ff: "font-family",
    fs: "font-size",
    fc: "color",
    cl: "text-decoration",
    un: "border-bottom"
  };
  var inlineStyleAffectAttribute = {
    bl: 1,
    it: 1,
    ff: 1,
    cl: 1,
    un: 1,
    fs: 1,
    fc: 1
  };
  var inlineStyleAffectCssName = {
    "font-weight": 1,
    "font-style": 1,
    "font-family": 1,
    "text-decoration": 1,
    "border-bottom": 1,
    "font-size": 1,
    color: 1
  };
  function isInlineStringCell(cell) {
    var _cell$ct, _cell$ct$s$length, _cell$ct2, _cell$ct2$s;
    return (cell === null || cell === void 0 ? void 0 : (_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : _cell$ct.t) === "inlineStr" && ((_cell$ct$s$length = cell === null || cell === void 0 ? void 0 : (_cell$ct2 = cell.ct) === null || _cell$ct2 === void 0 ? void 0 : (_cell$ct2$s = _cell$ct2.s) === null || _cell$ct2$s === void 0 ? void 0 : _cell$ct2$s.length) !== null && _cell$ct$s$length !== void 0 ? _cell$ct$s$length : 0) > 0;
  }
  function isInlineStringCT(ct) {
    var _ct$s$length, _ct$s;
    return (ct === null || ct === void 0 ? void 0 : ct.t) === "inlineStr" && ((_ct$s$length = ct === null || ct === void 0 ? void 0 : (_ct$s = ct.s) === null || _ct$s === void 0 ? void 0 : _ct$s.length) !== null && _ct$s$length !== void 0 ? _ct$s$length : 0) > 0;
  }
  function getInlineStringNoStyle(r2, c2, data) {
    var ct = getCellValue(r2, c2, data, "ct");
    if (isInlineStringCT(ct)) {
      var strings = ct.s;
      var value = "";
      for (var i2 = 0; i2 < strings.length; i2 += 1) {
        var strObj = strings[i2];
        if (strObj.v) {
          value += strObj.v;
        }
      }
      return value;
    }
    return "";
  }
  function convertCssToStyleList(cssText) {
    if (_$1.isEmpty(cssText)) {
      return {};
    }
    var cssTextArray = cssText.split(";");
    var styleList = {
      fc: "#000000",
      fs: 10,
      cl: 0,
      un: 0,
      bl: 0,
      it: 0
    };
    cssTextArray.forEach(function(s2) {
      s2 = s2.toLowerCase();
      var key = _$1.trim(s2.substring(0, s2.indexOf(":")));
      var value = _$1.trim(s2.substring(s2.indexOf(":") + 1));
      if (key === "font-weight") {
        if (value === "bold") {
          styleList.bl = 1;
        } else {
          styleList.bl = 0;
        }
      }
      if (key === "font-style") {
        if (value === "italic") {
          styleList.it = 1;
        } else {
          styleList.it = 0;
        }
      }
      if (key === "font-size") {
        styleList.fs = parseInt(value, 10);
      }
      if (key === "color") {
        styleList.fc = value;
      }
      if (key === "text-decoration") {
        styleList.cl = 1;
      }
      if (key === "border-bottom") {
        styleList.un = 1;
      }
      if (key === "lucky-strike") {
        styleList.cl = Number(value);
      }
      if (key === "lucky-underline") {
        styleList.un = Number(value);
      }
    });
    return styleList;
  }
  function convertSpanToShareString($dom) {
    var styles = [];
    var preStyleList;
    var preStyleListString = null;
    for (var i2 = 0; i2 < $dom.length; i2 += 1) {
      var span = $dom[i2];
      var styleList = convertCssToStyleList(span.style.cssText);
      var curStyleListString = JSON.stringify(styleList);
      var v2 = span.innerText;
      v2 = v2.replace(/\n/g, "\r\n");
      if (i2 === $dom.length - 1) {
        if (v2.endsWith("\r\n") && !v2.endsWith("\r\n\r\n")) {
          v2 = v2.slice(0, v2.length - 2);
        }
      }
      if (curStyleListString === preStyleListString) {
        preStyleList.v += v2;
      } else {
        styleList.v = v2;
        styles.push(styleList);
        preStyleListString = curStyleListString;
        preStyleList = styleList;
      }
    }
    return styles;
  }
  function updateInlineStringFormatOutside(cell, key, value) {
    if (_$1.isNil(cell.ct)) {
      return;
    }
    var s2 = cell.ct.s;
    if (_$1.isNil(s2)) {
      return;
    }
    for (var i2 = 0; i2 < s2.length; i2 += 1) {
      var item = s2[i2];
      item[key] = value;
    }
  }
  function getClassWithcss(cssText, ukey) {
    var cssTextArray = cssText.split(";");
    if (ukey == null || ukey.length === 0) {
      return cssText;
    }
    if (cssText.indexOf(ukey) > -1) {
      for (var i2 = 0; i2 < cssTextArray.length; i2 += 1) {
        var s2 = cssTextArray[i2];
        s2 = s2.toLowerCase();
        var key = _$1.trim(s2.substring(0, s2.indexOf(":")));
        var value = _$1.trim(s2.substring(s2.indexOf(":") + 1));
        if (key === ukey) {
          return value;
        }
      }
    }
    return "";
  }
  function upsetClassWithCss(cssText, ukey, uvalue) {
    var cssTextArray = cssText.split(";");
    var newCss = "";
    if (ukey == null || ukey.length === 0) {
      return cssText;
    }
    if (cssText.indexOf(ukey) > -1) {
      for (var i2 = 0; i2 < cssTextArray.length; i2 += 1) {
        var s2 = cssTextArray[i2];
        s2 = s2.toLowerCase();
        var key = _$1.trim(s2.substring(0, s2.indexOf(":")));
        var value = _$1.trim(s2.substring(s2.indexOf(":") + 1));
        if (key === ukey) {
          newCss += "".concat(key, ":").concat(uvalue, ";");
        } else if (key.length > 0) {
          newCss += "".concat(key, ":").concat(value, ";");
        }
      }
    } else if (ukey.length > 0) {
      cssText += "".concat(ukey, ":").concat(uvalue, ";");
      newCss = cssText;
    }
    return newCss;
  }
  function removeClassWidthCss(cssText, ukey) {
    var cssTextArray = cssText.split(";");
    var newCss = "";
    var oUkey = ukey;
    if (ukey == null || ukey.length === 0) {
      return cssText;
    }
    if (ukey in attrToCssName) {
      ukey = attrToCssName[ukey];
    }
    if (cssText.indexOf(ukey) > -1) {
      for (var i2 = 0; i2 < cssTextArray.length; i2 += 1) {
        var s2 = cssTextArray[i2];
        s2 = s2.toLowerCase();
        var key = _$1.trim(s2.substring(0, s2.indexOf(":")));
        var value = _$1.trim(s2.substring(s2.indexOf(":") + 1));
        if (key === ukey || oUkey === "cl" && key === "lucky-strike" || oUkey === "un" && key === "lucky-underline") {
          continue;
        } else if (key.length > 0) {
          newCss += "".concat(key, ":").concat(value, ";");
        }
      }
    } else {
      newCss = cssText;
    }
    return newCss;
  }
  function getCssText(cssText, attr, value) {
    var styleObj = {};
    styleObj[attr] = value;
    if (attr === "un") {
      var fontColor = getClassWithcss(cssText, "color");
      if (fontColor === "") {
        fontColor = "#000000";
      }
      var fs = getClassWithcss(cssText, "font-size");
      if (fs === "") {
        fs = "11";
      }
      styleObj._fontSize = Number(fs);
      styleObj._color = fontColor;
    }
    var s2 = getFontStyleByCell(styleObj, void 0, void 0, false);
    var ukey = _$1.kebabCase(Object.keys(s2)[0]);
    var uvalue = Object.values(s2)[0];
    cssText = removeClassWidthCss(cssText, attr);
    cssText = upsetClassWithCss(cssText, ukey, uvalue);
    return cssText;
  }
  function extendCssText(origin, cover) {
    var isLimit = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var originArray = origin.split(";");
    var coverArray = cover.split(";");
    var newCss = "";
    var addKeyList = {};
    for (var i2 = 0; i2 < originArray.length; i2 += 1) {
      var so = originArray[i2];
      var isAdd = true;
      so = so.toLowerCase();
      var okey = _$1.trim(so.substring(0, so.indexOf(":")));
      if (okey === "font-size") {
        continue;
      }
      var ovalue = _$1.trim(so.substring(so.indexOf(":") + 1));
      if (isLimit) {
        if (!(okey in inlineStyleAffectCssName)) {
          continue;
        }
      }
      for (var a2 = 0; a2 < coverArray.length; a2 += 1) {
        var sc2 = coverArray[a2];
        sc2 = sc2.toLowerCase();
        var ckey = _$1.trim(sc2.substring(0, sc2.indexOf(":")));
        var cvalue = _$1.trim(sc2.substring(sc2.indexOf(":") + 1));
        if (okey === ckey) {
          newCss += "".concat(ckey, ":").concat(cvalue, ";");
          isAdd = false;
          continue;
        }
      }
      if (isAdd) {
        newCss += "".concat(okey, ":").concat(ovalue, ";");
      }
      addKeyList[okey] = 1;
    }
    for (var _a = 0; _a < coverArray.length; _a += 1) {
      var _sc = coverArray[_a];
      _sc = _sc.toLowerCase();
      var _ckey = _$1.trim(_sc.substring(0, _sc.indexOf(":")));
      var _cvalue = _$1.trim(_sc.substring(_sc.indexOf(":") + 1));
      if (isLimit) {
        if (!(_ckey in inlineStyleAffectCssName)) {
          continue;
        }
      }
      if (!(_ckey in addKeyList)) {
        newCss += "".concat(_ckey, ":").concat(_cvalue, ";");
      }
    }
    return newCss;
  }
  function updateInlineStringFormat(ctx, cell, attr, value, cellInput) {
    var w2 = window.getSelection();
    if (!w2) return;
    var range = w2.getRangeAt(0);
    var $textEditor = cellInput;
    if (range.collapsed === true) {
      return;
    }
    var endContainer = range.endContainer;
    var startContainer = range.startContainer;
    var endOffset = range.endOffset;
    var startOffset = range.startOffset;
    if ($textEditor) {
      if (startContainer === endContainer) {
        var span = startContainer.parentNode;
        var spanIndex;
        var inherit = false;
        var content = (span === null || span === void 0 ? void 0 : span.innerHTML) || "";
        var fullContent = $textEditor.innerHTML;
        if (fullContent.substring(0, 5) !== "<span") {
          inherit = true;
        }
        if (span) {
          var _startContainer$paren;
          var left = "";
          var mid = "";
          var right = "";
          var s1 = 0;
          var s2 = startOffset;
          var s3 = endOffset;
          var s4 = content.length;
          left = content.substring(s1, s2);
          mid = content.substring(s2, s3);
          right = content.substring(s3, s4);
          var cont = "";
          if (left !== "") {
            var cssText = span.style.cssText;
            if (inherit) {
              var box = span.closest("#luckysheet-input-box");
              if (box != null) {
                cssText = extendCssText(box.style.cssText, cssText);
              }
            }
            cont += "<span style='".concat(cssText, "'>").concat(left, "</span>");
          }
          if (mid !== "") {
            var _cssText = getCssText(span.style.cssText, attr, value);
            if (inherit) {
              var _box = span.closest("#luckysheet-input-box");
              if (_box != null) {
                _cssText = extendCssText(_box.style.cssText, _cssText);
              }
            }
            cont += "<span style='".concat(_cssText, "'>").concat(mid, "</span>");
          }
          if (right !== "") {
            var _cssText2 = span.style.cssText;
            if (inherit) {
              var _box2 = span.closest("#luckysheet-input-box");
              if (_box2 != null) {
                _cssText2 = extendCssText(_box2.style.cssText, _cssText2);
              }
            }
            cont += "<span style='".concat(_cssText2, "'>").concat(right, "</span>");
          }
          if (((_startContainer$paren = startContainer.parentElement) === null || _startContainer$paren === void 0 ? void 0 : _startContainer$paren.tagName) === "SPAN") {
            spanIndex = _$1.indexOf($textEditor.querySelectorAll("span"), span);
            span.outerHTML = cont;
          } else {
            spanIndex = 0;
            span.innerHTML = cont;
          }
          var seletedNodeIndex = 0;
          if (s1 === s2) {
            seletedNodeIndex = spanIndex;
          } else {
            seletedNodeIndex = spanIndex + 1;
          }
          selectTextContent($textEditor.querySelectorAll("span")[seletedNodeIndex]);
        }
      } else {
        var _startContainer$paren2, _endContainer$parentE;
        if (((_startContainer$paren2 = startContainer.parentElement) === null || _startContainer$paren2 === void 0 ? void 0 : _startContainer$paren2.tagName) === "SPAN" && ((_endContainer$parentE = endContainer.parentElement) === null || _endContainer$parentE === void 0 ? void 0 : _endContainer$parentE.tagName) === "SPAN") {
          var startSpan = startContainer.parentNode;
          var endSpan = endContainer.parentNode;
          var allSpans = $textEditor.querySelectorAll("span");
          var startSpanIndex = _$1.indexOf(allSpans, startSpan);
          var endSpanIndex = _$1.indexOf(allSpans, endSpan);
          var startContent = (startSpan === null || startSpan === void 0 ? void 0 : startSpan.innerHTML) || "";
          var endContent = (endSpan === null || endSpan === void 0 ? void 0 : endSpan.innerHTML) || "";
          var sleft = "";
          var sright = "";
          var eleft = "";
          var eright = "";
          var _s = 0;
          var _s2 = startOffset;
          var _s3 = endOffset;
          var _s4 = endContent.length;
          sleft = startContent.substring(_s, _s2);
          sright = startContent.substring(_s2, startContent.length);
          eleft = endContent.substring(0, _s3);
          eright = endContent.substring(_s3, _s4);
          var spans = $textEditor.querySelectorAll("span");
          var _cont = "";
          for (var i2 = 0; i2 < startSpanIndex; i2 += 1) {
            var _span = spans[i2];
            var _content = _span.innerHTML;
            _cont += "<span style='".concat(_span.style.cssText, "'>").concat(_content, "</span>");
          }
          if (sleft !== "") {
            _cont += "<span style='".concat(startSpan.style.cssText, "'>").concat(sleft, "</span>");
          }
          if (sright !== "") {
            var _cssText3 = getCssText(startSpan.style.cssText, attr, value);
            _cont += "<span style='".concat(_cssText3, "'>").concat(sright, "</span>");
          }
          if (startSpanIndex < endSpanIndex) {
            for (var _i = startSpanIndex + 1; _i < endSpanIndex; _i += 1) {
              var _span2 = spans[_i];
              var _content2 = _span2.innerHTML;
              _cont += "<span style='".concat(_span2.style.cssText, "'>").concat(_content2, "</span>");
            }
          }
          if (eleft !== "") {
            var _cssText4 = getCssText(endSpan.style.cssText, attr, value);
            _cont += "<span style='".concat(_cssText4, "'>").concat(eleft, "</span>");
          }
          if (eright !== "") {
            _cont += "<span style='".concat(endSpan.style.cssText, "'>").concat(eright, "</span>");
          }
          for (var _i2 = endSpanIndex + 1; _i2 < spans.length; _i2 += 1) {
            var _span3 = spans[_i2];
            var _content3 = _span3.innerHTML;
            _cont += "<span style='".concat(_span3.style.cssText, "'>").concat(_content3, "</span>");
          }
          $textEditor.innerHTML = _cont;
          var startSeletedNodeIndex;
          var endSeletedNodeIndex;
          if (_s === _s2) {
            startSeletedNodeIndex = startSpanIndex;
            endSeletedNodeIndex = endSpanIndex;
          } else {
            startSeletedNodeIndex = startSpanIndex + 1;
            endSeletedNodeIndex = endSpanIndex + 1;
          }
          spans = $textEditor.querySelectorAll("span");
          selectTextContentCross(spans[startSeletedNodeIndex], spans[endSeletedNodeIndex]);
        }
      }
    }
  }
  function checkWordByteLength(value) {
    return Math.ceil(value.charCodeAt(0).toString(2).length / 8);
  }
  function hasChinaword(s2) {
    var patrn = /[\u4E00-\u9FA5]|[\uFE30-\uFFA0]/gi;
    if (!patrn.exec(s2)) {
      return false;
    }
    return true;
  }
  var textHeightCache = {};
  var measureTextCache = {};
  var measureTextCellInfoCache = {};
  function clearMeasureTextCache() {
    measureTextCache = {};
    measureTextCellInfoCache = {};
  }
  function getTextSize(text2, font) {
    if (font in textHeightCache) {
      return textHeightCache[font];
    }
    var ele = document.createElement("span");
    ele.style.float = "left";
    ele.style.whiteSpace = "nowrap";
    ele.style.visibility = "hidden";
    ele.style.margin = "0";
    ele.style.padding = "0";
    ele.innerHTML = text2;
    document.body.append(ele);
    var w2 = Math.max(ele.scrollWidth, ele.offsetWidth, ele.clientWidth);
    var h2 = Math.max(ele.scrollHeight, ele.offsetHeight, ele.clientHeight);
    textHeightCache[font] = [w2, h2];
    ele.remove();
    return [w2, h2];
  }
  function defaultFont(defaultFontSize) {
    return "normal normal normal ".concat(defaultFontSize, 'pt "Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC",  "WenQuanYi Micro Hei", sans-serif');
  }
  function getFontSet(format, defaultFontSize, ctx) {
    if (_$1.isPlainObject(format)) {
      var fontAttr = [];
      if (format.it === "0" || format.it === 0 || _$1.isNil(format.it)) {
        fontAttr.push("normal");
      } else {
        fontAttr.push("italic");
      }
      fontAttr.push("normal");
      if (format.bl === "0" || format.bl === 0 || _$1.isNil(format.bl)) {
        fontAttr.push("normal");
      } else {
        fontAttr.push("bold");
      }
      if (!format.fs) {
        fontAttr.push("".concat(defaultFontSize, "pt"));
      } else {
        fontAttr.push("".concat(Math.ceil(format.fs), "pt"));
      }
      var fontSet = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
      if (ctx) {
        var _locale = locale(ctx), fontarray = _locale.fontarray;
        if (!format.ff) {
          fontSet = "".concat(fontarray[0], ",").concat(fontSet);
        } else {
          var fontfamily = null;
          if (ctx) {
            if (isdatatypemulti(format.ff).num) {
              fontfamily = fontarray[parseInt(format.ff, 10)];
            } else {
              fontfamily = format.ff;
              fontfamily = fontfamily.replace(/"/g, "").replace(/'/g, "");
              if (fontfamily.indexOf(" ") > -1) {
                fontfamily = '"'.concat(fontfamily, '"');
              }
            }
          }
          fontSet = "".concat(fontfamily, ",").concat(fontSet);
        }
      }
      return "".concat(fontAttr.join(" "), " ").concat(fontSet);
    }
    return defaultFont(defaultFontSize);
  }
  function getMeasureText(value, renderCtx, sheetCtx, fontset) {
    var mtc = measureTextCache["".concat(value, "_").concat(renderCtx.font)];
    if (fontset) {
      mtc = measureTextCache["".concat(value, "_").concat(fontset)];
    }
    if (mtc != null) {
      return mtc;
    }
    if (fontset) {
      renderCtx.font = fontset;
    }
    var measureText = renderCtx.measureText(value);
    var cache = {};
    cache.width = measureText.width;
    if (fontset) {
      renderCtx.font = fontset;
    }
    cache.actualBoundingBoxDescent = measureText.actualBoundingBoxDescent;
    cache.actualBoundingBoxAscent = measureText.actualBoundingBoxAscent;
    if (cache.actualBoundingBoxDescent == null || cache.actualBoundingBoxAscent == null || Number.isNaN(cache.actualBoundingBoxDescent) || Number.isNaN(cache.actualBoundingBoxAscent)) {
      var commonWord = "M";
      if (hasChinaword(value)) {
        commonWord = "田";
      }
      var oneLineTextHeight = getTextSize(commonWord, renderCtx.font)[1] * 0.8;
      if (renderCtx.textBaseline === "top") {
        cache.actualBoundingBoxDescent = oneLineTextHeight;
        cache.actualBoundingBoxAscent = 0;
      } else if (renderCtx.textBaseline === "middle") {
        cache.actualBoundingBoxDescent = oneLineTextHeight / 2;
        cache.actualBoundingBoxAscent = oneLineTextHeight / 2;
      } else {
        cache.actualBoundingBoxDescent = 0;
        cache.actualBoundingBoxAscent = oneLineTextHeight;
      }
    }
    if (renderCtx.textBaseline === "alphabetic") {
      var descText = "gjpqy";
      var matchText = "abcdABCD";
      var descTextMeasure = measureTextCache["".concat(descText, "_").concat(renderCtx.font)];
      if (fontset) {
        descTextMeasure = measureTextCache["".concat(descText, "_").concat(fontset)];
      }
      var matchTextMeasure = measureTextCache["".concat(matchText, "_").concat(renderCtx.font)];
      if (fontset) {
        matchTextMeasure = measureTextCache["".concat(matchText, "_").concat(fontset)];
      }
      if (descTextMeasure == null) {
        descTextMeasure = renderCtx.measureText(descText);
      }
      if (matchTextMeasure == null) {
        matchTextMeasure = renderCtx.measureText(matchText);
      }
      if (cache.actualBoundingBoxDescent <= matchTextMeasure.actualBoundingBoxDescent) {
        cache.actualBoundingBoxDescent = descTextMeasure.actualBoundingBoxDescent;
        if (!cache.actualBoundingBoxDescent) {
          cache.actualBoundingBoxDescent = 0;
        }
      }
    }
    cache.width *= sheetCtx.zoomRatio;
    cache.actualBoundingBoxDescent *= sheetCtx.zoomRatio;
    cache.actualBoundingBoxAscent *= sheetCtx.zoomRatio;
    measureTextCache["".concat(value, "_").concat(sheetCtx.zoomRatio, "_").concat(renderCtx.font)] = cache;
    return cache;
  }
  function isSupportBoundingBox(ctx) {
    var measureText = ctx.measureText("田");
    if (_$1.isNil(measureText.actualBoundingBoxAscent)) {
      return false;
    }
    return true;
  }
  function drawLineInfo(wordGroup, cancelLine, underLine, option) {
    var left = option.left;
    var top = option.top;
    var width = option.width;
    var asc = option.asc;
    var desc = option.desc;
    var fs = option.fs;
    if (wordGroup.wrap === true) {
      return;
    }
    if (wordGroup.inline === true && !_$1.isNil(wordGroup.style)) {
      cancelLine = wordGroup.style.cl;
      underLine = wordGroup.style.un;
    }
    if (Number(cancelLine) !== 0) {
      wordGroup.cancelLine = {};
      wordGroup.cancelLine.startX = left;
      wordGroup.cancelLine.startY = top - asc / 2 + 1;
      wordGroup.cancelLine.endX = left + width;
      wordGroup.cancelLine.endY = top - asc / 2 + 1;
      wordGroup.cancelLine.fs = fs;
    }
    var nUnderline = Number(underLine);
    if (nUnderline !== 0) {
      wordGroup.underLine = [];
      if (nUnderline === 1 || nUnderline === 2) {
        var item = {};
        item.startX = left;
        item.startY = top + 3;
        item.endX = left + width;
        item.endY = top + 3;
        item.fs = fs;
        wordGroup.underLine.push(item);
      }
      if (nUnderline === 2) {
        var _item = {};
        _item.startX = left;
        _item.startY = top + desc;
        _item.endX = left + width;
        _item.endY = top + desc;
        _item.fs = fs;
        wordGroup.underLine.push(_item);
      }
      if (nUnderline === 3 || nUnderline === 4) {
        var _item2 = {};
        _item2.startX = left;
        _item2.startY = top + desc;
        _item2.endX = left + width;
        _item2.endY = top + desc;
        _item2.fs = fs;
        wordGroup.underLine.push(_item2);
      }
      if (nUnderline === 4) {
        var _item3 = {};
        _item3.startX = left;
        _item3.startY = top + desc + 2;
        _item3.endX = left + width;
        _item3.endY = top + desc + 2;
        _item3.fs = fs;
        wordGroup.underLine.push(_item3);
      }
    }
  }
  function getCellTextInfo(cell, renderCtx, sheetCtx, option, ctx) {
    var cellWidth = option.cellWidth;
    var cellHeight = option.cellHeight;
    var isMode = "";
    var isModeSplit = "";
    if (cellWidth == null) {
      isMode = "onlyWidth";
      isModeSplit = "_";
    }
    var textInfo = measureTextCellInfoCache["".concat(option.r, "_").concat(option.c).concat(isModeSplit).concat(isMode)];
    if (textInfo) {
      return textInfo;
    }
    var space_width = option.space_width;
    var space_height = option.space_height;
    if (space_width === void 0) {
      space_width = 2;
    }
    if (space_height === void 0) {
      space_height = 2;
    }
    var horizonAlign = normalizedCellAttr(cell, "ht");
    var verticalAlign = normalizedCellAttr(cell, "vt");
    var tb2 = normalizedCellAttr(cell, "tb");
    var tr = normalizedCellAttr(cell, "tr");
    var rt = normalizedCellAttr(cell, "rt");
    var isRotateUp = 1;
    if (_$1.isNil(rt)) {
      if (tr === "0") {
        rt = 0;
      } else if (tr === "1") {
        rt = 45;
      } else if (tr === "4") {
        rt = 90;
      } else if (tr === "2") {
        rt = 135;
      } else if (tr === "5") {
        rt = 180;
      }
      if (_$1.isNil(rt)) {
        rt = 0;
      }
    }
    if (rt > 180 || rt < 0) {
      rt = 0;
    }
    rt = parseInt(rt, 10);
    if (rt > 90) {
      rt = 90 - rt;
      isRotateUp = 0;
    }
    renderCtx.textAlign = "start";
    var textContent = {};
    textContent.values = [];
    var fontset;
    var cancelLine = "0";
    var underLine = "0";
    var fontSize = 11;
    var isInline = false;
    var value;
    var inlineStringArr = [];
    if (isInlineStringCell(cell)) {
      var sharedStrings = cell.ct.s;
      var similarIndex = 0;
      for (var i2 = 0; i2 < sharedStrings.length; i2 += 1) {
        var shareCell = sharedStrings[i2];
        var scfontset = getFontSet(shareCell, sheetCtx.defaultFontSize);
        var fc2 = shareCell.fc;
        var cl2 = shareCell.cl;
        var un2 = shareCell.un;
        var v2 = shareCell.v;
        var fs = shareCell.fs;
        v2 = v2.replace(/\r\n/g, "_x000D_").replace(/&#13;&#10;/g, "_x000D_").replace(/\r/g, "_x000D_").replace(/\n/g, "_x000D_");
        var splitArr = v2.split("_x000D_");
        for (var x2 = 0; x2 < splitArr.length; x2 += 1) {
          var newValue = splitArr[x2];
          if (newValue === "" && x2 !== splitArr.length - 1) {
            inlineStringArr.push({
              fontset: scfontset,
              fc: !fc2 ? "#000" : fc2,
              cl: !cl2 ? 0 : cl2,
              un: !un2 ? 0 : un2,
              wrap: true,
              fs: !fs ? 11 : fs
            });
            similarIndex += 1;
          } else {
            var newValueArray = newValue.split("");
            for (var n2 = 0; n2 < newValueArray.length; n2 += 1) {
              var nv = newValueArray[n2];
              inlineStringArr.push({
                fontset: scfontset,
                fc: !fc2 ? "#000" : fc2,
                cl: !cl2 ? 0 : cl2,
                un: !un2 ? 0 : un2,
                v: nv,
                si: similarIndex,
                fs: !fs ? 11 : fs
              });
            }
            if (x2 !== splitArr.length - 1) {
              inlineStringArr.push({
                fontset: scfontset,
                fc: !fc2 ? "#000" : fc2,
                cl: !cl2 ? 0 : cl2,
                un: !un2 ? 0 : un2,
                wrap: true,
                fs: !fs ? 11 : fs
              });
              similarIndex += 1;
            }
          }
        }
        similarIndex += 1;
      }
      isInline = true;
    } else {
      fontset = getFontSet(cell, sheetCtx.defaultFontSize, ctx);
      renderCtx.font = fontset;
      cancelLine = normalizedCellAttr(cell, "cl");
      underLine = normalizedCellAttr(cell, "un");
      fontSize = normalizedCellAttr(cell, "fs");
      if (cell instanceof Object) {
        value = cell.m;
        if (_$1.isNil(value)) {
          value = cell.v;
        }
      } else {
        value = cell;
      }
      if (_$1.isEmpty(value)) {
        return null;
      }
    }
    if (tr === "3") {
      renderCtx.textBaseline = "top";
      var textW_all = 0;
      var textH_all = 0;
      var colIndex = 0;
      var textH_all_cache = 0;
      var textH_all_Column = {};
      var textH_all_ColumnHeight = [];
      if (isInline) {
        var preShareCell = null;
        for (var _i = 0; _i < inlineStringArr.length; _i += 1) {
          var _shareCell = inlineStringArr[_i];
          var value1 = _shareCell.v;
          var showValue = _shareCell.v;
          if (_shareCell.wrap === true) {
            value1 = "M";
            showValue = "";
            if (!_$1.isNil(preShareCell) && preShareCell.wrap !== true && _i < inlineStringArr.length - 1) {
              textH_all_ColumnHeight.push(textH_all_cache);
              textH_all_cache = 0;
              colIndex += 1;
              preShareCell = _shareCell;
              continue;
            }
          }
          var measureText = getMeasureText(value1, renderCtx, sheetCtx, _shareCell.fontset);
          var textW = measureText.width + space_width;
          var textH = measureText.actualBoundingBoxAscent + measureText.actualBoundingBoxDescent + space_height;
          textH_all_cache += textH;
          if (tb2 === "2" && !_shareCell.wrap) {
            if (textH_all_cache > cellHeight && !_$1.isNil(textH_all_Column[colIndex])) {
              textH_all_ColumnHeight.push(textH_all_cache - textH);
              textH_all_cache = textH;
              colIndex += 1;
            }
          }
          if (_i === inlineStringArr.length - 1) {
            textH_all_ColumnHeight.push(textH_all_cache);
          }
          if (_$1.isNil(textH_all_Column[colIndex])) {
            textH_all_Column[colIndex] = [];
          }
          var item = {
            content: showValue,
            style: _shareCell,
            width: textW,
            height: textH,
            left: 0,
            top: 0,
            colIndex,
            asc: measureText.actualBoundingBoxAscent,
            desc: measureText.actualBoundingBoxDescent,
            inline: true,
            wrap: false
          };
          if (_shareCell.wrap === true) {
            item.wrap = true;
          }
          textH_all_Column[colIndex].push(item);
          preShareCell = _shareCell;
        }
      } else {
        var _measureText = getMeasureText(value, renderCtx, sheetCtx);
        var textHeight = _measureText.actualBoundingBoxDescent + _measureText.actualBoundingBoxAscent;
        value = value.toString();
        var vArr = [];
        if (value.length > 1) {
          vArr = value.split("");
        } else {
          vArr.push(value);
        }
        var oneWordWidth = getMeasureText(vArr[0], renderCtx, sheetCtx).width;
        for (var _i2 = 0; _i2 < vArr.length; _i2 += 1) {
          var _textW = oneWordWidth + space_width;
          var _textH = textHeight + space_height;
          textH_all_cache += _textH;
          if (tb2 === "2") {
            if (textH_all_cache > cellHeight && !_$1.isNil(textH_all_Column[colIndex])) {
              textH_all_ColumnHeight.push(textH_all_cache - _textH);
              textH_all_cache = _textH;
              colIndex += 1;
            }
          }
          if (_i2 === vArr.length - 1) {
            textH_all_ColumnHeight.push(textH_all_cache);
          }
          if (_$1.isNil(textH_all_Column[colIndex])) {
            textH_all_Column[colIndex] = [];
          }
          textH_all_Column[colIndex].push({
            content: vArr[_i2],
            style: fontset,
            width: _textW,
            height: _textH,
            left: 0,
            top: 0,
            colIndex,
            asc: _measureText.actualBoundingBoxAscent,
            desc: _measureText.actualBoundingBoxDescent
          });
        }
      }
      var textH_all_ColumWidth = [];
      for (var _i3 = 0; _i3 < textH_all_ColumnHeight.length; _i3 += 1) {
        var columnHeight = textH_all_ColumnHeight[_i3];
        var col = textH_all_Column[_i3];
        var colMaxW = 0;
        for (var c2 = 0; c2 < col.length; c2 += 1) {
          var word = col[c2];
          colMaxW = Math.max(colMaxW, word.width);
        }
        textH_all_ColumWidth.push(colMaxW);
        textW_all += colMaxW;
        textH_all = Math.max(textH_all, columnHeight);
      }
      textContent.type = "verticalWrap";
      textContent.textWidthAll = textW_all;
      textContent.textHeightAll = textH_all;
      if (isMode === "onlyWidth") {
        return textContent;
      }
      var cumColumnWidth = 0;
      for (var _i4 = 0; _i4 < textH_all_ColumnHeight.length; _i4 += 1) {
        var _columnHeight = textH_all_ColumnHeight[_i4];
        var columnWidth = textH_all_ColumWidth[_i4];
        var _col = textH_all_Column[_i4];
        var cumWordHeight = 0;
        for (var _c = 0; _c < _col.length; _c += 1) {
          var _word = _col[_c];
          var left = space_width + cumColumnWidth;
          if (horizonAlign === "0") {
            left = cellWidth / 2 + cumColumnWidth - textW_all / 2 + space_width * textH_all_ColumnHeight.length;
          } else if (horizonAlign === "2") {
            left = cellWidth + cumColumnWidth - textW_all + space_width;
          }
          var top = cellHeight - space_height + cumWordHeight - _columnHeight;
          if (verticalAlign === "0") {
            top = cellHeight / 2 + cumWordHeight - _columnHeight / 2;
          } else if (verticalAlign === "1") {
            top = space_height + cumWordHeight;
          }
          cumWordHeight += _word.height;
          _word.left = left;
          _word.top = top;
          drawLineInfo(_word, cancelLine, underLine, {
            width: columnWidth,
            height: _word.height,
            left,
            top: top + _word.height - space_height,
            asc: _word.height,
            desc: 0,
            fs: fontSize
          });
          textContent.values.push(_word);
        }
        cumColumnWidth += columnWidth;
      }
    } else {
      var supportBoundBox = isSupportBoundingBox(renderCtx);
      if (supportBoundBox) {
        renderCtx.textBaseline = "alphabetic";
      } else {
        renderCtx.textBaseline = "bottom";
      }
      if (tb2 === "2" || isInline) {
        var _textW_all = 0;
        var _textH_all = 0;
        var textW_all_inner = 0;
        var splitIndex = 0;
        var text_all_split = {};
        textContent.rotate = rt;
        rt = Math.abs(rt);
        var anchor = 0;
        var preStr;
        var preTextHeight;
        var preTextWidth;
        var preMeasureText;
        var _i5 = 1;
        var spaceOrTwoByte = null;
        var spaceOrTwoByteIndex = null;
        if (isInline) {
          while (_i5 <= inlineStringArr.length) {
            var shareCells = inlineStringArr.slice(anchor, _i5);
            if (shareCells[shareCells.length - 1].wrap === true) {
              anchor = _i5;
              if (shareCells.length > 1) {
                for (var s2 = 0; s2 < shareCells.length - 1; s2 += 1) {
                  var sc2 = shareCells[s2];
                  var _item4 = {
                    content: sc2.v,
                    style: sc2,
                    width: sc2.measureText.width,
                    height: sc2.measureText.actualBoundingBoxAscent + sc2.measureText.actualBoundingBoxDescent,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: sc2.measureText.actualBoundingBoxAscent,
                    desc: sc2.measureText.actualBoundingBoxDescent,
                    inline: true,
                    fs: sc2.fs
                  };
                  text_all_split[splitIndex].push(_item4);
                }
              }
              if (shareCells.length === 1) {
                var _sc = shareCells[0];
                var _measureText2 = getMeasureText("M", renderCtx, sheetCtx, _sc.fontset);
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                text_all_split[splitIndex].push({
                  content: "",
                  style: _sc,
                  width: _measureText2.width,
                  height: _measureText2.actualBoundingBoxAscent + _measureText2.actualBoundingBoxDescent,
                  left: 0,
                  top: 0,
                  splitIndex,
                  asc: _measureText2.actualBoundingBoxAscent,
                  desc: _measureText2.actualBoundingBoxDescent,
                  inline: true,
                  wrap: true,
                  fs: _sc.fs
                });
              }
              splitIndex += 1;
              _i5 += 1;
              continue;
            }
            var textWidth = 0;
            var _textHeight = 0;
            for (var _s = 0; _s < shareCells.length; _s += 1) {
              var _sc2 = shareCells[_s];
              if (_$1.isNil(_sc2.measureText)) {
                _sc2.measureText = getMeasureText(_sc2.v, renderCtx, sheetCtx, _sc2.fontset);
              }
              textWidth += _sc2.measureText.width;
              _textHeight = Math.max(_sc2.measureText.actualBoundingBoxAscent + _sc2.measureText.actualBoundingBoxDescent);
            }
            var width = textWidth * Math.cos(rt * Math.PI / 180) + _textHeight * Math.sin(rt * Math.PI / 180);
            var height = textWidth * Math.sin(rt * Math.PI / 180) + _textHeight * Math.cos(rt * Math.PI / 180);
            var lastWord = shareCells[shareCells.length - 1];
            if (lastWord.v === " " || checkWordByteLength(lastWord.v) === 2) {
              spaceOrTwoByteIndex = _i5;
            }
            if (rt !== 0) {
              if (height + space_height > cellHeight && !_$1.isNil(text_all_split[splitIndex]) && tb2 === "2") {
                if (!_$1.isNil(spaceOrTwoByteIndex) && spaceOrTwoByteIndex < _i5) {
                  for (var _s2 = 0; _s2 < spaceOrTwoByteIndex - anchor; _s2 += 1) {
                    var _sc3 = shareCells[_s2];
                    text_all_split[splitIndex].push({
                      content: _sc3.v,
                      style: _sc3,
                      width: _sc3.measureText.width,
                      height: _sc3.measureText.actualBoundingBoxAscent + _sc3.measureText.actualBoundingBoxDescent,
                      left: 0,
                      top: 0,
                      splitIndex,
                      asc: _sc3.measureText.actualBoundingBoxAscent,
                      desc: _sc3.measureText.actualBoundingBoxDescent,
                      inline: true,
                      fs: _sc3.fs
                    });
                  }
                  anchor = spaceOrTwoByteIndex;
                  _i5 = spaceOrTwoByteIndex + 1;
                  splitIndex += 1;
                  spaceOrTwoByteIndex = null;
                } else {
                  anchor = _i5 - 1;
                  for (var _s3 = 0; _s3 < shareCells.length - 1; _s3 += 1) {
                    var _sc4 = shareCells[_s3];
                    text_all_split[splitIndex].push({
                      content: _sc4.v,
                      style: _sc4,
                      width: _sc4.measureText.width,
                      height: _sc4.measureText.actualBoundingBoxAscent + _sc4.measureText.actualBoundingBoxDescent,
                      left: 0,
                      top: 0,
                      splitIndex,
                      asc: _sc4.measureText.actualBoundingBoxAscent,
                      desc: _sc4.measureText.actualBoundingBoxDescent,
                      inline: true,
                      fs: _sc4.fs
                    });
                  }
                  splitIndex += 1;
                }
              } else if (_i5 === inlineStringArr.length) {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                for (var _s4 = 0; _s4 < shareCells.length; _s4 += 1) {
                  var _sc5 = shareCells[_s4];
                  text_all_split[splitIndex].push({
                    content: _sc5.v,
                    style: _sc5,
                    width: _sc5.measureText.width,
                    height: _sc5.measureText.actualBoundingBoxAscent + _sc5.measureText.actualBoundingBoxDescent,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: _sc5.measureText.actualBoundingBoxAscent,
                    desc: _sc5.measureText.actualBoundingBoxDescent,
                    inline: true,
                    fs: _sc5.fs
                  });
                }
                break;
              } else {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                _i5 += 1;
              }
            } else {
              if (width + space_width > cellWidth && !_$1.isNil(text_all_split[splitIndex]) && tb2 === "2") {
                if (!_$1.isNil(spaceOrTwoByteIndex) && spaceOrTwoByteIndex < _i5) {
                  for (var _s5 = 0; _s5 < spaceOrTwoByteIndex - anchor; _s5 += 1) {
                    var _sc6 = shareCells[_s5];
                    text_all_split[splitIndex].push({
                      content: _sc6.v,
                      style: _sc6,
                      width: _sc6.measureText.width,
                      height: _sc6.measureText.actualBoundingBoxAscent + _sc6.measureText.actualBoundingBoxDescent,
                      left: 0,
                      top: 0,
                      splitIndex,
                      asc: _sc6.measureText.actualBoundingBoxAscent,
                      desc: _sc6.measureText.actualBoundingBoxDescent,
                      inline: true,
                      fs: _sc6.fs
                    });
                  }
                  anchor = spaceOrTwoByteIndex;
                  _i5 = spaceOrTwoByteIndex + 1;
                  splitIndex += 1;
                  spaceOrTwoByteIndex = null;
                } else {
                  anchor = _i5 - 1;
                  for (var _s6 = 0; _s6 < shareCells.length - 1; _s6 += 1) {
                    var _sc7 = shareCells[_s6];
                    text_all_split[splitIndex].push({
                      content: _sc7.v,
                      style: _sc7,
                      width: _sc7.measureText.width,
                      height: _sc7.measureText.actualBoundingBoxAscent + _sc7.measureText.actualBoundingBoxDescent,
                      left: 0,
                      top: 0,
                      splitIndex,
                      asc: _sc7.measureText.actualBoundingBoxAscent,
                      desc: _sc7.measureText.actualBoundingBoxDescent,
                      inline: true,
                      fs: _sc7.fs
                    });
                  }
                  splitIndex += 1;
                }
              } else if (_i5 === inlineStringArr.length) {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                for (var _s7 = 0; _s7 < shareCells.length; _s7 += 1) {
                  var _sc8 = shareCells[_s7];
                  text_all_split[splitIndex].push({
                    content: _sc8.v,
                    style: _sc8,
                    width: _sc8.measureText.width,
                    height: _sc8.measureText.actualBoundingBoxAscent + _sc8.measureText.actualBoundingBoxDescent,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: _sc8.measureText.actualBoundingBoxAscent,
                    desc: _sc8.measureText.actualBoundingBoxDescent,
                    inline: true,
                    fs: _sc8.fs
                  });
                }
                break;
              } else {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                _i5 += 1;
              }
            }
          }
        } else {
          value = value.toString();
          while (_i5 <= value.length) {
            var str = value.substring(anchor, _i5);
            var _measureText3 = getMeasureText(str, renderCtx, sheetCtx);
            var _textWidth = _measureText3.width;
            var _textHeight2 = _measureText3.actualBoundingBoxAscent + _measureText3.actualBoundingBoxDescent;
            var _width = _textWidth * Math.cos(rt * Math.PI / 180) + _textHeight2 * Math.sin(rt * Math.PI / 180);
            var _height = _textWidth * Math.sin(rt * Math.PI / 180) + _textHeight2 * Math.cos(rt * Math.PI / 180);
            var _lastWord = str.substr(str.length - 1, 1);
            if (_lastWord === " " || checkWordByteLength(_lastWord) === 2) {
              spaceOrTwoByte = {
                index: _i5,
                str,
                width: _width,
                height: _height,
                asc: _measureText3.actualBoundingBoxAscent,
                desc: _measureText3.actualBoundingBoxDescent
              };
            }
            if (rt !== 0) {
              if (_height + space_height > cellHeight && !_$1.isNil(text_all_split[splitIndex])) {
                if (!_$1.isNil(spaceOrTwoByte) && spaceOrTwoByte.index < _i5) {
                  anchor = spaceOrTwoByte.index;
                  _i5 = spaceOrTwoByte.index + 1;
                  text_all_split[splitIndex].push({
                    content: spaceOrTwoByte.str,
                    style: fontset,
                    width: spaceOrTwoByte.width,
                    height: spaceOrTwoByte.height,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: spaceOrTwoByte.asc,
                    desc: spaceOrTwoByte.desc,
                    fs: fontSize
                  });
                  splitIndex += 1;
                  spaceOrTwoByte = null;
                } else {
                  anchor = _i5 - 1;
                  text_all_split[splitIndex].push({
                    content: preStr,
                    style: fontset,
                    left: 0,
                    top: 0,
                    splitIndex,
                    height: preTextHeight,
                    width: preTextWidth,
                    asc: _measureText3.actualBoundingBoxAscent,
                    desc: _measureText3.actualBoundingBoxDescent,
                    fs: fontSize
                  });
                  splitIndex += 1;
                }
              } else if (_i5 === value.length) {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                text_all_split[splitIndex].push({
                  content: str,
                  style: fontset,
                  left: 0,
                  top: 0,
                  splitIndex,
                  height: _textHeight2,
                  width: _textWidth,
                  asc: _measureText3.actualBoundingBoxAscent,
                  desc: _measureText3.actualBoundingBoxDescent,
                  fs: fontSize
                });
                break;
              } else {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                _i5 += 1;
              }
            } else {
              if (_width + space_width > cellWidth && !_$1.isNil(text_all_split[splitIndex])) {
                if (!_$1.isNil(spaceOrTwoByte) && spaceOrTwoByte.index < _i5) {
                  anchor = spaceOrTwoByte.index;
                  _i5 = spaceOrTwoByte.index + 1;
                  text_all_split[splitIndex].push({
                    content: spaceOrTwoByte.str,
                    style: fontset,
                    width: spaceOrTwoByte.width,
                    height: spaceOrTwoByte.height,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: spaceOrTwoByte.asc,
                    desc: spaceOrTwoByte.desc,
                    fs: fontSize
                  });
                  splitIndex += 1;
                  spaceOrTwoByte = null;
                } else {
                  spaceOrTwoByte = null;
                  anchor = _i5 - 1;
                  text_all_split[splitIndex].push({
                    content: preStr,
                    style: fontset,
                    width: preTextWidth,
                    height: preTextHeight,
                    left: 0,
                    top: 0,
                    splitIndex,
                    asc: preMeasureText.actualBoundingBoxAscent,
                    desc: preMeasureText.actualBoundingBoxDescent,
                    fs: fontSize
                  });
                  splitIndex += 1;
                }
              } else if (_i5 === value.length) {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                text_all_split[splitIndex].push({
                  content: str,
                  style: fontset,
                  width: _textWidth,
                  height: _textHeight2,
                  left: 0,
                  top: 0,
                  splitIndex,
                  asc: _measureText3.actualBoundingBoxAscent,
                  desc: _measureText3.actualBoundingBoxDescent,
                  fs: fontSize
                });
                break;
              } else {
                if (_$1.isNil(text_all_split[splitIndex])) {
                  text_all_split[splitIndex] = [];
                }
                _i5 += 1;
              }
            }
            preStr = str;
            preTextHeight = _textHeight2;
            preTextWidth = _textWidth;
            preMeasureText = _measureText3;
          }
        }
        var split_all_size = [];
        var splitLen = Object.keys(text_all_split).length;
        if (splitLen === 0) return textContent;
        for (var j2 = 0; j2 < splitLen; j2 += 1) {
          var splitLists = text_all_split[j2];
          if (_$1.isNil(splitLists)) {
            continue;
          }
          var sWidth = 0;
          var sHeight = 0;
          var maxDesc = 0;
          var maxAsc = 0;
          var lineHeight = 0;
          var maxWordCount = 0;
          for (var _s8 = 0; _s8 < splitLists.length; _s8 += 1) {
            var sp = splitLists[_s8];
            if (rt !== 0) {
              sWidth += sp.width;
              sHeight = Math.max(sHeight, sp.height - (supportBoundBox ? sp.desc : 0));
            } else {
              sWidth += sp.width;
              sHeight = Math.max(sHeight, sp.height - (supportBoundBox ? sp.desc : 0));
            }
            maxDesc = Math.max(maxDesc, supportBoundBox ? sp.desc : 0);
            maxAsc = Math.max(maxAsc, sp.asc);
            maxWordCount += 1;
          }
          lineHeight = sHeight / 2;
          if (rt !== 0) {
            sHeight += lineHeight;
            textW_all_inner = Math.max(textW_all_inner, sWidth);
            _textH_all += sHeight;
          } else {
            sHeight += lineHeight;
            _textW_all = Math.max(_textW_all, sWidth);
            _textH_all += sHeight;
          }
          split_all_size.push({
            width: sWidth,
            height: sHeight,
            desc: maxDesc,
            asc: maxAsc,
            lineHeight,
            wordCount: maxWordCount
          });
        }
        var _cumWordHeight = 0;
        var _cumColumnWidth = 0;
        var rtPI = rt * Math.PI / 180;
        var lastLine = split_all_size[splitLen - 1];
        var lastLineSpaceHeight = lastLine.lineHeight;
        _textH_all = _textH_all - lastLineSpaceHeight + lastLine.desc;
        var rw = _textH_all / Math.sin(rtPI) + textW_all_inner * Math.cos(rtPI);
        var rh2 = textW_all_inner * Math.sin(rtPI);
        var fixOneLineLeft = 0;
        if (rt !== 0) {
          if (splitLen === 1) {
            _textW_all = textW_all_inner + 2 * (_textH_all / Math.tan(rtPI));
            fixOneLineLeft = _textH_all / Math.tan(rtPI);
          } else {
            _textW_all = textW_all_inner + _textH_all / Math.tan(rtPI);
          }
          textContent.textWidthAll = rw;
          textContent.textHeightAll = rh2;
        } else {
          textContent.textWidthAll = _textW_all;
          textContent.textHeightAll = _textH_all;
        }
        if (isMode === "onlyWidth") {
          return textContent;
        }
        if (rt !== 0 && Number(isRotateUp) === 1) {
          renderCtx.textAlign = "end";
          for (var _j = 0; _j < splitLen; _j += 1) {
            var _splitLists = text_all_split[_j];
            if (_$1.isNil(_splitLists)) {
              continue;
            }
            var size2 = split_all_size[_j];
            _cumColumnWidth = 0;
            for (var _c2 = _splitLists.length - 1; _c2 >= 0; _c2 -= 1) {
              var wordGroup = _splitLists[_c2];
              var _left = void 0;
              var _top = void 0;
              if (rt !== 0) {
                var y2 = _cumWordHeight + size2.asc;
                var _x = _cumWordHeight / Math.tan(rtPI) - _cumColumnWidth + textW_all_inner;
                if (horizonAlign === "0") {
                  if (verticalAlign === "0") {
                    _left = _x + cellWidth / 2 - _textW_all / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top = y2 + cellHeight / 2 - _textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left = _x + cellWidth / 2 - _textW_all / 2;
                    _top = y2 - (_textH_all / 2 - rh2 / 2);
                  } else if (verticalAlign === "2") {
                    _left = _x + cellWidth / 2 - _textW_all / 2 + lastLineSpaceHeight * Math.cos(rtPI);
                    _top = y2 + cellHeight - rh2 / 2 - _textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                } else if (horizonAlign === "1") {
                  if (verticalAlign === "0") {
                    _left = _x - rh2 * Math.sin(rtPI) / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top = y2 + cellHeight / 2 + rh2 * Math.cos(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left = _x - rh2 * Math.sin(rtPI);
                    _top = y2 + rh2 * Math.cos(rtPI);
                  } else if (verticalAlign === "2") {
                    _left = _x + lastLineSpaceHeight * Math.cos(rtPI);
                    _top = y2 + cellHeight - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                } else if (horizonAlign === "2") {
                  if (verticalAlign === "0") {
                    _left = _x + cellWidth - rw / 2 - (textW_all_inner / 2 + _textH_all / 2 / Math.tan(rtPI)) + lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top = y2 + cellHeight / 2 - _textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left = _x + cellWidth - _textW_all + fixOneLineLeft;
                    _top = y2 - _textH_all;
                  } else if (verticalAlign === "2") {
                    _left = _x + cellWidth - rw * Math.cos(rtPI) + lastLineSpaceHeight * Math.cos(rtPI);
                    _top = y2 + cellHeight - rw * Math.sin(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                }
              }
              wordGroup.left = _left;
              wordGroup.top = _top;
              drawLineInfo(wordGroup, cancelLine, underLine, {
                width: wordGroup.width,
                height: wordGroup.height,
                left: (_left || 0) - wordGroup.width,
                top: _top,
                asc: size2.asc,
                desc: size2.desc,
                fs: wordGroup.fs
              });
              textContent.values.push(wordGroup);
              _cumColumnWidth += wordGroup.width;
            }
            _cumWordHeight += size2.height;
          }
        } else {
          for (var _j2 = 0; _j2 < splitLen; _j2 += 1) {
            var _splitLists2 = text_all_split[_j2];
            if (_$1.isNil(_splitLists2)) {
              continue;
            }
            var _size = split_all_size[_j2];
            _cumColumnWidth = 0;
            for (var _c3 = 0; _c3 < _splitLists2.length; _c3 += 1) {
              var _wordGroup = _splitLists2[_c3];
              var _left2 = void 0;
              var _top2 = void 0;
              if (rt !== 0) {
                var _y = _cumWordHeight + _size.asc;
                var _x2 = (_textH_all - _cumWordHeight) / Math.tan(rtPI) + _cumColumnWidth;
                if (horizonAlign === "0") {
                  if (verticalAlign === "0") {
                    _left2 = _x2 + cellWidth / 2 - _textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top2 = _y + cellHeight / 2 - _textH_all / 2 + lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left2 = _x2 + cellWidth / 2 - _textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top2 = _y - (_textH_all / 2 - rh2 / 2) + lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "2") {
                    _left2 = _x2 + cellWidth / 2 - _textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);
                    _top2 = _y + cellHeight - rh2 / 2 - _textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                } else if (horizonAlign === "1") {
                  if (verticalAlign === "0") {
                    _left2 = _x2 - rh2 * Math.sin(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top2 = _y - _textH_all + cellHeight / 2 - rh2 * Math.cos(rtPI) / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left2 = _x2;
                    _top2 = _y - _textH_all;
                  } else if (verticalAlign === "2") {
                    _left2 = _x2 - rh2 * Math.sin(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);
                    _top2 = _y - _textH_all + cellHeight - rh2 * Math.cos(rtPI) - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                } else if (horizonAlign === "2") {
                  if (verticalAlign === "0") {
                    _left2 = _x2 + cellWidth - rw / 2 - _textW_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                    _top2 = _y + cellHeight / 2 - _textH_all / 2 - lastLineSpaceHeight * Math.cos(rtPI) / 2;
                  } else if (verticalAlign === "1") {
                    _left2 = _x2 + cellWidth - rw * Math.cos(rtPI);
                    _top2 = _y + rh2 * Math.cos(rtPI);
                  } else if (verticalAlign === "2") {
                    _left2 = _x2 + cellWidth - _textW_all - lastLineSpaceHeight * Math.cos(rtPI) + fixOneLineLeft;
                    _top2 = _y + cellHeight - lastLineSpaceHeight * Math.cos(rtPI);
                  }
                }
                drawLineInfo(_wordGroup, cancelLine, underLine, {
                  width: _wordGroup.width,
                  height: _wordGroup.height,
                  left: _left2,
                  top: _top2,
                  asc: _size.asc,
                  desc: _size.desc,
                  fs: _wordGroup.fs
                });
              } else {
                _left2 = space_width + _cumColumnWidth;
                if (horizonAlign === "0") {
                  _left2 = cellWidth / 2 + _cumColumnWidth - _size.width / 2;
                } else if (horizonAlign === "2") {
                  _left2 = cellWidth + _cumColumnWidth - _size.width;
                }
                _top2 = cellHeight - space_height + _cumWordHeight + _size.asc - _textH_all;
                if (verticalAlign === "0") {
                  _top2 = cellHeight / 2 + _cumWordHeight - _textH_all / 2 + _size.asc;
                } else if (verticalAlign === "1") {
                  _top2 = space_height + _cumWordHeight + _size.asc;
                }
                drawLineInfo(_wordGroup, cancelLine, underLine, {
                  width: _wordGroup.width,
                  height: _wordGroup.height,
                  left: _left2,
                  top: _top2,
                  asc: _size.asc,
                  desc: _size.desc,
                  fs: _wordGroup.fs
                });
              }
              _wordGroup.left = _left2;
              _wordGroup.top = _top2;
              textContent.values.push(_wordGroup);
              _cumColumnWidth += _wordGroup.width;
            }
            _cumWordHeight += _size.height;
          }
        }
        textContent.type = "plainWrap";
        if (rt !== 0) {
          if (horizonAlign === "0") {
            textContent.textLeftAll = cellWidth / 2;
            if (verticalAlign === "0") {
              textContent.textTopAll = cellHeight / 2;
            } else if (verticalAlign === "1") {
              textContent.textTopAll = rh2 / 2;
            } else if (verticalAlign === "2") {
              textContent.textTopAll = cellHeight - rh2 / 2;
            }
          } else if (horizonAlign === "1") {
            if (verticalAlign === "0") {
              textContent.textLeftAll = 0;
              textContent.textTopAll = cellHeight / 2;
            } else if (verticalAlign === "1") {
              textContent.textLeftAll = 0;
              textContent.textTopAll = 0;
            } else if (verticalAlign === "2") {
              textContent.textLeftAll = 0;
              textContent.textTopAll = cellHeight;
            }
          } else if (horizonAlign === "2") {
            if (verticalAlign === "0") {
              textContent.textLeftAll = cellWidth - rw / 2;
              textContent.textTopAll = cellHeight / 2;
            } else if (verticalAlign === "1") {
              textContent.textLeftAll = cellWidth;
              textContent.textTopAll = 0;
            } else if (verticalAlign === "2") {
              textContent.textLeftAll = cellWidth;
              textContent.textTopAll = cellHeight;
            }
          }
        }
      } else {
        var _measureText4 = getMeasureText(value, renderCtx, sheetCtx);
        var _textWidth2 = _measureText4.width;
        var _textHeight3 = _measureText4.actualBoundingBoxDescent + _measureText4.actualBoundingBoxAscent;
        textContent.rotate = rt;
        rt = Math.abs(rt);
        var _rtPI = rt * Math.PI / 180;
        var textWidthAll = _textWidth2 * Math.cos(_rtPI) + _textHeight3 * Math.sin(_rtPI);
        var textHeightAll = _textWidth2 * Math.sin(_rtPI) + _textHeight3 * Math.cos(_rtPI);
        if (rt !== 0) {
          textContent.textHeightAll = textHeightAll;
        } else {
          textContent.textHeightAll = textHeightAll + _textHeight3 / 2 - _measureText4.actualBoundingBoxDescent - space_height;
        }
        textContent.textWidthAll = textWidthAll;
        if (isMode === "onlyWidth") {
          return textContent;
        }
        var _width2 = textWidthAll;
        var _height2 = textHeightAll;
        var _left3 = space_width + _textHeight3 * Math.sin(_rtPI) * isRotateUp;
        if (horizonAlign === "0") {
          _left3 = cellWidth / 2 - _width2 / 2 + _textHeight3 * Math.sin(_rtPI) * isRotateUp;
        } else if (horizonAlign === "2") {
          _left3 = cellWidth - space_width - _width2 + _textHeight3 * Math.sin(_rtPI) * isRotateUp;
        }
        var _top3 = cellHeight - space_height - _height2 + _measureText4.actualBoundingBoxAscent * Math.cos(_rtPI) + _textWidth2 * Math.sin(_rtPI) * isRotateUp;
        if (verticalAlign === "0") {
          _top3 = cellHeight / 2 - _height2 / 2 + _measureText4.actualBoundingBoxAscent * Math.cos(_rtPI) + _textWidth2 * Math.sin(_rtPI) * isRotateUp;
        } else if (verticalAlign === "1") {
          _top3 = space_height + _measureText4.actualBoundingBoxAscent * Math.cos(_rtPI) + _textWidth2 * Math.sin(_rtPI) * isRotateUp;
        }
        textContent.type = "plain";
        var _wordGroup2 = {
          content: value,
          style: fontset,
          width: _width2,
          height: _height2,
          left: _left3,
          top: _top3
        };
        drawLineInfo(_wordGroup2, cancelLine, underLine, {
          width: _textWidth2,
          left: _left3,
          top: _top3,
          asc: _measureText4.actualBoundingBoxAscent,
          desc: _measureText4.actualBoundingBoxDescent,
          fs: fontSize
        });
        textContent.values.push(_wordGroup2);
        textContent.textLeftAll = _left3;
        textContent.textTopAll = _top3;
        textContent.asc = _measureText4.actualBoundingBoxAscent;
        textContent.desc = _measureText4.actualBoundingBoxDescent;
      }
    }
    return textContent;
  }
  var error = {
    v: "#VALUE!",
    n: "#NAME?",
    na: "#N/A",
    r: "#REF!",
    d: "#DIV/0!",
    nm: "#NUM!",
    nl: "#NULL!",
    sp: "#SPILL!"
  };
  var errorValues = Object.values(error);
  function valueIsError(value) {
    return errorValues.includes(value);
  }
  function isRealNull(val) {
    return _$1.isNil(val) || val.toString().replace(/\s/g, "") === "";
  }
  function isRealNum(val) {
    if (_$1.isNil(val) || val.toString().replace(/\s/g, "") === "") {
      return false;
    }
    if (typeof val === "boolean") {
      return false;
    }
    return !Number.isNaN(Number(val));
  }
  function checkDateTime(str) {
    var reg1 = /^(\d{4})-(\d{1,2})-(\d{1,2})(\s(\d{1,2}):(\d{1,2})(:(\d{1,2}))?)?$/;
    var reg2 = /^(\d{4})\/(\d{1,2})\/(\d{1,2})(\s(\d{1,2}):(\d{1,2})(:(\d{1,2}))?)?$/;
    if (!reg1.test(str) && !reg2.test(str)) {
      return false;
    }
    var year = Number(RegExp.$1);
    var month = Number(RegExp.$2);
    var day = Number(RegExp.$3);
    if (year < 1900) {
      return false;
    }
    if (month > 12) {
      return false;
    }
    if (day > 31) {
      return false;
    }
    if (month === 2) {
      if (new Date(year, 1, 29).getDate() === 29 && day > 29) {
        return false;
      }
      if (new Date(year, 1, 29).getDate() !== 29 && day > 28) {
        return false;
      }
    }
    return true;
  }
  function isdatetime(s2) {
    if (s2 === null || s2.toString().length < 5) {
      return false;
    }
    if (checkDateTime(s2)) {
      return true;
    }
    return false;
  }
  function diff(now, then) {
    return dayjs(now).diff(dayjs(then));
  }
  function isdatatypemulti(s2) {
    var type = {};
    if (isdatetime(s2)) {
      type.date = true;
    }
    if (!Number.isNaN(parseFloat(s2)) && !hasChinaword(s2)) {
      type.num = true;
    }
    return type;
  }
  function hasPartMC(ctx, cfg, r1, r2, c1, c2) {
    var ret = false;
    _$1.forEach(ctx.config.merge, function(mc2) {
      if (r1 < mc2.r) {
        if (r2 >= mc2.r && r2 < mc2.r + mc2.rs - 1) {
          if (c1 >= mc2.c && c1 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c2 >= mc2.c && c2 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 < mc2.c && c2 > mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
        } else if (r2 >= mc2.r && r2 === mc2.r + mc2.rs - 1) {
          if (c1 > mc2.c && c1 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c2 > mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 === mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 > mc2.c && c2 === mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
        } else if (r2 > mc2.r + mc2.rs - 1) {
          if (c1 > mc2.c && c1 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c2 >= mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 === mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 > mc2.c && c2 === mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
        }
      } else if (r1 === mc2.r) {
        if (r2 < mc2.r + mc2.rs - 1) {
          if (c1 >= mc2.c && c1 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c2 >= mc2.c && c2 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 < mc2.c && c2 > mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
        } else if (r2 >= mc2.r + mc2.rs - 1) {
          if (c1 > mc2.c && c1 <= mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c2 >= mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 === mc2.c && c2 < mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
          if (c1 > mc2.c && c2 === mc2.c + mc2.cs - 1) {
            ret = true;
            return false;
          }
        }
      } else if (r1 <= mc2.r + mc2.rs - 1) {
        if (c1 >= mc2.c && c1 <= mc2.c + mc2.cs - 1) {
          ret = true;
          return false;
        }
        if (c2 >= mc2.c && c2 <= mc2.c + mc2.cs - 1) {
          ret = true;
          return false;
        }
        if (c1 < mc2.c && c2 > mc2.c + mc2.cs - 1) {
          ret = true;
          return false;
        }
      }
      return true;
    });
    return ret;
  }
  var SSF = {};
  var make_ssf = function make_ssf2(SSF2) {
    SSF2.version = "0.11.2";
    function _strrev(x2) {
      var o2 = "", i2 = x2.length - 1;
      while (i2 >= 0) {
        o2 += x2.charAt(i2--);
      }
      return o2;
    }
    function fill(c2, l2) {
      var o2 = "";
      while (o2.length < l2) {
        o2 += c2;
      }
      return o2;
    }
    function pad0(v2, d2) {
      var t2 = "" + v2;
      return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
    }
    function pad_(v2, d2) {
      var t2 = "" + v2;
      return t2.length >= d2 ? t2 : fill(" ", d2 - t2.length) + t2;
    }
    function rpad_(v2, d2) {
      var t2 = "" + v2;
      return t2.length >= d2 ? t2 : t2 + fill(" ", d2 - t2.length);
    }
    function pad0r1(v2, d2) {
      var t2 = "" + Math.round(v2);
      return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
    }
    function pad0r2(v2, d2) {
      var t2 = "" + v2;
      return t2.length >= d2 ? t2 : fill("0", d2 - t2.length) + t2;
    }
    var p2_32 = Math.pow(2, 32);
    function pad0r(v2, d2) {
      if (v2 > p2_32 || v2 < -p2_32) return pad0r1(v2, d2);
      var i2 = Math.round(v2);
      return pad0r2(i2, d2);
    }
    function isgeneral(s2, i2) {
      i2 = i2 || 0;
      return s2.length >= 7 + i2 && (s2.charCodeAt(i2) | 32) === 103 && (s2.charCodeAt(i2 + 1) | 32) === 101 && (s2.charCodeAt(i2 + 2) | 32) === 110 && (s2.charCodeAt(i2 + 3) | 32) === 101 && (s2.charCodeAt(i2 + 4) | 32) === 114 && (s2.charCodeAt(i2 + 5) | 32) === 97 && (s2.charCodeAt(i2 + 6) | 32) === 108;
    }
    var days = [["Sun", "Sunday"], ["Mon", "Monday"], ["Tue", "Tuesday"], ["Wed", "Wednesday"], ["Thu", "Thursday"], ["Fri", "Friday"], ["Sat", "Saturday"]];
    var months = [["J", "Jan", "January"], ["F", "Feb", "February"], ["M", "Mar", "March"], ["A", "Apr", "April"], ["M", "May", "May"], ["J", "Jun", "June"], ["J", "Jul", "July"], ["A", "Aug", "August"], ["S", "Sep", "September"], ["O", "Oct", "October"], ["N", "Nov", "November"], ["D", "Dec", "December"]];
    function init_table(t2) {
      t2[0] = "General";
      t2[1] = "0";
      t2[2] = "0.00";
      t2[3] = "#,##0";
      t2[4] = "#,##0.00";
      t2[9] = "0%";
      t2[10] = "0.00%";
      t2[11] = "0.00E+00";
      t2[12] = "# ?/?";
      t2[13] = "# ??/??";
      t2[14] = "m/d/yy";
      t2[15] = "d-mmm-yy";
      t2[16] = "d-mmm";
      t2[17] = "mmm-yy";
      t2[18] = "h:mm AM/PM";
      t2[19] = "h:mm:ss AM/PM";
      t2[20] = "h:mm";
      t2[21] = "h:mm:ss";
      t2[22] = "m/d/yy h:mm";
      t2[37] = "#,##0 ;(#,##0)";
      t2[38] = "#,##0 ;[Red](#,##0)";
      t2[39] = "#,##0.00;(#,##0.00)";
      t2[40] = "#,##0.00;[Red](#,##0.00)";
      t2[45] = "mm:ss";
      t2[46] = "[h]:mm:ss";
      t2[47] = "mmss.0";
      t2[48] = "##0.0E+0";
      t2[49] = "@";
      t2[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "';
      t2[65535] = "General";
    }
    var table_fmt = {};
    init_table(table_fmt);
    var default_map = [];
    var defi = 0;
    for (defi = 5; defi <= 8; ++defi) {
      default_map[defi] = 32 + defi;
    }
    for (defi = 23; defi <= 26; ++defi) {
      default_map[defi] = 0;
    }
    for (defi = 27; defi <= 31; ++defi) {
      default_map[defi] = 14;
    }
    for (defi = 50; defi <= 58; ++defi) {
      default_map[defi] = 14;
    }
    for (defi = 59; defi <= 62; ++defi) {
      default_map[defi] = defi - 58;
    }
    for (defi = 67; defi <= 68; ++defi) {
      default_map[defi] = defi - 58;
    }
    for (defi = 72; defi <= 75; ++defi) {
      default_map[defi] = defi - 58;
    }
    for (defi = 67; defi <= 68; ++defi) {
      default_map[defi] = defi - 57;
    }
    for (defi = 76; defi <= 78; ++defi) {
      default_map[defi] = defi - 56;
    }
    for (defi = 79; defi <= 81; ++defi) {
      default_map[defi] = defi - 34;
    }
    var default_str = [];
    default_str[5] = default_str[63] = '"$"#,##0_);\\("$"#,##0\\)';
    default_str[6] = default_str[64] = '"$"#,##0_);[Red]\\("$"#,##0\\)';
    default_str[7] = default_str[65] = '"$"#,##0.00_);\\("$"#,##0.00\\)';
    default_str[8] = default_str[66] = '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)';
    default_str[41] = '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)';
    default_str[42] = '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)';
    default_str[43] = '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)';
    default_str[44] = '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)';
    function frac(x2, D2, mixed) {
      var sgn = x2 < 0 ? -1 : 1;
      var B2 = x2 * sgn;
      var P_2 = 0, P_1 = 1, P2 = 0;
      var Q_2 = 1, Q_1 = 0, Q2 = 0;
      var A2 = Math.floor(B2);
      while (Q_1 < D2) {
        A2 = Math.floor(B2);
        P2 = A2 * P_1 + P_2;
        Q2 = A2 * Q_1 + Q_2;
        if (B2 - A2 < 5e-8) break;
        B2 = 1 / (B2 - A2);
        P_2 = P_1;
        P_1 = P2;
        Q_2 = Q_1;
        Q_1 = Q2;
      }
      if (Q2 > D2) {
        if (Q_1 > D2) {
          Q2 = Q_2;
          P2 = P_2;
        } else {
          Q2 = Q_1;
          P2 = P_1;
        }
      }
      if (!mixed) return [0, sgn * P2, Q2];
      var q2 = Math.floor(sgn * P2 / Q2);
      return [q2, sgn * P2 - q2 * Q2, Q2];
    }
    function parse_date_code(v2, opts, b2) {
      if (v2 > 2958465 || v2 < 0) return null;
      var date = v2 | 0, time = Math.floor(86400 * (v2 - date)), dow = 0;
      var dout = [];
      var out = {
        D: date,
        T: time,
        u: 86400 * (v2 - date) - time,
        y: 0,
        m: 0,
        d: 0,
        H: 0,
        M: 0,
        S: 0,
        q: 0
      };
      if (Math.abs(out.u) < 1e-6) out.u = 0;
      if (opts && opts.date1904) date += 1462;
      if (out.u > 0.9999) {
        out.u = 0;
        if (++time == 86400) {
          out.T = time = 0;
          ++date;
          ++out.D;
        }
      }
      if (date === 60) {
        dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
        dow = 3;
      } else if (date === 0) {
        dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
        dow = 6;
      } else {
        if (date > 60) --date;
        var d2 = new Date(1900, 0, 1);
        d2.setDate(d2.getDate() + date - 1);
        dout = [d2.getFullYear(), d2.getMonth() + 1, d2.getDate()];
        dow = d2.getDay();
        if (date < 60) dow = (dow + 6) % 7;
        if (b2) dow = fix_hijri(d2, dout);
      }
      out.y = dout[0];
      out.m = dout[1];
      out.d = dout[2];
      out.S = time % 60;
      time = Math.floor(time / 60);
      out.M = time % 60;
      time = Math.floor(time / 60);
      out.H = time;
      out.q = dow;
      return out;
    }
    SSF2.parse_date_code = parse_date_code;
    var basedate = new Date(1899, 11, 31, 0, 0, 0);
    var dnthresh = basedate.getTime();
    var base19042 = new Date(1900, 2, 1, 0, 0, 0);
    function datenum_local2(v2, date1904) {
      var epoch = v2.getTime();
      if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
      else if (v2 >= base19042) epoch += 24 * 60 * 60 * 1e3;
      return (epoch - (dnthresh + (v2.getTimezoneOffset() - basedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
    }
    function general_fmt_int(v2) {
      return v2.toString(10);
    }
    SSF2._general_int = general_fmt_int;
    var general_fmt_num = /* @__PURE__ */ function make_general_fmt_num() {
      var trailing_zeroes_and_decimal = /(?:\.0*|(\.\d*[1-9])0+)$/;
      function strip_decimal(o2) {
        return o2.indexOf(".") == -1 ? o2 : o2.replace(trailing_zeroes_and_decimal, "$1");
      }
      var mantissa_zeroes_and_decimal = /(?:\.0*|(\.\d*[1-9])0+)[Ee]/;
      var exp_with_single_digit = /(E[+-])(\d)$/;
      function normalize_exp(o2) {
        if (o2.indexOf("E") == -1) return o2;
        return o2.replace(mantissa_zeroes_and_decimal, "$1E").replace(exp_with_single_digit, "$10$2");
      }
      function small_exp(v2) {
        var w2 = v2 < 0 ? 12 : 11;
        var o2 = strip_decimal(v2.toFixed(12));
        if (o2.length <= w2) return o2;
        o2 = v2.toPrecision(10);
        if (o2.length <= w2) return o2;
        return Number(v2).toExponential(5);
      }
      function large_exp(v2) {
        var o2 = strip_decimal(v2.toFixed(11));
        return o2.length > (v2 < 0 ? 12 : 11) || o2 === "0" || o2 === "-0" ? v2.toPrecision(6) : o2;
      }
      function general_fmt_num_base(v2) {
        var V2 = Math.floor(Math.log(Math.abs(v2)) * Math.LOG10E), o2;
        if (V2 >= -4 && V2 <= -1) o2 = v2.toPrecision(10 + V2);
        else if (Math.abs(V2) <= 9) o2 = small_exp(v2);
        else if (V2 === 10) o2 = v2.toFixed(10).substr(0, 12);
        else o2 = large_exp(v2);
        return strip_decimal(normalize_exp(o2.toUpperCase()));
      }
      return general_fmt_num_base;
    }();
    SSF2._general_num = general_fmt_num;
    function general_fmt(v2, opts) {
      switch (_typeof(v2)) {
        case "string":
          return v2;
        case "boolean":
          return v2 ? "TRUE" : "FALSE";
        case "number":
          return (v2 | 0) === v2 ? v2.toString(10) : general_fmt_num(v2);
        case "undefined":
          return "";
        case "object":
          if (v2 == null) return "";
          if (v2 instanceof Date) return format(14, datenum_local2(v2, opts && opts.date1904), opts);
      }
      throw new Error("unsupported value in General format: " + v2);
    }
    SSF2._general = general_fmt;
    function fix_hijri(date, o2) {
      o2[0] -= 581;
      var dow = date.getDay();
      if (date < 60) dow = (dow + 6) % 7;
      return dow;
    }
    function write_date(type, fmt, val, ss0) {
      var o2 = "", ss = 0, tt = 0, y2 = val.y, out, outl = 0;
      switch (type) {
        case 98:
          y2 = val.y + 543;
        case 121:
          switch (fmt.length) {
            case 1:
            case 2:
              out = y2 % 100;
              outl = 2;
              break;
            default:
              out = y2 % 1e4;
              outl = 4;
              break;
          }
          break;
        case 109:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.m;
              outl = fmt.length;
              break;
            case 3:
              return months[val.m - 1][1];
            case 5:
              return months[val.m - 1][0];
            default:
              return months[val.m - 1][2];
          }
          break;
        case 100:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.d;
              outl = fmt.length;
              break;
            case 3:
              return days[val.q][0];
            default:
              return days[val.q][1];
          }
          break;
        case 104:
          switch (fmt.length) {
            case 1:
            case 2:
              out = 1 + (val.H + 11) % 12;
              outl = fmt.length;
              break;
            default:
              throw "bad hour format: " + fmt;
          }
          break;
        case 72:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.H;
              outl = fmt.length;
              break;
            default:
              throw "bad hour format: " + fmt;
          }
          break;
        case 77:
          switch (fmt.length) {
            case 1:
            case 2:
              out = val.M;
              outl = fmt.length;
              break;
            default:
              throw "bad minute format: " + fmt;
          }
          break;
        case 115:
          if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
          if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
          if (ss0 >= 2) tt = ss0 === 3 ? 1e3 : 100;
          else tt = ss0 === 1 ? 10 : 1;
          ss = Math.round(tt * (val.S + val.u));
          if (ss >= 60 * tt) ss = 0;
          if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt;
          o2 = pad0(ss, 2 + ss0);
          if (fmt === "ss") return o2.substr(0, 2);
          return "." + o2.substr(2, fmt.length - 1);
        case 90:
          switch (fmt) {
            case "[h]":
            case "[hh]":
              out = val.D * 24 + val.H;
              break;
            case "[m]":
            case "[mm]":
              out = (val.D * 24 + val.H) * 60 + val.M;
              break;
            case "[s]":
            case "[ss]":
              out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
              break;
            default:
              throw "bad abstime format: " + fmt;
          }
          outl = fmt.length === 3 ? 1 : 2;
          break;
        case 101:
          out = y2;
          outl = 1;
          break;
      }
      var outstr = outl > 0 ? pad0(out, outl) : "";
      return outstr;
    }
    function commaify(s2) {
      var w2 = 3;
      if (s2.length <= w2) return s2;
      var j2 = s2.length % w2, o2 = s2.substr(0, j2);
      for (; j2 != s2.length; j2 += w2) {
        o2 += (o2.length > 0 ? "," : "") + s2.substr(j2, w2);
      }
      return o2;
    }
    var write_num = /* @__PURE__ */ function make_write_num() {
      var pct1 = /%/g;
      function write_num_pct(type, fmt, val) {
        var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
        return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
      }
      function write_num_cm(type, fmt, val) {
        var idx = fmt.length - 1;
        while (fmt.charCodeAt(idx - 1) === 44) {
          --idx;
        }
        return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
      }
      function write_num_exp(fmt, val) {
        var o2;
        var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
        if (fmt.match(/^#+0.0E\+0$/)) {
          if (val == 0) return "0.0E+0";
          else if (val < 0) return "-" + write_num_exp(fmt, -val);
          var period = fmt.indexOf(".");
          if (period === -1) period = fmt.indexOf("E");
          var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
          if (ee2 < 0) ee2 += period;
          o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
          if (o2.indexOf("e") === -1) {
            var fakee = Math.floor(Math.log(val) * Math.LOG10E);
            if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
            else o2 += "E+" + (fakee - ee2);
            while (o2.substr(0, 2) === "0.") {
              o2 = o2.charAt(0) + o2.substr(2, period) + "." + o2.substr(2 + period);
              o2 = o2.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
            }
            o2 = o2.replace(/\+-/, "-");
          }
          o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
            return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
          });
        } else o2 = Number(val).toExponential(idx);
        if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
        if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
        return o2.replace("e", "E");
      }
      var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
      function write_num_f1(r2, aval, sign) {
        var den = parseInt(r2[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
        var myn = rr - base * den, myd = den;
        return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r2[1].length + 1 + r2[4].length) : pad_(myn, r2[1].length) + r2[2] + "/" + r2[3] + pad0(myd, r2[4].length));
      }
      function write_num_f2(r2, aval, sign) {
        return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r2[1].length + 2 + r2[4].length);
      }
      var dec1 = /^#*0*\.([0#]+)/;
      var closeparen = /\).*[0#]/;
      var phone = /\(###\) ###\\?-####/;
      function hashq(str) {
        var o2 = "", cc2;
        for (var i2 = 0; i2 != str.length; ++i2) {
          switch (cc2 = str.charCodeAt(i2)) {
            case 35:
              break;
            case 63:
              o2 += " ";
              break;
            case 48:
              o2 += "0";
              break;
            default:
              o2 += String.fromCharCode(cc2);
          }
        }
        return o2;
      }
      function rnd(val, d2) {
        var dd2 = Math.pow(10, d2);
        return "" + Math.round(val * dd2) / dd2;
      }
      function dec(val, d2) {
        var _frac = val - Math.floor(val), dd2 = Math.pow(10, d2);
        if (d2 < ("" + Math.round(_frac * dd2)).length) return 0;
        return Math.round(_frac * dd2);
      }
      function carry(val, d2) {
        if (d2 < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d2))).length) {
          return 1;
        }
        return 0;
      }
      function flr(val) {
        if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
        return "" + Math.floor(val);
      }
      function write_num_flt(type, fmt, val) {
        if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
          var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
          if (val >= 0) return write_num_flt("n", ffmt, val);
          return "(" + write_num_flt("n", ffmt, -val) + ")";
        }
        if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
        if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
        if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
        if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
        var o2;
        var r2, ri2, ff2, aval = Math.abs(val), sign = val < 0 ? "-" : "";
        if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
        if (fmt.match(/^[#?]+$/)) {
          o2 = pad0r(val, 0);
          if (o2 === "0") o2 = "";
          return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
        }
        if (r2 = fmt.match(frac1)) return write_num_f1(r2, aval, sign);
        if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
        if (r2 = fmt.match(dec1)) {
          o2 = rnd(val, r2[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1])).replace(/\.(\d*)$/, function($$, $1) {
            return "." + $1 + fill("0", hashq(r2[1]).length - $1.length);
          });
          return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
        }
        fmt = fmt.replace(/^#+([0.])/, "$1");
        if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
          return sign + rnd(aval, r2[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
        }
        if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
        if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r2[1].length))) + "." + pad0(dec(val, r2[1].length), r2[1].length);
        }
        if (r2 = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
        if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
          o2 = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
          ri2 = 0;
          return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
            return ri2 < o2.length ? o2.charAt(ri2++) : x3 === "0" ? "0" : "";
          }));
        }
        if (fmt.match(phone)) {
          o2 = write_num_flt(type, "##########", val);
          return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
        }
        var oa2 = "";
        if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri2 = Math.min(r2[4].length, 7);
          ff2 = frac(aval, Math.pow(10, ri2) - 1, false);
          o2 = "" + sign;
          oa2 = write_num("n", r2[1], ff2[1]);
          if (oa2.charAt(oa2.length - 1) == " ") oa2 = oa2.substr(0, oa2.length - 1) + "0";
          o2 += oa2 + r2[2] + "/" + r2[3];
          oa2 = rpad_(ff2[2], ri2);
          if (oa2.length < r2[4].length) oa2 = hashq(r2[4].substr(r2[4].length - oa2.length)) + oa2;
          o2 += oa2;
          return o2;
        }
        if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri2 = Math.min(Math.max(r2[1].length, r2[4].length), 7);
          ff2 = frac(aval, Math.pow(10, ri2) - 1, true);
          return sign + (ff2[0] || (ff2[1] ? "" : "0")) + " " + (ff2[1] ? pad_(ff2[1], ri2) + r2[2] + "/" + r2[3] + rpad_(ff2[2], ri2) : fill(" ", 2 * ri2 + 1 + r2[2].length + r2[3].length));
        }
        if (r2 = fmt.match(/^[#0?]+$/)) {
          o2 = pad0r(val, 0);
          if (fmt.length <= o2.length) return o2;
          return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
        }
        if (r2 = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
          o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
          ri2 = o2.indexOf(".");
          var lres = fmt.indexOf(".") - ri2, rres = fmt.length - o2.length - lres;
          return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
        }
        if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
          ri2 = dec(val, r2[1].length);
          return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
            return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
          }) + "." + pad0(ri2, r2[1].length);
        }
        switch (fmt) {
          case "###,##0.00":
            return write_num_flt(type, "#,##0.00", val);
          case "###,###":
          case "##,###":
          case "#,###":
            var x2 = commaify(pad0r(aval, 0));
            return x2 !== "0" ? sign + x2 : "";
          case "###,###.00":
            return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
          case "#,###.00":
            return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
        }
        throw new Error("unsupported format |" + fmt + "|");
      }
      function write_num_cm2(type, fmt, val) {
        var idx = fmt.length - 1;
        while (fmt.charCodeAt(idx - 1) === 44) {
          --idx;
        }
        return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
      }
      function write_num_pct2(type, fmt, val) {
        var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
        return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
      }
      function write_num_exp2(fmt, val) {
        var o2;
        var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
        if (fmt.match(/^#+0.0E\+0$/)) {
          if (val == 0) return "0.0E+0";
          else if (val < 0) return "-" + write_num_exp2(fmt, -val);
          var period = fmt.indexOf(".");
          if (period === -1) period = fmt.indexOf("E");
          var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
          if (ee2 < 0) ee2 += period;
          o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
          if (!o2.match(/[Ee]/)) {
            var fakee = Math.floor(Math.log(val) * Math.LOG10E);
            if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
            else o2 += "E+" + (fakee - ee2);
            o2 = o2.replace(/\+-/, "-");
          }
          o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
            return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
          });
        } else o2 = Number(val).toExponential(idx);
        if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
        if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
        return o2.replace("e", "E");
      }
      function write_num_int(type, fmt, val) {
        if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
          var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
          if (val >= 0) return write_num_int("n", ffmt, val);
          return "(" + write_num_int("n", ffmt, -val) + ")";
        }
        if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
        if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
        if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
        if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
        var o2;
        var r2, ri2, ff2, aval = Math.abs(val), sign = val < 0 ? "-" : "";
        if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
        if (fmt.match(/^[#?]+$/)) {
          o2 = "" + val;
          if (val === 0) o2 = "";
          return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
        }
        if (r2 = fmt.match(frac1)) return write_num_f2(r2, aval, sign);
        if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
        if (r2 = fmt.match(dec1)) {
          o2 = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1]));
          o2 = o2.replace(/\.(\d*)$/, function($$, $1) {
            return "." + $1 + fill("0", hashq(r2[1]).length - $1.length);
          });
          return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
        }
        fmt = fmt.replace(/^#+([0.])/, "$1");
        if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
          return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
        }
        if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
        if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r2[1].length);
        }
        if (r2 = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
        if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
          o2 = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
          ri2 = 0;
          return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x3) {
            return ri2 < o2.length ? o2.charAt(ri2++) : x3 === "0" ? "0" : "";
          }));
        }
        if (fmt.match(phone)) {
          o2 = write_num_int(type, "##########", val);
          return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
        }
        var oa2 = "";
        if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri2 = Math.min(r2[4].length, 7);
          ff2 = frac(aval, Math.pow(10, ri2) - 1, false);
          o2 = "" + sign;
          oa2 = write_num("n", r2[1], ff2[1]);
          if (oa2.charAt(oa2.length - 1) == " ") oa2 = oa2.substr(0, oa2.length - 1) + "0";
          o2 += oa2 + r2[2] + "/" + r2[3];
          oa2 = rpad_(ff2[2], ri2);
          if (oa2.length < r2[4].length) oa2 = hashq(r2[4].substr(r2[4].length - oa2.length)) + oa2;
          o2 += oa2;
          return o2;
        }
        if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
          ri2 = Math.min(Math.max(r2[1].length, r2[4].length), 7);
          ff2 = frac(aval, Math.pow(10, ri2) - 1, true);
          return sign + (ff2[0] || (ff2[1] ? "" : "0")) + " " + (ff2[1] ? pad_(ff2[1], ri2) + r2[2] + "/" + r2[3] + rpad_(ff2[2], ri2) : fill(" ", 2 * ri2 + 1 + r2[2].length + r2[3].length));
        }
        if (r2 = fmt.match(/^[#0?]+$/)) {
          o2 = "" + val;
          if (fmt.length <= o2.length) return o2;
          return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
        }
        if (r2 = fmt.match(/^([#0]+)\.([#0]+)$/)) {
          o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
          ri2 = o2.indexOf(".");
          var lres = fmt.indexOf(".") - ri2, rres = fmt.length - o2.length - lres;
          return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
        }
        if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
          return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
            return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
          }) + "." + pad0(0, r2[1].length);
        }
        switch (fmt) {
          case "###,###":
          case "##,###":
          case "#,###":
            var x2 = commaify("" + aval);
            return x2 !== "0" ? sign + x2 : "";
          default:
            if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
        }
        throw new Error("unsupported format |" + fmt + "|");
      }
      return function write_num2(type, fmt, val) {
        return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
      };
    }();
    function split_fmt(fmt) {
      var out = [];
      var in_str = false;
      for (var i2 = 0, j2 = 0; i2 < fmt.length; ++i2) {
        switch (
          /*cc=*/
          fmt.charCodeAt(i2)
        ) {
          case 34:
            in_str = !in_str;
            break;
          case 95:
          case 42:
          case 92:
            ++i2;
            break;
          case 59:
            out[out.length] = fmt.substr(j2, i2 - j2);
            j2 = i2 + 1;
        }
      }
      out[out.length] = fmt.substr(j2);
      if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
      return out;
    }
    SSF2._split = split_fmt;
    var abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
    function fmt_is_date(fmt) {
      var i2 = 0, c2 = "", o2 = "";
      while (i2 < fmt.length) {
        switch (c2 = fmt.charAt(i2)) {
          case "G":
            if (isgeneral(fmt, i2)) i2 += 6;
            i2++;
            break;
          case '"':
            for (
              ;
              /*cc=*/
              fmt.charCodeAt(++i2) !== 34 && i2 < fmt.length;
            ) {
            }
            ++i2;
            break;
          case "\\":
            i2 += 2;
            break;
          case "_":
            i2 += 2;
            break;
          case "@":
            ++i2;
            break;
          case "B":
          case "b":
            if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2") return true;
          case "M":
          case "D":
          case "Y":
          case "H":
          case "S":
          case "E":
          case "m":
          case "d":
          case "y":
          case "h":
          case "s":
          case "e":
          case "g":
            return true;
          case "A":
          case "a":
          case "上":
            if (fmt.substr(i2, 3).toUpperCase() === "A/P") return true;
            if (fmt.substr(i2, 5).toUpperCase() === "AM/PM") return true;
            if (fmt.substr(i2, 5).toUpperCase() === "上午/下午") return true;
            ++i2;
            break;
          case "[":
            o2 = c2;
            while (fmt.charAt(i2++) !== "]" && i2 < fmt.length) {
              o2 += fmt.charAt(i2);
            }
            if (o2.match(abstime)) return true;
            break;
          case ".":
          case "0":
          case "#":
            while (i2 < fmt.length && ("0#?.,E+-%".indexOf(c2 = fmt.charAt(++i2)) > -1 || c2 == "\\" && fmt.charAt(i2 + 1) == "-" && "0#".indexOf(fmt.charAt(i2 + 2)) > -1)) {
            }
            break;
          case "?":
            while (fmt.charAt(++i2) === c2) {
            }
            break;
          case "*":
            ++i2;
            if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*") ++i2;
            break;
          case "(":
          case ")":
            ++i2;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1) {
            }
            break;
          case " ":
            ++i2;
            break;
          default:
            ++i2;
            break;
        }
      }
      return false;
    }
    SSF2.is_date = fmt_is_date;
    function eval_fmt(fmt, v2, opts, flen) {
      var out = [], o2 = "", i2 = 0, c2 = "", lst = "t", dt, j2, cc2;
      var hr = "H";
      while (i2 < fmt.length) {
        switch (c2 = fmt.charAt(i2)) {
          case "G":
            if (!isgeneral(fmt, i2)) throw new Error("unrecognized character " + c2 + " in " + fmt);
            out[out.length] = {
              t: "G",
              v: "General"
            };
            i2 += 7;
            break;
          case '"':
            for (o2 = ""; (cc2 = fmt.charCodeAt(++i2)) !== 34 && i2 < fmt.length; ) {
              o2 += String.fromCharCode(cc2);
            }
            out[out.length] = {
              t: "t",
              v: o2
            };
            ++i2;
            break;
          case "\\":
            var w2 = fmt.charAt(++i2), t2 = w2 === "(" || w2 === ")" ? w2 : "t";
            out[out.length] = {
              t: t2,
              v: w2
            };
            ++i2;
            break;
          case "_":
            out[out.length] = {
              t: "t",
              v: " "
            };
            i2 += 2;
            break;
          case "@":
            out[out.length] = {
              t: "T",
              v: v2
            };
            ++i2;
            break;
          case "B":
          case "b":
            if (fmt.charAt(i2 + 1) === "1" || fmt.charAt(i2 + 1) === "2") {
              if (dt == null) {
                dt = parse_date_code(v2, opts, fmt.charAt(i2 + 1) === "2");
                if (dt == null) return "";
              }
              out[out.length] = {
                t: "X",
                v: fmt.substr(i2, 2)
              };
              lst = c2;
              i2 += 2;
              break;
            }
          case "M":
          case "D":
          case "Y":
          case "H":
          case "S":
          case "E":
            c2 = c2.toLowerCase();
          case "m":
          case "d":
          case "y":
          case "h":
          case "s":
          case "e":
          case "g":
            if (v2 < 0) return "";
            if (dt == null) {
              dt = parse_date_code(v2, opts);
              if (dt == null) return "#####";
            }
            o2 = c2;
            while (++i2 < fmt.length && fmt.charAt(i2).toLowerCase() === c2) {
              o2 += c2;
            }
            if (c2 === "m" && lst.toLowerCase() === "h") c2 = "M";
            if (c2 === "h") c2 = hr;
            out[out.length] = {
              t: c2,
              v: o2
            };
            lst = c2;
            break;
          case "A":
          case "a":
          case "上":
            var q2 = {
              t: c2,
              v: c2
            };
            if (dt == null) dt = parse_date_code(v2, opts);
            if (fmt.substr(i2, 3).toUpperCase() === "A/P") {
              if (dt != null) q2.v = dt.H >= 12 ? "P" : "A";
              q2.t = "T";
              hr = "h";
              i2 += 3;
            } else if (fmt.substr(i2, 5).toUpperCase() === "AM/PM") {
              if (dt != null) q2.v = dt.H >= 12 ? "PM" : "AM";
              q2.t = "T";
              i2 += 5;
              hr = "h";
            } else if (fmt.substr(i2, 5).toUpperCase() === "上午/下午") {
              if (dt != null) q2.v = dt.H >= 12 ? "下午" : "上午";
              q2.t = "T";
              i2 += 5;
              hr = "h";
            } else {
              q2.t = "t";
              ++i2;
            }
            if (dt == null && q2.t === "T") return "";
            out[out.length] = q2;
            lst = c2;
            break;
          case "[":
            o2 = c2;
            while (fmt.charAt(i2++) !== "]" && i2 < fmt.length) {
              o2 += fmt.charAt(i2);
            }
            if (o2.slice(-1) !== "]") throw 'unterminated "[" block: |' + o2 + "|";
            if (o2.match(abstime)) {
              if (dt == null) {
                dt = parse_date_code(v2, opts);
                if (dt == null) return "";
              }
              out[out.length] = {
                t: "Z",
                v: o2.toLowerCase()
              };
              lst = o2.charAt(1);
            } else if (o2.indexOf("$") > -1) {
              o2 = (o2.match(/\$([^-\[\]]*)/) || [])[1] || "$";
              if (!fmt_is_date(fmt)) out[out.length] = {
                t: "t",
                v: o2
              };
            }
            break;
          case ".":
            if (dt != null) {
              o2 = c2;
              while (++i2 < fmt.length && (c2 = fmt.charAt(i2)) === "0") {
                o2 += c2;
              }
              out[out.length] = {
                t: "s",
                v: o2
              };
              break;
            }
          case "0":
          case "#":
            o2 = c2;
            while (++i2 < fmt.length && "0#?.,E+-%".indexOf(c2 = fmt.charAt(i2)) > -1) {
              o2 += c2;
            }
            out[out.length] = {
              t: "n",
              v: o2
            };
            break;
          case "?":
            o2 = c2;
            while (fmt.charAt(++i2) === c2) {
              o2 += c2;
            }
            out[out.length] = {
              t: c2,
              v: o2
            };
            lst = c2;
            break;
          case "*":
            ++i2;
            if (fmt.charAt(i2) == " " || fmt.charAt(i2) == "*") ++i2;
            break;
          case "(":
          case ")":
            out[out.length] = {
              t: flen === 1 ? "t" : c2,
              v: c2
            };
            ++i2;
            break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            o2 = c2;
            while (i2 < fmt.length && "0123456789".indexOf(fmt.charAt(++i2)) > -1) {
              o2 += fmt.charAt(i2);
            }
            out[out.length] = {
              t: "D",
              v: o2
            };
            break;
          case " ":
            out[out.length] = {
              t: c2,
              v: c2
            };
            ++i2;
            break;
          case "$":
            out[out.length] = {
              t: "t",
              v: "$"
            };
            ++i2;
            break;
          default:
            if ("¤฿BsBr₵₡₫ƒFtRs.₭kr£₤Lm₥₦₱PQRSkRp৲৳R$S/.〒₮₩¥NT￥zł₴₪៛руб€＄,$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP$￥LekdinAf$dhAflRial?￡BirrKzMOPPGKRsGsB/R$ррlevkrKMzBsPNuFBuKPkrRD$NfkCFA?CVEGMDFrCDHTGNAfLFdjKGSFGGHSRielKCFknKshLSLL￡LtRFRONArRfMWKRMMURsMROS/KMDLMTnRC$kr€GELCHFSLLSCRDbSZLSDGSOSSomFCFPTShT$VUVQUGXгрнsomWSTNT$FtDramRpZMWFCFA".indexOf(c2) === -1) throw new Error("unrecognized character " + c2 + " in " + fmt);
            out[out.length] = {
              t: "t",
              v: c2
            };
            ++i2;
            break;
        }
      }
      var bt = 0, ss0 = 0, ssm;
      for (i2 = out.length - 1, lst = "t"; i2 >= 0; --i2) {
        switch (out[i2].t) {
          case "h":
          case "H":
            out[i2].t = hr;
            lst = "h";
            if (bt < 1) bt = 1;
            break;
          case "s":
            if (ssm = out[i2].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
            if (bt < 3) bt = 3;
          case "d":
          case "y":
          case "M":
          case "e":
            lst = out[i2].t;
            break;
          case "m":
            if (lst === "s") {
              out[i2].t = "M";
              if (bt < 2) bt = 2;
            }
            break;
          case "X":
            break;
          case "Z":
            if (bt < 1 && out[i2].v.match(/[Hh]/)) bt = 1;
            if (bt < 2 && out[i2].v.match(/[Mm]/)) bt = 2;
            if (bt < 3 && out[i2].v.match(/[Ss]/)) bt = 3;
        }
      }
      switch (bt) {
        case 0:
          break;
        case 1:
          if (dt.u >= 0.5) {
            dt.u = 0;
            ++dt.S;
          }
          if (dt.S >= 60) {
            dt.S = 0;
            ++dt.M;
          }
          if (dt.M >= 60) {
            dt.M = 0;
            ++dt.H;
          }
          break;
        case 2:
          if (dt.u >= 0.5) {
            dt.u = 0;
            ++dt.S;
          }
          if (dt.S >= 60) {
            dt.S = 0;
            ++dt.M;
          }
          break;
      }
      var nstr = "", jj2;
      for (i2 = 0; i2 < out.length; ++i2) {
        switch (out[i2].t) {
          case "t":
          case "T":
          case " ":
          case "D":
            break;
          case "X":
            out[i2].v = "";
            out[i2].t = ";";
            break;
          case "d":
          case "m":
          case "y":
          case "h":
          case "H":
          case "M":
          case "s":
          case "e":
          case "b":
          case "Z":
            out[i2].v = write_date(out[i2].t.charCodeAt(0), out[i2].v, dt, ss0);
            out[i2].t = "t";
            break;
          case "n":
          case "?":
            jj2 = i2 + 1;
            while (out[jj2] != null && ((c2 = out[jj2].t) === "?" || c2 === "D" || (c2 === " " || c2 === "t") && out[jj2 + 1] != null && (out[jj2 + 1].t === "?" || out[jj2 + 1].t === "t" && out[jj2 + 1].v === "/") || out[i2].t === "(" && (c2 === " " || c2 === "n" || c2 === ")") || c2 === "t" && (out[jj2].v === "/" || out[jj2].v === " " && out[jj2 + 1] != null && out[jj2 + 1].t == "?"))) {
              out[i2].v += out[jj2].v;
              out[jj2] = {
                v: "",
                t: ";"
              };
              ++jj2;
            }
            nstr += out[i2].v;
            i2 = jj2 - 1;
            break;
          case "G":
            out[i2].t = "t";
            out[i2].v = general_fmt(v2, opts);
            break;
        }
      }
      var vv = "", myv, ostr;
      if (nstr.length > 0) {
        if (nstr.charCodeAt(0) == 40) {
          myv = v2 < 0 && nstr.charCodeAt(0) === 45 ? -v2 : v2;
          ostr = write_num("n", nstr, myv);
        } else {
          myv = v2 < 0 && flen > 1 ? -v2 : v2;
          ostr = write_num("n", nstr, myv);
          if (myv < 0 && out[0] && out[0].t == "t") {
            ostr = ostr.substr(1);
            out[0].v = "-" + out[0].v;
          }
        }
        jj2 = ostr.length - 1;
        var decpt = out.length;
        for (i2 = 0; i2 < out.length; ++i2) {
          if (out[i2] != null && out[i2].t != "t" && out[i2].v.indexOf(".") > -1) {
            decpt = i2;
            break;
          }
        }
        var lasti = out.length;
        if (decpt === out.length && ostr.indexOf("E") === -1) {
          for (i2 = out.length - 1; i2 >= 0; --i2) {
            if (out[i2] == null || "n?".indexOf(out[i2].t) === -1) continue;
            if (jj2 >= out[i2].v.length - 1) {
              jj2 -= out[i2].v.length;
              out[i2].v = ostr.substr(jj2 + 1, out[i2].v.length);
            } else if (jj2 < 0) out[i2].v = "";
            else {
              out[i2].v = ostr.substr(0, jj2 + 1);
              jj2 = -1;
            }
            out[i2].t = "t";
            lasti = i2;
          }
          if (jj2 >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj2 + 1) + out[lasti].v;
        } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
          jj2 = ostr.indexOf(".") - 1;
          for (i2 = decpt; i2 >= 0; --i2) {
            if (out[i2] == null || "n?".indexOf(out[i2].t) === -1) continue;
            j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") - 1 : out[i2].v.length - 1;
            vv = out[i2].v.substr(j2 + 1);
            for (; j2 >= 0; --j2) {
              if (jj2 >= 0 && (out[i2].v.charAt(j2) === "0" || out[i2].v.charAt(j2) === "#")) vv = ostr.charAt(jj2--) + vv;
            }
            out[i2].v = vv;
            out[i2].t = "t";
            lasti = i2;
          }
          if (jj2 >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj2 + 1) + out[lasti].v;
          jj2 = ostr.indexOf(".") + 1;
          for (i2 = decpt; i2 < out.length; ++i2) {
            if (out[i2] == null || "n?(".indexOf(out[i2].t) === -1 && i2 !== decpt) continue;
            j2 = out[i2].v.indexOf(".") > -1 && i2 === decpt ? out[i2].v.indexOf(".") + 1 : 0;
            vv = out[i2].v.substr(0, j2);
            for (; j2 < out[i2].v.length; ++j2) {
              if (jj2 < ostr.length) vv += ostr.charAt(jj2++);
            }
            out[i2].v = vv;
            out[i2].t = "t";
            lasti = i2;
          }
        }
      }
      for (i2 = 0; i2 < out.length; ++i2) {
        if (out[i2] != null && "n?".indexOf(out[i2].t) > -1) {
          myv = flen > 1 && v2 < 0 && i2 > 0 && out[i2 - 1].v === "-" ? -v2 : v2;
          out[i2].v = write_num(out[i2].t, out[i2].v, myv);
          out[i2].t = "t";
        }
      }
      var retval = "";
      for (i2 = 0; i2 !== out.length; ++i2) {
        if (out[i2] != null) retval += out[i2].v;
      }
      return retval;
    }
    SSF2._eval = eval_fmt;
    var cfregex = /\[[=<>]/;
    var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
    function chkcond(v2, rr) {
      if (rr == null) return false;
      var thresh = parseFloat(rr[2]);
      switch (rr[1]) {
        case "=":
          if (v2 == thresh) return true;
          break;
        case ">":
          if (v2 > thresh) return true;
          break;
        case "<":
          if (v2 < thresh) return true;
          break;
        case "<>":
          if (v2 != thresh) return true;
          break;
        case ">=":
          if (v2 >= thresh) return true;
          break;
        case "<=":
          if (v2 <= thresh) return true;
          break;
      }
      return false;
    }
    function choose_fmt(f2, v2) {
      var fmt = split_fmt(f2);
      var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
      if (l2 < 4 && lat > -1) --l2;
      if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
      if (parseFloat(v2).toString() == "NaN") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
      switch (fmt.length) {
        case 1:
          fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
          break;
        case 2:
          fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
          break;
        case 3:
          fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
          break;
      }
      var ff2 = v2 > 0 ? fmt[0] : v2 < 0 ? fmt[1] : fmt[2];
      if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l2, ff2];
      if (fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {
        var m1 = fmt[0].match(cfregex2);
        var m2 = fmt[1].match(cfregex2);
        return chkcond(v2, m1) ? [l2, fmt[0]] : chkcond(v2, m2) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m2 != null ? 2 : 1]];
      }
      return [l2, ff2];
    }
    function format(fmt, v2, o2) {
      if (o2 == null) o2 = {};
      var sfmt = "";
      switch (_typeof(fmt)) {
        case "string":
          if (fmt == "m/d/yy" && o2.dateNF) sfmt = o2.dateNF;
          else sfmt = fmt;
          break;
        case "number":
          if (fmt == 14 && o2.dateNF) sfmt = o2.dateNF;
          else sfmt = (o2.table != null ? o2.table : table_fmt)[fmt];
          if (sfmt == null) sfmt = o2.table && o2.table[default_map[fmt]] || table_fmt[default_map[fmt]];
          if (sfmt == null) sfmt = default_str[fmt] || "General";
          break;
      }
      var reg = /^(w|W)((0?)|(0\.0+))$/;
      if (!!sfmt.match(reg)) {
        if (isNaN(v2)) {
          return v2;
        }
        var acc = sfmt.slice(1);
        var isNegative = false;
        if (!isNaN(v2) && Number(v2) < 0) {
          isNegative = true;
          v2 = Math.abs(v2);
        }
        var vInt = parseInt(v2);
        var vlength = vInt.toString().length;
        if (vlength > 4) {
          if (vlength > 8) {
            var y2 = parseInt(v2 / 1e8);
            var w2 = parseInt(parseFloat(v2) - y2 * 1e8 / 1e4);
            var q2 = parseFloat(v2) - (y2 * 1e8 + w2 * 1e4);
            if (acc != "") {
              q2 = numeral(q2).format(acc);
            }
            v2 = y2 + "亿" + w2 + "万" + q2;
          } else {
            var w2 = parseInt(v2 / 1e4);
            var q2 = parseFloat(v2) - w2 * 1e4;
            if (acc != "") {
              q2 = numeral(q2).format(acc);
            }
            v2 = w2 + "万" + q2;
          }
          if (v2.indexOf("亿0万0") != -1) {
            v2 = v2.replace("0万0", "");
          } else if (v2.indexOf("亿0万") != -1) {
            v2 = v2.replace("0万", "");
          } else if (v2.indexOf("万0") != -1) {
            v2 = v2.replace("万0", "万");
          }
          if (v2.indexOf("亿") != -1 && v2.indexOf("万") == -1) {
            var afterYi = v2.substring(v2.indexOf("亿") + 1);
            if (afterYi.substring(0, 1) !== "." && afterYi != "") {
              switch ((parseInt(afterYi) + "").length) {
                case 1:
                  afterYi = "000" + afterYi;
                  break;
                case 2:
                  afterYi = "00" + afterYi;
                  break;
                case 3:
                  afterYi = "0" + afterYi;
                  break;
              }
              v2 = v2.substring(0, v2.indexOf("亿") + 1) + afterYi;
            }
          } else if (v2.indexOf("亿") == -1 && v2.indexOf("万") != -1) {
            var afterWan = v2.substring(v2.indexOf("万") + 1);
            if (afterWan.substring(0, 1) !== "." && afterWan != "") {
              switch ((parseInt(afterWan) + "").length) {
                case 1:
                  afterWan = "000" + afterWan;
                  break;
                case 2:
                  afterWan = "00" + afterWan;
                  break;
                case 3:
                  afterWan = "0" + afterWan;
                  break;
              }
              v2 = v2.substring(0, v2.indexOf("万") + 1) + afterWan;
            }
          } else if (v2.indexOf("亿") != -1 && v2.indexOf("万") != -1) {
            var afterYi = v2.substring(v2.indexOf("亿") + 1, v2.indexOf("万")), afterWan = v2.substring(v2.indexOf("万") + 1);
            switch ((parseInt(afterYi) + "").length) {
              case 1:
                afterYi = "000" + afterYi;
                break;
              case 2:
                afterYi = "00" + afterYi;
                break;
              case 3:
                afterYi = "0" + afterYi;
                break;
            }
            v2 = v2.substring(0, v2.indexOf("亿") + 1) + afterYi + v2.substring(v2.indexOf("万"));
            if (afterWan.substring(0, 1) !== "." && afterWan != "") {
              switch ((parseInt(afterWan) + "").length) {
                case 1:
                  afterWan = "000" + afterWan;
                  break;
                case 2:
                  afterWan = "00" + afterWan;
                  break;
                case 3:
                  afterWan = "0" + afterWan;
                  break;
              }
              v2 = v2.substring(0, v2.indexOf("万") + 1) + afterWan;
            }
          }
        } else {
          if (acc != "") {
            v2 = numeral(v2).format(acc);
          }
        }
        if (isNegative) {
          return "-" + v2;
        } else {
          return v2;
        }
      }
      if (isgeneral(sfmt, 0)) return general_fmt(v2, o2);
      if (v2 instanceof Date) v2 = datenum_local2(v2, o2.date1904);
      var f2 = choose_fmt(sfmt, v2);
      if (isgeneral(f2[1])) return general_fmt(v2, o2);
      if (v2 === true) v2 = "TRUE";
      else if (v2 === false) v2 = "FALSE";
      else if (v2 === "" || v2 == null) return "";
      return eval_fmt(f2[1], v2, o2, f2[0]);
    }
    function load_entry(fmt, idx) {
      if (typeof idx != "number") {
        idx = +idx || -1;
        for (var i2 = 0; i2 < 392; ++i2) {
          if (table_fmt[i2] == void 0) {
            if (idx < 0) idx = i2;
            continue;
          }
          if (table_fmt[i2] == fmt) {
            idx = i2;
            break;
          }
        }
        if (idx < 0) idx = 391;
      }
      table_fmt[idx] = fmt;
      return idx;
    }
    SSF2.load = load_entry;
    SSF2._table = table_fmt;
    SSF2.get_table = function get_table() {
      return table_fmt;
    };
    SSF2.load_table = function load_table(tbl) {
      for (var i2 = 0; i2 != 392; ++i2) {
        if (tbl[i2] !== void 0) load_entry(tbl[i2], i2);
      }
    };
    SSF2.init_table = init_table;
    SSF2.format = format;
  };
  make_ssf(SSF);
  var base1904 = new Date(1900, 2, 1, 0, 0, 0);
  function datenum_local(v2, date1904) {
    var epoch = Date.UTC(v2.getFullYear(), v2.getMonth(), v2.getDate(), v2.getHours(), v2.getMinutes(), v2.getSeconds());
    var dnthresh_utc = Date.UTC(1899, 11, 31, 0, 0, 0);
    if (v2 >= base1904) epoch += 24 * 60 * 60 * 1e3;
    return (epoch - dnthresh_utc) / (24 * 60 * 60 * 1e3);
  }
  var good_pd_date = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
  if (Number.isNaN(good_pd_date.getFullYear())) good_pd_date = /* @__PURE__ */ new Date("2/19/17");
  var good_pd = good_pd_date.getFullYear() === 2017;
  function parseDate(str, fixdate) {
    var d2 = new Date(str);
    if (good_pd) {
      if (!_$1.isNil(fixdate)) ;
      return d2;
    }
    if (str instanceof Date) return str;
    if (good_pd_date.getFullYear() === 1917 && !Number.isNaN(d2.getFullYear())) {
      var s2 = d2.getFullYear();
      if (str.indexOf("".concat(s2)) > -1) return d2;
      d2.setFullYear(d2.getFullYear() + 100);
      return d2;
    }
    var n2 = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
    var out = new Date(+n2[0], +n2[1] - 1, +n2[2], +n2[3] || 0, +n2[4] || 0, +n2[5] || 0);
    if (str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
    return out;
  }
  function genarate(value) {
    var m2 = null;
    var ct = {};
    var v2 = value;
    if (_$1.isNil(value)) {
      return null;
    }
    if (/^-?[0-9]{1,}[,][0-9]{3}(.[0-9]{1,2})?$/.test(value)) {
      value = value;
      m2 = value;
      v2 = Number(value.split(".")[0].replace(",", ""));
      var fa2 = "#,##0";
      if (value.split(".")[1]) {
        fa2 = "#,##0.";
        for (var i2 = 0; i2 < value.split(".")[1].length; i2 += 1) {
          fa2 += 0;
        }
      }
      ct = {
        fa: fa2,
        t: "n"
      };
    } else if (value.toString().substring(0, 1) === "'") {
      m2 = value.toString().substring(1);
      ct = {
        fa: "@",
        t: "s"
      };
    } else if (value.toString().toUpperCase() === "TRUE") {
      m2 = "TRUE";
      ct = {
        fa: "General",
        t: "b"
      };
      v2 = true;
    } else if (value.toString().toUpperCase() === "FALSE") {
      m2 = "FALSE";
      ct = {
        fa: "General",
        t: "b"
      };
      v2 = false;
    } else if (valueIsError(value.toString())) {
      m2 = value.toString();
      ct = {
        fa: "General",
        t: "e"
      };
    } else if (/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test(value)) {
      m2 = value.toString();
      ct = {
        fa: "@",
        t: "s"
      };
    } else if (isRealNum(value) && Math.abs(parseFloat(value)) > 0 && (Math.abs(parseFloat(value)) >= 1e11 || Math.abs(parseFloat(value)) < 1e-9)) {
      v2 = parseFloat(value);
      var str = v2.toExponential();
      if (str.indexOf(".") > -1) {
        var strlen = str.split(".")[1].split("e")[0].length;
        if (strlen > 5) {
          strlen = 5;
        }
        ct = {
          fa: "#0.".concat(new Array(strlen + 1).join("0"), "E+00"),
          t: "n"
        };
      } else {
        ct = {
          fa: "#0.E+00",
          t: "n"
        };
      }
      m2 = SSF.format(ct.fa, v2);
    } else if (value.toString().indexOf("%") > -1) {
      var index2 = value.toString().indexOf("%");
      var value2 = value.toString().substring(0, index2);
      var value3 = value2.replace(/,/g, "");
      if (index2 === value.toString().length - 1 && isRealNum(value3)) {
        if (value2.indexOf(".") > -1) {
          if (value2.indexOf(".") === value2.lastIndexOf(".")) {
            var value4 = value2.split(".")[0];
            var value5 = value2.split(".")[1];
            var len = value5.length;
            if (len > 9) {
              len = 9;
            }
            if (value4.indexOf(",") > -1) {
              var isThousands = true;
              var ThousandsArr = value4.split(",");
              for (var _i = 1; _i < ThousandsArr.length; _i += 1) {
                if (ThousandsArr[_i].length < 3) {
                  isThousands = false;
                  break;
                }
              }
              if (isThousands) {
                ct = {
                  fa: "#,##0.".concat(new Array(len + 1).join("0"), "%"),
                  t: "n"
                };
                v2 = numeral(value).value();
                m2 = SSF.format(ct.fa, v2);
              } else {
                m2 = value.toString();
                ct = {
                  fa: "@",
                  t: "s"
                };
              }
            } else {
              ct = {
                fa: "0.".concat(new Array(len + 1).join("0"), "%"),
                t: "n"
              };
              v2 = numeral(value).value();
              m2 = SSF.format(ct.fa, v2);
            }
          } else {
            m2 = value.toString();
            ct = {
              fa: "@",
              t: "s"
            };
          }
        } else if (value2.indexOf(",") > -1) {
          var _isThousands = true;
          var _ThousandsArr = value2.split(",");
          for (var _i2 = 1; _i2 < _ThousandsArr.length; _i2 += 1) {
            if (_ThousandsArr[_i2].length < 3) {
              _isThousands = false;
              break;
            }
          }
          if (_isThousands) {
            ct = {
              fa: "#,##0%",
              t: "n"
            };
            v2 = numeral(value).value();
            m2 = SSF.format(ct.fa, v2);
          } else {
            m2 = value.toString();
            ct = {
              fa: "@",
              t: "s"
            };
          }
        } else {
          ct = {
            fa: "0%",
            t: "n"
          };
          v2 = numeral(value).value();
          m2 = SSF.format(ct.fa, v2);
        }
      } else {
        m2 = value.toString();
        ct = {
          fa: "@",
          t: "s"
        };
      }
    } else if (value.toString().indexOf(".") > -1) {
      if (value.toString().indexOf(".") === value.toString().lastIndexOf(".")) {
        var value1 = value.toString().split(".")[0];
        var _value = value.toString().split(".")[1];
        var _len = _value.length;
        if (_len > 9) {
          _len = 9;
        }
        if (value1.indexOf(",") > -1) {
          var _isThousands2 = true;
          var _ThousandsArr2 = value1.split(",");
          for (var _i3 = 1; _i3 < _ThousandsArr2.length; _i3 += 1) {
            if (!isRealNum(_ThousandsArr2[_i3]) || _ThousandsArr2[_i3].length < 3) {
              _isThousands2 = false;
              break;
            }
          }
          if (_isThousands2) {
            ct = {
              fa: "#,##0.".concat(new Array(_len + 1).join("0")),
              t: "n"
            };
            v2 = numeral(value).value();
            m2 = SSF.format(ct.fa, v2);
          } else {
            m2 = value.toString();
            ct = {
              fa: "@",
              t: "s"
            };
          }
        } else {
          if (isRealNum(value1) && isRealNum(_value)) {
            ct = {
              fa: "0.".concat(new Array(_len + 1).join("0")),
              t: "n"
            };
            v2 = numeral(value).value();
            m2 = SSF.format(ct.fa, v2);
          } else {
            m2 = value.toString();
            ct = {
              fa: "@",
              t: "s"
            };
          }
        }
      } else {
        m2 = value.toString();
        ct = {
          fa: "@",
          t: "s"
        };
      }
    } else if (isRealNum(value)) {
      m2 = parseFloat(value).toString();
      ct = {
        fa: "General",
        t: "n"
      };
      v2 = parseFloat(value);
    } else if (isdatetime(value) && (value.toString().indexOf(".") > -1 || value.toString().indexOf(":") > -1 || value.toString().length < 16)) {
      v2 = datenum_local(parseDate(value.toString().replace(/-/g, "/")));
      if (v2.toString().indexOf(".") > -1) {
        if (value.toString().length > 18) {
          ct.fa = "yyyy-MM-dd hh:mm:ss";
        } else if (value.toString().length > 11) {
          ct.fa = "yyyy-MM-dd hh:mm";
        } else {
          ct.fa = "yyyy-MM-dd";
        }
      } else {
        ct.fa = "yyyy-MM-dd";
      }
      ct.t = "d";
      m2 = SSF.format(ct.fa, v2);
    } else {
      m2 = value;
      ct.fa = "General";
      ct.t = "g";
    }
    return [m2, ct, v2];
  }
  function update(fmt, v2) {
    return SSF.format(fmt, v2);
  }
  function is_date(fmt, v2) {
    return SSF.is_date(fmt, v2);
  }
  function fuzzynum(s2) {
    var v2 = Number(s2);
    if (typeof s2 === "number") {
      return s2;
    }
    if (!Number.isNaN(v2)) return v2;
    var wt = 1;
    var ss = s2.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
      wt *= 100;
      return "";
    });
    v2 = Number(ss);
    if (!Number.isNaN(v2)) return v2 / wt;
    ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
      wt = -wt;
      return $1;
    });
    v2 = Number(ss);
    if (!Number.isNaN(v2)) return v2 / wt;
    return v2;
  }
  function valueShowEs(r2, c2, d2) {
    var value = getCellValue(r2, c2, d2, "m");
    if (value == null) {
      value = getCellValue(r2, c2, d2, "v");
    } else {
      var _d$r, _d$r$c, _d$r$c$ct, _d$r2, _d$r2$c, _d$r2$c$ct;
      if (!Number.isNaN(fuzzynum(value))) {
        if (_$1.isString(value) && value.indexOf("%") > -1) ;
        else {
          value = getCellValue(r2, c2, d2, "v");
        }
      } else if (((_d$r = d2[r2]) === null || _d$r === void 0 ? void 0 : (_d$r$c = _d$r[c2]) === null || _d$r$c === void 0 ? void 0 : (_d$r$c$ct = _d$r$c.ct) === null || _d$r$c$ct === void 0 ? void 0 : _d$r$c$ct.t) === "d") ;
      else if (((_d$r2 = d2[r2]) === null || _d$r2 === void 0 ? void 0 : (_d$r2$c = _d$r2[c2]) === null || _d$r2$c === void 0 ? void 0 : (_d$r2$c$ct = _d$r2$c.ct) === null || _d$r2$c$ct === void 0 ? void 0 : _d$r2$c$ct.t) === "b") ;
      else {
        value = getCellValue(r2, c2, d2, "v");
      }
    }
    return value;
  }
  var colors = ["#c1232b", "#27727b", "#fcce10", "#e87c25", "#b5c334", "#fe8463", "#9bca63", "#fad860", "#f3a43b", "#60c0dd", "#d7504b", "#c6e579", "#f4e001", "#f0805a", "#26c0c0", "#c12e34", "#e6b600", "#0098d9", "#2b821d", "#005eaa", "#339ca8", "#cda819", "#32a487", "#3fb1e3", "#6be6c1", "#626c91", "#a0a7e6", "#c4ebad", "#96dee8"];
  function mousePosition(x2, y2, ctx) {
    var newX = x2 - ctx.rowHeaderWidth;
    var newY = y2 - ctx.toolbarHeight - ctx.calculatebarHeight - ctx.columnHeaderHeight;
    return [newX, newY];
  }
  function rowLocationByIndex(row_index, visibleRow) {
    var row = 0;
    var row_pre = 0;
    row = visibleRow[row_index];
    if (row_index === 0) {
      row_pre = 0;
    } else {
      row_pre = visibleRow[row_index - 1];
    }
    return [row_pre, row, row_index];
  }
  function rowLocation(y2, visibleRow) {
    var row_index = _$1.sortedIndex(visibleRow, y2);
    if (row_index >= visibleRow.length && y2 > 0) {
      row_index = visibleRow.length - 1;
    } else if (row_index === -1 && y2 <= 0) {
      row_index = 0;
    }
    return rowLocationByIndex(row_index, visibleRow);
  }
  function colLocationByIndex(col_index, visibleCol) {
    var col = 0;
    var col_pre = 0;
    col = visibleCol[col_index];
    if (col_index === 0) {
      col_pre = 0;
    } else {
      col_pre = visibleCol[col_index - 1];
    }
    return [col_pre, col, col_index];
  }
  function colLocation(x2, visibleCol) {
    var col_index = _$1.sortedIndex(visibleCol, x2);
    if (col_index >= visibleCol.length && x2 > 0) {
      col_index = visibleCol.length - 1;
    } else if (col_index === -1 && x2 <= 0) {
      col_index = 0;
    }
    return colLocationByIndex(col_index, visibleCol);
  }
  var functionHTMLIndex = 0;
  var rangeIndexes = [];
  var operatorPriority = {
    "^": 0,
    "%": 1,
    "*": 1,
    "/": 1,
    "+": 2,
    "-": 2
  };
  var operatorArr = "==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^".split("|");
  var operatorjson = {};
  for (var i$1 = 0; i$1 < operatorArr.length; i$1 += 1) {
    operatorjson[operatorArr[i$1].toString()] = 1;
  }
  var simpleSheetName = "[A-Za-z0-9_À-ʯ]+";
  var quotedSheetName = "'(?:(?!').|'')*'";
  var sheetNameRegexp = "(".concat(simpleSheetName, "|").concat(quotedSheetName, ")!");
  var rowColumnRegexp = "[$]?[A-Za-z]+[$]?[0-9]+";
  var rowColumnWithSheetName = "(?:".concat(sheetNameRegexp, ")?(").concat(rowColumnRegexp, ")");
  var LABEL_EXTRACT_REGEXP = new RegExp("^".concat(rowColumnWithSheetName, "(?:[:]").concat(rowColumnWithSheetName, ")?$"));
  var FormulaCache = /* @__PURE__ */ function() {
    function FormulaCache2() {
      _classCallCheck(this, FormulaCache2);
      this.parser = void 0;
      this.func_selectedrange = void 0;
      this.data_parm_index = void 0;
      this.cellTextToIndexList = void 0;
      this.rangechangeindex = void 0;
      this.selectingRangeIndex = void 0;
      this.rangeResizeObj = void 0;
      this.rangeResize = void 0;
      this.rangeResizeIndex = void 0;
      this.rangeResizexy = void 0;
      this.rangeResizeWinH = void 0;
      this.rangeResizeWinW = void 0;
      this.rangeResizeTo = void 0;
      this.rangeSetValueTo = void 0;
      this.rangeIndex = void 0;
      this.rangestart = void 0;
      this.rangetosheet = void 0;
      this.rangedrag_column_start = void 0;
      this.rangedrag_row_start = void 0;
      this.functionRangeIndex = void 0;
      this.functionlistMap = void 0;
      this.execFunctionExist = void 0;
      this.execFunctionGlobalData = void 0;
      var that = this;
      this.data_parm_index = 0;
      this.selectingRangeIndex = -1;
      this.functionlistMap = {};
      this.execFunctionGlobalData = {};
      this.cellTextToIndexList = {};
      this.parser = new Parser();
      this.parser.on("callCellValue", function(cellCoord, options, done) {
        var _context$formulaCache, _flowdata$cellCoord$r;
        var context = that.parser.context;
        var id2 = cellCoord.sheetName == null ? options.sheetId : getSheetIdByName(context, cellCoord.sheetName);
        if (id2 == null) throw Error(ERROR_REF);
        var flowdata = getFlowdata(context, id2);
        var cell = (context === null || context === void 0 ? void 0 : (_context$formulaCache = context.formulaCache.execFunctionGlobalData) === null || _context$formulaCache === void 0 ? void 0 : _context$formulaCache["".concat(cellCoord.row.index, "_").concat(cellCoord.column.index, "_").concat(id2)]) || (flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$cellCoord$r = flowdata[cellCoord.row.index]) === null || _flowdata$cellCoord$r === void 0 ? void 0 : _flowdata$cellCoord$r[cellCoord.column.index]);
        var v2 = that.tryGetCellAsNumber(cell);
        done(v2);
      });
      this.parser.on("callRangeValue", function(startCellCoord, endCellCoord, options, done) {
        var context = that.parser.context;
        var id2 = startCellCoord.sheetName == null ? options.sheetId : getSheetIdByName(context, startCellCoord.sheetName);
        if (id2 == null) throw Error(ERROR_REF);
        var flowdata = getFlowdata(context, id2);
        var fragment = [];
        var startRow = startCellCoord.row.index;
        var endRow = endCellCoord.row.index;
        var startCol = startCellCoord.column.index;
        var endCol = endCellCoord.column.index;
        var emptyRow = startRow === -1 || endRow === -1;
        var emptyCol = startCol === -1 || endCol === -1;
        if (emptyRow) {
          var _flowdata$length;
          startRow = 0;
          endRow = (_flowdata$length = flowdata === null || flowdata === void 0 ? void 0 : flowdata.length) !== null && _flowdata$length !== void 0 ? _flowdata$length : 0;
        }
        if (emptyCol) {
          var _flowdata$0$length;
          startCol = 0;
          endCol = (_flowdata$0$length = flowdata === null || flowdata === void 0 ? void 0 : flowdata[0].length) !== null && _flowdata$0$length !== void 0 ? _flowdata$0$length : 0;
        }
        if (emptyRow && emptyCol) throw Error(ERROR_REF);
        for (var row = startRow; row <= endRow; row += 1) {
          var colFragment = [];
          for (var col = startCol; col <= endCol; col += 1) {
            var _context$formulaCache2, _flowdata$row;
            var cell = (context === null || context === void 0 ? void 0 : (_context$formulaCache2 = context.formulaCache.execFunctionGlobalData) === null || _context$formulaCache2 === void 0 ? void 0 : _context$formulaCache2["".concat(row, "_").concat(col, "_").concat(id2)]) || (flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$row = flowdata[row]) === null || _flowdata$row === void 0 ? void 0 : _flowdata$row[col]);
            var v2 = that.tryGetCellAsNumber(cell);
            colFragment.push(v2);
          }
          fragment.push(colFragment);
        }
        if (fragment) {
          done(fragment);
        }
      });
    }
    _createClass(FormulaCache2, [{
      key: "tryGetCellAsNumber",
      value: function tryGetCellAsNumber(cell) {
        var _cell$ct;
        if ((cell === null || cell === void 0 ? void 0 : (_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : _cell$ct.t) === "n") {
          var n2 = Number(cell === null || cell === void 0 ? void 0 : cell.v);
          return Number.isNaN(n2) ? cell.v : n2;
        }
        return cell === null || cell === void 0 ? void 0 : cell.v;
      }
    }]);
    return FormulaCache2;
  }();
  function parseElement(eleString) {
    return new DOMParser().parseFromString(eleString, "text/html").body.childNodes[0];
  }
  function iscelldata(txt) {
    var val = txt.split("!");
    var rangetxt;
    if (val.length > 1) {
      var _val = _slicedToArray$1(val, 2);
      rangetxt = _val[1];
    } else {
      var _val2 = _slicedToArray$1(val, 1);
      rangetxt = _val2[0];
    }
    var reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g;
    var reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g;
    if (rangetxt.indexOf(":") === -1) {
      var _row = parseInt(rangetxt.replace(/[^0-9]/g, ""), 10) - 1;
      var _col = columnCharToIndex(rangetxt.replace(/[^A-Za-z]/g, ""));
      if (!Number.isNaN(_row) && !Number.isNaN(_col) && rangetxt.toString().match(reg_cell)) {
        return true;
      }
      if (!Number.isNaN(_row)) {
        return false;
      }
      if (!Number.isNaN(_col)) {
        return false;
      }
      return false;
    }
    reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;
    var rangetxtArr = rangetxt.split(":");
    var row = [];
    var col = [];
    row[0] = parseInt(rangetxtArr[0].replace(/[^0-9]/g, ""), 10) - 1;
    row[1] = parseInt(rangetxtArr[1].replace(/[^0-9]/g, ""), 10) - 1;
    if (row[0] > row[1]) {
      return false;
    }
    col[0] = columnCharToIndex(rangetxtArr[0].replace(/[^A-Za-z]/g, ""));
    col[1] = columnCharToIndex(rangetxtArr[1].replace(/[^A-Za-z]/g, ""));
    if (col[0] > col[1]) {
      return false;
    }
    if (rangetxtArr[0].toString().match(reg_cellRange) && rangetxtArr[1].toString().match(reg_cellRange)) {
      return true;
    }
    return false;
  }
  function addToCellIndexList(ctx, txt, infoObj) {
    if (_$1.isNil(txt) || txt.length === 0 || _$1.isNil(infoObj)) {
      return;
    }
    if (_$1.isNil(ctx.formulaCache.cellTextToIndexList)) {
      ctx.formulaCache.cellTextToIndexList = {};
    }
    if (txt.indexOf("!") > -1) {
      txt = txt.replace(/\\'/g, "'").replace(/''/g, "'");
      ctx.formulaCache.cellTextToIndexList[txt] = infoObj;
    } else {
      ctx.formulaCache.cellTextToIndexList["".concat(txt, "_").concat(infoObj.sheetId)] = infoObj;
    }
  }
  function getcellrange(ctx, txt, formulaId) {
    if (_$1.isNil(txt) || txt.length === 0) {
      return null;
    }
    var flowdata = getFlowdata(ctx, formulaId);
    var sheettxt = "";
    var rangetxt = "";
    var sheetId = null;
    var sheetdata = null;
    var luckysheetfile = ctx.luckysheetfile;
    if (txt.indexOf("!") > -1) {
      if (txt in ctx.formulaCache.cellTextToIndexList) {
        return ctx.formulaCache.cellTextToIndexList[txt];
      }
      var matchRes = txt.match(LABEL_EXTRACT_REGEXP);
      if (matchRes == null) {
        return null;
      }
      var _matchRes = _slicedToArray$1(matchRes, 5), sheettxt1 = _matchRes[1], starttxt1 = _matchRes[2], sheettxt2 = _matchRes[3], starttxt2 = _matchRes[4];
      if (sheettxt2 != null && sheettxt1 !== sheettxt2) {
        return null;
      }
      rangetxt = starttxt2 ? "".concat(starttxt1, ":").concat(starttxt2) : starttxt1;
      sheettxt = sheettxt1.replace(/^'|'$/g, "").replace(/\\'/g, "'").replace(/''/g, "'");
      _$1.forEach(luckysheetfile, function(f2) {
        if (sheettxt === f2.name) {
          sheetId = f2.id;
          sheetdata = f2.data;
          return false;
        }
        return true;
      });
    } else {
      var _i = formulaId;
      if (_$1.isNil(_i)) {
        _i = ctx.currentSheetId;
      }
      if ("".concat(txt, "_").concat(_i) in ctx.formulaCache.cellTextToIndexList) {
        return ctx.formulaCache.cellTextToIndexList["".concat(txt, "_").concat(_i)];
      }
      var index2 = getSheetIndex(ctx, _i);
      if (_$1.isNil(index2)) {
        return null;
      }
      sheettxt = luckysheetfile[index2].name;
      sheetId = luckysheetfile[index2].id;
      sheetdata = flowdata;
      rangetxt = txt;
    }
    if (_$1.isNil(sheetdata)) {
      return null;
    }
    if (rangetxt.indexOf(":") === -1) {
      var _row2 = parseInt(rangetxt.replace(/[^0-9]/g, ""), 10) - 1;
      var _col2 = columnCharToIndex(rangetxt.replace(/[^A-Za-z]/g, ""));
      if (!Number.isNaN(_row2) && !Number.isNaN(_col2)) {
        var _item = {
          row: [_row2, _row2],
          column: [_col2, _col2],
          sheetId
        };
        addToCellIndexList(ctx, txt, _item);
        return _item;
      }
      return null;
    }
    var rangetxtArr = rangetxt.split(":");
    var row = [];
    var col = [];
    row[0] = parseInt(rangetxtArr[0].replace(/[^0-9]/g, ""), 10) - 1;
    row[1] = parseInt(rangetxtArr[1].replace(/[^0-9]/g, ""), 10) - 1;
    if (Number.isNaN(row[0])) {
      row[0] = 0;
    }
    if (Number.isNaN(row[1])) {
      row[1] = sheetdata.length - 1;
    }
    if (row[0] > row[1]) {
      return null;
    }
    col[0] = columnCharToIndex(rangetxtArr[0].replace(/[^A-Za-z]/g, ""));
    col[1] = columnCharToIndex(rangetxtArr[1].replace(/[^A-Za-z]/g, ""));
    if (Number.isNaN(col[0])) {
      col[0] = 0;
    }
    if (Number.isNaN(col[1])) {
      col[1] = sheetdata[0].length - 1;
    }
    if (col[0] > col[1]) {
      return null;
    }
    var item = {
      row,
      column: col,
      sheetId
    };
    addToCellIndexList(ctx, txt, item);
    return item;
  }
  function calPostfixExpression(cal) {
    if (cal.length === 0) {
      return "";
    }
    var stack = [];
    for (var _i2 = cal.length - 1; _i2 >= 0; _i2 -= 1) {
      var c2 = cal[_i2];
      if (c2 in operatorjson) {
        var s2 = stack.pop();
        var s1 = stack.pop();
        var str = "luckysheet_compareWith(".concat(s1, ",'").concat(c2, "', ").concat(s2, ")");
        stack.push(str);
      } else {
        stack.push(c2);
      }
    }
    if (stack.length > 0) {
      return stack[0];
    }
    return "";
  }
  function checkSpecialFunctionRange(ctx, function_str, r2, c2, id2, dynamicArray_compute, cellRangeFunction) {
    if (function_str.substring(0, 30) === "luckysheet_getSpecialReference" || function_str.substring(0, 20) === "luckysheet_function.") {
      if (function_str.substring(0, 20) === "luckysheet_function.") {
        var funcName = function_str.split(".")[1];
        if (!_$1.isNil(funcName)) {
          funcName = funcName.toUpperCase();
          if (funcName !== "INDIRECT" && funcName !== "OFFSET" && funcName !== "INDEX") {
            return;
          }
        }
      }
      try {
        ctx.calculateSheetId = id2;
        var str = function_str.split(",")[function_str.split(",").length - 1].split("'")[1].split("'")[0];
        var str_nb = _$1.trim(str);
        if (iscelldata(str_nb)) {
          if (typeof cellRangeFunction === "function") {
            cellRangeFunction(str_nb);
          }
        }
      } catch (_unused) {
      }
    }
  }
  function isFunctionRange(ctx, txt, r2, c2, id2, dynamicArray_compute, cellRangeFunction) {
    if (txt.substring(0, 1) === "=") {
      txt = txt.substring(1);
    }
    var funcstack = txt.split("");
    var i2 = 0;
    var str = "";
    var function_str = "";
    var matchConfig = {
      squote: 0,
      dquote: 0,
      braces: 0
    };
    var cal1 = [];
    var cal2 = [];
    var bracket = [];
    while (i2 < funcstack.length) {
      var s2 = funcstack[i2];
      if (s2 === "(" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        if (str.length > 0 && bracket.length === 0) {
          str = str.toUpperCase();
          if (str.indexOf(":") > -1) {
            var funcArray = str.split(":");
            function_str += "luckysheet_getSpecialReference(true,'".concat(_$1.trim(funcArray[0]).replace(/'/g, "\\'"), "', luckysheet_function.").concat(funcArray[1], ".f(#lucky#");
          } else {
            function_str += "luckysheet_function.".concat(str, ".f(");
          }
          bracket.push(1);
          str = "";
        } else if (bracket.length === 0) {
          function_str += "(";
          bracket.push(0);
          str = "";
        } else {
          bracket.push(0);
          str += s2;
        }
      } else if (s2 === ")" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        bracket.pop();
        if (bracket.length === 0) {
          var functionS = isFunctionRange(ctx, str, r2, c2, id2, dynamicArray_compute, cellRangeFunction);
          if (functionS.indexOf("#lucky#") > -1) {
            functionS = "".concat(functionS.replace(/#lucky#/g, ""), ")");
          }
          function_str += "".concat(functionS, ")");
          str = "";
        } else {
          str += s2;
        }
      } else if (s2 === "{" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
        str += "{";
        matchConfig.braces += 1;
      } else if (s2 === "}" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
        str += "}";
        matchConfig.braces -= 1;
      } else if (s2 === '"' && matchConfig.squote === 0) {
        if (matchConfig.dquote > 0) {
          if (i2 < funcstack.length - 1 && funcstack[i2 + 1] === '"') {
            i2 += 1;
            str += "";
          } else {
            matchConfig.dquote -= 1;
            str += '"';
          }
        } else {
          matchConfig.dquote += 1;
          str += '"';
        }
      } else if (s2 === "'" && matchConfig.dquote === 0) {
        str += "'";
        if (matchConfig.squote > 0) {
          if (i2 < funcstack.length - 1 && funcstack[i2 + 1] === "'") {
            i2 += 1;
            str += "'";
          } else {
            matchConfig.squote -= 1;
          }
        } else {
          matchConfig.squote += 1;
        }
      } else if (s2 === "," && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        if (bracket.length <= 1) {
          var _functionS = isFunctionRange(ctx, str, r2, c2, id2, dynamicArray_compute, cellRangeFunction);
          if (_functionS.indexOf("#lucky#") > -1) {
            _functionS = "".concat(_functionS.replace(/#lucky#/g, ""), ")");
          }
          function_str += "".concat(_functionS, ",");
          str = "";
        } else {
          str += ",";
        }
      } else if (s2 in operatorjson && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        var s_next = "";
        var op = operatorPriority;
        if (i2 + 1 < funcstack.length) {
          s_next = funcstack[i2 + 1];
        }
        if (s2 + s_next in operatorjson) {
          if (bracket.length === 0) {
            if (_$1.trim(str).length > 0) {
              cal2.unshift(isFunctionRange(ctx, _$1.trim(str), r2, c2, id2, dynamicArray_compute, cellRangeFunction));
            } else if (_$1.trim(function_str).length > 0) {
              cal2.unshift(_$1.trim(function_str));
            }
            if (cal1[0] in operatorjson) {
              var stackCeilPri = op[cal1[0]];
              while (cal1.length > 0 && !_$1.isNil(stackCeilPri)) {
                cal2.unshift(cal1.shift());
                stackCeilPri = op[cal1[0]];
              }
            }
            cal1.unshift(s2 + s_next);
            function_str = "";
            str = "";
          } else {
            str += s2 + s_next;
          }
          i2 += 1;
        } else {
          if (bracket.length === 0) {
            if (_$1.trim(str).length > 0) {
              cal2.unshift(isFunctionRange(ctx, _$1.trim(str), r2, c2, id2, dynamicArray_compute, cellRangeFunction));
            } else if (_$1.trim(function_str).length > 0) {
              cal2.unshift(_$1.trim(function_str));
            }
            if (cal1[0] in operatorjson) {
              var _stackCeilPri = op[cal1[0]];
              _stackCeilPri = _$1.isNil(_stackCeilPri) ? 1e3 : _stackCeilPri;
              var sPri = op[s2];
              sPri = _$1.isNil(sPri) ? 1e3 : sPri;
              while (cal1.length > 0 && sPri >= _stackCeilPri) {
                cal2.unshift(cal1.shift());
                _stackCeilPri = op[cal1[0]];
                _stackCeilPri = _$1.isNil(_stackCeilPri) ? 1e3 : _stackCeilPri;
              }
            }
            cal1.unshift(s2);
            function_str = "";
            str = "";
          } else {
            str += s2;
          }
        }
      } else {
        if (matchConfig.dquote === 0 && matchConfig.squote === 0) {
          str += _$1.trim(s2);
        } else {
          str += s2;
        }
      }
      if (i2 === funcstack.length - 1) {
        var endstr = "";
        var str_nb = _$1.trim(str).replace(/'/g, "\\'");
        if (iscelldata(str_nb) && str_nb.substring(0, 1) !== ":") {
          endstr = "luckysheet_getcelldata('".concat(str_nb, "')");
        } else if (str_nb.substring(0, 1) === ":") {
          str_nb = str_nb.substring(1);
          if (iscelldata(str_nb)) {
            endstr = "luckysheet_getSpecialReference(false,".concat(function_str, ",'").concat(str_nb, "')");
          }
        } else {
          str = _$1.trim(str);
          var regx = /{.*?}/;
          if (regx.test(str) && str.substring(0, 1) !== '"' && str.substring(str.length - 1, 1) !== '"') {
            var _regx$exec;
            var arraytxt = (_regx$exec = regx.exec(str)) === null || _regx$exec === void 0 ? void 0 : _regx$exec[0];
            var arraystart = str.search(regx);
            if (arraystart > 0) {
              endstr += str.substring(0, arraystart);
            }
            endstr += "luckysheet_getarraydata('".concat(arraytxt, "')");
            if (arraystart + arraytxt.length < str.length) {
              endstr += str.substring(arraystart + arraytxt.length, str.length);
            }
          } else {
            endstr = str;
          }
        }
        if (endstr.length > 0) {
          cal2.unshift(endstr);
        }
        if (cal1.length > 0) {
          if (function_str.length > 0) {
            cal2.unshift(function_str);
            function_str = "";
          }
          while (cal1.length > 0) {
            cal2.unshift(cal1.shift());
          }
        }
        if (cal2.length > 0) {
          function_str = calPostfixExpression(cal2);
        } else {
          function_str += endstr;
        }
      }
      i2 += 1;
    }
    checkSpecialFunctionRange(ctx, function_str, r2, c2, id2, dynamicArray_compute, cellRangeFunction);
    return function_str;
  }
  function getAllFunctionGroup(ctx) {
    var luckysheetfile = ctx.luckysheetfile;
    var ret = [];
    for (var _i3 = 0; _i3 < luckysheetfile.length; _i3 += 1) {
      var file = luckysheetfile[_i3];
      var calcChain = file.calcChain;
      var dynamicArray_compute = file.dynamicArray_compute;
      if (_$1.isNil(calcChain)) {
        calcChain = [];
      }
      if (_$1.isNil(dynamicArray_compute)) {
        dynamicArray_compute = [];
      }
      ret = ret.concat(calcChain);
      for (var j2 = 0; j2 < dynamicArray_compute.length; j2 += 1) {
        var d2 = dynamicArray_compute[0];
        ret.push({
          r: d2.r,
          c: d2.c,
          id: d2.id
        });
      }
    }
    return ret;
  }
  function delFunctionGroup(ctx, r2, c2, id2) {
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    var file = ctx.luckysheetfile[getSheetIndex(ctx, id2)];
    var calcChain = file.calcChain;
    if (!_$1.isNil(calcChain)) {
      var modified = false;
      var calcChainClone = _$1.cloneDeep(calcChain);
      for (var _i4 = 0; _i4 < calcChainClone.length; _i4 += 1) {
        var calc = calcChainClone[_i4];
        if (calc.r === r2 && calc.c === c2 && calc.id === id2) {
          calcChainClone.splice(_i4, 1);
          modified = true;
          break;
        }
      }
      if (modified) {
        file.calcChain = calcChainClone;
      }
    }
    var dynamicArray = file.dynamicArray;
    if (!_$1.isNil(dynamicArray)) {
      var _modified = false;
      var dynamicArrayClone = _$1.cloneDeep(dynamicArray);
      for (var _i5 = 0; _i5 < dynamicArrayClone.length; _i5 += 1) {
        var _calc = dynamicArrayClone[_i5];
        if (_calc.r === r2 && _calc.c === c2 && (_$1.isNil(_calc.id) || _calc.id === id2)) {
          dynamicArrayClone.splice(_i5, 1);
          _modified = true;
          break;
        }
      }
      if (_modified) {
        file.dynamicArray = dynamicArrayClone;
      }
    }
  }
  function checkBracketNum(fp) {
    var bra_l = fp.match(/\(/g);
    var bra_r = fp.match(/\)/g);
    var bra_tl_txt = fp.match(/(['"])(?:(?!\1).)*?\1/g);
    var bra_tr_txt = fp.match(/(['"])(?:(?!\1).)*?\1/g);
    var bra_l_len = 0;
    var bra_r_len = 0;
    if (!_$1.isNil(bra_l)) {
      bra_l_len += bra_l.length;
    }
    if (!_$1.isNil(bra_r)) {
      bra_r_len += bra_r.length;
    }
    var bra_tl_len = 0;
    var bra_tr_len = 0;
    if (!_$1.isNil(bra_tl_txt)) {
      for (var _i6 = 0; _i6 < bra_tl_txt.length; _i6 += 1) {
        var bra_tl = bra_tl_txt[_i6].match(/\(/g);
        if (!_$1.isNil(bra_tl)) {
          bra_tl_len += bra_tl.length;
        }
      }
    }
    if (!_$1.isNil(bra_tr_txt)) {
      for (var _i7 = 0; _i7 < bra_tr_txt.length; _i7 += 1) {
        var bra_tr = bra_tr_txt[_i7].match(/\)/g);
        if (!_$1.isNil(bra_tr)) {
          bra_tr_len += bra_tr.length;
        }
      }
    }
    bra_l_len -= bra_tl_len;
    bra_r_len -= bra_tr_len;
    if (bra_l_len !== bra_r_len) {
      return false;
    }
    return true;
  }
  function insertUpdateFunctionGroup(ctx, r2, c2, id2) {
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    var luckysheetfile = ctx.luckysheetfile;
    var idx = getSheetIndex(ctx, id2);
    if (_$1.isNil(idx)) {
      return;
    }
    var file = luckysheetfile[idx];
    var calcChain = file.calcChain;
    if (_$1.isNil(calcChain)) {
      calcChain = [];
    }
    for (var _i8 = 0; _i8 < calcChain.length; _i8 += 1) {
      var calc = calcChain[_i8];
      if (calc.r === r2 && calc.c === c2 && calc.id === id2) {
        return;
      }
    }
    var cc2 = {
      r: r2,
      c: c2,
      id: id2
    };
    calcChain.push(cc2);
    file.calcChain = calcChain;
    ctx.luckysheetfile = luckysheetfile;
  }
  function execfunction(ctx, txt, r2, c2, id2, isrefresh, notInsertFunc) {
    if (txt.indexOf(error.r) > -1) {
      return [false, error.r, txt];
    }
    if (!checkBracketNum(txt)) {
      txt += ")";
    }
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    ctx.calculateSheetId = id2;
    ctx.formulaCache.parser.context = ctx;
    var _ctx$formulaCache$par = ctx.formulaCache.parser.parse(txt.substring(1), {
      sheetId: id2 || ctx.currentSheetId
    }), result = _ctx$formulaCache$par.result, formulaError = _ctx$formulaCache$par.error;
    if (!_$1.isNil(r2) && !_$1.isNil(c2)) {
      if (isrefresh) {
        execFunctionGroup(ctx, r2, c2, _$1.isNil(formulaError) ? result : formulaError, id2);
      }
      {
        insertUpdateFunctionGroup(ctx, r2, c2, id2);
      }
    }
    return [true, _$1.isNil(formulaError) ? result : formulaError, txt];
  }
  function insertUpdateDynamicArray(ctx, dynamicArrayItem) {
    var r2 = dynamicArrayItem.r, c2 = dynamicArrayItem.c;
    var id2 = dynamicArrayItem.id;
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    var luckysheetfile = ctx.luckysheetfile;
    var idx = getSheetIndex(ctx, id2);
    if (idx == null) return [];
    var file = luckysheetfile[idx];
    var dynamicArray = file.dynamicArray;
    if (_$1.isNil(dynamicArray)) {
      dynamicArray = [];
    }
    for (var _i9 = 0; _i9 < dynamicArray.length; _i9 += 1) {
      var calc = dynamicArray[_i9];
      if (calc.r === r2 && calc.c === c2 && calc.id === id2) {
        calc.data = dynamicArrayItem.data;
        calc.f = dynamicArrayItem.f;
        return dynamicArray;
      }
    }
    dynamicArray.push(dynamicArrayItem);
    return dynamicArray;
  }
  function groupValuesRefresh(ctx) {
    var luckysheetfile = ctx.luckysheetfile;
    if (ctx.groupValuesRefreshData.length > 0) {
      for (var _i10 = 0; _i10 < ctx.groupValuesRefreshData.length; _i10 += 1) {
        var item = ctx.groupValuesRefreshData[_i10];
        var idx = getSheetIndex(ctx, item.id);
        if (idx == null) continue;
        var file = luckysheetfile[idx];
        var data = file.data;
        if (_$1.isNil(data)) {
          continue;
        }
        var updateValue = {};
        if (!_$1.isNil(item.spe)) {
          if (item.spe.type === "sparklines") {
            updateValue.spl = item.spe.data;
          } else if (item.spe.type === "dynamicArrayItem") {
            file.dynamicArray = insertUpdateDynamicArray(ctx, item.spe.data);
          }
        }
        updateValue.v = item.v;
        updateValue.f = item.f;
        setCellValue(ctx, item.r, item.c, data, updateValue);
      }
      ctx.groupValuesRefreshData = [];
    }
  }
  function execFunctionGroup(ctx, origin_r, origin_c, value, id2, data) {
    var isForce = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    if (_$1.isNil(data)) {
      data = getFlowdata(ctx);
    }
    if (_$1.isNil(ctx.formulaCache.execFunctionGlobalData)) {
      ctx.formulaCache.execFunctionGlobalData = {};
    }
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    if (!_$1.isNil(value)) {
      var cellCache = [[{
        v: void 0
      }]];
      setCellValue(ctx, 0, 0, cellCache, value);
      var _cellCache$ = _slicedToArray$1(cellCache[0], 1);
      ctx.formulaCache.execFunctionGlobalData["".concat(origin_r, "_").concat(origin_c, "_").concat(id2)] = _cellCache$[0];
    }
    var calcChains = getAllFunctionGroup(ctx);
    var formulaObjects = {};
    var sheets = ctx.luckysheetfile;
    var sheetData = {};
    for (var _i11 = 0; _i11 < sheets.length; _i11 += 1) {
      var sheet = sheets[_i11];
      sheetData[sheet.id] = sheet.data;
    }
    var updateValueOjects = {};
    var updateValueArray = [];
    if (_$1.isNil(ctx.formulaCache.execFunctionExist)) {
      var key = "r".concat(origin_r, "c").concat(origin_c, "i").concat(id2);
      updateValueOjects[key] = 1;
    } else {
      for (var x2 = 0; x2 < ctx.formulaCache.execFunctionExist.length; x2 += 1) {
        var cell = ctx.formulaCache.execFunctionExist[x2];
        var _key = "r".concat(cell.r, "c").concat(cell.c, "i").concat(cell.i);
        updateValueOjects[_key] = 1;
      }
    }
    var arrayMatchCache = {};
    var arrayMatch = function arrayMatch2(formulaArray, _formulaObjects, _updateValueOjects, func2) {
      for (var a2 = 0; a2 < formulaArray.length; a2 += 1) {
        var range = formulaArray[a2];
        var cacheKey = "r".concat(range.row[0]).concat(range.row[1], "c").concat(range.column[0]).concat(range.column[1], "id").concat(range.sheetId);
        if (cacheKey in arrayMatchCache) {
          var amc = arrayMatchCache[cacheKey];
          amc.forEach(function(item) {
            func2(item.key, item.r, item.c, item.sheetId);
          });
        } else {
          var functionArr = [];
          for (var r2 = range.row[0]; r2 <= range.row[1]; r2 += 1) {
            for (var c2 = range.column[0]; c2 <= range.column[1]; c2 += 1) {
              var _key2 = "r".concat(r2, "c").concat(c2, "i").concat(range.sheetId);
              func2(_key2, r2, c2, range.sheetId);
              if (_formulaObjects && _key2 in _formulaObjects || _updateValueOjects && _key2 in _updateValueOjects) {
                functionArr.push({
                  key: _key2,
                  r: r2,
                  c: c2,
                  sheetId: range.sheetId
                });
              }
            }
          }
          if (_formulaObjects || _updateValueOjects) {
            arrayMatchCache[cacheKey] = functionArr;
          }
        }
      }
    };
    var _loop = function _loop3(_i122) {
      var formulaCell2 = calcChains[_i122];
      var key2 = "r".concat(formulaCell2.r, "c").concat(formulaCell2.c, "i").concat(formulaCell2.id);
      var calc_funcStr2 = getcellFormula(ctx, formulaCell2.r, formulaCell2.c, formulaCell2.id);
      if (_$1.isNil(calc_funcStr2)) {
        return "continue";
      }
      var txt1 = calc_funcStr2.toUpperCase();
      var isOffsetFunc = txt1.indexOf("INDIRECT(") > -1 || txt1.indexOf("OFFSET(") > -1 || txt1.indexOf("INDEX(") > -1;
      var formulaArray = [];
      if (isOffsetFunc) {
        isFunctionRange(ctx, calc_funcStr2, null, null, formulaCell2.id, null, function(str_nb) {
          var range2 = getcellrange(ctx, _$1.trim(str_nb), formulaCell2.id);
          if (!_$1.isNil(range2)) {
            formulaArray.push(range2);
          }
        });
      } else if (!(calc_funcStr2.substring(0, 2) === '="' && calc_funcStr2.substring(calc_funcStr2.length - 1, 1) === '"')) {
        var point = 0;
        var squote = -1;
        var dquote = -1;
        var formulaTextArray = [];
        var sq_end_array = [];
        var calc_funcStr_length = calc_funcStr2.length;
        for (var j2 = 0; j2 < calc_funcStr_length; j2 += 1) {
          var char = calc_funcStr2.charAt(j2);
          if (char === "'" && dquote === -1) {
            if (squote === -1) {
              if (point !== j2) {
                formulaTextArray.push.apply(formulaTextArray, _toConsumableArray$1(calc_funcStr2.substring(point, j2).split(/==|!=|<>|<=|>=|[,()=+-/*%&^><]/)));
              }
              squote = j2;
              point = j2;
            } else {
              if (j2 < calc_funcStr_length - 1 && calc_funcStr2.charAt(j2 + 1) === "'") {
                j2 += 1;
              } else {
                point = j2 + 1;
                formulaTextArray.push(calc_funcStr2.substring(squote, point));
                sq_end_array.push(formulaTextArray.length - 1);
                squote = -1;
              }
            }
          }
          if (char === '"' && squote === -1) {
            if (dquote === -1) {
              if (point !== j2) {
                formulaTextArray.push.apply(formulaTextArray, _toConsumableArray$1(calc_funcStr2.substring(point, j2).split(/==|!=|<>|<=|>=|[,()=+-/*%&^><]/)));
              }
              dquote = j2;
              point = j2;
            } else {
              if (j2 < calc_funcStr_length - 1 && calc_funcStr2.charAt(j2 + 1) === '"') {
                j2 += 1;
              } else {
                point = j2 + 1;
                formulaTextArray.push(calc_funcStr2.substring(dquote, point));
                dquote = -1;
              }
            }
          }
        }
        if (point !== calc_funcStr_length) {
          formulaTextArray.push.apply(formulaTextArray, _toConsumableArray$1(calc_funcStr2.substring(point, calc_funcStr_length).split(/==|!=|<>|<=|>=|[,()=+-/*%&^><]/)));
        }
        for (var _j = sq_end_array.length - 1; _j >= 0; _j -= 1) {
          if (sq_end_array[_j] !== formulaTextArray.length - 1) {
            formulaTextArray[sq_end_array[_j]] += formulaTextArray[sq_end_array[_j] + 1];
            formulaTextArray.splice(sq_end_array[_j] + 1, 1);
          }
        }
        for (var _j2 = 0; _j2 < formulaTextArray.length; _j2 += 1) {
          var t2 = formulaTextArray[_j2];
          if (t2.length <= 1) {
            continue;
          }
          if (t2.substring(0, 1) === '"' && t2.substring(t2.length - 1, 1) === '"' || !iscelldata(t2)) {
            continue;
          }
          var range = getcellrange(ctx, _$1.trim(t2), formulaCell2.id);
          if (_$1.isNil(range)) {
            continue;
          }
          formulaArray.push(range);
        }
      }
      var item = {
        formulaArray,
        calc_funcStr: calc_funcStr2,
        key: key2,
        r: formulaCell2.r,
        c: formulaCell2.c,
        id: formulaCell2.id,
        parents: {},
        chidren: {},
        color: "w"
      };
      formulaObjects[key2] = item;
    };
    for (var _i12 = 0; _i12 < calcChains.length; _i12 += 1) {
      var _ret = _loop(_i12);
      if (_ret === "continue") continue;
    }
    Object.keys(formulaObjects).forEach(function(key2) {
      var formulaObject = formulaObjects[key2];
      arrayMatch(formulaObject.formulaArray, formulaObjects, updateValueOjects, function(childKey) {
        if (childKey in formulaObjects) {
          var childFormulaObject = formulaObjects[childKey];
          formulaObject.chidren[childKey] = 1;
          childFormulaObject.parents[key2] = 1;
        }
        if (!isForce && childKey in updateValueOjects) {
          updateValueArray.push(formulaObject);
        }
      });
      if (isForce) {
        updateValueArray.push(formulaObject);
      }
    });
    var formulaRunList = [];
    var stack = updateValueArray;
    var existsFormulaRunList = {};
    var _loop2 = function _loop22() {
      var formulaObject = stack.pop();
      if (_$1.isNil(formulaObject) || formulaObject.key in existsFormulaRunList) {
        return "continue";
      }
      if (formulaObject.color === "b") {
        formulaRunList.push(formulaObject);
        existsFormulaRunList[formulaObject.key] = 1;
        return "continue";
      }
      var cacheStack = [];
      Object.keys(formulaObject.parents).forEach(function(parentKey) {
        var parentFormulaObject = formulaObjects[parentKey];
        if (!_$1.isNil(parentFormulaObject)) {
          cacheStack.push(parentFormulaObject);
        }
      });
      if (cacheStack.length === 0) {
        formulaRunList.push(formulaObject);
        existsFormulaRunList[formulaObject.key] = 1;
      } else {
        formulaObject.color = "b";
        stack.push(formulaObject);
        stack = stack.concat(cacheStack);
      }
    };
    while (stack.length > 0) {
      var _ret2 = _loop2();
      if (_ret2 === "continue") continue;
    }
    formulaRunList.reverse();
    for (var _i13 = 0; _i13 < formulaRunList.length; _i13 += 1) {
      var formulaCell = formulaRunList[_i13];
      if (formulaCell.level === Math.max) {
        continue;
      }
      var calc_funcStr = formulaCell.calc_funcStr;
      var v2 = execfunction(ctx, calc_funcStr, formulaCell.r, formulaCell.c, formulaCell.id);
      ctx.groupValuesRefreshData.push({
        r: formulaCell.r,
        c: formulaCell.c,
        v: v2[1],
        f: v2[2],
        spe: v2[3],
        id: formulaCell.id
      });
      ctx.formulaCache.execFunctionGlobalData["".concat(formulaCell.r, "_").concat(formulaCell.c, "_").concat(formulaCell.id)] = {
        v: v2[1],
        f: v2[2]
      };
    }
    ctx.formulaCache.execFunctionExist = void 0;
  }
  function findrangeindex(ctx, v2, vp) {
    var re2 = /<span.*?>/g;
    var v_a = v2.replace(re2, "").split("</span>");
    var vp_a = vp.replace(re2, "").split("</span>");
    v_a.pop();
    if (vp_a[vp_a.length - 1] === "") vp_a.pop();
    var pfri = ctx.formulaCache.functionRangeIndex;
    if (pfri == null) return [];
    var vplen = vp_a.length;
    var vlen = v_a.length;
    if (vplen === vlen) {
      var _i14 = pfri[0];
      var p2 = vp_a[_i14];
      var n2 = v_a[_i14];
      if (_$1.isNil(p2)) {
        if (vp_a.length <= _i14) {
          pfri = [vp_a.length - 1, vp_a.length - 1];
        } else if (v_a.length <= _i14) {
          pfri = [v_a.length - 1, v_a.length - 1];
        }
        return pfri;
      }
      if (p2.length === n2.length) {
        if (!_$1.isNil(vp_a[_i14 + 1]) && !_$1.isNil(v_a[_i14 + 1]) && vp_a[_i14 + 1].length < v_a[_i14 + 1].length) {
          pfri[0] += 1;
          pfri[1] = 1;
        }
        return pfri;
      }
      if (p2.length > n2.length) {
        if (!_$1.isNil(p2) && !_$1.isNil(v_a[_i14 + 1]) && v_a[_i14 + 1].substring(0, 1) === '"' && (p2.indexOf("{") > -1 || p2.indexOf("}") > -1)) {
          pfri[0] += 1;
          pfri[1] = 1;
        }
        return pfri;
      }
      if (p2.length < n2.length) {
        if (pfri[1] > n2.length) {
          pfri[1] = n2.length;
        }
        return pfri;
      }
    } else if (vplen > vlen) {
      var _i15 = pfri[0];
      var _p = vp_a[_i15];
      var _n = v_a[_i15];
      if (_$1.isNil(_n)) {
        if (v_a[_i15 - 1].indexOf("{") > -1) {
          pfri[0] -= 1;
          var start = v_a[_i15 - 1].search("{");
          pfri[1] += start;
        } else {
          pfri[0] = 0;
          pfri[1] = 0;
        }
      } else if (_p.length === _n.length) {
        if (!_$1.isNil(v_a[_i15 + 1]) && (v_a[_i15 + 1].substring(0, 1) === '"' || v_a[_i15 + 1].substring(0, 1) === "{" || v_a[_i15 + 1].substring(0, 1) === "}")) {
          pfri[0] += 1;
          pfri[1] = 1;
        } else if (!_$1.isNil(_p) && _p.length > 2 && _p.substring(0, 1) === '"' && _p.substring(_p.length - 1, 1) === '"') ;
        else if (!_$1.isNil(v_a[_i15]) && v_a[_i15] === '")') {
          pfri[1] = 1;
        } else if (!_$1.isNil(v_a[_i15]) && v_a[_i15] === '"}') {
          pfri[1] = 1;
        } else if (!_$1.isNil(v_a[_i15]) && v_a[_i15] === "{)") {
          pfri[1] = 1;
        } else {
          pfri[1] = _n.length;
        }
        return pfri;
      } else if (_p.length > _n.length) {
        if (!_$1.isNil(v_a[_i15 + 1]) && (v_a[_i15 + 1].substring(0, 1) === '"' || v_a[_i15 + 1].substring(0, 1) === "{" || v_a[_i15 + 1].substring(0, 1) === "}")) {
          pfri[0] += 1;
          pfri[1] = 1;
        }
        return pfri;
      } else if (_p.length < _n.length) {
        return pfri;
      }
      return pfri;
    } else if (vplen < vlen) {
      var _i16 = pfri[0];
      var _p2 = vp_a[_i16];
      var _n2 = v_a[_i16];
      if (_$1.isNil(_p2)) {
        pfri[0] = v_a.length - 1;
        if (!_$1.isNil(_n2)) {
          pfri[1] = _n2.length;
        } else {
          pfri[1] = 1;
        }
      } else if (_p2.length === _n2.length) {
        if (vp_a[_i16 + 1] != null && (vp_a[_i16 + 1].substring(0, 1) === '"' || vp_a[_i16 + 1].substring(0, 1) === "{" || vp_a[_i16 + 1].substring(0, 1) === "}")) {
          pfri[1] = _n2.length;
        } else if (!_$1.isNil(v_a[_i16 + 1]) && v_a[_i16 + 1].substring(0, 1) === '"' && (v_a[_i16 + 1].substring(0, 1) === "{" || v_a[_i16 + 1].substring(0, 1) === "}")) {
          pfri[0] += 1;
          pfri[1] = 1;
        } else if (!_$1.isNil(_n2) && _n2.substring(0, 1) === '"' && _n2.substring(_n2.length - 1, 1) === '"' && _p2.substring(0, 1) === '"' && _p2.substring(_p2.length - 1, 1) === ")") {
          pfri[1] = _n2.length;
        } else if (!_$1.isNil(_n2) && _n2.substring(0, 1) === "{" && _n2.substring(_n2.length - 1, 1) === "}" && _p2.substring(0, 1) === "{" && _p2.substring(_p2.length - 1, 1) === ")") {
          pfri[1] = _n2.length;
        } else {
          pfri[0] = pfri[0] + vlen - vplen;
          if (v_a.length > vp_a.length) {
            pfri[1] = v_a[_i16 + 1].length;
          } else {
            pfri[1] = 1;
          }
        }
        return pfri;
      } else if (_p2.length > _n2.length) {
        if (!_$1.isNil(_p2) && _p2.substring(0, 1) === '"') {
          pfri[1] = _n2.length;
        } else if (_$1.isNil(v_a[_i16 + 1]) && /{.*?}/.test(v_a[_i16 + 1])) {
          pfri[0] += 1;
          pfri[1] = v_a[_i16 + 1].length;
        } else if (!_$1.isNil(_p2) && v_a[_i16 + 1].substring(0, 1) === '"' && (_p2.indexOf("{") > -1 || _p2.indexOf("}") > -1)) {
          pfri[0] += 1;
          pfri[1] = 1;
        } else if (!_$1.isNil(_p2) && (_p2.indexOf("{") > -1 || _p2.indexOf("}") > -1)) ;
        else if (!_$1.isNil(_p2) && !_$1.startsWith(_p2[0], "=") && _$1.startsWith(_n2, "=")) {
          return [vlen - 1, v_a[vlen - 1].length];
        } else {
          pfri[0] = pfri[0] + vlen - vplen - 1;
          pfri[1] = v_a[(_i16 || 1) - 1].length;
        }
        return pfri;
      } else if (_p2.length < _n2.length) {
        return pfri;
      }
      return pfri;
    }
    return null;
  }
  function createFormulaRangeSelect(ctx, select) {
    ctx.formulaRangeSelect = select;
  }
  function createRangeHightlight(ctx, inputInnerHtmlStr) {
    var ignoreRangeIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    var $span = parseElement("<div>".concat(inputInnerHtmlStr, "</div>"));
    var formulaRanges = [];
    $span.querySelectorAll("span.fortune-formula-functionrange-cell").forEach(function(ele) {
      var rangeIndex = parseInt(ele.getAttribute("rangeindex") || "0", 10);
      if (rangeIndex === ignoreRangeIndex) return;
      var cellrange = getcellrange(ctx, ele.textContent || "");
      if (rangeIndex === ctx.formulaCache.selectingRangeIndex || cellrange == null) return;
      if (cellrange.sheetId === ctx.currentSheetId || cellrange.sheetId === -1 && ctx.formulaCache.rangetosheet === ctx.currentSheetId) {
        var rect = seletedHighlistByindex(ctx, cellrange.row[0], cellrange.row[1], cellrange.column[0], cellrange.column[1]);
        if (rect) {
          formulaRanges.push(_objectSpread2$1(_objectSpread2$1({
            rangeIndex
          }, rect), {}, {
            backgroundColor: colors[rangeIndex]
          }));
        }
      }
    });
    ctx.formulaRangeHighlight = formulaRanges;
  }
  function setCaretPosition(ctx, textDom, children, pos) {
    try {
      var el2 = textDom;
      var range = document.createRange();
      var sel = window.getSelection();
      range.setStart(el2.childNodes[children], pos);
      range.collapse(true);
      sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
      sel === null || sel === void 0 ? void 0 : sel.addRange(range);
      el2.focus();
    } catch (err) {
      console.error(err);
      moveToEnd(ctx.formulaCache.rangeResizeTo[0]);
    }
  }
  function functionRange(ctx, obj, v2, vp) {
    if (window.getSelection) {
      var currSelection = window.getSelection();
      if (!currSelection) return;
      var fri = findrangeindex(ctx, v2, vp);
      if (_$1.isNil(fri)) {
        currSelection.selectAllChildren(obj);
        currSelection.collapseToEnd();
      } else {
        setCaretPosition(ctx, obj.querySelectorAll("span")[fri[0]], 0, fri[1]);
      }
    } else if (document.selection) {
      ctx.formulaCache.functionRangeIndex.moveToElementText(obj);
      ctx.formulaCache.functionRangeIndex.collapse(false);
      ctx.formulaCache.functionRangeIndex.select();
    }
  }
  function searchFunction(ctx, searchtxt) {
    var _locale = locale(ctx), functionlist = _locale.functionlist;
    var f2 = [];
    var s2 = [];
    var t2 = [];
    var result_i = 0;
    for (var _i17 = 0; _i17 < functionlist.length; _i17 += 1) {
      var item = functionlist[_i17];
      var n2 = item.n;
      if (n2 === searchtxt) {
        f2.unshift(item);
        result_i += 1;
      } else if (_$1.startsWith(n2, searchtxt)) {
        s2.unshift(item);
        result_i += 1;
      } else if (n2.indexOf(searchtxt) > -1) {
        t2.unshift(item);
        result_i += 1;
      }
      if (result_i >= 10) {
        break;
      }
    }
    var list = [].concat(f2, s2, t2);
    if (list.length <= 0) {
      return;
    }
    ctx.functionCandidates = list;
  }
  function getrangeseleciton() {
    var _anchorNode$parentNod, _anchorNode$parentNod2, _anchorNode$parentEle, _anchorNode$parentEle2;
    var currSelection = window.getSelection();
    if (!currSelection) return null;
    var anchorNode = currSelection.anchorNode, anchorOffset = currSelection.anchorOffset;
    if (!anchorNode) return null;
    if (((_anchorNode$parentNod = anchorNode.parentNode) === null || _anchorNode$parentNod === void 0 ? void 0 : (_anchorNode$parentNod2 = _anchorNode$parentNod.nodeName) === null || _anchorNode$parentNod2 === void 0 ? void 0 : _anchorNode$parentNod2.toLowerCase()) === "span" && anchorOffset !== 0) {
      var txt = _$1.trim(anchorNode.textContent || "");
      if (txt.length === 0 && anchorNode.parentNode.previousSibling) {
        var ahr = anchorNode.parentNode.previousSibling;
        txt = _$1.trim(ahr.textContent || "");
        return ahr;
      }
      return anchorNode.parentNode;
    }
    var anchorElement = anchorNode;
    if (anchorElement.id === "luckysheet-rich-text-editor" || anchorElement.id === "luckysheet-functionbox-cell") {
      var _$last;
      var _txt = _$1.trim((_$last = _$1.last(anchorElement.querySelectorAll("span"))) === null || _$last === void 0 ? void 0 : _$last.innerText);
      if (_txt.length === 0 && anchorElement.querySelectorAll("span").length > 1) {
        var _ahr = anchorElement.querySelectorAll("span");
        _txt = _$1.trim(_ahr[_ahr.length - 2].innerText);
        return _ahr === null || _ahr === void 0 ? void 0 : _ahr[0];
      }
      return _$1.last(anchorElement.querySelectorAll("span"));
    }
    if ((anchorNode === null || anchorNode === void 0 ? void 0 : (_anchorNode$parentEle = anchorNode.parentElement) === null || _anchorNode$parentEle === void 0 ? void 0 : _anchorNode$parentEle.id) === "luckysheet-rich-text-editor" || (anchorNode === null || anchorNode === void 0 ? void 0 : (_anchorNode$parentEle2 = anchorNode.parentElement) === null || _anchorNode$parentEle2 === void 0 ? void 0 : _anchorNode$parentEle2.id) === "luckysheet-functionbox-cell" || anchorOffset === 0) {
      var newAnchorNode = anchorOffset === 0 ? anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.parentNode : anchorNode;
      if (newAnchorNode === null || newAnchorNode === void 0 ? void 0 : newAnchorNode.previousSibling) {
        return newAnchorNode === null || newAnchorNode === void 0 ? void 0 : newAnchorNode.previousSibling;
      }
    }
    return null;
  }
  function helpFunctionExe($editer, currSelection, ctx) {
    var _currSelection$parent;
    var _locale2 = locale(ctx), functionlist = _locale2.functionlist;
    if (_$1.isEmpty(ctx.formulaCache.functionlistMap)) {
      for (var _i18 = 0; _i18 < functionlist.length; _i18 += 1) {
        ctx.formulaCache.functionlistMap[functionlist[_i18].n] = functionlist[_i18];
      }
    }
    if (!currSelection) {
      return null;
    }
    var $prev = currSelection;
    var $span = $editer.querySelectorAll("span");
    var currentIndex = _$1.indexOf((_currSelection$parent = currSelection.parentNode) === null || _currSelection$parent === void 0 ? void 0 : _currSelection$parent.childNodes, currSelection);
    var i2 = currentIndex;
    if ($prev == null) {
      return null;
    }
    var funcName = null;
    if ($span[i2].classList.contains("luckysheet-formula-text-func")) {
      funcName = $span[i2].textContent;
    } else {
      var $cur = null;
      var exceptIndex = [-1, -1];
      while (--i2 > 0) {
        $cur = $span[i2];
        if ($cur.classList.contains("luckysheet-formula-text-func") || _$1.trim($cur.textContent || "").toUpperCase() in ctx.formulaCache.functionlistMap) {
          funcName = $cur.textContent;
          var endstate = true;
          for (var a2 = i2; a2 <= currentIndex; a2 += 1) {
            if (a2 >= exceptIndex[0] && a2 <= exceptIndex[1]) {
              continue;
            }
            $cur = $span[a2];
            if ($cur.classList.contains("luckysheet-formula-text-rpar")) {
              exceptIndex = [i2, a2];
              funcName = null;
              endstate = false;
              break;
            }
            if ($cur.classList.contains("luckysheet-formula-text-comma")) ;
          }
          if (endstate) {
            break;
          }
        }
      }
    }
    return funcName;
  }
  function rangeHightlightselected(ctx, $editor) {
    var currSelection = getrangeseleciton();
    if (!currSelection) return;
    var currText = _$1.trim(currSelection.textContent || "");
    if (currText === null || currText === void 0 ? void 0 : currText.match(/^[a-zA-Z_]+$/)) {
      searchFunction(ctx, currText.toUpperCase());
      ctx.functionHint = null;
    } else {
      var funcName = helpFunctionExe($editor, currSelection, ctx);
      ctx.functionHint = funcName === null || funcName === void 0 ? void 0 : funcName.toUpperCase();
      ctx.functionCandidates = [];
    }
  }
  function functionHTML(txt) {
    if (txt.substr(0, 1) === "=") {
      txt = txt.substr(1);
    }
    var funcstack = txt.split("");
    var i2 = 0;
    var str = "";
    var function_str = "";
    var matchConfig = {
      bracket: 0,
      squote: 0,
      dquote: 0,
      braces: 0
    };
    while (i2 < funcstack.length) {
      var s2 = funcstack[i2];
      if (s2 === "(" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        matchConfig.bracket += 1;
        if (str.length > 0) {
          function_str += '<span dir="auto" class="luckysheet-formula-text-func">'.concat(str, '</span><span dir="auto" class="luckysheet-formula-text-lpar">(</span>');
        } else {
          function_str += '<span dir="auto" class="luckysheet-formula-text-lpar">(</span>';
        }
        str = "";
      } else if (s2 === ")" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        matchConfig.bracket -= 1;
        function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-rpar">)</span>');
        str = "";
      } else if (s2 === "{" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
        str += "{";
        matchConfig.braces += 1;
      } else if (s2 === "}" && matchConfig.squote === 0 && matchConfig.dquote === 0) {
        str += "}";
        matchConfig.braces -= 1;
      } else if (s2 === '"' && matchConfig.squote === 0) {
        if (matchConfig.dquote > 0) {
          if (str.length > 0) {
            function_str += "".concat(str, '"</span>');
          } else {
            function_str += '"</span>';
          }
          matchConfig.dquote -= 1;
          str = "";
        } else {
          matchConfig.dquote += 1;
          if (str.length > 0) {
            function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-string">"');
          } else {
            function_str += '<span dir="auto" class="luckysheet-formula-text-string">"';
          }
          str = "";
        }
      } else if (s2 === "'" && matchConfig.dquote === 0) {
        str += "'";
        matchConfig.squote = matchConfig.squote === 0 ? 1 : 0;
      } else if (s2 === "," && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-comma">,</span>');
        str = "";
      } else if (s2 === "&" && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        if (str.length > 0) {
          function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-calc">') + "&</span>";
          str = "";
        } else {
          function_str += '<span dir="auto" class="luckysheet-formula-text-calc">&</span>';
        }
      } else if (s2 in operatorjson && matchConfig.squote === 0 && matchConfig.dquote === 0 && matchConfig.braces === 0) {
        var s_next = "";
        if (i2 + 1 < funcstack.length) {
          s_next = funcstack[i2 + 1];
        }
        var p2 = i2 - 1;
        var s_pre = null;
        if (p2 >= 0) {
          do {
            s_pre = funcstack[p2];
            p2 -= 1;
          } while (p2 >= 0 && s_pre === " ");
        }
        if (s2 + s_next in operatorjson) {
          if (str.length > 0) {
            function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-calc">').concat(s2).concat(s_next, "</span>");
            str = "";
          } else {
            function_str += '<span dir="auto" class="luckysheet-formula-text-calc">'.concat(s2).concat(s_next, "</span>");
          }
          i2 += 1;
        } else if (!/[^0-9]/.test(s_next) && s2 === "-" && (s_pre === "(" || _$1.isNil(s_pre) || s_pre === "," || s_pre === " " || s_pre in operatorjson)) {
          str += s2;
        } else {
          if (str.length > 0) {
            function_str += "".concat(functionHTML(str), '<span dir="auto" class="luckysheet-formula-text-calc">').concat(s2, "</span>");
            str = "";
          } else {
            function_str += '<span dir="auto" class="luckysheet-formula-text-calc">'.concat(s2, "</span>");
          }
        }
      } else {
        str += s2;
      }
      if (i2 === funcstack.length - 1) {
        if (iscelldata(_$1.trim(str))) {
          var rangeIndex = rangeIndexes.length > functionHTMLIndex ? rangeIndexes[functionHTMLIndex] : functionHTMLIndex;
          function_str += '<span class="fortune-formula-functionrange-cell" rangeindex="'.concat(rangeIndex, '" dir="auto" style="color:').concat(colors[rangeIndex], ';">').concat(str, "</span>");
          functionHTMLIndex += 1;
        } else if (matchConfig.dquote > 0) {
          function_str += "".concat(str, "</span>");
        } else if (str.indexOf("</span>") === -1 && str.length > 0) {
          var regx = /{.*?}/;
          if (regx.test(_$1.trim(str))) {
            var arraytxt = regx.exec(str)[0];
            var arraystart = str.search(regx);
            var alltxt = "";
            if (arraystart > 0) {
              alltxt += '<span dir="auto" class="luckysheet-formula-text-color">'.concat(str.substr(0, arraystart), "</span>");
            }
            alltxt += '<span dir="auto" style="color:#959a05" class="luckysheet-formula-text-array">'.concat(arraytxt, "</span>");
            if (arraystart + arraytxt.length < str.length) {
              alltxt += '<span dir="auto" class="luckysheet-formula-text-color">'.concat(str.substr(arraystart + arraytxt.length, str.length), "</span>");
            }
            function_str += alltxt;
          } else {
            function_str += '<span dir="auto" class="luckysheet-formula-text-color">'.concat(str, "</span>");
          }
        }
      }
      i2 += 1;
    }
    return function_str;
  }
  function functionHTMLGenerate(txt) {
    if (txt.length === 0 || txt.substring(0, 1) !== "=") {
      return txt;
    }
    functionHTMLIndex = 0;
    return '<span dir="auto" class="luckysheet-formula-text-color">=</span>'.concat(functionHTML(txt));
  }
  function getRangeIndexes($editor) {
    var res = [];
    $editor.querySelectorAll("span.fortune-formula-functionrange-cell").forEach(function(ele) {
      var indexStr = ele.getAttribute("rangeindex");
      if (indexStr) {
        var rangeIndex = parseInt(indexStr, 10);
        res.push(rangeIndex);
      }
    });
    return res;
  }
  function handleFormulaInput(ctx, $copyTo, $editor, kcode, preText) {
    var refreshRangeSelect = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
    var value1;
    var value1txt = preText !== null && preText !== void 0 ? preText : $editor.innerText;
    var value = $editor.innerText;
    value = escapeScriptTag(value);
    if (value.length > 0 && value.substring(0, 1) === "=" && (kcode !== 229 || value.length === 1)) {
      if (!refreshRangeSelect) rangeIndexes = getRangeIndexes($editor);
      value = functionHTMLGenerate(value);
      if (!refreshRangeSelect && functionHTMLIndex < rangeIndexes.length) refreshRangeSelect = true;
      value1 = functionHTMLGenerate(value1txt);
      rangeIndexes = [];
      if (window.getSelection) {
        var _currSelection$anchor;
        var currSelection = window.getSelection();
        if (!currSelection) return;
        if (((_currSelection$anchor = currSelection.anchorNode) === null || _currSelection$anchor === void 0 ? void 0 : _currSelection$anchor.nodeName.toLowerCase()) === "div") {
          var _$editor$querySelecto;
          var editorlen = $editor.querySelectorAll("span").length;
          ctx.formulaCache.functionRangeIndex = [editorlen - 1, (_$editor$querySelecto = $editor.querySelectorAll("span").item(editorlen - 1).textContent) === null || _$editor$querySelecto === void 0 ? void 0 : _$editor$querySelecto.length];
        } else {
          var _currSelection$anchor2, _currSelection$anchor3, _currSelection$anchor4, _currSelection$anchor5;
          ctx.formulaCache.functionRangeIndex = [_$1.indexOf((_currSelection$anchor2 = currSelection.anchorNode) === null || _currSelection$anchor2 === void 0 ? void 0 : (_currSelection$anchor3 = _currSelection$anchor2.parentNode) === null || _currSelection$anchor3 === void 0 ? void 0 : (_currSelection$anchor4 = _currSelection$anchor3.parentNode) === null || _currSelection$anchor4 === void 0 ? void 0 : _currSelection$anchor4.childNodes, (_currSelection$anchor5 = currSelection.anchorNode) === null || _currSelection$anchor5 === void 0 ? void 0 : _currSelection$anchor5.parentNode), currSelection.anchorOffset];
        }
      } else {
        var textRange = document.selection.createRange();
        ctx.formulaCache.functionRangeIndex = textRange;
      }
      $editor.innerHTML = value;
      if ($copyTo) $copyTo.innerHTML = value;
      functionRange(ctx, $editor, value, value1);
      if (refreshRangeSelect) {
        cancelFunctionrangeSelected(ctx);
        if (kcode !== 46) {
          createRangeHightlight(ctx, value);
        }
        ctx.formulaCache.rangestart = false;
        ctx.formulaCache.rangedrag_column_start = false;
        ctx.formulaCache.rangedrag_row_start = false;
        rangeHightlightselected(ctx, $editor);
      }
    } else if (_$1.startsWith(value1txt, "=") && !_$1.startsWith(value, "=")) {
      if ($copyTo) $copyTo.innerHTML = value;
      $editor.innerHTML = escapeHTMLTag(value);
    } else if (!_$1.startsWith(value1txt, "=")) {
      if (!$copyTo) return;
      if ($copyTo.id === "luckysheet-rich-text-editor") {
        if (!_$1.startsWith($copyTo.innerHTML, "<span")) {
          $copyTo.innerHTML = escapeHTMLTag(value);
        }
      } else {
        $copyTo.innerHTML = escapeHTMLTag(value);
      }
    }
  }
  function isfreezonFuc(txt) {
    var row = txt.replace(/[^0-9]/g, "");
    var col = txt.replace(/[^A-Za-z]/g, "");
    var row$ = txt.substr(txt.indexOf(row) - 1, 1);
    var col$ = txt.substr(txt.indexOf(col) - 1, 1);
    var ret = [false, false];
    if (row$ === "$") {
      ret[0] = true;
    }
    if (col$ === "$") {
      ret[1] = true;
    }
    return ret;
  }
  function functionStrChange_range(txt, type, rc2, orient, stindex, step) {
    var val = txt.split("!");
    var rangetxt;
    var prefix = "";
    if (val.length > 1) {
      var _val3 = _slicedToArray$1(val, 2);
      rangetxt = _val3[1];
      prefix = "".concat(val[0], "!");
    } else {
      var _val4 = _slicedToArray$1(val, 1);
      rangetxt = _val4[0];
    }
    var r1;
    var r2;
    var c1;
    var c2;
    var $row0;
    var $row1;
    var $col0;
    var $col1;
    if (rangetxt.indexOf(":") === -1) {
      r1 = parseInt(rangetxt.replace(/[^0-9]/g, ""), 10) - 1;
      r2 = r1;
      c1 = columnCharToIndex(rangetxt.replace(/[^A-Za-z]/g, ""));
      c2 = c1;
      var freezonFuc = isfreezonFuc(rangetxt);
      $row0 = freezonFuc[0] ? "$" : "";
      $row1 = $row0;
      $col0 = freezonFuc[1] ? "$" : "";
      $col1 = $col0;
    } else {
      rangetxt = rangetxt.split(":");
      r1 = parseInt(rangetxt[0].replace(/[^0-9]/g, ""), 10) - 1;
      r2 = parseInt(rangetxt[1].replace(/[^0-9]/g, ""), 10) - 1;
      if (r1 > r2) {
        return txt;
      }
      c1 = columnCharToIndex(rangetxt[0].replace(/[^A-Za-z]/g, ""));
      c2 = columnCharToIndex(rangetxt[1].replace(/[^A-Za-z]/g, ""));
      if (c1 > c2) {
        return txt;
      }
      var freezonFuc0 = isfreezonFuc(rangetxt[0]);
      $row0 = freezonFuc0[0] ? "$" : "";
      $col0 = freezonFuc0[1] ? "$" : "";
      var freezonFuc1 = isfreezonFuc(rangetxt[1]);
      $row1 = freezonFuc1[0] ? "$" : "";
      $col1 = freezonFuc1[1] ? "$" : "";
    }
    if (type === "del") {
      if (rc2 === "row") {
        if (r1 >= stindex && r2 <= stindex + step - 1) {
          return error.r;
        }
        if (r1 > stindex + step - 1) {
          r1 -= step;
        } else if (r1 >= stindex) {
          r1 = stindex;
        }
        if (r2 > stindex + step - 1) {
          r2 -= step;
        } else if (r2 >= stindex) {
          r2 = stindex - 1;
        }
        if (r1 < 0) {
          r1 = 0;
        }
        if (r2 < r1) {
          r2 = r1;
        }
      } else if (rc2 === "col") {
        if (c1 >= stindex && c2 <= stindex + step - 1) {
          return error.r;
        }
        if (c1 > stindex + step - 1) {
          c1 -= step;
        } else if (c1 >= stindex) {
          c1 = stindex;
        }
        if (c2 > stindex + step - 1) {
          c2 -= step;
        } else if (c2 >= stindex) {
          c2 = stindex - 1;
        }
        if (c1 < 0) {
          c1 = 0;
        }
        if (c2 < c1) {
          c2 = c1;
        }
      }
      if (r1 === r2 && c1 === c2) {
        if (!Number.isNaN(r1) && !Number.isNaN(c1)) {
          return prefix + $col0 + indexToColumnChar(c1) + $row0 + (r1 + 1);
        }
        if (!Number.isNaN(r1)) {
          return prefix + $row0 + (r1 + 1);
        }
        if (!Number.isNaN(c1)) {
          return prefix + $col0 + indexToColumnChar(c1);
        }
        return txt;
      }
      if (Number.isNaN(c1) && Number.isNaN(c2)) {
        return "".concat(prefix + $row0 + (r1 + 1), ":").concat($row1).concat(r2 + 1);
      }
      if (Number.isNaN(r1) && Number.isNaN(r2)) {
        return "".concat(prefix + $col0 + indexToColumnChar(c1), ":").concat($col1).concat(indexToColumnChar(c2));
      }
      return "".concat(prefix + $col0 + indexToColumnChar(c1) + $row0 + (r1 + 1), ":").concat($col1).concat(indexToColumnChar(c2)).concat($row1).concat(r2 + 1);
    }
    if (type === "add") {
      if (rc2 === "row") {
        if (orient === "lefttop") {
          if (r1 >= stindex) {
            r1 += step;
          }
          if (r2 >= stindex) {
            r2 += step;
          }
        } else if (orient === "rightbottom") {
          if (r1 > stindex) {
            r1 += step;
          }
          if (r2 > stindex) {
            r2 += step;
          }
        }
      } else if (rc2 === "col") {
        if (orient === "lefttop") {
          if (c1 >= stindex) {
            c1 += step;
          }
          if (c2 >= stindex) {
            c2 += step;
          }
        } else if (orient === "rightbottom") {
          if (c1 > stindex) {
            c1 += step;
          }
          if (c2 > stindex) {
            c2 += step;
          }
        }
      }
      if (r1 === r2 && c1 === c2) {
        if (!Number.isNaN(r1) && !Number.isNaN(c1)) {
          return prefix + $col0 + indexToColumnChar(c1) + $row0 + (r1 + 1);
        }
        if (!Number.isNaN(r1)) {
          return prefix + $row0 + (r1 + 1);
        }
        if (!Number.isNaN(c1)) {
          return prefix + $col0 + indexToColumnChar(c1);
        }
        return txt;
      }
      if (Number.isNaN(c1) && Number.isNaN(c2)) {
        return "".concat(prefix + $row0 + (r1 + 1), ":").concat($row1).concat(r2 + 1);
      }
      if (Number.isNaN(r1) && Number.isNaN(r2)) {
        return "".concat(prefix + $col0 + indexToColumnChar(c1), ":").concat($col1).concat(indexToColumnChar(c2));
      }
      return "".concat(prefix + $col0 + indexToColumnChar(c1) + $row0 + (r1 + 1), ":").concat($col1).concat(indexToColumnChar(c2)).concat($row1).concat(r2 + 1);
    }
    return "";
  }
  function israngeseleciton(ctx, istooltip) {
    var _anchor, _anchor2, _anchor2$parentNode;
    if (istooltip == null) {
      istooltip = false;
    }
    var currSelection = window.getSelection();
    if (currSelection == null) return false;
    var anchor = currSelection.anchorNode;
    if (!((_anchor = anchor) === null || _anchor === void 0 ? void 0 : _anchor.textContent)) return false;
    var anchorOffset = currSelection.anchorOffset;
    var anchorElement = anchor;
    var parentElement = anchor.parentNode;
    if (((_anchor2 = anchor) === null || _anchor2 === void 0 ? void 0 : (_anchor2$parentNode = _anchor2.parentNode) === null || _anchor2$parentNode === void 0 ? void 0 : _anchor2$parentNode.nodeName.toLowerCase()) === "span" && anchorOffset !== 0) {
      var txt = _$1.trim(anchor.textContent);
      var lasttxt = "";
      if (txt.length === 0 && anchor.parentNode.previousSibling) {
        var ahr = anchor.parentNode.previousSibling;
        txt = _$1.trim(ahr.textContent || "");
        lasttxt = txt.substring(txt.length - 1, 1);
        ctx.formulaCache.rangeSetValueTo = anchor.parentNode;
      } else {
        lasttxt = txt.substring(anchorOffset - 1, 1);
        ctx.formulaCache.rangeSetValueTo = anchor.parentNode;
      }
      if (istooltip && (lasttxt === "(" || lasttxt === ",") || !istooltip && (lasttxt === "(" || lasttxt === "," || lasttxt === "=" || lasttxt in operatorjson || lasttxt === "&")) {
        return true;
      }
    } else if (anchorElement.id === "luckysheet-rich-text-editor" || anchorElement.id === "luckysheet-functionbox-cell") {
      var _$last2;
      var _txt2 = _$1.trim((_$last2 = _$1.last(anchorElement.querySelectorAll("span"))) === null || _$last2 === void 0 ? void 0 : _$last2.innerText);
      ctx.formulaCache.rangeSetValueTo = _$1.last(anchorElement.querySelectorAll("span"));
      if (_txt2.length === 0 && anchorElement.querySelectorAll("span").length > 1) {
        var _ahr2 = anchorElement.querySelectorAll("span");
        _txt2 = _$1.trim(_ahr2[_ahr2.length - 2].innerText);
        _txt2 = _$1.trim(_ahr2[_ahr2.length - 2].innerText);
        ctx.formulaCache.rangeSetValueTo = _ahr2;
      }
      var _lasttxt = _txt2.substring(_txt2.length - 1, 1);
      if (istooltip && (_lasttxt === "(" || _lasttxt === ",") || !istooltip && (_lasttxt === "(" || _lasttxt === "," || _lasttxt === "=" || _lasttxt in operatorjson || _lasttxt === "&")) {
        return true;
      }
    } else if (parentElement.id === "luckysheet-rich-text-editor" || parentElement.id === "luckysheet-functionbox-cell" || anchorOffset === 0) {
      var _anchor$previousSibli;
      if (anchorOffset === 0) {
        anchor = anchor.parentNode;
      }
      if (!anchor) return false;
      if (((_anchor$previousSibli = anchor.previousSibling) === null || _anchor$previousSibli === void 0 ? void 0 : _anchor$previousSibli.textContent) == null) return false;
      if (anchor.previousSibling) {
        var _txt3 = _$1.trim(anchor.previousSibling.textContent);
        var _lasttxt2 = _txt3.substring(_txt3.length - 1, 1);
        ctx.formulaCache.rangeSetValueTo = anchor.previousSibling;
        if (istooltip && (_lasttxt2 === "(" || _lasttxt2 === ",") || !istooltip && (_lasttxt2 === "(" || _lasttxt2 === "," || _lasttxt2 === "=" || _lasttxt2 in operatorjson || _lasttxt2 === "&")) {
          return true;
        }
      }
    }
    return false;
  }
  function functionStrChange(txt, type, rc2, orient, stindex, step) {
    if (!txt) {
      return "";
    }
    if (txt.substring(0, 1) === "=") {
      txt = txt.substring(1);
    }
    var funcstack = txt.split("");
    var i2 = 0;
    var str = "";
    var function_str = "";
    var matchConfig = {
      bracket: 0,
      squote: 0,
      dquote: 0
    };
    while (i2 < funcstack.length) {
      var s2 = funcstack[i2];
      if (s2 === "(" && matchConfig.dquote === 0) {
        matchConfig.bracket += 1;
        if (str.length > 0) {
          function_str += "".concat(str, "(");
        } else {
          function_str += "(";
        }
        str = "";
      } else if (s2 === ")" && matchConfig.dquote === 0) {
        matchConfig.bracket -= 1;
        function_str += "".concat(functionStrChange(str, type, rc2, orient, stindex, step), ")");
        str = "";
      } else if (s2 === '"' && matchConfig.squote === 0) {
        if (matchConfig.dquote > 0) {
          function_str += "".concat(str, '"');
          matchConfig.dquote -= 1;
          str = "";
        } else {
          matchConfig.dquote += 1;
          str += '"';
        }
      } else if (s2 === "," && matchConfig.dquote === 0) {
        function_str += "".concat(functionStrChange(str, type, rc2, orient, stindex, step), ",");
        str = "";
      } else if (s2 === "&" && matchConfig.dquote === 0) {
        if (str.length > 0) {
          function_str += "".concat(functionStrChange(str, type, rc2, orient, stindex, step), "&");
          str = "";
        } else {
          function_str += "&";
        }
      } else if (s2 in operatorjson && matchConfig.dquote === 0) {
        var s_next = "";
        if (i2 + 1 < funcstack.length) {
          s_next = funcstack[i2 + 1];
        }
        var p2 = i2 - 1;
        var s_pre = null;
        if (p2 >= 0) {
          do {
            s_pre = funcstack[p2 -= 1];
          } while (p2 >= 0 && s_pre === " ");
        }
        if (s2 + s_next in operatorjson) {
          if (str.length > 0) {
            function_str += functionStrChange(str, type, rc2, orient, stindex, step) + s2 + s_next;
            str = "";
          } else {
            function_str += s2 + s_next;
          }
          i2 += 1;
        } else if (!/[^0-9]/.test(s_next) && s2 === "-" && (s_pre === "(" || s_pre == null || s_pre === "," || s_pre === " " || s_pre in operatorjson)) {
          str += s2;
        } else {
          if (str.length > 0) {
            function_str += functionStrChange(str, type, rc2, orient, stindex, step) + s2;
            str = "";
          } else {
            function_str += s2;
          }
        }
      } else {
        str += s2;
      }
      if (i2 === funcstack.length - 1) {
        if (iscelldata(_$1.trim(str))) {
          function_str += functionStrChange_range(_$1.trim(str), type, rc2, orient, stindex, step);
        } else {
          function_str += _$1.trim(str);
        }
      }
      i2 += 1;
    }
    return function_str;
  }
  function rangeSetValue(ctx, cellInput, selected, fxInput) {
    var _document$activeEleme;
    var $editor = cellInput;
    var $copyTo = fxInput;
    if (((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.id) === "luckysheet-functionbox-cell") {
      $editor = fxInput;
      $copyTo = cellInput;
    }
    var range = "";
    var rf2 = selected.row[0];
    var cf2 = selected.column[0];
    if (ctx.config.merge != null && "".concat(rf2, "_").concat(cf2) in ctx.config.merge) {
      range = getRangetxt(ctx, ctx.currentSheetId, {
        column: [cf2, cf2],
        row: [rf2, rf2]
      }, ctx.formulaCache.rangetosheet);
    } else {
      range = getRangetxt(ctx, ctx.currentSheetId, selected, ctx.formulaCache.rangetosheet);
    }
    if (!israngeseleciton(ctx) && (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start)) {
      var span = $editor.querySelector("span[rangeindex='".concat(ctx.formulaCache.rangechangeindex, "']"));
      if (span) {
        span.innerHTML = range;
        setCaretPosition(ctx, span, 0, range.length);
      }
    } else {
      var function_str = '<span class="fortune-formula-functionrange-cell" rangeindex="'.concat(functionHTMLIndex, '" dir="auto" style="color:').concat(colors[functionHTMLIndex], ';">').concat(range, "</span>");
      var newEle = parseElement(function_str);
      var refEle = ctx.formulaCache.rangeSetValueTo;
      if (refEle && refEle.parentNode) {
        refEle.parentNode.insertBefore(newEle, refEle.nextSibling);
      } else {
        $editor.appendChild(newEle);
      }
      ctx.formulaCache.rangechangeindex = functionHTMLIndex;
      var _span = $editor.querySelector("span[rangeindex='".concat(ctx.formulaCache.rangechangeindex, "']"));
      setCaretPosition(ctx, _span, 0, range.length);
      functionHTMLIndex += 1;
    }
    if ($copyTo) $copyTo.innerHTML = $editor.innerHTML;
  }
  function onFormulaRangeDragEnd(ctx) {
    if (ctx.formulaCache.func_selectedrange) {
      var _ctx$formulaCache$fun = ctx.formulaCache.func_selectedrange, left = _ctx$formulaCache$fun.left_move, top = _ctx$formulaCache$fun.top_move, width = _ctx$formulaCache$fun.width_move, height = _ctx$formulaCache$fun.height_move;
      if (left != null && top != null && width != null && height != null && (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start)) ctx.formulaRangeSelect = {
        rangeIndex: ctx.formulaCache.rangeIndex || 0,
        left,
        top,
        width,
        height
      };
    }
    ctx.formulaCache.selectingRangeIndex = -1;
  }
  function setRangeSelect(container, left, top, height, width) {
    var rangeElement = container.querySelector(".fortune-formula-functionrange-select");
    if (rangeElement == null) return;
    rangeElement.style.left = "".concat(left, "px");
    rangeElement.style.top = "".concat(top, "px");
    rangeElement.style.height = "".concat(height, "px");
    rangeElement.style.width = "".concat(width, "px");
  }
  function rangeDrag(ctx, e, cellInput, scrollLeft, scrollTop, container, fxInput) {
    var func_selectedrange = ctx.formulaCache.func_selectedrange;
    if (!func_selectedrange || func_selectedrange.left == null || func_selectedrange.height == null || func_selectedrange.top == null || func_selectedrange.width == null) return;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollLeft;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollTop;
    var _rowLocation = rowLocation(y2, ctx.visibledatarow), _rowLocation2 = _slicedToArray$1(_rowLocation, 3), row_pre = _rowLocation2[0], row = _rowLocation2[1], row_index = _rowLocation2[2];
    var _colLocation = colLocation(x2, ctx.visibledatacolumn), _colLocation2 = _slicedToArray$1(_colLocation, 3), col_pre = _colLocation2[0], col = _colLocation2[1], col_index = _colLocation2[2];
    var top = 0;
    var height = 0;
    var rowseleted = [];
    if (func_selectedrange.top > row_pre) {
      top = row_pre;
      height = func_selectedrange.top + func_selectedrange.height - row_pre;
      rowseleted = [row_index, func_selectedrange.row[1]];
    } else if (func_selectedrange.top === row_pre) {
      top = row_pre;
      height = func_selectedrange.top + func_selectedrange.height - row_pre;
      rowseleted = [row_index, func_selectedrange.row[0]];
    } else {
      top = func_selectedrange.top;
      height = row - func_selectedrange.top - 1;
      rowseleted = [func_selectedrange.row[0], row_index];
    }
    var left = 0;
    var width = 0;
    var columnseleted = [];
    if (func_selectedrange.left > col_pre) {
      left = col_pre;
      width = func_selectedrange.left + func_selectedrange.width - col_pre;
      columnseleted = [col_index, func_selectedrange.column[1]];
    } else if (func_selectedrange.left === col_pre) {
      left = col_pre;
      width = func_selectedrange.left + func_selectedrange.width - col_pre;
      columnseleted = [col_index, func_selectedrange.column[0]];
    } else {
      left = func_selectedrange.left;
      width = col - func_selectedrange.left - 1;
      columnseleted = [func_selectedrange.column[0], col_index];
    }
    var changeparam = mergeMoveMain(ctx, columnseleted, rowseleted, func_selectedrange, top, height, left, width);
    if (changeparam != null) {
      var _changeparam = _slicedToArray$1(changeparam, 6);
      columnseleted = _changeparam[0];
      rowseleted = _changeparam[1];
      top = _changeparam[2];
      height = _changeparam[3];
      left = _changeparam[4];
      width = _changeparam[5];
    }
    func_selectedrange.row = rowseleted;
    func_selectedrange.column = columnseleted;
    func_selectedrange.left_move = left;
    func_selectedrange.width_move = width;
    func_selectedrange.top_move = top;
    func_selectedrange.height_move = height;
    rangeSetValue(ctx, cellInput, {
      row: rowseleted,
      column: columnseleted
    }, fxInput);
    setRangeSelect(container, left, top, height, width);
    e.preventDefault();
  }
  function rangeDragColumn(ctx, e, cellInput, scrollLeft, scrollTop, container, fxInput) {
    var func_selectedrange = ctx.formulaCache.func_selectedrange;
    if (!func_selectedrange || func_selectedrange.left == null || func_selectedrange.height == null || func_selectedrange.top == null || func_selectedrange.width == null) return;
    var mouse = mousePosition(e.pageX, e.pageY, ctx);
    var x2 = mouse[0] + scrollLeft;
    var visibledatarow = ctx.visibledatarow;
    var row_index = visibledatarow.length - 1;
    var row = visibledatarow[row_index];
    var row_pre = 0;
    var _colLocation3 = colLocation(x2, ctx.visibledatacolumn), _colLocation4 = _slicedToArray$1(_colLocation3, 3), col_pre = _colLocation4[0], col = _colLocation4[1], col_index = _colLocation4[2];
    var left = 0;
    var width = 0;
    var columnseleted = [];
    if (func_selectedrange.left > col_pre) {
      left = col_pre;
      width = func_selectedrange.left + func_selectedrange.width - col_pre;
      columnseleted = [col_index, func_selectedrange.column[1]];
    } else if (func_selectedrange.left === col_pre) {
      left = col_pre;
      width = func_selectedrange.left + func_selectedrange.width - col_pre;
      columnseleted = [col_index, func_selectedrange.column[0]];
    } else {
      left = func_selectedrange.left;
      width = col - func_selectedrange.left - 1;
      columnseleted = [func_selectedrange.column[0], col_index];
    }
    var changeparam = mergeMoveMain(ctx, columnseleted, [0, row_index], func_selectedrange, row_pre, row - row_pre - 1, left, width);
    if (changeparam != null) {
      var _changeparam2 = _slicedToArray$1(changeparam, 6);
      columnseleted = _changeparam2[0];
      left = _changeparam2[4];
      width = _changeparam2[5];
    }
    func_selectedrange.column = columnseleted;
    func_selectedrange.left_move = left;
    func_selectedrange.width_move = width;
    rangeSetValue(ctx, cellInput, {
      row: [null, null],
      column: columnseleted
    }, fxInput);
    setRangeSelect(container, left, row_pre, row - row_pre - 1, width);
  }
  function rangeDragRow(ctx, e, cellInput, scrollLeft, scrollTop, container, fxInput) {
    var func_selectedrange = ctx.formulaCache.func_selectedrange;
    if (!func_selectedrange || func_selectedrange.left == null || func_selectedrange.height == null || func_selectedrange.top == null || func_selectedrange.width == null) return;
    var mouse = mousePosition(e.pageX, e.pageY, ctx);
    var y2 = mouse[1] + scrollTop;
    var _rowLocation3 = rowLocation(y2, ctx.visibledatarow), _rowLocation4 = _slicedToArray$1(_rowLocation3, 3), row_pre = _rowLocation4[0], row = _rowLocation4[1], row_index = _rowLocation4[2];
    var visibledatacolumn = ctx.visibledatacolumn;
    var col_index = visibledatacolumn.length - 1;
    var col = visibledatacolumn[col_index];
    var col_pre = 0;
    var top = 0;
    var height = 0;
    var rowseleted = [];
    if (func_selectedrange.top > row_pre) {
      top = row_pre;
      height = func_selectedrange.top + func_selectedrange.height - row_pre;
      rowseleted = [row_index, func_selectedrange.row[1]];
    } else if (func_selectedrange.top === row_pre) {
      top = row_pre;
      height = func_selectedrange.top + func_selectedrange.height - row_pre;
      rowseleted = [row_index, func_selectedrange.row[0]];
    } else {
      top = func_selectedrange.top;
      height = row - func_selectedrange.top - 1;
      rowseleted = [func_selectedrange.row[0], row_index];
    }
    var changeparam = mergeMoveMain(ctx, [0, col_index], rowseleted, func_selectedrange, top, height, col_pre, col - col_pre - 1);
    if (changeparam != null) {
      var _changeparam3 = _slicedToArray$1(changeparam, 4);
      rowseleted = _changeparam3[1];
      top = _changeparam3[2];
      height = _changeparam3[3];
    }
    func_selectedrange.row = rowseleted;
    func_selectedrange.top_move = top;
    func_selectedrange.height_move = height;
    rangeSetValue(ctx, cellInput, {
      row: rowseleted,
      column: [null, null]
    }, fxInput);
    setRangeSelect(container, col_pre, top, height, col - col_pre - 1);
  }
  function updateparam(orient, txt, step) {
    var val = txt.split("!");
    var rangetxt;
    var prefix = "";
    if (val.length > 1) {
      var _val5 = _slicedToArray$1(val, 2);
      rangetxt = _val5[1];
      prefix = "".concat(val[0], "!");
    } else {
      var _val6 = _slicedToArray$1(val, 1);
      rangetxt = _val6[0];
    }
    if (rangetxt.indexOf(":") === -1) {
      var _row3 = parseInt(rangetxt.replace(/[^0-9]/g, ""), 10);
      var _col3 = columnCharToIndex(rangetxt.replace(/[^A-Za-z]/g, ""));
      var freezonFuc = isfreezonFuc(rangetxt);
      var $row = freezonFuc[0] ? "$" : "";
      var $col = freezonFuc[1] ? "$" : "";
      if (orient === "u" && !freezonFuc[0]) {
        _row3 -= step;
      } else if (orient === "r" && !freezonFuc[1]) {
        _col3 += step;
      } else if (orient === "l" && !freezonFuc[1]) {
        _col3 -= step;
      } else if (orient === "d" && !freezonFuc[0]) {
        _row3 += step;
      }
      if (!Number.isNaN(_row3) && !Number.isNaN(_col3)) {
        return prefix + $col + indexToColumnChar(_col3) + $row + _row3;
      }
      if (!Number.isNaN(_row3)) {
        return prefix + $row + _row3;
      }
      if (!Number.isNaN(_col3)) {
        return prefix + $col + indexToColumnChar(_col3);
      }
      return txt;
    }
    rangetxt = rangetxt.split(":");
    var row = [];
    var col = [];
    row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, ""), 10);
    row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, ""), 10);
    if (row[0] > row[1]) {
      return txt;
    }
    col[0] = columnCharToIndex(rangetxt[0].replace(/[^A-Za-z]/g, ""));
    col[1] = columnCharToIndex(rangetxt[1].replace(/[^A-Za-z]/g, ""));
    if (col[0] > col[1]) {
      return txt;
    }
    var freezonFuc0 = isfreezonFuc(rangetxt[0]);
    var freezonFuc1 = isfreezonFuc(rangetxt[1]);
    var $row0 = freezonFuc0[0] ? "$" : "";
    var $col0 = freezonFuc0[1] ? "$" : "";
    var $row1 = freezonFuc1[0] ? "$" : "";
    var $col1 = freezonFuc1[1] ? "$" : "";
    if (orient === "u") {
      if (!freezonFuc0[0]) {
        row[0] -= step;
      }
      if (!freezonFuc1[0]) {
        row[1] -= step;
      }
    } else if (orient === "r") {
      if (!freezonFuc0[1]) {
        col[0] += step;
      }
      if (!freezonFuc1[1]) {
        col[1] += step;
      }
    } else if (orient === "l") {
      if (!freezonFuc0[1]) {
        col[0] -= step;
      }
      if (!freezonFuc1[1]) {
        col[1] -= step;
      }
    } else if (orient === "d") {
      if (!freezonFuc0[0]) {
        row[0] += step;
      }
      if (!freezonFuc1[0]) {
        row[1] += step;
      }
    }
    if (row[0] < 0 || col[0] < 0) {
      return error.r;
    }
    if (Number.isNaN(col[0]) && Number.isNaN(col[1])) {
      return "".concat(prefix + $row0 + row[0], ":").concat($row1).concat(row[1]);
    }
    if (Number.isNaN(row[0]) && Number.isNaN(row[1])) {
      return "".concat(prefix + $col0 + indexToColumnChar(col[0]), ":").concat($col1).concat(indexToColumnChar(col[1]));
    }
    return "".concat(prefix + $col0 + indexToColumnChar(col[0]) + $row0 + row[0], ":").concat($col1).concat(indexToColumnChar(col[1])).concat($row1).concat(row[1]);
  }
  function downparam(txt, step) {
    return updateparam("d", txt, step);
  }
  function upparam(txt, step) {
    return updateparam("u", txt, step);
  }
  function leftparam(txt, step) {
    return updateparam("l", txt, step);
  }
  function rightparam(txt, step) {
    return updateparam("r", txt, step);
  }
  function functionCopy(ctx, txt, mode, step) {
    if (mode == null) {
      mode = "down";
    }
    if (step == null) {
      step = 1;
    }
    if (txt.substring(0, 1) === "=") {
      txt = txt.substring(1);
    }
    var funcstack = txt.split("");
    var i2 = 0;
    var str = "";
    var function_str = "";
    var matchConfig = {
      bracket: 0,
      squote: 0,
      dquote: 0
    };
    while (i2 < funcstack.length) {
      var s2 = funcstack[i2];
      if (s2 === "(" && matchConfig.dquote === 0) {
        matchConfig.bracket += 1;
        if (str.length > 0) {
          function_str += "".concat(str, "(");
        } else {
          function_str += "(";
        }
        str = "";
      } else if (s2 === ")" && matchConfig.dquote === 0) {
        matchConfig.bracket -= 1;
        function_str += "".concat(functionCopy(ctx, str, mode, step), ")");
        str = "";
      } else if (s2 === '"' && matchConfig.squote === 0) {
        if (matchConfig.dquote > 0) {
          function_str += "".concat(str, '"');
          matchConfig.dquote -= 1;
          str = "";
        } else {
          matchConfig.dquote += 1;
          str += '"';
        }
      } else if (s2 === "," && matchConfig.dquote === 0) {
        function_str += "".concat(functionCopy(ctx, str, mode, step), ",");
        str = "";
      } else if (s2 === "&" && matchConfig.dquote === 0) {
        if (str.length > 0) {
          function_str += "".concat(functionCopy(ctx, str, mode, step), "&");
          str = "";
        } else {
          function_str += "&";
        }
      } else if (s2 in operatorjson && matchConfig.dquote === 0) {
        var s_next = "";
        if (i2 + 1 < funcstack.length) {
          s_next = funcstack[i2 + 1];
        }
        var p2 = i2 - 1;
        var s_pre = null;
        if (p2 >= 0) {
          do {
            s_pre = funcstack[p2];
            p2 -= 1;
          } while (p2 >= 0 && s_pre === " ");
        }
        if (s2 + s_next in operatorjson) {
          if (str.length > 0) {
            function_str += functionCopy(ctx, str, mode, step) + s2 + s_next;
            str = "";
          } else {
            function_str += s2 + s_next;
          }
          i2 += 1;
        } else if (!/[^0-9]/.test(s_next) && s2 === "-" && (s_pre === "(" || s_pre == null || s_pre === "," || s_pre === " " || s_pre in operatorjson)) {
          str += s2;
        } else {
          if (str.length > 0) {
            function_str += functionCopy(ctx, str, mode, step) + s2;
            str = "";
          } else {
            function_str += s2;
          }
        }
      } else {
        str += s2;
      }
      if (i2 === funcstack.length - 1) {
        if (iscelldata(_$1.trim(str))) {
          if (mode === "down") {
            function_str += downparam(_$1.trim(str), step);
          } else if (mode === "up") {
            function_str += upparam(_$1.trim(str), step);
          } else if (mode === "left") {
            function_str += leftparam(_$1.trim(str), step);
          } else if (mode === "right") {
            function_str += rightparam(_$1.trim(str), step);
          }
        } else {
          function_str += _$1.trim(str);
        }
      }
      i2 += 1;
    }
    return function_str;
  }
  function checkProtectionSelectLockedOrUnLockedCells(ctx, r2, c2, sheetId) {
    var _data$r;
    var sheetFile = getSheetByIndex(ctx, sheetId);
    if (_$1.isNil(sheetFile)) {
      return true;
    }
    if (_$1.isNil(sheetFile.config) || _$1.isNil(sheetFile.config.authority)) {
      return true;
    }
    var aut = sheetFile.config.authority;
    if (_$1.isNil(aut) || _$1.isNil(aut.sheet) || aut.sheet === 0) {
      return true;
    }
    var data = sheetFile.data;
    var cell = data === null || data === void 0 ? void 0 : (_data$r = data[r2]) === null || _data$r === void 0 ? void 0 : _data$r[c2];
    if (cell && cell.lo === 0) {
      if (aut.selectunLockedCells === 1 || _$1.isNil(aut.selectunLockedCells)) {
        return true;
      }
      return false;
    }
    if (aut.selectLockedCells === 1 || _$1.isNil(aut.selectLockedCells)) {
      return true;
    }
    return false;
  }
  function checkProtectionAllSelected(ctx, sheetId) {
    var sheetFile = getSheetByIndex(ctx, sheetId);
    if (_$1.isNil(sheetFile)) {
      return true;
    }
    if (_$1.isNil(sheetFile.config) || _$1.isNil(sheetFile.config.authority)) {
      return true;
    }
    var aut = sheetFile.config.authority;
    if (_$1.isNil(aut) || _$1.isNil(aut.sheet) || aut.sheet === 0) {
      return true;
    }
    var selectunLockedCells = false;
    if (aut.selectunLockedCells === 1 || _$1.isNil(aut.selectunLockedCells)) {
      selectunLockedCells = true;
    }
    var selectLockedCells = false;
    if (aut.selectLockedCells === 1 || _$1.isNil(aut.selectLockedCells)) {
      selectLockedCells = true;
    }
    if (selectunLockedCells && selectLockedCells) {
      return true;
    }
    return false;
  }
  function checkProtectionFormatCells(ctx) {
    var sheetFile = getSheetByIndex(ctx, ctx.currentSheetId);
    if (_$1.isNil(sheetFile)) {
      return true;
    }
    if (_$1.isNil(sheetFile.config) || _$1.isNil(sheetFile.config.authority)) {
      return true;
    }
    var aut = sheetFile.config.authority;
    if (_$1.isNil(aut) || _$1.isNil(aut.sheet) || aut.sheet === 0) {
      return true;
    }
    var ht = "";
    if (!_$1.isNil(aut.hintText) && aut.hintText.length > 0) {
      ht = aut.hintText;
    } else {
      ht = aut.defaultSheetHintText;
    }
    ctx.warnDialog = ht;
    return false;
  }
  function setConditionRules(ctx, protection, generalDialog, conditionformat, rules) {
    var _ctx$luckysheet_selec, _ctx$luckysheetfile$i;
    if (!checkProtectionFormatCells(ctx)) {
      return;
    }
    var conditionName = rules.rulesType;
    var conditionRange = [];
    var conditionValue = [];
    if (conditionName === "greaterThan" || conditionName === "lessThan" || conditionName === "equal" || conditionName === "textContains") {
      var v2 = rules.rulesValue;
      var rangeArr = getRangeByTxt(ctx, v2);
      if (rangeArr.length > 1) {
        var r1 = rangeArr[0].row[0];
        var r2 = rangeArr[0].row[1];
        var c1 = rangeArr[0].column[0];
        var c2 = rangeArr[0].column[1];
        if (r1 === r2 && c1 === c2) {
          var d2 = getFlowdata(ctx);
          if (!d2) return;
          v2 = getCellValue(r1, c1, d2);
          conditionRange.push({
            row: rangeArr[0].row,
            column: rangeArr[0].column
          });
          conditionValue.push(v2);
        } else {
          ctx.warnDialog = conditionformat.onlySingleCell;
        }
      } else if (rangeArr.length === 0) {
        if (_$1.isNaN(v2) || v2 === "") {
          ctx.warnDialog = conditionformat.conditionValueCanOnly;
          return;
        }
        conditionValue.push(v2);
      }
    } else if (conditionName === "between") {
      var v1 = rules.betweenValue.value1;
      var v22 = rules.betweenValue.value2;
      var rangeArr1 = getRangeByTxt(ctx, v1);
      if (rangeArr1.length > 1) {
        ctx.warnDialog = conditionformat.onlySingleCell;
        return;
      }
      if (rangeArr1.length === 1) {
        var _r = rangeArr1[0].row[0];
        var _r2 = rangeArr1[0].row[1];
        var _c = rangeArr1[0].column[0];
        var _c2 = rangeArr1[0].column[1];
        if (_r === _r2 && _c === _c2) {
          var _d = getFlowdata(ctx);
          if (!_d) return;
          v1 = getCellValue(_r, _c, _d);
          conditionRange.push({
            row: rangeArr1[0].row,
            column: rangeArr1[0].column
          });
          conditionValue.push(v1);
        } else {
          ctx.warnDialog = conditionformat.onlySingleCell;
          return;
        }
      } else if (rangeArr1.length === 0) {
        if (_$1.isNaN(v1) || v1 === "") {
          ctx.warnDialog = conditionformat.conditionValueCanOnly;
          return;
        }
        conditionValue.push(v1);
      }
      var rangeArr2 = getRangeByTxt(ctx, v22);
      if (rangeArr2.length > 1) {
        ctx.warnDialog = conditionformat.onlySingleCell;
        return;
      }
      if (rangeArr2.length === 1) {
        var _r3 = rangeArr2[0].row[0];
        var _r4 = rangeArr2[0].row[1];
        var _c3 = rangeArr2[0].column[0];
        var _c4 = rangeArr2[0].column[1];
        if (_r3 === _r4 && _c3 === _c4) {
          var _d2 = getFlowdata(ctx);
          if (!_d2) return;
          v22 = getCellValue(_r3, _c3, _d2);
          conditionRange.push({
            row: rangeArr2[0].row,
            column: rangeArr2[0].column
          });
        } else {
          ctx.warnDialog = conditionformat.onlySingleCell;
          return;
        }
      } else if (rangeArr2.length === 0) {
        if (_$1.isNaN(v22) || v22 === "") {
          ctx.warnDialog = conditionformat.conditionValueCanOnly;
        } else {
          conditionValue.push(v22);
        }
      }
    } else if (conditionName === "occurrenceDate") {
      var _v = rules.dateValue;
      if (!_v) {
        ctx.warnDialog = conditionformat.pleaseSelectADate;
        return;
      }
      conditionValue.push(_v);
    } else if (conditionName === "duplicateValue") {
      conditionValue.push(rules.repeatValue);
    } else if (conditionName === "top10" || conditionName === "top10_percent" || conditionName === "last10" || conditionName === "last10_percent") {
      var _v2 = rules.projectValue;
      if (parseInt(_v2, 10).toString() !== _v2 || parseInt(_v2, 10) < 1 || parseInt(_v2, 10) > 1e3) {
        ctx.warnDialog = conditionformat.pleaseEnterInteger;
        return;
      }
      conditionValue.push(_v2);
    } else {
      conditionValue.push(conditionName);
    }
    var textColor = null;
    if (rules.textColor.check) {
      textColor = rules.textColor.color;
    }
    var cellColor = null;
    if (rules.cellColor.check) {
      cellColor = rules.cellColor.color;
    }
    var rule = {
      type: "default",
      cellrange: (_ctx$luckysheet_selec = ctx.luckysheet_select_save) !== null && _ctx$luckysheet_selec !== void 0 ? _ctx$luckysheet_selec : [],
      format: {
        textColor,
        cellColor
      },
      conditionName,
      conditionRange,
      conditionValue
    };
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var ruleArr = (_ctx$luckysheetfile$i = ctx.luckysheetfile[index2].luckysheet_conditionformat_save) !== null && _ctx$luckysheetfile$i !== void 0 ? _ctx$luckysheetfile$i : [];
    ruleArr === null || ruleArr === void 0 ? void 0 : ruleArr.push(rule);
    ctx.luckysheetfile[index2].luckysheet_conditionformat_save = ruleArr;
  }
  function getColorGradation(color1, color2, value1, value2, value) {
    var rgb1 = color1.split(",");
    var r1 = parseInt(rgb1[0].split("(")[1], 10);
    var g1 = parseInt(rgb1[1], 10);
    var b1 = parseInt(rgb1[2].split(")")[0], 10);
    var rgb2 = color2.split(",");
    var r2 = parseInt(rgb2[0].split("(")[1], 10);
    var g2 = parseInt(rgb2[1], 10);
    var b2 = parseInt(rgb2[2].split(")")[0], 10);
    var v12 = value1 - value2;
    var v10 = value1 - value;
    var r3 = Math.round(r1 - (r1 - r2) / v12 * v10);
    var g3 = Math.round(g1 - (g1 - g2) / v12 * v10);
    var b3 = Math.round(b1 - (b1 - b2) / v12 * v10);
    return "rgb(".concat(r3, ", ").concat(g3, ", ").concat(b3, ")");
  }
  function compute(ctx, ruleArr, d2) {
    if (_$1.isNil(ruleArr)) {
      ruleArr = [];
    }
    var computeMap = {};
    if (ruleArr.length > 0) {
      for (var i2 = 0; i2 < ruleArr.length; i2 += 1) {
        var _ruleArr$i = ruleArr[i2], type = _ruleArr$i.type, cellrange = _ruleArr$i.cellrange, format = _ruleArr$i.format;
        if (type === "dataBar") {
          var max = null;
          var min = null;
          for (var s2 = 0; s2 < cellrange.length; s2 += 1) {
            for (var r2 = cellrange[s2].row[0]; r2 <= cellrange[s2].row[1]; r2 += 1) {
              for (var c2 = cellrange[s2].column[0]; c2 <= cellrange[s2].column[1]; c2 += 1) {
                if (_$1.isNil(d2[r2]) || _$1.isNil(d2[r2][c2])) {
                  continue;
                }
                var cell = d2[r2][c2];
                if (!_$1.isNil(cell) && !_$1.isNil(cell.ct) && cell.ct.t === "n" && _$1.isNil(cell.v)) {
                  if (_$1.isNil(max) || parseInt("".concat(cell.v), 10) > max) {
                    max = parseInt("".concat(cell.v), 10);
                  }
                  if (_$1.isNil(min) || parseInt("".concat(cell.v), 10) < min) {
                    min = parseInt("".concat(cell.v), 10);
                  }
                }
              }
            }
          }
          if (!_$1.isNil(max) && !_$1.isNil(min)) {
            if (min < 0) {
              var plusLen = Math.round(max / (max - min) * 10) / 10;
              var minusLen = Math.round(Math.abs(min) / (max - min) * 10) / 10;
              for (var _s = 0; _s < cellrange.length; _s += 1) {
                for (var _r5 = cellrange[_s].row[0]; _r5 <= cellrange[_s].row[1]; _r5 += 1) {
                  for (var _c5 = cellrange[_s].column[0]; _c5 <= cellrange[_s].column[1]; _c5 += 1) {
                    if (_$1.isNil(d2[_r5]) || _$1.isNil(d2[_r5][_c5])) {
                      continue;
                    }
                    var _cell = d2[_r5][_c5];
                    if (!_$1.isNil(_cell) && !_$1.isNil(_cell.ct) && _cell.ct.t === "n" && !_$1.isNil(_cell.v)) {
                      if (parseInt("".concat(_cell.v), 10) < 0) {
                        var valueLen = Math.round(Math.abs(parseInt("".concat(_cell.v), 10)) / Math.abs(min) * 100) / 100;
                        if ("".concat(_r5, "_").concat(_c5) in computeMap) {
                          computeMap["".concat(_r5, "_").concat(_c5)].dataBar = {
                            valueType: "minus",
                            minusLen,
                            valueLen,
                            format
                          };
                        } else {
                          computeMap["".concat(_r5, "_").concat(_c5)] = {
                            dataBar: {
                              valueType: "minus",
                              minusLen,
                              valueLen,
                              format
                            }
                          };
                        }
                      }
                      if (parseInt("".concat(_cell.v), 10) > 0) {
                        var _valueLen = Math.round(parseInt("".concat(_cell.v), 10) / max * 100) / 100;
                        if ("".concat(_r5, "_").concat(_c5) in computeMap) {
                          computeMap["".concat(_r5, "_").concat(_c5)].dataBar = {
                            valueType: "plus",
                            plusLen,
                            minusLen,
                            valueLen: _valueLen,
                            format
                          };
                        } else {
                          computeMap["".concat(_r5, "_").concat(_c5)] = {
                            dataBar: {
                              valueType: "plus",
                              plusLen,
                              minusLen,
                              valueLen: _valueLen,
                              format
                            }
                          };
                        }
                      }
                    }
                  }
                }
              }
            } else {
              var _plusLen = 1;
              for (var _s2 = 0; _s2 < cellrange.length; _s2 += 1) {
                for (var _r6 = cellrange[_s2].row[0]; _r6 <= cellrange[_s2].row[1]; _r6 += 1) {
                  for (var _c6 = cellrange[_s2].column[0]; _c6 <= cellrange[_s2].column[1]; _c6 += 1) {
                    if (_$1.isNil(d2[_r6]) || _$1.isNil(d2[_r6][_c6])) {
                      continue;
                    }
                    var _cell2 = d2[_r6][_c6];
                    if (!_$1.isNil(_cell2) && !_$1.isNil(_cell2.ct) && _cell2.ct.t === "n" && !_$1.isNil(_cell2.v)) {
                      var _valueLen2 = void 0;
                      if (max === 0) {
                        _valueLen2 = 1;
                      } else {
                        _valueLen2 = Math.round(parseInt("".concat(_cell2.v), 10) / max * 100) / 100;
                      }
                      if ("".concat(_r6, "_").concat(_c6) in computeMap) {
                        computeMap["".concat(_r6, "_").concat(_c6)].dataBar = {
                          valueType: "plus",
                          plusLen: _plusLen,
                          valueLen: _valueLen2,
                          format
                        };
                      } else {
                        computeMap["".concat(_r6, "_").concat(_c6)] = {
                          dataBar: {
                            valueType: "plus",
                            plusLen: _plusLen,
                            valueLen: _valueLen2,
                            format
                          }
                        };
                      }
                    }
                  }
                }
              }
            }
          }
        } else if (type === "colorGradation") {
          var _max = null;
          var _min = null;
          var sum = 0;
          var count = 0;
          for (var _s3 = 0; _s3 < cellrange.length; _s3 += 1) {
            for (var _r7 = cellrange[_s3].row[0]; _r7 <= cellrange[_s3].row[1]; _r7 += 1) {
              for (var _c7 = cellrange[_s3].column[0]; _c7 <= cellrange[_s3].column[1]; _c7 += 1) {
                if (_$1.isNil(d2[_r7]) || _$1.isNil(d2[_r7][_c7])) {
                  continue;
                }
                var _cell3 = d2[_r7][_c7];
                if (!_$1.isNil(_cell3) && !_$1.isNil(_cell3.ct) && _cell3.ct.t === "n" && !_$1.isNil(_cell3.v)) {
                  count += 1;
                  sum += parseInt("".concat(_cell3.v), 10);
                  if (_$1.isNil(_max) || parseInt("".concat(_cell3.v), 10) > _max) {
                    _max = parseInt("".concat(_cell3.v), 10);
                  }
                  if (_$1.isNil(_min) || parseInt("".concat(_cell3.v), 10) < _min) {
                    _min = parseInt("".concat(_cell3.v), 10);
                  }
                }
              }
            }
          }
          if (!_$1.isNil(_max) && !_$1.isNil(_min)) {
            if (format.length === 3) {
              var avg = Math.floor(sum / count);
              for (var _s4 = 0; _s4 < cellrange.length; _s4 += 1) {
                for (var _r8 = cellrange[_s4].row[0]; _r8 <= cellrange[_s4].row[1]; _r8 += 1) {
                  for (var _c8 = cellrange[_s4].column[0]; _c8 <= cellrange[_s4].column[1]; _c8 += 1) {
                    if (_$1.isNil(d2[_r8]) || _$1.isNil(d2[_r8][_c8])) {
                      continue;
                    }
                    var _cell4 = d2[_r8][_c8];
                    if (!_$1.isNil(_cell4) && !_$1.isNil(_cell4.ct) && _cell4.ct.t === "n" && !_$1.isNil(_cell4.v)) {
                      if (parseInt("".concat(_cell4.v), 10) === _min) {
                        if ("".concat(_r8, "_").concat(_c8) in computeMap) {
                          computeMap["".concat(_r8, "_").concat(_c8)].cellColor = format.cellColor;
                        } else {
                          computeMap["".concat(_r8, "_").concat(_c8)] = {
                            cellColor: format.cellColor
                          };
                        }
                      } else if (parseInt("".concat(_cell4.v), 10) > _min && parseInt("".concat(_cell4.v), 10) < avg) {
                        if ("".concat(_r8, "_").concat(_c8) in computeMap) {
                          computeMap["".concat(_r8, "_").concat(_c8)].cellColor = getColorGradation(format.cellColor, format.textColor, _min, avg, parseInt("".concat(_cell4.v), 10));
                        } else {
                          computeMap["".concat(_r8, "_").concat(_c8)] = {
                            cellColor: getColorGradation(format[2], format[1], _min, avg, parseInt("".concat(_cell4.v), 10))
                          };
                        }
                      } else if (parseInt("".concat(_cell4.v), 10) === avg) {
                        if ("".concat(_r8, "_").concat(_c8) in computeMap) {
                          computeMap["".concat(_r8, "_").concat(_c8)].cellColor = format.cellColor;
                        } else {
                          computeMap["".concat(_r8, "_").concat(_c8)] = {
                            cellColor: format[1]
                          };
                        }
                      } else if (parseInt("".concat(_cell4.v), 10) > avg && parseInt("".concat(_cell4.v), 10) < _max) {
                        if ("".concat(_r8, "_").concat(_c8) in computeMap) {
                          computeMap["".concat(_r8, "_").concat(_c8)].cellColor = getColorGradation(format[1], format[0], avg, _max, parseInt("".concat(_cell4.v), 10));
                        } else {
                          computeMap["".concat(_r8, "_").concat(_c8)] = {
                            cellColor: getColorGradation(format[1], format[0], avg, _max, parseInt("".concat(_cell4.v), 10))
                          };
                        }
                      } else if (parseInt("".concat(_cell4.v), 10) === _max) {
                        if ("".concat(_r8, "_").concat(_c8) in computeMap) {
                          computeMap["".concat(_r8, "_").concat(_c8)].cellColor = format.cellColor;
                        } else {
                          computeMap["".concat(_r8, "_").concat(_c8)] = {
                            cellColor: format[0]
                          };
                        }
                      }
                    }
                  }
                }
              }
            } else if (format.length === 2) {
              for (var _s5 = 0; _s5 < cellrange.length; _s5 += 1) {
                for (var _r9 = cellrange[_s5].row[0]; _r9 <= cellrange[_s5].row[1]; _r9 += 1) {
                  for (var _c9 = cellrange[_s5].column[0]; _c9 <= cellrange[_s5].column[1]; _c9 += 1) {
                    if (_$1.isNil(d2[_r9]) || _$1.isNil(d2[_r9][_c9])) {
                      continue;
                    }
                    var _cell5 = d2[_r9][_c9];
                    if (!_$1.isNil(_cell5) && !_$1.isNil(_cell5.ct) && _cell5.ct.t === "n" && !_$1.isNil(_cell5.v)) {
                      if (parseInt("".concat(_cell5.v), 10) === _min) {
                        if ("".concat(_r9, "_").concat(_c9) in computeMap) {
                          computeMap["".concat(_r9, "_").concat(_c9)].cellColor = format.cellColor;
                        } else {
                          computeMap["".concat(_r9, "_").concat(_c9)] = {
                            cellColor: format[1]
                          };
                        }
                      } else if (parseInt("".concat(_cell5.v), 10) > _min && parseInt("".concat(_cell5.v), 10) < _max) {
                        if ("".concat(_r9, "_").concat(_c9) in computeMap) {
                          computeMap["".concat(_r9, "_").concat(_c9)].cellColor = getColorGradation(format[1], format[0], _min, _max, parseInt("".concat(_cell5.v), 10));
                        } else {
                          computeMap["".concat(_r9, "_").concat(_c9)] = {
                            cellColor: getColorGradation(format[1], format[0], _min, _max, parseInt("".concat(_cell5.v), 10))
                          };
                        }
                      } else if (parseInt("".concat(_cell5.v), 10) === _max) {
                        if ("".concat(_r9, "_").concat(_c9) in computeMap) {
                          computeMap["".concat(_r9, "_").concat(_c9)].cellColor = format.textColor;
                        } else {
                          computeMap["".concat(_r9, "_").concat(_c9)] = {
                            cellColor: format[0]
                          };
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else if (type === "icons") ;
        else {
          (function() {
            var conditionName = ruleArr[i2].conditionName;
            var conditionValue0 = ruleArr[i2].conditionValue[0];
            var conditionValue1 = ruleArr[i2].conditionValue[1];
            var textColor = format.textColor, cellColor = format.cellColor;
            for (var _s6 = 0; _s6 < cellrange.length; _s6 += 1) {
              if (conditionName === "greaterThan" || conditionName === "lessThan" || conditionName === "equal" || conditionName === "textContains") {
                for (var _r10 = cellrange[_s6].row[0]; _r10 <= cellrange[_s6].row[1]; _r10 += 1) {
                  for (var _c10 = cellrange[_s6].column[0]; _c10 <= cellrange[_s6].column[1]; _c10 += 1) {
                    if (_$1.isNil(d2[_r10]) || _$1.isNil(d2[_r10][_c10])) {
                      continue;
                    }
                    var _cell6 = d2[_r10][_c10];
                    if (_$1.isNil(_cell6) || _$1.isNil(_cell6.v) || isRealNull(_cell6.v)) {
                      continue;
                    }
                    if (conditionName === "greaterThan" && _cell6.v > conditionValue0) {
                      if ("".concat(_r10, "_").concat(_c10) in computeMap) {
                        computeMap["".concat(_r10, "_").concat(_c10)].textColor = textColor;
                        computeMap["".concat(_r10, "_").concat(_c10)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(_r10, "_").concat(_c10)] = {
                          textColor,
                          cellColor
                        };
                      }
                    } else if (conditionName === "lessThan" && _cell6.v < conditionValue0) {
                      if ("".concat(_r10, "_").concat(_c10) in computeMap) {
                        computeMap["".concat(_r10, "_").concat(_c10)].textColor = textColor;
                        computeMap["".concat(_r10, "_").concat(_c10)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(_r10, "_").concat(_c10)] = {
                          textColor,
                          cellColor
                        };
                      }
                    } else if (conditionName === "equal" && _cell6.v.toString() === conditionValue0) {
                      if ("".concat(_r10, "_").concat(_c10) in computeMap) {
                        computeMap["".concat(_r10, "_").concat(_c10)].textColor = textColor;
                        computeMap["".concat(_r10, "_").concat(_c10)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(_r10, "_").concat(_c10)] = {
                          textColor,
                          cellColor
                        };
                      }
                    } else if (conditionName === "textContains" && _cell6.v.toString().indexOf(conditionValue0) !== -1) {
                      if ("".concat(_r10, "_").concat(_c10) in computeMap) {
                        computeMap["".concat(_r10, "_").concat(_c10)].textColor = textColor;
                        computeMap["".concat(_r10, "_").concat(_c10)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(_r10, "_").concat(_c10)] = {
                          textColor,
                          cellColor
                        };
                      }
                    }
                  }
                }
              } else if (conditionName === "between") {
                var vBig = 0;
                var vSmall = 0;
                if (conditionValue0 > conditionValue1) {
                  vBig = conditionValue0;
                  vSmall = conditionValue1;
                } else {
                  vBig = conditionValue1;
                  vSmall = conditionValue0;
                }
                for (var _r11 = cellrange[_s6].row[0]; _r11 <= cellrange[_s6].row[1]; _r11 += 1) {
                  for (var _c11 = cellrange[_s6].column[0]; _c11 <= cellrange[_s6].column[1]; _c11 += 1) {
                    if (_$1.isNil(d2[_r11]) || _$1.isNil(d2[_r11][_c11])) {
                      continue;
                    }
                    var _cell7 = d2[_r11][_c11];
                    if (_$1.isNil(_cell7) || _$1.isNil(_cell7.v) || isRealNull(_cell7.v)) {
                      continue;
                    }
                    if (_cell7.v >= vSmall && _cell7.v <= vBig) {
                      if ("".concat(_r11, "_").concat(_c11) in computeMap) {
                        computeMap["".concat(_r11, "_").concat(_c11)].textColor = textColor;
                        computeMap["".concat(_r11, "_").concat(_c11)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(_r11, "_").concat(_c11)] = {
                          textColor,
                          cellColor
                        };
                      }
                    }
                  }
                }
              } else if (conditionName === "occurrenceDate") {
                var dBig = void 0;
                var dSmall = void 0;
                if (conditionValue0.toString().indexOf("-") === -1) {
                  dBig = genarate(conditionValue0)[2].toString();
                  dSmall = genarate(conditionValue0)[2].toString();
                } else {
                  var str = conditionValue0.toString().split("-");
                  dBig = genarate(str[1].trim())[2].toString();
                  dSmall = genarate(str[0].trim()[2].toString());
                }
                for (var _r12 = cellrange[_s6].row[0]; _r12 <= cellrange[_s6].row[1]; _r12 += 1) {
                  for (var _c12 = cellrange[_s6].column[0]; _c12 <= cellrange[_s6].column[1]; _c12 += 1) {
                    if (_$1.isNil(d2[_r12]) || _$1.isNil(d2[_r12][_c12])) {
                      continue;
                    }
                    if (!_$1.isNil(d2[_r12][_c12]) && !_$1.isNil(d2[_r12][_c12].ct) && d2[_r12][_c12].ct.t === "d") {
                      var cellVal = getCellValue(_r12, _c12, d2);
                      if (cellVal >= dSmall && cellVal <= dBig) {
                        if ("".concat(_r12, "_").concat(_c12) in computeMap) {
                          computeMap["".concat(_r12, "_").concat(_c12)].textColor = textColor;
                          computeMap["".concat(_r12, "_").concat(_c12)].cellColor = cellColor;
                        } else {
                          computeMap["".concat(_r12, "_").concat(_c12)] = {
                            textColor,
                            cellColor
                          };
                        }
                      }
                    }
                  }
                }
              } else if (conditionName === "duplicateValue") {
                var dmap = {};
                for (var _r13 = cellrange[_s6].row[0]; _r13 <= cellrange[_s6].row[1]; _r13 += 1) {
                  for (var _c13 = cellrange[_s6].column[0]; _c13 <= cellrange[_s6].column[1]; _c13 += 1) {
                    var item = getCellValue(_r13, _c13, d2);
                    if (!(item in dmap)) {
                      dmap[item] = [];
                    }
                    dmap[item].push({
                      r: _r13,
                      c: _c13
                    });
                  }
                }
                if (conditionValue0 === "0") {
                  _$1.forEach(dmap, function(x2) {
                    if (x2.length > 1) {
                      for (var j3 = 0; j3 < x2.length; j3 += 1) {
                        if ("".concat(x2[j3].r, "_").concat(x2[j3].c) in computeMap) {
                          computeMap["".concat(x2[j3].r, "_").concat(x2[j3].c)].textColor = textColor;
                          computeMap["".concat(x2[j3].r, "_").concat(x2[j3].c)].cellColor = cellColor;
                        } else {
                          computeMap["".concat(x2[j3].r, "_").concat(x2[j3].c)] = {
                            textColor,
                            cellColor
                          };
                        }
                      }
                    }
                  });
                } else if (conditionValue0 === "1") {
                  _$1.forEach(dmap, function(x2) {
                    if (x2.length === 1) {
                      if ("".concat(x2[0].r, "_").concat(x2[0].c) in computeMap) {
                        computeMap["".concat(x2[0].r, "_").concat(x2[0].c)].textColor = textColor;
                        computeMap["".concat(x2[0].r, "_").concat(x2[0].c)].cellColor = cellColor;
                      } else {
                        computeMap["".concat(x2[0].r, "_").concat(x2[0].c)] = {
                          textColor,
                          cellColor
                        };
                      }
                    }
                  });
                }
              } else if (conditionName === "top10" || conditionName === "top10_percent" || conditionName === "last10" || conditionName === "last10_percent" || conditionName === "aboveAverage" || conditionName === "belowAverage") {
                var dArr = [];
                for (var _r14 = cellrange[_s6].row[0]; _r14 <= cellrange[_s6].row[1]; _r14 += 1) {
                  for (var _c14 = cellrange[_s6].column[0]; _c14 <= cellrange[_s6].column[1]; _c14 += 1) {
                    if (_$1.isNil(d2[_r14]) || _$1.isNil(d2[_r14][_c14])) {
                      continue;
                    }
                    if (!_$1.isNil(d2[_r14][_c14]) && !_$1.isNil(d2[_r14][_c14].ct) && d2[_r14][_c14].ct.t === "n") {
                      dArr.push(getCellValue(_r14, _c14, d2));
                    }
                  }
                }
                if (conditionName === "top10" || conditionName === "top10_percent" || conditionName === "last10" || conditionName === "last10_percent") {
                  for (var j2 = 0; j2 < dArr.length; j2 += 1) {
                    for (var k2 = 0; k2 < dArr.length - 1 - j2; k2 += 1) {
                      if (dArr[k2] < dArr[k2 + 1]) {
                        var temp = dArr[k2];
                        dArr[k2] = dArr[k2 + 1];
                        dArr[k2 + 1] = temp;
                      }
                    }
                  }
                  var cArr = void 0;
                  if (conditionName === "top10") {
                    cArr = dArr.slice(0, conditionValue0);
                  } else if (conditionName === "top10_percent") {
                    cArr = dArr.slice(0, Math.floor(conditionValue0 * dArr.length / 100));
                  } else if (conditionName === "last10") {
                    cArr = dArr.slice(dArr.length - conditionValue0, dArr.length);
                  } else if (conditionName === "last10_percent") {
                    cArr = dArr.slice(dArr.length - Math.floor(conditionValue0 * dArr.length / 100), dArr.length);
                  }
                  for (var _r15 = cellrange[_s6].row[0]; _r15 <= cellrange[_s6].row[1]; _r15 += 1) {
                    for (var _c15 = cellrange[_s6].column[0]; _c15 <= cellrange[_s6].column[1]; _c15 += 1) {
                      if (_$1.isNil(d2[_r15]) || _$1.isNil(d2[_r15][_c15])) {
                        continue;
                      }
                      var _cellVal = getCellValue(_r15, _c15, d2);
                      if (!_$1.isNil(cArr) && cArr.indexOf(_cellVal) !== -1) {
                        if ("".concat(_r15, "_").concat(_c15) in computeMap) {
                          computeMap["".concat(_r15, "_").concat(_c15)].textColor = textColor;
                          computeMap["".concat(_r15, "_").concat(_c15)].cellColor = cellColor;
                        } else {
                          computeMap["".concat(_r15, "_").concat(_c15)] = {
                            textColor,
                            cellColor
                          };
                        }
                      }
                    }
                  }
                } else if (conditionName === "aboveAverage" || conditionName === "belowAverage") {
                  var _sum = 0;
                  for (var _j = 0; _j < dArr.length; _j += 1) {
                    _sum += dArr[_j];
                  }
                  var averageNum = _sum / dArr.length;
                  if (conditionName === "aboveAverage") {
                    for (var _r16 = cellrange[_s6].row[0]; _r16 <= cellrange[_s6].row[1]; _r16 += 1) {
                      for (var _c16 = cellrange[_s6].column[0]; _c16 <= cellrange[_s6].column[1]; _c16 += 1) {
                        if (_$1.isNil(d2[_r16]) || _$1.isNil(d2[_r16][_c16])) {
                          continue;
                        }
                        var _cellVal2 = getCellValue(_r16, _c16, d2);
                        if (_cellVal2 > averageNum) {
                          if ("".concat(_r16, "_").concat(_c16) in computeMap) {
                            computeMap["".concat(_r16, "_").concat(_c16)].textColor = textColor;
                            computeMap["".concat(_r16, "_").concat(_c16)].cellColor = cellColor;
                          } else {
                            computeMap["".concat(_r16, "_").concat(_c16)] = {
                              textColor,
                              cellColor
                            };
                          }
                        }
                      }
                    }
                  } else if (conditionName === "belowAverage") {
                    for (var _r17 = cellrange[_s6].row[0]; _r17 <= cellrange[_s6].row[1]; _r17 += 1) {
                      for (var _c17 = cellrange[_s6].column[0]; _c17 <= cellrange[_s6].column[1]; _c17 += 1) {
                        if (_$1.isNil(d2[_r17]) || _$1.isNil(d2[_r17][_c17])) {
                          continue;
                        }
                        var _cellVal3 = getCellValue(_r17, _c17, d2);
                        if (_cellVal3 < averageNum) {
                          if ("".concat(_r17, "_").concat(_c17) in computeMap) {
                            computeMap["".concat(_r17, "_").concat(_c17)].textColor = textColor;
                            computeMap["".concat(_r17, "_").concat(_c17)].cellColor = cellColor;
                          } else {
                            computeMap["".concat(_r17, "_").concat(_c17)] = {
                              textColor,
                              cellColor
                            };
                          }
                        }
                      }
                    }
                  }
                }
              } else if (conditionName === "formula") {
                var _str = cellrange[_s6].row[0];
                var edr = cellrange[_s6].row[1];
                var stc = cellrange[_s6].column[0];
                var edc = cellrange[_s6].column[1];
                var formulaTxt = conditionValue0;
                if (conditionValue0.toString().slice(0, 1) !== "=") {
                  formulaTxt = "=".concat(conditionValue0);
                }
                for (var _r18 = _str; _r18 <= edr; _r18 += 1) {
                  for (var _c18 = stc; _c18 <= edc; _c18 += 1) {
                    var func2 = formulaTxt;
                    var offsetRow = _r18 - _str;
                    var offsetCol = _c18 - stc;
                    if (offsetRow > 0) {
                      func2 = "=".concat(functionCopy(ctx, func2, "down", offsetRow));
                    }
                    if (offsetCol > 0) {
                      func2 = "=".concat(functionCopy(ctx, func2, "right", offsetCol));
                    }
                    var funcV = execfunction(ctx, func2, _r18, _c18);
                    var v2 = funcV[1];
                    if (typeof v2 !== "boolean") {
                      v2 = !!Number(v2);
                    }
                    if (!v2) {
                      continue;
                    }
                    if ("".concat(_r18, "_").concat(_c18) in computeMap) {
                      computeMap["".concat(_r18, "_").concat(_c18)].textColor = textColor;
                      computeMap["".concat(_r18, "_").concat(_c18)].cellColor = cellColor;
                    } else {
                      computeMap["".concat(_r18, "_").concat(_c18)] = {
                        textColor,
                        cellColor
                      };
                    }
                  }
                }
              }
            }
          })();
        }
      }
    }
    return computeMap;
  }
  function getComputeMap(ctx) {
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var ruleArr = ctx.luckysheetfile[index2].luckysheet_conditionformat_save;
    var data = ctx.luckysheetfile[index2].data;
    if (_$1.isNil(data)) return null;
    var computeMap = compute(ctx, ruleArr, data);
    return computeMap;
  }
  function checkCF(r2, c2, computeMap) {
    if (!_$1.isNil(computeMap) && "".concat(r2, "_").concat(c2) in computeMap) {
      return computeMap["".concat(r2, "_").concat(c2)];
    }
    return null;
  }
  function updateItem(ctx, type) {
    if (!checkProtectionFormatCells(ctx)) {
      return;
    }
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var ruleArr = [];
    {
      ruleArr = [];
    }
    ctx.luckysheetfile[index2].luckysheet_conditionformat_save = ruleArr;
  }
  function CFSplitRange(range1, range2, range3, type) {
    var range = [];
    var offset_r = range3.row[0] - range2.row[0];
    var offset_c = range3.column[0] - range2.column[0];
    var r1 = range1.row[0];
    var r2 = range1.row[1];
    var c1 = range1.column[0];
    var c2 = range1.column[1];
    if (r1 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1 + offset_r, r2 + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, r2 + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, c2 + offset_c]
        }];
      }
    } else if (c1 >= range2.column[0] && c1 <= range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [r1 + offset_r, r2 + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, r2 + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (c2 >= range2.column[0] && c2 <= range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1 + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [r1 + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [c1 + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, c2 + offset_c]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r1 >= range2.row[0] && r1 <= range2.row[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [r1 + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r2 >= range2.row[0] && r2 <= range2.row[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, r2 + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 < range2.column[0] && c2 > range2.column[1]) {
      if (type === "allPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }, {
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [{
          row: [range2.row[0] + offset_r, range2.row[1] + offset_r],
          column: [range2.column[0] + offset_c, range2.column[1] + offset_c]
        }];
      }
    } else {
      if (type === "allPart") {
        range = [{
          row: [r1, r2],
          column: [c1, c2]
        }];
      } else if (type === "restPart") {
        range = [{
          row: [r1, r2],
          column: [c1, c2]
        }];
      } else if (type === "operatePart") {
        range = [];
      }
    }
    return range;
  }
  function getDropdownList(ctx, txt) {
    var list = [];
    if (iscelldata(txt)) {
      var range = getcellrange(ctx, txt);
      var index2 = getSheetIndex(ctx, ctx.currentSheetId);
      var d2 = ctx.luckysheetfile[index2].data;
      if (!d2) return [];
      for (var r2 = range.row[0]; r2 <= range.row[1]; r2 += 1) {
        for (var c2 = range.column[0]; c2 <= range.column[1]; c2 += 1) {
          if (!d2[r2]) {
            continue;
          }
          var cell = d2[r2][c2];
          if (!cell || !cell.v) {
            continue;
          }
          var v2 = cell.m || cell.v;
          if (!list.includes(v2)) {
            list.push(v2);
          }
        }
      }
    } else {
      var arr = txt.split(",");
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        var _v = arr[i2];
        if (_v.length === 0) {
          continue;
        }
        if (!list.includes(_v)) {
          list.push(_v);
        }
      }
    }
    return list;
  }
  function validateIdCard(ctx, idCard) {
    var regIdCard = /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/;
    if (regIdCard.test(idCard)) {
      if (idCard.length === 18) {
        var idCardWi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
        var idCardY = [1, 0, 10, 9, 8, 7, 6, 5, 4, 3, 2];
        var idCardWiSum = 0;
        for (var i2 = 0; i2 < 17; i2 += 1) {
          idCardWiSum += Number(idCard.substring(i2, i2 + 1)) * idCardWi[i2];
        }
        var idCardMod = idCardWiSum % 11;
        var idCardLast = idCard.substring(17);
        if (idCardMod === 2) {
          if (idCardLast === "X" || idCardLast === "x") {
            return true;
          }
          return false;
        }
        if (idCardLast === idCardY[idCardMod].toString()) {
          return true;
        }
        return false;
      }
    } else {
      return false;
    }
    return false;
  }
  function validateCellData(ctx, item, cellValue) {
    var value1 = item.value1, value2 = item.value2;
    var type = item.type, type2 = item.type2;
    if (type === "dropdown") {
      var list = getDropdownList(ctx, value1);
      if (type2 && cellValue) {
        return cellValue.toString().split(",").every(function(i3) {
          return list.indexOf(i3) !== -1;
        });
      }
      var result = false;
      for (var i2 = 0; i2 < list.length; i2 += 1) {
        if (list[i2] === cellValue) {
          result = true;
          break;
        }
      }
      return result;
    }
    if (type === "checkbox") ;
    else if (type === "number" || type === "number_integer" || type === "number_decimal") {
      if (!isRealNum(cellValue)) {
        return false;
      }
      cellValue = Number(cellValue);
      if (type === "number_integer" && cellValue % 1 !== 0) {
        return false;
      }
      if (type === "number_decimal" && cellValue % 1 === 0) {
        return false;
      }
      value1 = Number(value1);
      value2 = Number(value2);
      if (type2 === "between" && (cellValue < value1 || cellValue > value2)) {
        return false;
      }
      if (type2 === "notBetween" && cellValue >= value1 && cellValue <= value2) {
        return false;
      }
      if (type2 === "equal" && cellValue !== value1) {
        return false;
      }
      if (type2 === "notEqualTo" && cellValue === value1) {
        return false;
      }
      if (type2 === "moreThanThe" && cellValue <= value1) {
        return false;
      }
      if (type2 === "lessThan" && cellValue >= value1) {
        return false;
      }
      if (type2 === "greaterOrEqualTo" && cellValue < value1) {
        return false;
      }
      if (type2 === "lessThanOrEqualTo" && cellValue > value1) {
        return false;
      }
    } else if (type === "text_content") {
      cellValue = cellValue.toString();
      value1 = value1.toString();
      if (type2 === "include" && cellValue.indexOf(value1) === -1) {
        return false;
      }
      if (type2 === "exclude" && cellValue.indexOf(value1) > -1) {
        return false;
      }
      if (type2 === "equal" && cellValue !== value1) {
        return false;
      }
    } else if (type === "text_length") {
      cellValue = cellValue.toString().length;
      value1 = Number(value1);
      value2 = Number(value2);
      if (type2 === "between" && (cellValue < value1 || cellValue > value2)) {
        return false;
      }
      if (type2 === "notBetween" && cellValue >= value1 && cellValue <= value2) {
        return false;
      }
      if (type2 === "equal" && cellValue !== value1) {
        return false;
      }
      if (type2 === "notEqualTo" && cellValue === value1) {
        return false;
      }
      if (type2 === "moreThanThe" && cellValue <= value1) {
        return false;
      }
      if (type2 === "lessThan" && cellValue >= value1) {
        return false;
      }
      if (type2 === "greaterOrEqualTo" && cellValue < value1) {
        return false;
      }
      if (type2 === "lessThanOrEqualTo" && cellValue > value1) {
        return false;
      }
    } else if (type === "date") {
      if (!isdatetime(cellValue)) {
        return false;
      }
      if (type2 === "between" && (diff(cellValue, value1) < 0 || diff(cellValue, value2) > 0)) {
        return false;
      }
      if (type2 === "notBetween" && diff(cellValue, value1) >= 0 && diff(cellValue, value2) <= 0) {
        return false;
      }
      if (type2 === "equal" && diff(cellValue, value1) !== 0) {
        return false;
      }
      if (type2 === "notEqualTo" && diff(cellValue, value1) === 0) {
        return false;
      }
      if (type2 === "earlierThan" && diff(cellValue, value1) >= 0) {
        return false;
      }
      if (type2 === "noEarlierThan" && diff(cellValue, value1) < 0) {
        return false;
      }
      if (type2 === "laterThan" && diff(cellValue, value1) <= 0) {
        return false;
      }
      if (type2 === "noLaterThan" && diff(cellValue, value1) > 0) {
        return false;
      }
    } else if (type === "validity") {
      if (type2 === "identificationNumber" && !validateIdCard(ctx, cellValue)) {
        return false;
      }
      if (type2 === "phoneNumber" && !/^1[3456789]\d{9}$/.test(cellValue)) {
        return false;
      }
    }
    return true;
  }
  function checkboxChange(ctx, r2, c2) {
    var _ctx$luckysheetfile$i;
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var currentDataVerification = (_ctx$luckysheetfile$i = ctx.luckysheetfile[index2].dataVerification) !== null && _ctx$luckysheetfile$i !== void 0 ? _ctx$luckysheetfile$i : {};
    var item = currentDataVerification["".concat(r2, "_").concat(c2)];
    item.checked = !item.checked;
    var value = item.value2;
    if (item.checked) {
      value = item.value1;
    }
    var d2 = getFlowdata(ctx);
    setCellValue(ctx, r2, c2, d2, value);
  }
  function getFailureText(ctx, item) {
    var failureText = "";
    var lang = ctx.lang;
    var type = item.type, type2 = item.type2, value1 = item.value1, value2 = item.value2;
    if (lang === "en") {
      var _ctx$dataVerification;
      var optionLabel_en = (_ctx$dataVerification = ctx.dataVerification) === null || _ctx$dataVerification === void 0 ? void 0 : _ctx$dataVerification.optionLabel_en;
      if (type === "dropdown") {
        failureText += "what you selected is not an option in the drop-down list";
      } else if (type === "checkbox") ;
      else if (type === "number" || type === "number_integer" || type === "number_decimal") {
        failureText += "what you entered is not a ".concat(optionLabel_en[item.type], " ").concat(optionLabel_en[item.type2], " ").concat(item.value1);
        if (item.type2 === "between" || item.type2 === "notBetween") {
          failureText += " and ".concat(item.value2);
        }
      } else if (type === "text_content") {
        failureText += "what you entered is not text that ".concat(optionLabel_en[item.type2], " ").concat(item.value1);
      } else if (type === "text_length") {
        failureText += "the text you entered is not length ".concat(optionLabel_en[item.type2], " ").concat(item.value1);
        if (item.type2 === "between" || item.type2 === "notBetween") {
          failureText += " and ".concat(item.value2);
        }
      } else if (type === "date") {
        failureText += "the date you entered is not ".concat(optionLabel_en[item.type2], " ").concat(item.value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += " and ".concat(item.value2);
        }
      } else if (type === "validity") {
        failureText += "what you entered is not a correct ".concat(optionLabel_en[item.type2]);
      }
    } else if (lang === "zh" || lang === "zh-CN") {
      var _ctx$dataVerification2;
      var optionLabel_zh = (_ctx$dataVerification2 = ctx.dataVerification) === null || _ctx$dataVerification2 === void 0 ? void 0 : _ctx$dataVerification2.optionLabel_zh;
      if (type === "dropdown") {
        failureText += "你选择的不是下拉列表中的选项";
      } else if (type === "checkbox") ;
      else if (type === "number" || type === "number_integer" || type === "number_decimal") {
        failureText += "你输入的不是".concat(optionLabel_zh[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之间");
        }
        failureText += "的".concat(optionLabel_zh[type]);
      } else if (type === "text_content") {
        failureText += "你输入的不是内容".concat(optionLabel_zh[type2]).concat(value1, "的文本");
      } else if (type === "text_length") {
        failureText += "你输入的不是长度".concat(optionLabel_zh[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之间");
        }
        failureText += "的文本";
      } else if (type === "date") {
        failureText += "你输入的不是".concat(optionLabel_zh[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之间");
        }
        failureText += "的日期";
      } else if (type === "validity") {
        failureText += "你输入的不是一个正确的".concat(optionLabel_zh[type2]);
      }
    } else if (lang === "zh-TW") {
      var _ctx$dataVerification3;
      var optionLabel_zh_tw = (_ctx$dataVerification3 = ctx.dataVerification) === null || _ctx$dataVerification3 === void 0 ? void 0 : _ctx$dataVerification3.optionLabel_zh_tw;
      if (type === "dropdown") {
        failureText += "你選擇的不是下拉清單中的選項";
      } else if (type === "checkbox") ;
      else if (type === "number" || type === "number_integer" || type === "number_decimal") {
        failureText += "你輸入的不是".concat(optionLabel_zh_tw[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之間");
        }
        failureText += "的".concat(optionLabel_zh_tw[type]);
      } else if (type === "text_content") {
        failureText += "你輸入的不是內容".concat(optionLabel_zh_tw[type2]).concat(value1, "的文本");
      } else if (type === "text_length") {
        failureText += "你輸入的不是長度".concat(optionLabel_zh_tw[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之间");
        }
        failureText += "的文本";
      } else if (type === "date") {
        failureText += "你輸入的不是".concat(optionLabel_zh_tw[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "和".concat(value2, "之间");
        }
        failureText += "的日期";
      } else if (type === "validity") {
        failureText += "你輸入的不是一個正確的".concat(optionLabel_zh_tw[type2]);
      }
    } else if (lang === "es") {
      var _ctx$dataVerification4;
      var optionLabel_es = (_ctx$dataVerification4 = ctx.dataVerification) === null || _ctx$dataVerification4 === void 0 ? void 0 : _ctx$dataVerification4.optionLabel_es;
      if (type === "dropdown") {
        failureText += "No elegiste una opción en la lista desplegable";
      } else if (type === "checkbox") ;
      else if (type === "number" || type === "number_integer" || type === "number_decimal") {
        failureText += "Lo que introduciste no es".concat(optionLabel_es[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "Y".concat(value2, "Entre");
        }
        failureText += "De".concat(optionLabel_es[type]);
      } else if (type === "text_content") {
        failureText += "Lo que introduciste no fue contenido".concat(optionLabel_es[type2]).concat(value1, "Texto");
      } else if (type === "text_length") {
        failureText += "No introduciste la longitud".concat(optionLabel_es[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "Y".concat(value2, "Entre");
        }
        failureText += "Texto";
      } else if (type === "date") {
        failureText += "Lo que introduciste no es".concat(optionLabel_es[type2]).concat(value1);
        if (type2 === "between" || type2 === "notBetween") {
          failureText += "Y".concat(value2, "Entre");
        }
        failureText += "Fecha";
      } else if (type === "validity") {
        failureText += "Lo que ingresas no es correcto".concat(optionLabel_es[type2]);
      }
    }
    return failureText;
  }
  function getHintText(ctx, item) {
    var hintValue = item.hintValue || "";
    var type = item.type, type2 = item.type2, value1 = item.value1, value2 = item.value2;
    var lang = ctx.lang;
    if (!hintValue) {
      if (lang === "en") {
        var _ctx$dataVerification5;
        var optionLabel_en = (_ctx$dataVerification5 = ctx.dataVerification) === null || _ctx$dataVerification5 === void 0 ? void 0 : _ctx$dataVerification5.optionLabel_en;
        if (type === "dropdown") {
          hintValue += "please select an option in the drop-down list";
        } else if (type === "checkbox") ;
        else if (type === "number" || type === "number_integer" || type === "number_decimal") {
          hintValue += "please enter a ".concat(optionLabel_en[type], " ").concat(optionLabel_en[type2], " ").concat(item.value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += " and ".concat(value2);
          }
        } else if (type === "text_content") {
          hintValue += "please enter text ".concat(optionLabel_en[type2], " ").concat(value1);
        } else if (type === "date") {
          hintValue += "please enter a date ".concat(optionLabel_en[type2], " ").concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += " and ".concat(value2);
          }
        } else if (type === "validity") {
          hintValue += "please enter the correct ".concat(optionLabel_en[type2]);
        }
      } else if (lang === "zh" || lang === "zh-CN") {
        var _ctx$dataVerification6;
        var optionLabel_zh = (_ctx$dataVerification6 = ctx.dataVerification) === null || _ctx$dataVerification6 === void 0 ? void 0 : _ctx$dataVerification6.optionLabel_zh;
        if (type === "dropdown") {
          hintValue += "请选择下拉列表中的选项";
        } else if (type === "checkbox") ;
        else if (type === "number" || type === "number_integer" || type === "number_decimal") {
          hintValue += "请输入".concat(optionLabel_zh[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之间");
          }
          hintValue += "的".concat(optionLabel_zh[type]);
        } else if (type === "text_content") {
          hintValue += "请输入内容".concat(optionLabel_zh[type2]).concat(value1, "的文本");
        } else if (type === "text_length") {
          hintValue += "请输入长度".concat(optionLabel_zh[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之间");
          }
          hintValue += "的文本";
        } else if (type === "date") {
          hintValue += "请输入".concat(optionLabel_zh[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之间");
          }
          hintValue += "的日期";
        } else if (type === "validity") {
          hintValue += "请输入正确的".concat(optionLabel_zh[type2]);
        }
      } else if (lang === "zh-TW") {
        var _ctx$dataVerification7;
        var optionLabel_zh_tw = (_ctx$dataVerification7 = ctx.dataVerification) === null || _ctx$dataVerification7 === void 0 ? void 0 : _ctx$dataVerification7.optionLabel_zh_tw;
        if (type === "dropdown") {
          hintValue += "請選擇下拉清單中的選項";
        } else if (type === "checkbox") ;
        else if (type === "number" || type === "number_integer" || type === "number_decimal") {
          hintValue += "請輸入".concat(optionLabel_zh_tw[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之間");
          }
          hintValue += "的".concat(optionLabel_zh_tw[type]);
        } else if (type === "text_content") {
          hintValue += "請輸入內容".concat(optionLabel_zh_tw[type2]).concat(value1, "的文本");
        } else if (type === "text_length") {
          hintValue += "請輸入長度".concat(optionLabel_zh_tw[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之間");
          }
          hintValue += "的文本";
        } else if (type === "date") {
          hintValue += "請輸入".concat(optionLabel_zh_tw[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "和".concat(value2, "之間");
          }
          hintValue += "的日期";
        } else if (type === "validity") {
          hintValue += "請輸入正確的".concat(optionLabel_zh_tw[type2]);
        }
      } else if (lang === "es") {
        var _ctx$dataVerification8;
        var optionLabel_es = (_ctx$dataVerification8 = ctx.dataVerification) === null || _ctx$dataVerification8 === void 0 ? void 0 : _ctx$dataVerification8.optionLabel_es;
        if (type === "dropdown") {
          hintValue += "Por favor, elija una opción en la lista desplegable";
        } else if (type === "checkbox") ;
        else if (type === "number" || type === "number_integer" || type === "number_decimal") {
          hintValue += "Por favor, introduzca".concat(optionLabel_es[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "Y".concat(value2, "Entre");
          }
          hintValue += "De".concat(optionLabel_es[type]);
        } else if (type === "text_content") {
          hintValue += "Por favor, introduzca el contenido".concat(optionLabel_es[type2]).concat(value1, "Texto");
        } else if (type === "text_length") {
          hintValue += "Por favor, introduzca la longitud".concat(optionLabel_es[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "Y".concat(value2, "Entre");
          }
          hintValue += "Texto";
        } else if (type === "date") {
          hintValue += "Por favor, introduzca".concat(optionLabel_es[type2]).concat(value1);
          if (type2 === "between" || type2 === "notBetween") {
            hintValue += "Y".concat(value2, "Entre");
          }
          hintValue += "Fecha";
        } else if (type === "validity") {
          hintValue += "Por favor, introduzca lo correcto.".concat(optionLabel_es[type2]);
        }
      }
    }
    return hintValue;
  }
  function cellFocus(ctx, r2, c2, clickMode) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var showHintBox = document.getElementById("luckysheet-dataVerification-showHintBox");
    var dropDownBtn = document.getElementById("luckysheet-dataVerification-dropdown-btn");
    ctx.dataVerificationDropDownList = false;
    if (!showHintBox || !dropDownBtn) return;
    showHintBox.style.display = "none";
    dropDownBtn.style.display = "none";
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var dataVerification = ctx.luckysheetfile[index2].dataVerification;
    ctx.dataVerificationDropDownList = false;
    if (!dataVerification) return;
    var row = ctx.visibledatarow[r2];
    var row_pre = r2 === 0 ? 0 : ctx.visibledatarow[r2 - 1];
    var col = ctx.visibledatacolumn[c2];
    var col_pre = c2 === 0 ? 0 : ctx.visibledatacolumn[c2 - 1];
    var d2 = getFlowdata(ctx);
    if (!d2) return;
    var margeSet = mergeBorder(ctx, d2, r2, c2);
    if (margeSet) {
      var _margeSet$row = _slicedToArray$1(margeSet.row, 2);
      row_pre = _margeSet$row[0];
      row = _margeSet$row[1];
      var _margeSet$column = _slicedToArray$1(margeSet.column, 2);
      col_pre = _margeSet$column[0];
      col = _margeSet$column[1];
    }
    var item = dataVerification["".concat(r2, "_").concat(c2)];
    if (!item) return;
    if (item.type === "checkbox") {
      checkboxChange(ctx, r2, c2);
    }
    if (item.type === "dropdown") {
      dropDownBtn.style.display = "block";
      dropDownBtn.style.maxWidth = "".concat(col - col_pre, "px");
      dropDownBtn.style.maxHeight = "".concat(row - row_pre, "px");
      dropDownBtn.style.left = "".concat(col - 20, "px");
      dropDownBtn.style.top = "".concat(row_pre + (row - row_pre - 20) / 2 - 2, "px");
    }
    if (item.hintShow) {
      var hintText = "";
      var lang = ctx.lang;
      if (lang === "en") {
        hintText = '<span style="color:#f5a623;">Hint: </span>';
      } else if (lang === "zh" || lang === "zh-CN") {
        hintText = '<span style="color:#f5a623;">提示：</span>';
      } else if (lang === "zh-TW") {
        hintText = '<span style="color:#f5a623;">提示：</span>';
      } else if (lang === "es") {
        hintText = '<span style="color:#f5a623;">Consejos：</span>';
      }
      hintText += getHintText(ctx, item);
      showHintBox.innerHTML = hintText;
      showHintBox.style.display = "block";
      showHintBox.style.left = "".concat(col_pre, "px");
      showHintBox.style.top = "".concat(row, "px");
    }
    var cellValue = getCellValue(r2, c2, d2);
    if (isRealNull(cellValue)) {
      return;
    }
    var validate2 = validateCellData(ctx, item, cellValue);
    if (!validate2) {
      var failureText = "";
      var _lang = ctx.lang;
      if (_lang === "en") {
        failureText = '<span style="color:#f72626;">Failure: </span>';
      } else if (_lang === "zh" || _lang === "zh-CN") {
        failureText = '<span style="color:#f72626;">失效：</span>';
      } else if (_lang === "zh-TW") {
        failureText = '<span style="color:#f72626;">失效：</span>';
      } else if (_lang === "es") {
        failureText = '<span style="color:#f72626;">Caducidad: </span>';
      }
      failureText += getFailureText(ctx, item);
      showHintBox.innerHTML = failureText;
      showHintBox.style.display = "block";
      showHintBox.style.left = "".concat(col_pre, "px");
      showHintBox.style.top = "".concat(row, "px");
    }
  }
  function setDropcownValue(ctx, value, arr) {
    if (!ctx.luckysheet_select_save) return;
    var d2 = getFlowdata(ctx);
    if (!d2) return;
    var last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
    var rowIndex = last.row_focus;
    var colIndex = last.column_focus;
    if (rowIndex == null || colIndex == null) return;
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var item = ctx.luckysheetfile[index2].dataVerification["".concat(rowIndex, "_").concat(colIndex)];
    if (item.type2 === "true") {
      value = item.value1.split(",").filter(function(v2) {
        return arr.indexOf(v2) >= 0;
      }).join(",");
    } else {
      ctx.dataVerificationDropDownList = false;
    }
    setCellValue(ctx, rowIndex, colIndex, d2, value);
  }
  function confirmMessage(ctx, generalDialog, dataVerification) {
    var _ctx$dataVerification9, _ctx$dataVerification10;
    var range = getRangeByTxt(ctx, (_ctx$dataVerification9 = ctx.dataVerification) === null || _ctx$dataVerification9 === void 0 ? void 0 : (_ctx$dataVerification10 = _ctx$dataVerification9.dataRegulation) === null || _ctx$dataVerification10 === void 0 ? void 0 : _ctx$dataVerification10.rangeTxt);
    if (range.length === 0) {
      ctx.warnDialog = generalDialog.noSeletionError;
      return false;
    }
    range[range.length - 1].row[0];
    var edr = range[range.length - 1].row[1];
    range[range.length - 1].column[0];
    var edc = range[range.length - 1].column[1];
    var d2 = getFlowdata(ctx);
    if (!d2) return false;
    if (edr > d2.length - 1) {
      edr = d2.length - 1;
    }
    if (edc > d2[0].length - 1) {
      edc = d2[0].length - 1;
    }
    var regulation = ctx.dataVerification.dataRegulation;
    var verifacationT = regulation === null || regulation === void 0 ? void 0 : regulation.type;
    var value1 = regulation.value1, value2 = regulation.value2, type2 = regulation.type2;
    var v1 = parseFloat(value1).toString() !== "NaN";
    var v2 = parseFloat(value2).toString() !== "NaN";
    if (verifacationT === "dropdown") {
      if (!value1) {
        ctx.warnDialog = dataVerification.tooltipInfo1;
      }
    } else if (verifacationT === "checkbox") {
      if (!value1 || !value2) {
        ctx.warnDialog = dataVerification.tooltipInfo2;
      }
    } else if (verifacationT === "number" || verifacationT === "number_integer" || verifacationT === "number_decimal") {
      if (!v1) {
        ctx.warnDialog = dataVerification.tooltipInfo3;
        return false;
      }
      if (type2 === "between" || type2 === "notBetween") {
        if (!v2) {
          ctx.warnDialog = dataVerification.tooltipInfo3;
          return false;
        }
        if (Number(value2) < Number(value1)) {
          ctx.warnDialog = dataVerification.tooltipInfo4;
          return false;
        }
      }
    } else if (verifacationT === "text_content") {
      if (!value1) {
        ctx.warnDialog = dataVerification.tooltipInfo5;
        return false;
      }
    } else if (verifacationT === "text_length") {
      if (!v1) {
        ctx.warnDialog = dataVerification.tooltipInfo3;
        return false;
      }
      if (!Number.isInteger(Number(value1)) || Number(value1) < 0) {
        ctx.warnDialog = dataVerification.textlengthInteger;
        return false;
      }
      if (type2 === "between" || type2 === "notBetween") {
        if (!v2) {
          ctx.warnDialog = dataVerification.tooltipInfo3;
          return false;
        }
        if (!Number.isInteger(Number(value2)) || Number(value2) < 0) {
          ctx.warnDialog = dataVerification.textlengthInteger;
          return false;
        }
        if (Number(value2) < Number(value1)) {
          ctx.warnDialog = dataVerification.tooltipInfo4;
          return false;
        }
      }
    } else if (verifacationT === "date") {
      if (!isdatetime(value1)) {
        ctx.warnDialog = dataVerification.tooltipInfo6;
        return false;
      }
      if (type2 === "between" || type2 === "notBetween") {
        if (!isdatetime(value2)) {
          ctx.warnDialog = dataVerification.tooltipInfo6;
          return false;
        }
        if (diff(value1, value2) > 0) {
          ctx.warnDialog = dataVerification.tooltipInfo7;
          return false;
        }
      }
    }
    return true;
  }
  function normalizedCellAttr(cell, attr) {
    var defaultFontSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10;
    var tf2 = {
      bl: 1,
      it: 1,
      ff: 1,
      cl: 1,
      un: 1
    };
    var value = cell === null || cell === void 0 ? void 0 : cell[attr];
    if (attr in tf2 || attr === "fs" && isInlineStringCell(cell)) {
      value || (value = "0");
    } else if (["fc", "bg", "bc"].includes(attr)) {
      var _value;
      if (["fc", "bc"].includes(attr)) {
        value || (value = "#000000");
      }
      if (((_value = value) === null || _value === void 0 ? void 0 : _value.indexOf("rgba")) > -1) {
        value = rgbToHex(value);
      }
    } else if (attr.substring(0, 2) === "bs") {
      value || (value = "none");
    } else if (attr === "ht" || attr === "vt") {
      var defaultValue = attr === "ht" ? "1" : "0";
      value = !_$1.isNil(value) ? value.toString() : defaultValue;
      if (["0", "1", "2"].indexOf(value.toString()) === -1) {
        value = defaultValue;
      }
    } else if (attr === "fs") {
      value || (value = defaultFontSize.toString());
    } else if (attr === "tb" || attr === "tr") {
      value || (value = "0");
    }
    return value;
  }
  function normalizedAttr(data, r2, c2, attr) {
    if (!data || !data[r2]) {
      console.warn("cell (%d, %d) is null", r2, c2);
      return null;
    }
    var cell = data[r2][c2];
    if (!cell) return void 0;
    return normalizedCellAttr(cell, attr);
  }
  function getCellValue(r2, c2, data, attr) {
    if (!attr) {
      attr = "v";
    }
    var d_value;
    if (!_$1.isNil(r2) && !_$1.isNil(c2)) {
      d_value = data[r2][c2];
    } else if (!_$1.isNil(r2)) {
      d_value = data[r2];
    } else if (!_$1.isNil(c2)) {
      var newData = data[0].map(function(col, i2) {
        return data.map(function(row) {
          return row[i2];
        });
      });
      d_value = newData[c2];
    } else {
      return data;
    }
    var retv = d_value;
    if (_$1.isPlainObject(d_value)) {
      var d2 = d_value;
      retv = d2[attr];
      if (attr === "f" && !_$1.isNil(retv)) {
        retv = functionHTMLGenerate(retv);
      } else if (attr === "f") {
        retv = d2.v;
      } else if (d2 && d2.ct && d2.ct.t === "d") {
        retv = d2.m;
      }
    }
    if (retv === void 0) {
      retv = null;
    }
    return retv;
  }
  function setCellValue(ctx, r2, c2, d2, v2) {
    var _cell$ct, _cell$ct2, _cell$ct3, _cell$ct4, _cell$ct5, _cell$ct6;
    if (_$1.isNil(d2)) {
      d2 = getFlowdata(ctx);
    }
    if (!d2) return;
    var cell = d2[r2][c2];
    var vupdate;
    if (_$1.isPlainObject(v2)) {
      if (_$1.isNil(cell)) {
        cell = v2;
      } else {
        if (!_$1.isNil(v2.f)) {
          cell.f = v2.f;
        } else if ("f" in cell) {
          delete cell.f;
        }
        if (!_$1.isNil(v2.ct)) {
          cell.ct = v2.ct;
        }
      }
      if (_$1.isPlainObject(v2.v)) {
        vupdate = v2.v.v;
      } else {
        vupdate = v2.v;
      }
    } else {
      vupdate = v2;
    }
    if (isRealNull(vupdate)) {
      if (_$1.isPlainObject(cell)) {
        delete cell.m;
        delete cell.v;
      } else {
        cell = null;
      }
      d2[r2][c2] = cell;
      return;
    }
    if (isRealNull(cell) || (_$1.isString(cell) || _$1.isNumber(cell)) && cell === v2) {
      cell = {};
    }
    if (!cell) return;
    var vupdateStr = vupdate.toString();
    if (vupdateStr.substr(0, 1) === "'") {
      cell.m = vupdateStr.substr(1);
      cell.ct = {
        fa: "@",
        t: "s"
      };
      cell.v = vupdateStr.substr(1);
      cell.qp = 1;
    } else if (cell.qp === 1) {
      cell.m = vupdateStr;
      cell.ct = {
        fa: "@",
        t: "s"
      };
      cell.v = vupdateStr;
    } else if (vupdateStr.toUpperCase() === "TRUE" && (_$1.isNil((_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : _cell$ct.fa) || ((_cell$ct2 = cell.ct) === null || _cell$ct2 === void 0 ? void 0 : _cell$ct2.fa) !== "@")) {
      cell.m = "TRUE";
      cell.ct = {
        fa: "General",
        t: "b"
      };
      cell.v = true;
    } else if (vupdateStr.toUpperCase() === "FALSE" && (_$1.isNil((_cell$ct3 = cell.ct) === null || _cell$ct3 === void 0 ? void 0 : _cell$ct3.fa) || ((_cell$ct4 = cell.ct) === null || _cell$ct4 === void 0 ? void 0 : _cell$ct4.fa) !== "@")) {
      cell.m = "FALSE";
      cell.ct = {
        fa: "General",
        t: "b"
      };
      cell.v = false;
    } else if (vupdateStr.substr(-1) === "%" && isRealNum(vupdateStr.substring(0, vupdateStr.length - 1)) && (_$1.isNil((_cell$ct5 = cell.ct) === null || _cell$ct5 === void 0 ? void 0 : _cell$ct5.fa) || ((_cell$ct6 = cell.ct) === null || _cell$ct6 === void 0 ? void 0 : _cell$ct6.fa) !== "@")) {
      cell.ct = {
        fa: "0%",
        t: "n"
      };
      cell.v = vupdateStr.substring(0, vupdateStr.length - 1) / 100;
      cell.m = vupdate;
    } else if (valueIsError(vupdate)) {
      cell.m = vupdateStr;
      if (!_$1.isNil(cell.ct)) {
        cell.ct.t = "e";
      } else {
        cell.ct = {
          fa: "General",
          t: "e"
        };
      }
      cell.v = vupdate;
    } else {
      if (!_$1.isNil(cell.f) && isRealNum(vupdate) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test(vupdate)) {
        cell.v = parseFloat(vupdate);
        if (_$1.isNil(cell.ct)) {
          cell.ct = {
            fa: "General",
            t: "n"
          };
        }
        if (cell.v === Infinity || cell.v === -Infinity) {
          cell.m = cell.v.toString();
        } else {
          if (cell.v.toString().indexOf("e") > -1) {
            var len;
            if (cell.v.toString().split(".").length === 1) {
              len = 0;
            } else {
              len = cell.v.toString().split(".")[1].split("e")[0].length;
            }
            if (len > 5) {
              len = 5;
            }
            cell.m = cell.v.toExponential(len).toString();
          } else {
            var v_p = Math.round(cell.v * 1e9) / 1e9;
            if (_$1.isNil(cell.ct)) {
              var mask = genarate(v_p);
              if (mask != null) {
                cell.m = mask[0].toString();
              }
            } else {
              var _mask = update(cell.ct.fa, v_p);
              cell.m = _mask.toString();
            }
          }
        }
      } else if (!_$1.isNil(cell.ct) && cell.ct.fa === "@") {
        cell.m = vupdateStr;
        cell.v = vupdate;
      } else if (!_$1.isNil(cell.ct) && !_$1.isNil(cell.ct.fa) && cell.ct.fa !== "General") {
        if (isRealNum(vupdate)) {
          vupdate = parseFloat(vupdate);
        }
        var _mask2 = update(cell.ct.fa, vupdate);
        if (_mask2 === vupdate) {
          _mask2 = genarate(vupdate);
          cell.m = _mask2[0].toString();
          var _mask3 = _mask2;
          var _mask4 = _slicedToArray$1(_mask3, 3);
          cell.ct = _mask4[1];
          cell.v = _mask4[2];
        } else {
          cell.m = _mask2.toString();
          cell.v = vupdate;
        }
      } else {
        if (isRealNum(vupdate) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test(vupdate)) {
          if (typeof vupdate === "string") {
            var flag = vupdate.split("").every(function(ele) {
              return ele === "0" || ele === ".";
            });
            if (flag) {
              vupdate = parseFloat(vupdate);
            }
          }
          cell.v = vupdate;
          cell.ct = {
            fa: "General",
            t: "n"
          };
          if (cell.v === Infinity || cell.v === -Infinity) {
            cell.m = cell.v.toString();
          } else if (cell.v != null) {
            var _mask5 = genarate(cell.v);
            if (_mask5) {
              cell.m = _mask5[0].toString();
            }
          }
        } else {
          var _mask6 = genarate(vupdate);
          if (_mask6) {
            cell.m = _mask6[0].toString();
            var _mask7 = _slicedToArray$1(_mask6, 3);
            cell.ct = _mask7[1];
            cell.v = _mask7[2];
          }
        }
      }
    }
    d2[r2][c2] = cell;
  }
  function getRealCellValue(r2, c2, data, attr) {
    var value = getCellValue(r2, c2, data, "m");
    if (_$1.isNil(value)) {
      value = getCellValue(r2, c2, data, attr);
      if (_$1.isNil(value)) {
        var ct = getCellValue(r2, c2, data, "ct");
        if (isInlineStringCT(ct)) {
          value = ct.s;
        }
      }
    }
    return value;
  }
  function mergeBorder(ctx, d2, row_index, col_index) {
    if (!d2 || !d2[row_index]) {
      console.warn("Merge info is null", row_index, col_index);
      return null;
    }
    var value = d2[row_index][col_index];
    if (!value) return null;
    if (value === null || value === void 0 ? void 0 : value.mc) {
      var _d$row_index, _d$row_index2, _d$row_index2$col_ind, _d$row_index2$col_ind2, _d$row_index3, _d$row_index3$col_ind, _d$row_index3$col_ind2, _d$row_index4, _d$row_index4$col_ind;
      var margeMaindata = value.mc;
      if (!margeMaindata) {
        console.warn("Merge info is null", row_index, col_index);
        return null;
      }
      col_index = margeMaindata.c;
      row_index = margeMaindata.r;
      if (_$1.isNil(d2 === null || d2 === void 0 ? void 0 : (_d$row_index = d2[row_index]) === null || _d$row_index === void 0 ? void 0 : _d$row_index[col_index])) {
        console.warn("Main merge Cell info is null", row_index, col_index);
        return null;
      }
      var col_rs = (_d$row_index2 = d2[row_index]) === null || _d$row_index2 === void 0 ? void 0 : (_d$row_index2$col_ind = _d$row_index2[col_index]) === null || _d$row_index2$col_ind === void 0 ? void 0 : (_d$row_index2$col_ind2 = _d$row_index2$col_ind.mc) === null || _d$row_index2$col_ind2 === void 0 ? void 0 : _d$row_index2$col_ind2.cs;
      var row_rs = (_d$row_index3 = d2[row_index]) === null || _d$row_index3 === void 0 ? void 0 : (_d$row_index3$col_ind = _d$row_index3[col_index]) === null || _d$row_index3$col_ind === void 0 ? void 0 : (_d$row_index3$col_ind2 = _d$row_index3$col_ind.mc) === null || _d$row_index3$col_ind2 === void 0 ? void 0 : _d$row_index3$col_ind2.rs;
      var mergeMain = (_d$row_index4 = d2[row_index]) === null || _d$row_index4 === void 0 ? void 0 : (_d$row_index4$col_ind = _d$row_index4[col_index]) === null || _d$row_index4$col_ind === void 0 ? void 0 : _d$row_index4$col_ind.mc;
      if (!mergeMain || _$1.isNil(mergeMain === null || mergeMain === void 0 ? void 0 : mergeMain.rs) || _$1.isNil(mergeMain === null || mergeMain === void 0 ? void 0 : mergeMain.cs) || _$1.isNil(col_rs) || _$1.isNil(row_rs)) {
        console.warn("Main merge info is null", mergeMain);
        return null;
      }
      var start_r;
      var end_r;
      var row;
      var row_pre;
      for (var r2 = row_index; r2 < mergeMain.rs + row_index; r2 += 1) {
        if (r2 === 0) {
          start_r = -1;
        } else {
          start_r = ctx.visibledatarow[r2 - 1] - 1;
        }
        end_r = ctx.visibledatarow[r2];
        if (row_pre === void 0) {
          row_pre = start_r;
          row = end_r;
        } else if (row !== void 0) {
          row += end_r - start_r - 1;
        }
      }
      var start_c;
      var end_c;
      var col;
      var col_pre;
      for (var c2 = col_index; c2 < mergeMain.cs + col_index; c2 += 1) {
        if (c2 === 0) {
          start_c = 0;
        } else {
          start_c = ctx.visibledatacolumn[c2 - 1];
        }
        end_c = ctx.visibledatacolumn[c2];
        if (col_pre === void 0) {
          col_pre = start_c;
          col = end_c;
        } else if (col !== void 0) {
          col += end_c - start_c;
        }
      }
      if (_$1.isNil(row_pre) || _$1.isNil(col_pre) || _$1.isNil(row) || _$1.isNil(col)) {
        console.warn("Main merge info row_pre or col_pre or row or col is null", mergeMain);
        return null;
      }
      return {
        row: [row_pre, row, row_index, row_index + row_rs - 1],
        column: [col_pre, col, col_index, col_index + col_rs - 1]
      };
    }
    return null;
  }
  function mergeMove(ctx, mc2, columnseleted, rowseleted, s2, top, height, left, width) {
    var row_st = mc2.r;
    var row_ed = mc2.r + mc2.rs - 1;
    var col_st = mc2.c;
    var col_ed = mc2.c + mc2.cs - 1;
    var ismatch = false;
    columnseleted[0] = Math.min(columnseleted[0], columnseleted[1]);
    rowseleted[0] = Math.min(rowseleted[0], rowseleted[1]);
    if (columnseleted[0] <= col_st && columnseleted[1] >= col_ed && rowseleted[0] <= row_st && rowseleted[1] >= row_ed || !(columnseleted[1] < col_st || columnseleted[0] > col_ed) && !(rowseleted[1] < row_st || rowseleted[0] > row_ed)) {
      var flowdata = getFlowdata(ctx);
      if (!flowdata) return null;
      var margeset = mergeBorder(ctx, flowdata, mc2.r, mc2.c);
      if (margeset) {
        var row = margeset.row[1];
        var row_pre = margeset.row[0];
        var col = margeset.column[1];
        var col_pre = margeset.column[0];
        if (!(columnseleted[1] < col_st || columnseleted[0] > col_ed)) {
          if (rowseleted[0] <= row_ed && rowseleted[0] >= row_st) {
            height += top - row_pre;
            top = row_pre;
            rowseleted[0] = row_st;
          }
          if (rowseleted[1] >= row_st && rowseleted[1] <= row_ed) {
            if (s2.row_focus >= row_st && s2.row_focus <= row_ed) {
              height = row - top;
            } else {
              height = row - top;
            }
            rowseleted[1] = row_ed;
          }
        }
        if (!(rowseleted[1] < row_st || rowseleted[0] > row_ed)) {
          if (columnseleted[0] <= col_ed && columnseleted[0] >= col_st) {
            width += left - col_pre;
            left = col_pre;
            columnseleted[0] = col_st;
          }
          if (columnseleted[1] >= col_st && columnseleted[1] <= col_ed) {
            if (s2.column_focus >= col_st && s2.column_focus <= col_ed) {
              width = col - left;
            } else {
              width = col - left;
            }
            columnseleted[1] = col_ed;
          }
        }
        ismatch = true;
      }
    }
    if (ismatch) {
      return [columnseleted, rowseleted, top, height, left, width];
    }
    return null;
  }
  function mergeMoveMain(ctx, columnseleted, rowseleted, s2, top, height, left, width) {
    var mergesetting = ctx.config.merge;
    if (!mergesetting) {
      return null;
    }
    var mcset = Object.keys(mergesetting);
    rowseleted[1] = Math.max(rowseleted[0], rowseleted[1]);
    columnseleted[1] = Math.max(columnseleted[0], columnseleted[1]);
    var offloop = true;
    var mergeMoveData = {};
    while (offloop) {
      offloop = false;
      for (var i2 = 0; i2 < mcset.length; i2 += 1) {
        var key = mcset[i2];
        var mc2 = mergesetting[key];
        if (key in mergeMoveData) {
          continue;
        }
        var changeparam = mergeMove(ctx, mc2, columnseleted, rowseleted, s2, top, height, left, width);
        if (changeparam != null) {
          mergeMoveData[key] = mc2;
          var _changeparam = _slicedToArray$1(changeparam, 6);
          columnseleted = _changeparam[0];
          rowseleted = _changeparam[1];
          top = _changeparam[2];
          height = _changeparam[3];
          left = _changeparam[4];
          width = _changeparam[5];
          offloop = true;
        } else {
          delete mergeMoveData[key];
        }
      }
    }
    return [columnseleted, rowseleted, top, height, left, width];
  }
  function cancelFunctionrangeSelected(ctx) {
    if (ctx.formulaCache.selectingRangeIndex === -1) {
      ctx.formulaRangeSelect = void 0;
    }
  }
  function cancelNormalSelected(ctx) {
    cancelFunctionrangeSelected(ctx);
    ctx.luckysheetCellUpdate = [];
    ctx.formulaRangeHighlight = [];
    ctx.functionHint = null;
    ctx.formulaCache.rangestart = false;
    ctx.formulaCache.rangedrag_column_start = false;
    ctx.formulaCache.rangedrag_row_start = false;
  }
  function updateCell(ctx, r2, c2, $input, value, canvas) {
    var _inputText, _curv, _ctx$hooks$beforeUpda, _ctx$hooks, _curv2;
    var inputText = $input === null || $input === void 0 ? void 0 : $input.innerText;
    var inputHtml = $input === null || $input === void 0 ? void 0 : $input.innerHTML;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var dataVerification = ctx.luckysheetfile[index2].dataVerification;
    if (!_$1.isNil(dataVerification)) {
      var dvItem = dataVerification["".concat(r2, "_").concat(c2)];
      if (!_$1.isNil(dvItem) && dvItem.prohibitInput && !validateCellData(ctx, dvItem, inputText)) {
        var failureText = getFailureText(ctx, dvItem);
        cancelNormalSelected(ctx);
        ctx.warnDialog = failureText;
        return;
      }
    }
    var curv = flowdata[r2][c2];
    var oldValue = _$1.cloneDeep(curv);
    var isPrevInline = isInlineStringCell(curv);
    var isCurInline = ((_inputText = inputText) === null || _inputText === void 0 ? void 0 : _inputText.slice(0, 1)) !== "=" && (inputHtml === null || inputHtml === void 0 ? void 0 : inputHtml.substring(0, 5)) === "<span";
    var isCopyVal = false;
    if (!isCurInline && inputText && inputText.length > 0) {
      var splitArr = inputText.replace(/\r\n/g, "_x000D_").replace(/&#13;&#10;/g, "_x000D_").replace(/\r/g, "_x000D_").replace(/\n/g, "_x000D_").split("_x000D_");
      if (splitArr.length > 1 && inputHtml !== "<br>") {
        isCopyVal = true;
        isCurInline = true;
        inputText = splitArr.join("\r\n");
      }
    }
    if (((_curv = curv) === null || _curv === void 0 ? void 0 : _curv.ct) && !value && !isCurInline && isPrevInline) {
      delete curv.ct.s;
      curv.ct.t = "g";
      curv.ct.fa = "General";
      value = "";
    } else if (isCurInline) {
      if (!_$1.isPlainObject(curv)) {
        curv = {};
      }
      curv || (curv = {});
      var fontSize = curv.fs || 10;
      delete curv.fs;
      delete curv.f;
      delete curv.v;
      delete curv.m;
      if (!curv.ct) {
        curv.ct = {};
        curv.ct.fa = "General";
      }
      curv.ct.t = "inlineStr";
      curv.ct.s = convertSpanToShareString($input.querySelectorAll("span"));
      curv.fs = fontSize;
      if (isCopyVal) {
        curv.ct.s = [{
          v: inputText,
          fs: fontSize
        }];
      }
    }
    value = value || ($input === null || $input === void 0 ? void 0 : $input.innerText);
    if (((_ctx$hooks$beforeUpda = (_ctx$hooks = ctx.hooks).beforeUpdateCell) === null || _ctx$hooks$beforeUpda === void 0 ? void 0 : _ctx$hooks$beforeUpda.call(_ctx$hooks, r2, c2, value)) === false) {
      cancelNormalSelected(ctx);
      return;
    }
    if (!isCurInline) {
      if (isRealNull(value) && !isPrevInline) {
        if (!curv || isRealNull(curv.v) && !curv.spl && !curv.f) {
          cancelNormalSelected(ctx);
          return;
        }
      } else if (curv && curv.qp !== 1) {
        if (_$1.isPlainObject(curv) && (value === curv.f || value === curv.v || value === curv.m)) {
          cancelNormalSelected(ctx);
          return;
        }
        if (value === curv) {
          cancelNormalSelected(ctx);
          return;
        }
      }
      if (_$1.isString(value) && value.slice(0, 1) === "=" && value.length > 1) ;
      else if (_$1.isPlainObject(curv) && curv && curv.ct && curv.ct.fa && curv.ct.fa !== "@" && !isRealNull(value)) {
        delete curv.m;
        if (curv.f) {
          delete curv.f;
          delete curv.spl;
        }
      }
    }
    var d2 = flowdata;
    if (_$1.isPlainObject(curv)) {
      if (!isCurInline) {
        if (_$1.isString(value) && value.slice(0, 1) === "=" && value.length > 1) {
          var _d$r;
          var v2 = execfunction(ctx, value, r2, c2, void 0, true);
          curv = _$1.cloneDeep((d2 === null || d2 === void 0 ? void 0 : (_d$r = d2[r2]) === null || _d$r === void 0 ? void 0 : _d$r[c2]) || {});
          var _v = _slicedToArray$1(v2, 3);
          curv.v = _v[1];
          curv.f = _v[2];
          if (v2.length === 4 && v2[3].type === "sparklines") {
            delete curv.m;
            delete curv.v;
            var curCalv = v2[3].data;
            if (_$1.isArray(curCalv) && !_$1.isPlainObject(curCalv[0])) {
              var _curCalv = _slicedToArray$1(curCalv, 1);
              curv.v = _curCalv[0];
            } else {
              curv.spl = v2[3].data;
            }
          } else if (v2.length === 4 && v2[3].type === "dynamicArrayItem") {
            v2[3].data;
          }
        } else if (_$1.isPlainObject(value)) {
          var valueFunction = value.f;
          if (_$1.isString(valueFunction) && valueFunction.slice(0, 1) === "=" && valueFunction.length > 1) {
            var _d$r2;
            var _v2 = execfunction(ctx, valueFunction, r2, c2, void 0, true);
            curv = _$1.cloneDeep((d2 === null || d2 === void 0 ? void 0 : (_d$r2 = d2[r2]) === null || _d$r2 === void 0 ? void 0 : _d$r2[c2]) || {});
            var _v3 = _slicedToArray$1(_v2, 3);
            curv.v = _v3[1];
            curv.f = _v3[2];
            if (_v2.length === 4 && _v2[3].type === "sparklines") {
              delete curv.m;
              delete curv.v;
              var _curCalv2 = _v2[3].data;
              if (_$1.isArray(_curCalv2) && !_$1.isPlainObject(_curCalv2[0])) {
                var _curCalv3 = _slicedToArray$1(_curCalv2, 1);
                curv.v = _curCalv3[0];
              } else {
                curv.spl = _v2[3].data;
              }
            } else if (_v2.length === 4 && _v2[3].type === "dynamicArrayItem") {
              _v2[3].data;
            }
          } else {
            Object.keys(value).forEach(function(attr) {
              curv[attr] = value[attr];
            });
          }
        } else {
          var _d$r3;
          delFunctionGroup(ctx, r2, c2);
          execFunctionGroup(ctx, r2, c2, value);
          curv = _$1.cloneDeep((d2 === null || d2 === void 0 ? void 0 : (_d$r3 = d2[r2]) === null || _d$r3 === void 0 ? void 0 : _d$r3[c2]) || {});
          curv.v = value;
          delete curv.f;
          delete curv.spl;
          if (curv.qp === 1 && "".concat(value).substring(0, 1) !== "'") {
            curv.qp = 0;
            if (curv.ct) {
              curv.ct.fa = "General";
              curv.ct.t = "n";
            }
          }
        }
      }
      value = curv;
    } else {
      if (_$1.isString(value) && value.slice(0, 1) === "=" && value.length > 1) {
        var _v4 = execfunction(ctx, value, r2, c2, void 0, true);
        value = {
          v: _v4[1],
          f: _v4[2]
        };
        if (_v4.length === 4 && _v4[3].type === "sparklines") {
          var _curCalv4 = _v4[3].data;
          if (_$1.isArray(_curCalv4) && !_$1.isPlainObject(_curCalv4[0])) {
            var _curCalv5 = _slicedToArray$1(_curCalv4, 1);
            value.v = _curCalv5[0];
          } else {
            value.spl = _v4[3].data;
          }
        } else if (_v4.length === 4 && _v4[3].type === "dynamicArrayItem") {
          _v4[3].data;
        }
      } else if (_$1.isPlainObject(value)) {
        var _valueFunction = value.f;
        if (_$1.isString(_valueFunction) && _valueFunction.slice(0, 1) === "=" && _valueFunction.length > 1) {
          var _v5 = execfunction(ctx, _valueFunction, r2, c2, void 0, true);
          var _v6 = _slicedToArray$1(_v5, 3);
          value.v = _v6[1];
          value.f = _v6[2];
          if (_v5.length === 4 && _v5[3].type === "sparklines") {
            var _curCalv6 = _v5[3].data;
            if (_$1.isArray(_curCalv6) && !_$1.isPlainObject(_curCalv6[0])) {
              var _curCalv7 = _slicedToArray$1(_curCalv6, 1);
              value.v = _curCalv7[0];
            } else {
              value.spl = _v5[3].data;
            }
          } else if (_v5.length === 4 && _v5[3].type === "dynamicArrayItem") {
            _v5[3].data;
          }
        } else {
          var _v7 = curv;
          if (_$1.isNil(value.v)) {
            value.v = _v7;
          }
        }
      } else {
        delFunctionGroup(ctx, r2, c2);
        execFunctionGroup(ctx, r2, c2, value);
      }
    }
    setCellValue(ctx, r2, c2, d2, value);
    cancelNormalSelected(ctx);
    if (((_curv2 = curv) === null || _curv2 === void 0 ? void 0 : _curv2.tb) === "2" && curv.v || isInlineStringCell(d2[r2][c2])) {
      var _cfg$columnlen, _cfg$rowlen;
      var defaultrowlen = ctx.defaultrowlen;
      var cfg = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].config || {};
      if (!(((_cfg$columnlen = cfg.columnlen) === null || _cfg$columnlen === void 0 ? void 0 : _cfg$columnlen[c2]) && ((_cfg$rowlen = cfg.rowlen) === null || _cfg$rowlen === void 0 ? void 0 : _cfg$rowlen[r2]))) {
        var _cfg$columnlen2, _cfg$customHeight;
        var cellWidth = ((_cfg$columnlen2 = cfg.columnlen) === null || _cfg$columnlen2 === void 0 ? void 0 : _cfg$columnlen2[c2]) || ctx.defaultcollen;
        var textInfo = canvas ? getCellTextInfo(d2[r2][c2], canvas, ctx, {
          r: r2,
          c: c2,
          cellWidth
        }) : null;
        var currentRowLen = defaultrowlen;
        if (textInfo) {
          currentRowLen = textInfo.textHeightAll + 2;
        }
        if (currentRowLen > defaultrowlen && !((_cfg$customHeight = cfg.customHeight) === null || _cfg$customHeight === void 0 ? void 0 : _cfg$customHeight[r2])) {
          if (_$1.isNil(cfg.rowlen)) cfg.rowlen = {};
          cfg.rowlen[r2] = currentRowLen;
        }
      }
    }
    if (ctx.hooks.afterUpdateCell) {
      var newValue = _$1.cloneDeep(flowdata[r2][c2]);
      var afterUpdateCell = ctx.hooks.afterUpdateCell;
      setTimeout(function() {
        afterUpdateCell === null || afterUpdateCell === void 0 ? void 0 : afterUpdateCell(r2, c2, oldValue, newValue);
      });
    }
    ctx.formulaCache.execFunctionGlobalData = null;
  }
  function getOrigincell(ctx, r2, c2, i2) {
    var data = getFlowdata(ctx, i2);
    if (_$1.isNil(r2) || _$1.isNil(c2)) {
      return null;
    }
    if (!data || !data[r2] || !data[r2][c2]) {
      return null;
    }
    return data[r2][c2];
  }
  function getcellFormula(ctx, r2, c2, i2, data) {
    var cell;
    if (_$1.isNil(data)) {
      cell = getOrigincell(ctx, r2, c2, i2);
    } else {
      cell = data[r2][c2];
    }
    if (_$1.isNil(cell)) {
      return null;
    }
    return cell.f;
  }
  function getRange(ctx) {
    var rangeArr = _$1.cloneDeep(ctx.luckysheet_select_save);
    var result = [];
    if (!rangeArr) return result;
    for (var i2 = 0; i2 < rangeArr.length; i2 += 1) {
      var rangeItem = rangeArr[i2];
      var temp = {
        row: rangeItem.row,
        column: rangeItem.column
      };
      result.push(temp);
    }
    return result;
  }
  function getFlattenedRange(ctx, range) {
    range = range || getRange(ctx);
    var result = [];
    range.forEach(function(ele) {
      var rs = ele.row;
      var cs = ele.column;
      for (var r2 = rs[0]; r2 <= rs[1]; r2 += 1) {
        for (var c2 = cs[0]; c2 <= cs[1]; c2 += 1) {
          result.push({
            r: r2,
            c: c2
          });
        }
      }
    });
    return result;
  }
  function getRangetxt(ctx, sheetId, range, currentId) {
    var sheettxt = "";
    if (currentId == null) {
      currentId = ctx.currentSheetId;
    }
    if (sheetId !== currentId) {
      var index2 = getSheetIndex(ctx, sheetId);
      if (index2 == null) return "";
      sheettxt = ctx.luckysheetfile[index2].name.replace(/'/g, "''");
      if (/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/.test(sheettxt)) {
        sheettxt += "!";
      } else {
        sheettxt = "'".concat(sheettxt, "'!");
      }
    }
    var row0 = range.row[0];
    var row1 = range.row[1];
    var column0 = range.column[0];
    var column1 = range.column[1];
    if (row0 == null && row1 == null) {
      return "".concat(sheettxt + indexToColumnChar(column0), ":").concat(indexToColumnChar(column1));
    }
    if (column0 == null && column1 == null) {
      return "".concat(sheettxt + (row0 + 1), ":").concat(row1 + 1);
    }
    if (column0 === column1 && row0 === row1) {
      return sheettxt + indexToColumnChar(column0) + (row0 + 1);
    }
    return "".concat(sheettxt + indexToColumnChar(column0) + (row0 + 1), ":").concat(indexToColumnChar(column1)).concat(row1 + 1);
  }
  function getRangeByTxt(ctx, txt) {
    var range = [];
    if (txt.indexOf(",") !== -1) {
      var arr = txt.split(",");
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        if (iscelldata(arr[i2])) {
          range.push(getcellrange(ctx, arr[i2]));
        } else {
          range = [];
          break;
        }
      }
    } else {
      if (iscelldata(txt)) {
        range.push(getcellrange(ctx, txt));
      }
    }
    return range;
  }
  function isAllSelectedCellsInStatus(ctx, attr, status) {
    if (!_$1.isEmpty(ctx.luckysheetCellUpdate)) {
      var _startContainer$paren2, _endContainer$parentE;
      var w2 = window.getSelection();
      if (!w2) return false;
      var range = w2.getRangeAt(0);
      if (range.collapsed === true) {
        return false;
      }
      var endContainer = range.endContainer;
      var startContainer = range.startContainer;
      var cssField = _$1.camelCase(attrToCssName[attr]);
      if (startContainer === endContainer) {
        var _startContainer$paren;
        return !_$1.isEmpty((_startContainer$paren = startContainer.parentElement) === null || _startContainer$paren === void 0 ? void 0 : _startContainer$paren.style[cssField]);
      }
      if (((_startContainer$paren2 = startContainer.parentElement) === null || _startContainer$paren2 === void 0 ? void 0 : _startContainer$paren2.tagName) === "SPAN" && ((_endContainer$parentE = endContainer.parentElement) === null || _endContainer$parentE === void 0 ? void 0 : _endContainer$parentE.tagName) === "SPAN") {
        var _startSpan$parentNode;
        var startSpan = startContainer.parentNode;
        var endSpan = endContainer.parentNode;
        var allSpans = startSpan === null || startSpan === void 0 ? void 0 : (_startSpan$parentNode = startSpan.parentNode) === null || _startSpan$parentNode === void 0 ? void 0 : _startSpan$parentNode.querySelectorAll("span");
        if (allSpans) {
          var startSpanIndex = _$1.indexOf(allSpans, startSpan);
          var endSpanIndex = _$1.indexOf(allSpans, endSpan);
          var rangeSpans = [];
          for (var i2 = startSpanIndex; i2 <= endSpanIndex; i2 += 1) {
            rangeSpans.push(allSpans[i2]);
          }
          return _$1.every(rangeSpans, function(s2) {
            return !_$1.isEmpty(s2.style[cssField]);
          });
        }
      }
    }
    var cells = getFlattenedRange(ctx);
    var flowdata = getFlowdata(ctx);
    return cells.every(function(_ref) {
      var _flowdata$r;
      var r2 = _ref.r, c2 = _ref.c;
      var cell = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$r = flowdata[r2]) === null || _flowdata$r === void 0 ? void 0 : _flowdata$r[c2];
      if (_$1.isNil(cell)) {
        return false;
      }
      return cell[attr] === status;
    });
  }
  function getFontStyleByCell(cell, checksAF, checksCF) {
    var isCheck = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    var style = {};
    if (!cell) {
      return style;
    }
    _$1.forEach(cell, function(v2, key) {
      var _checksAF$length;
      var value = cell[key];
      if (isCheck) {
        value = normalizedCellAttr(cell, key);
      }
      var valueNum = Number(value);
      if (key === "bl" && valueNum !== 0) {
        style.fontWeight = "bold";
      }
      if (key === "it" && valueNum !== 0) {
        style.fontStyle = "italic";
      }
      if (key === "fs" && valueNum !== 10) {
        style.fontSize = "".concat(valueNum, "pt");
      }
      if (key === "fc" && value !== "#000000" || ((_checksAF$length = checksAF === null || checksAF === void 0 ? void 0 : checksAF.length) !== null && _checksAF$length !== void 0 ? _checksAF$length : 0) > 0 || (checksCF === null || checksCF === void 0 ? void 0 : checksCF.textColor)) {
        var _checksAF$length2;
        if (checksCF === null || checksCF === void 0 ? void 0 : checksCF.textColor) {
          style.color = checksCF.textColor;
        } else if (((_checksAF$length2 = checksAF === null || checksAF === void 0 ? void 0 : checksAF.length) !== null && _checksAF$length2 !== void 0 ? _checksAF$length2 : 0) > 0) {
          var _checksAF = _slicedToArray$1(checksAF, 1);
          style.color = _checksAF[0];
        } else {
          style.color = value;
        }
      }
      if (key === "cl" && valueNum !== 0) {
        style.textDecoration = "line-through";
      }
      if (key === "un" && (valueNum === 1 || valueNum === 3)) {
        var _cell$_color, _cell$_fontSize;
        var color = (_cell$_color = cell._color) !== null && _cell$_color !== void 0 ? _cell$_color : cell.fc;
        var fs = (_cell$_fontSize = cell._fontSize) !== null && _cell$_fontSize !== void 0 ? _cell$_fontSize : cell.fs;
        style.borderBottom = "".concat(Math.floor(fs / 9), "px solid ").concat(color);
      }
    });
    return style;
  }
  function getStyleByCell(ctx, d2, r2, c2) {
    var style = {};
    var checksAF = [];
    var cf_compute = getComputeMap(ctx);
    var checksCF = checkCF(r2, c2, cf_compute);
    var cell = d2[r2][c2];
    if (!cell) return {};
    var isInline = isInlineStringCell(cell);
    if ("bg" in cell) {
      var value = normalizedCellAttr(cell, "bg");
      if (checksCF === null || checksCF === void 0 ? void 0 : checksCF.cellColor) {
        if (checksCF === null || checksCF === void 0 ? void 0 : checksCF.cellColor) {
          style.background = "".concat(checksCF.cellColor);
        } else if (checksAF.length > 1) {
          style.background = "".concat(checksAF[1]);
        } else {
          style.background = "".concat(value);
        }
      }
    }
    if ("ht" in cell) {
      var _value2 = normalizedCellAttr(cell, "ht");
      if (Number(_value2) === 0) {
        style.textAlign = "center";
      } else if (Number(_value2) === 2) {
        style.textAlign = "right";
      }
    }
    if ("vt" in cell) {
      var _value3 = normalizedCellAttr(cell, "vt");
      if (Number(_value3) === 0) {
        style.alignItems = "center";
      } else if (Number(_value3) === 2) {
        style.alignItems = "flex-end";
      }
    }
    if (!isInline) {
      style = _$1.assign(style, getFontStyleByCell(cell, checksAF, checksCF));
    }
    return style;
  }
  function getInlineStringHTML(r2, c2, data) {
    var ct = getCellValue(r2, c2, data, "ct");
    if (isInlineStringCT(ct)) {
      var strings = ct.s;
      var value = "";
      for (var i2 = 0; i2 < strings.length; i2 += 1) {
        var strObj = strings[i2];
        if (strObj.v) {
          var style = getFontStyleByCell(strObj);
          var styleStr = _$1.map(style, function(v2, key) {
            return "".concat(_$1.kebabCase(key), ":").concat(_$1.isNumber(v2) ? "".concat(v2, "px") : v2, ";");
          }).join("");
          value += `<span class="luckysheet-input-span" index='`.concat(i2, "' style='").concat(styleStr, "'>").concat(strObj.v, "</span>");
        }
      }
      return value;
    }
    return "";
  }
  function getQKBorder(width, type, color) {
    var bordertype = "";
    if (width.toString().indexOf("pt") > -1) {
      var nWidth = parseFloat(width);
      if (nWidth < 1) ;
      else if (nWidth < 1.5) {
        bordertype = "Medium";
      } else {
        bordertype = "Thick";
      }
    } else {
      var _nWidth = parseFloat(width);
      if (_nWidth < 2) ;
      else if (_nWidth < 3) {
        bordertype = "Medium";
      } else {
        bordertype = "Thick";
      }
    }
    var style = 0;
    type = type.toLowerCase();
    if (type === "double") {
      style = 2;
    } else if (type === "dotted") {
      if (bordertype === "Medium" || bordertype === "Thick") {
        style = 3;
      } else {
        style = 10;
      }
    } else if (type === "dashed") {
      if (bordertype === "Medium" || bordertype === "Thick") {
        style = 4;
      } else {
        style = 9;
      }
    } else if (type === "solid") {
      if (bordertype === "Medium") {
        style = 8;
      } else if (bordertype === "Thick") {
        style = 13;
      } else {
        style = 1;
      }
    }
    return [style, color];
  }
  function getdatabyselection(ctx, range, sheetId) {
    if (range == null && ctx.luckysheet_select_save) {
      var _ctx$luckysheet_selec = _slicedToArray$1(ctx.luckysheet_select_save, 1);
      range = _ctx$luckysheet_selec[0];
    }
    if (!range) return [];
    if (range.row == null || range.row.length === 0) {
      return [];
    }
    var d2;
    var cfg;
    if (sheetId != null && sheetId !== ctx.currentSheetId) {
      d2 = ctx.luckysheetfile[getSheetIndex(ctx, sheetId)].data;
      cfg = ctx.luckysheetfile[getSheetIndex(ctx, sheetId)].config;
    } else {
      d2 = getFlowdata(ctx);
      cfg = ctx.config;
    }
    var data = [];
    for (var r2 = range.row[0]; r2 <= range.row[1]; r2 += 1) {
      var _d, _cfg;
      if (((_d = d2) === null || _d === void 0 ? void 0 : _d[r2]) == null) {
        continue;
      }
      if (((_cfg = cfg) === null || _cfg === void 0 ? void 0 : _cfg.rowhidden) != null && cfg.rowhidden[r2] != null) {
        continue;
      }
      var row = [];
      for (var c2 = range.column[0]; c2 <= range.column[1]; c2 += 1) {
        var _cfg2;
        if (((_cfg2 = cfg) === null || _cfg2 === void 0 ? void 0 : _cfg2.colhidden) != null && cfg.colhidden[c2] != null) {
          continue;
        }
        row.push(d2[r2][c2]);
      }
      data.push(row);
    }
    return data;
  }
  function luckysheetUpdateCell(ctx, row_index, col_index) {
    ctx.luckysheetCellUpdate = [row_index, col_index];
  }
  function getDataBySelectionNoCopy(ctx, range) {
    if (!range || !range.row || range.row.length === 0) return [];
    var data = [];
    var flowData = getFlowdata(ctx);
    if (!flowData) return [];
    for (var r2 = range.row[0]; r2 <= range.row[1]; r2 += 1) {
      var row = [];
      if (ctx.config.rowhidden != null && ctx.config.rowhidden[r2] != null) {
        continue;
      }
      for (var c2 = range.column[0]; c2 <= range.column[1]; c2 += 1) {
        var value = null;
        if (ctx.config.colhidden != null && ctx.config.colhidden[c2] != null) {
          continue;
        }
        if (flowData[r2] != null && flowData[r2][c2] != null) {
          value = flowData[r2][c2];
        }
        row.push(value);
      }
      data.push(row);
    }
    return data;
  }
  var clipboard = /* @__PURE__ */ function() {
    function clipboard2() {
      _classCallCheck(this, clipboard2);
    }
    _createClass(clipboard2, null, [{
      key: "writeHtml",
      value: function writeHtml(str) {
        try {
          var ele = document.getElementById("fortune-copy-content");
          if (!ele) {
            var _document$querySelect;
            ele = document.createElement("div");
            ele.setAttribute("contentEditable", "true");
            ele.id = "fortune-copy-content";
            ele.style.position = "fixed";
            ele.style.height = "0";
            ele.style.width = "0";
            ele.style.left = "-10000px";
            (_document$querySelect = document.querySelector(".fortune-container")) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.append(ele);
          }
          var previouslyFocusedElement = document.activeElement;
          ele.style.display = "block";
          ele.innerHTML = str;
          ele.focus({
            preventScroll: true
          });
          document.execCommand("selectAll");
          document.execCommand("copy");
          setTimeout(function() {
            var _ele, _previouslyFocusedEle;
            (_ele = ele) === null || _ele === void 0 ? void 0 : _ele.blur();
            previouslyFocusedElement === null || previouslyFocusedElement === void 0 ? void 0 : (_previouslyFocusedEle = previouslyFocusedElement.focus) === null || _previouslyFocusedEle === void 0 ? void 0 : _previouslyFocusedEle.call(previouslyFocusedElement);
          }, 10);
        } catch (e) {
          console.error(e);
        }
      }
    }]);
    return clipboard2;
  }();
  function cutVolumn(arr, cutindex) {
    if (cutindex <= 0) {
      return arr;
    }
    var ret = arr.slice(cutindex);
    return ret;
  }
  function frozenTofreezen(ctx, cache, sheetId) {
    var file = ctx.luckysheetfile[getSheetIndex(ctx, sheetId)];
    var frozen = file.frozen;
    if (frozen == null) {
      delete cache.freezen;
      return;
    }
    var freezen = {};
    var range = frozen.range;
    if (!range) {
      range = {
        row_focus: 0,
        column_focus: 0
      };
    }
    var type = frozen.type;
    if (type === "row") {
      type = "rangeRow";
    } else if (type === "column") {
      type = "rangeColumn";
    } else if (type === "both") {
      type = "rangeBoth";
    }
    if (type === "rangeRow" || type === "rangeBoth") {
      var scrollTop = 0;
      var row_st = _$1.sortedIndex(ctx.visibledatarow, scrollTop);
      var _range = range, row_focus = _range.row_focus;
      if (row_focus > row_st) {
        row_st = row_focus;
      }
      if (row_st === -1) {
        row_st = 0;
      }
      var top = ctx.visibledatarow[row_st] - 2 - scrollTop + ctx.columnHeaderHeight;
      var freezenhorizontaldata = [ctx.visibledatarow[row_st], row_st + 1, scrollTop, cutVolumn(ctx.visibledatarow, row_st + 1), top];
      freezen.horizontal = {
        freezenhorizontaldata,
        top
      };
    }
    if (type === "rangeColumn" || type === "rangeBoth") {
      var scrollLeft = 0;
      var col_st = _$1.sortedIndex(ctx.visibledatacolumn, scrollLeft);
      var _range2 = range, column_focus = _range2.column_focus;
      if (column_focus > col_st) {
        col_st = column_focus;
      }
      if (col_st === -1) {
        col_st = 0;
      }
      var left = ctx.visibledatacolumn[col_st] - 2 - scrollLeft + ctx.rowHeaderWidth;
      var freezenverticaldata = [ctx.visibledatacolumn[col_st], col_st + 1, scrollLeft, cutVolumn(ctx.visibledatacolumn, col_st + 1), left];
      freezen.vertical = {
        freezenverticaldata,
        left
      };
    }
    cache.freezen || (cache.freezen = {});
    cache.freezen[ctx.currentSheetId] = freezen;
  }
  function initFreeze(ctx, cache, sheetId) {
    frozenTofreezen(ctx, cache, sheetId);
  }
  function scrollToFrozenRowCol(ctx, freeze2) {
    var _freeze$vertical, _freeze$horizontal;
    var select_save = ctx.luckysheet_select_save;
    if (!select_save) return;
    var row;
    var row_focus = select_save[0].row_focus;
    if (row_focus === select_save[0].row[0]) {
      var _select_save$0$row = _slicedToArray$1(select_save[0].row, 2);
      row = _select_save$0$row[1];
    } else if (row_focus === select_save[0].row[1]) {
      var _select_save$0$row2 = _slicedToArray$1(select_save[0].row, 1);
      row = _select_save$0$row2[0];
    }
    var column;
    var column_focus = select_save[0].column_focus;
    if (column_focus === select_save[0].column[0]) {
      var _select_save$0$column = _slicedToArray$1(select_save[0].column, 2);
      column = _select_save$0$column[1];
    } else if (column_focus === select_save[0].column[1]) {
      var _select_save$0$column2 = _slicedToArray$1(select_save[0].column, 1);
      column = _select_save$0$column2[0];
    }
    var freezenverticaldata = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$vertical = freeze2.vertical) === null || _freeze$vertical === void 0 ? void 0 : _freeze$vertical.freezenverticaldata;
    var freezenhorizontaldata = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$horizontal = freeze2.horizontal) === null || _freeze$horizontal === void 0 ? void 0 : _freeze$horizontal.freezenhorizontaldata;
    if (freezenverticaldata != null && column != null) {
      var freezen_colindex = freezenverticaldata[1];
      var offset = _$1.sortedIndex(freezenverticaldata[3], ctx.scrollLeft);
      var top = freezenverticaldata[4];
      freezen_colindex += offset;
      if (column >= ctx.visibledatacolumn.length) {
        column = ctx.visibledatacolumn.length - 1;
      }
      if (freezen_colindex >= ctx.visibledatacolumn.length) {
        freezen_colindex = ctx.visibledatacolumn.length - 1;
      }
      var column_px = ctx.visibledatacolumn[column];
      var freezen_px = ctx.visibledatacolumn[freezen_colindex];
      if (column_px <= freezen_px + top) {
        ctx.scrollLeft = 0;
      }
    }
    if (freezenhorizontaldata != null && row != null) {
      var freezen_rowindex = freezenhorizontaldata[1];
      var _offset = _$1.sortedIndex(freezenhorizontaldata[3], ctx.scrollTop);
      var left = freezenhorizontaldata[4];
      freezen_rowindex += _offset;
      if (row >= ctx.visibledatarow.length) {
        row = ctx.visibledatarow.length - 1;
      }
      if (freezen_rowindex >= ctx.visibledatarow.length) {
        freezen_rowindex = ctx.visibledatarow.length - 1;
      }
      var row_px = ctx.visibledatarow[row];
      var _freezen_px = ctx.visibledatarow[freezen_rowindex];
      if (row_px <= _freezen_px + left) {
        ctx.scrollTop = 0;
      }
    }
  }
  var refreshLocalMergeData = function refreshLocalMergeData2(merge_new, file) {
    Object.entries(merge_new).forEach(function(_ref) {
      var _file$data2, _file$data2$r;
      var _ref2 = _slicedToArray$1(_ref, 2), v2 = _ref2[1];
      var r2 = v2.r, c2 = v2.c, rs = v2.rs, cs = v2.cs;
      for (var i2 = r2; i2 < r2 + rs; i2 += 1) {
        for (var j2 = c2; j2 < c2 + cs; j2 += 1) {
          var _file$data, _file$data$i;
          if (file === null || file === void 0 ? void 0 : (_file$data = file.data) === null || _file$data === void 0 ? void 0 : (_file$data$i = _file$data[i2]) === null || _file$data$i === void 0 ? void 0 : _file$data$i[j2]) {
            file.data[i2][j2] = _objectSpread2$1(_objectSpread2$1({}, file.data[i2][j2]), {}, {
              mc: {
                r: r2,
                c: c2
              }
            });
          }
        }
      }
      if (file === null || file === void 0 ? void 0 : (_file$data2 = file.data) === null || _file$data2 === void 0 ? void 0 : (_file$data2$r = _file$data2[r2]) === null || _file$data2$r === void 0 ? void 0 : _file$data2$r[c2]) {
        file.data[r2][c2] = _objectSpread2$1(_objectSpread2$1({}, file.data[r2][c2]), {}, {
          mc: {
            r: r2,
            c: c2,
            rs,
            cs
          }
        });
      }
    });
  };
  function insertRowCol(ctx, op) {
    var changeSelection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var count = op.count, id2 = op.id;
    var type = op.type, index2 = op.index, direction = op.direction;
    id2 = id2 || ctx.currentSheetId;
    var curOrder = getSheetIndex(ctx, id2);
    if (curOrder == null) return;
    var file = ctx.luckysheetfile[curOrder];
    if (!file) return;
    var d2 = file.data;
    if (!d2) return;
    var cfg = file.config || {};
    if (changeSelection) {
      if (type === "row") {
        var _cfg$rowReadOnly;
        if ((_cfg$rowReadOnly = cfg.rowReadOnly) === null || _cfg$rowReadOnly === void 0 ? void 0 : _cfg$rowReadOnly[index2]) {
          throw new Error("readOnly");
        }
      } else {
        var _cfg$colReadOnly;
        if ((_cfg$colReadOnly = cfg.colReadOnly) === null || _cfg$colReadOnly === void 0 ? void 0 : _cfg$colReadOnly[index2]) {
          throw new Error("readOnly");
        }
      }
    }
    if (type === "row" && d2.length + count >= 1e4) {
      throw new Error("maxExceeded");
    }
    if (type === "column" && d2[0] && d2[0].length + count >= 1e3) {
      throw new Error("maxExceeded");
    }
    count = Math.floor(count);
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    var merge_new = {};
    _$1.forEach(cfg.merge, function(mc2) {
      var r3 = mc2.r, c3 = mc2.c, rs = mc2.rs, cs = mc2.cs;
      if (type === "row") {
        if (index2 < r3) {
          merge_new["".concat(r3 + count, "_").concat(c3)] = {
            r: r3 + count,
            c: c3,
            rs,
            cs
          };
        } else if (index2 === r3) {
          if (direction === "lefttop") {
            merge_new["".concat(r3 + count, "_").concat(c3)] = {
              r: r3 + count,
              c: c3,
              rs,
              cs
            };
          } else {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs: rs + count,
              cs
            };
          }
        } else if (index2 < r3 + rs - 1) {
          merge_new["".concat(r3, "_").concat(c3)] = {
            r: r3,
            c: c3,
            rs: rs + count,
            cs
          };
        } else if (index2 === r3 + rs - 1) {
          if (direction === "lefttop") {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs: rs + count,
              cs
            };
          } else {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs
            };
          }
        } else {
          merge_new["".concat(r3, "_").concat(c3)] = {
            r: r3,
            c: c3,
            rs,
            cs
          };
        }
      } else if (type === "column") {
        if (index2 < c3) {
          merge_new["".concat(r3, "_").concat(c3 + count)] = {
            r: r3,
            c: c3 + count,
            rs,
            cs
          };
        } else if (index2 === c3) {
          if (direction === "lefttop") {
            merge_new["".concat(r3, "_").concat(c3 + count)] = {
              r: r3,
              c: c3 + count,
              rs,
              cs
            };
          } else {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs: cs + count
            };
          }
        } else if (index2 < c3 + cs - 1) {
          merge_new["".concat(r3, "_").concat(c3)] = {
            r: r3,
            c: c3,
            rs,
            cs: cs + count
          };
        } else if (index2 === c3 + cs - 1) {
          if (direction === "lefttop") {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs: cs + count
            };
          } else {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs
            };
          }
        } else {
          merge_new["".concat(r3, "_").concat(c3)] = {
            r: r3,
            c: c3,
            rs,
            cs
          };
        }
      }
    });
    cfg.merge = merge_new;
    var newCalcChain = [];
    for (var SheetIndex = 0; SheetIndex < ctx.luckysheetfile.length; SheetIndex += 1) {
      if (_$1.isNil(ctx.luckysheetfile[SheetIndex].calcChain) || ctx.luckysheetfile.length === 0) {
        continue;
      }
      var calcChain = ctx.luckysheetfile[SheetIndex].calcChain;
      var data = ctx.luckysheetfile[SheetIndex].data;
      for (var i2 = 0; i2 < calcChain.length; i2 += 1) {
        var calc = _$1.cloneDeep(calcChain[i2]);
        var calc_r = calc.r;
        var calc_c = calc.c;
        var calc_i = calc.id;
        var calc_funcStr = getcellFormula(ctx, calc_r, calc_c, calc_i);
        if (type === "row" && SheetIndex === curOrder) {
          var _d$calc_r, _d$calc_r$calc_c;
          var functionStr = "=".concat(functionStrChange(calc_funcStr, "add", "row", direction, index2, count));
          if (((_d$calc_r = d2[calc_r]) === null || _d$calc_r === void 0 ? void 0 : (_d$calc_r$calc_c = _d$calc_r[calc_c]) === null || _d$calc_r$calc_c === void 0 ? void 0 : _d$calc_r$calc_c.f) === calc_funcStr) {
            d2[calc_r][calc_c].f = functionStr;
          }
          if (direction === "lefttop") {
            if (calc_r >= index2) {
              calc.r += count;
            }
          } else if (direction === "rightbottom") {
            if (calc_r > index2) {
              calc.r += count;
            }
          }
          newCalcChain.push(calc);
        } else if (type === "row") {
          var _data$calc_r, _data$calc_r$calc_c;
          var _functionStr = "=".concat(functionStrChange(calc_funcStr, "add", "row", direction, index2, count));
          if (((_data$calc_r = data[calc_r]) === null || _data$calc_r === void 0 ? void 0 : (_data$calc_r$calc_c = _data$calc_r[calc_c]) === null || _data$calc_r$calc_c === void 0 ? void 0 : _data$calc_r$calc_c.f) === calc_funcStr) {
            data[calc_r][calc_c].f = _functionStr;
          }
        } else if (type === "column" && SheetIndex === curOrder) {
          var _d$calc_r2, _d$calc_r2$calc_c;
          var _functionStr2 = "=".concat(functionStrChange(calc_funcStr, "add", "col", direction, index2, count));
          if (((_d$calc_r2 = d2[calc_r]) === null || _d$calc_r2 === void 0 ? void 0 : (_d$calc_r2$calc_c = _d$calc_r2[calc_c]) === null || _d$calc_r2$calc_c === void 0 ? void 0 : _d$calc_r2$calc_c.f) === calc_funcStr) {
            d2[calc_r][calc_c].f = _functionStr2;
          }
          if (direction === "lefttop") {
            if (calc_c >= index2) {
              calc.c += count;
            }
          } else if (direction === "rightbottom") {
            if (calc_c > index2) {
              calc.c += count;
            }
          }
          newCalcChain.push(calc);
        } else if (type === "column") {
          var _data$calc_r2, _data$calc_r2$calc_c;
          var _functionStr3 = "=".concat(functionStrChange(calc_funcStr, "add", "col", direction, index2, count));
          if (((_data$calc_r2 = data[calc_r]) === null || _data$calc_r2 === void 0 ? void 0 : (_data$calc_r2$calc_c = _data$calc_r2[calc_c]) === null || _data$calc_r2$calc_c === void 0 ? void 0 : _data$calc_r2$calc_c.f) === calc_funcStr) {
            data[calc_r][calc_c].f = _functionStr3;
          }
        }
      }
    }
    var filter_select = file.filter_select;
    var filter = file.filter;
    var newFilterObj = null;
    if (!_$1.isEmpty(filter_select) && filter_select != null) {
      newFilterObj = {
        filter_select: null,
        filter: null
      };
      var f_r1 = filter_select.row[0];
      var f_r2 = filter_select.row[1];
      var f_c1 = filter_select.column[0];
      var f_c2 = filter_select.column[1];
      if (type === "row") {
        if (f_r1 < index2) {
          if (f_r2 === index2 && direction === "lefttop") {
            f_r2 += count;
          } else if (f_r2 > index2) {
            f_r2 += count;
          }
        } else if (f_r1 === index2) {
          if (direction === "lefttop") {
            f_r1 += count;
            f_r2 += count;
          } else if (direction === "rightbottom" && f_r2 > index2) {
            f_r2 += count;
          }
        } else {
          f_r1 += count;
          f_r2 += count;
        }
        if (filter != null) {
          newFilterObj.filter = {};
          _$1.forEach(filter, function(v2, k2) {
            var f_rowhidden = filter[k2].rowhidden;
            var f_rowhidden_new = {};
            _$1.forEach(f_rowhidden, function(v1, nstr) {
              var n2 = parseFloat(nstr);
              if (n2 < index2) {
                f_rowhidden_new[n2] = 0;
              } else if (n2 === index2) {
                if (direction === "lefttop") {
                  f_rowhidden_new[n2 + count] = 0;
                } else if (direction === "rightbottom") {
                  f_rowhidden_new[n2] = 0;
                }
              } else {
                f_rowhidden_new[n2 + count] = 0;
              }
            });
            newFilterObj.filter[k2] = _$1.cloneDeep(filter[k2]);
            newFilterObj.filter[k2].rowhidden = f_rowhidden_new;
            newFilterObj.filter[k2].str = f_r1;
            newFilterObj.filter[k2].edr = f_r2;
          });
        }
      } else if (type === "column") {
        if (f_c1 < index2) {
          if (f_c2 === index2 && direction === "lefttop") {
            f_c2 += count;
          } else if (f_c2 > index2) {
            f_c2 += count;
          }
        } else if (f_c1 === index2) {
          if (direction === "lefttop") {
            f_c1 += count;
            f_c2 += count;
          } else if (direction === "rightbottom" && f_c2 > index2) {
            f_c2 += count;
          }
        } else {
          f_c1 += count;
          f_c2 += count;
        }
        if (filter != null) {
          newFilterObj.filter = {};
          _$1.forEach(filter, function(v2, k2) {
            var f_cindex = filter[k2].cindex;
            if (f_cindex === index2 && direction === "lefttop") {
              f_cindex += count;
            } else if (f_cindex > index2) {
              f_cindex += count;
            }
            newFilterObj.filter[f_cindex - f_c1] = _$1.cloneDeep(filter[k2]);
            newFilterObj.filter[f_cindex - f_c1].cindex = f_cindex;
            newFilterObj.filter[f_cindex - f_c1].stc = f_c1;
            newFilterObj.filter[f_cindex - f_c1].edc = f_c2;
          });
        }
      }
      newFilterObj.filter_select = {
        row: [f_r1, f_r2],
        column: [f_c1, f_c2]
      };
    }
    if (newFilterObj != null && newFilterObj.filter != null) {
      if (cfg.rowhidden == null) {
        cfg.rowhidden = {};
      }
      _$1.forEach(newFilterObj.filter, function(v2, k2) {
        var f_rowhidden = newFilterObj.filter[k2].rowhidden;
        _$1.forEach(f_rowhidden, function(v1, n2) {
          cfg.rowhidden[n2] = 0;
        });
      });
    }
    var CFarr = file.luckysheet_conditionformat_save;
    var newCFarr = [];
    if (CFarr != null && CFarr.length > 0) {
      for (var _i = 0; _i < CFarr.length; _i += 1) {
        var cf_range = CFarr[_i].cellrange;
        var cf_new_range = [];
        for (var j2 = 0; j2 < cf_range.length; j2 += 1) {
          var CFr1 = cf_range[j2].row[0];
          var CFr2 = cf_range[j2].row[1];
          var CFc1 = cf_range[j2].column[0];
          var CFc2 = cf_range[j2].column[1];
          if (type === "row") {
            if (CFr1 < index2) {
              if (CFr2 === index2 && direction === "lefttop") {
                CFr2 += count;
              } else if (CFr2 > index2) {
                CFr2 += count;
              }
            } else if (CFr1 === index2) {
              if (direction === "lefttop") {
                CFr1 += count;
                CFr2 += count;
              } else if (direction === "rightbottom" && CFr2 > index2) {
                CFr2 += count;
              }
            } else {
              CFr1 += count;
              CFr2 += count;
            }
          } else if (type === "column") {
            if (CFc1 < index2) {
              if (CFc2 === index2 && direction === "lefttop") {
                CFc2 += count;
              } else if (CFc2 > index2) {
                CFc2 += count;
              }
            } else if (CFc1 === index2) {
              if (direction === "lefttop") {
                CFc1 += count;
                CFc2 += count;
              } else if (direction === "rightbottom" && CFc2 > index2) {
                CFc2 += count;
              }
            } else {
              CFc1 += count;
              CFc2 += count;
            }
          }
          cf_new_range.push({
            row: [CFr1, CFr2],
            column: [CFc1, CFc2]
          });
        }
        var cf2 = _$1.clone(CFarr[_i]);
        cf2.cellrange = cf_new_range;
        newCFarr.push(cf2);
      }
    }
    var AFarr = file.luckysheet_alternateformat_save;
    var newAFarr = [];
    if (AFarr != null && AFarr.length > 0) {
      for (var _i2 = 0; _i2 < AFarr.length; _i2 += 1) {
        var AFr1 = AFarr[_i2].cellrange.row[0];
        var AFr2 = AFarr[_i2].cellrange.row[1];
        var AFc1 = AFarr[_i2].cellrange.column[0];
        var AFc2 = AFarr[_i2].cellrange.column[1];
        var af2 = _$1.clone(AFarr[_i2]);
        if (type === "row") {
          if (AFr1 < index2) {
            if (AFr2 === index2 && direction === "lefttop") {
              AFr2 += count;
            } else if (AFr2 > index2) {
              AFr2 += count;
            }
          } else if (AFr1 === index2) {
            if (direction === "lefttop") {
              AFr1 += count;
              AFr2 += count;
            } else if (direction === "rightbottom" && AFr2 > index2) {
              AFr2 += count;
            }
          } else {
            AFr1 += count;
            AFr2 += count;
          }
        } else if (type === "column") {
          if (AFc1 < index2) {
            if (AFc2 === index2 && direction === "lefttop") {
              AFc2 += count;
            } else if (AFc2 > index2) {
              AFc2 += count;
            }
          } else if (AFc1 === index2) {
            if (direction === "lefttop") {
              AFc1 += count;
              AFc2 += count;
            } else if (direction === "rightbottom" && AFc2 > index2) {
              AFc2 += count;
            }
          } else {
            AFc1 += count;
            AFc2 += count;
          }
        }
        af2.cellrange = {
          row: [AFr1, AFr2],
          column: [AFc1, AFc2]
        };
        newAFarr.push(af2);
      }
    }
    var frozen = file.frozen;
    if (frozen) {
      var normalizedIndex = direction === "lefttop" ? index2 - 1 : index2;
      if (type === "row" && (frozen.type === "rangeRow" || frozen.type === "rangeBoth")) {
        var _frozen$range$row_foc, _frozen$range;
        if (((_frozen$range$row_foc = (_frozen$range = frozen.range) === null || _frozen$range === void 0 ? void 0 : _frozen$range.row_focus) !== null && _frozen$range$row_foc !== void 0 ? _frozen$range$row_foc : -1) > normalizedIndex) {
          frozen.range.row_focus += count;
        }
      }
      if (type === "column" && (frozen.type === "rangeColumn" || frozen.type === "rangeBoth")) {
        var _frozen$range$column_, _frozen$range2;
        if (((_frozen$range$column_ = (_frozen$range2 = frozen.range) === null || _frozen$range2 === void 0 ? void 0 : _frozen$range2.column_focus) !== null && _frozen$range$column_ !== void 0 ? _frozen$range$column_ : -1) > normalizedIndex) {
          frozen.range.column_focus += count;
        }
      }
    }
    var dataVerification = file.dataVerification;
    var newDataVerification = {};
    if (dataVerification != null) {
      _$1.forEach(dataVerification, function(v2, key) {
        var r3 = Number(key.split("_")[0]);
        var c3 = Number(key.split("_")[1]);
        var item = dataVerification[key];
        if (type === "row") {
          if (index2 < r3) {
            newDataVerification["".concat(r3 + count, "_").concat(c3)] = item;
          } else if (index2 === r3) {
            if (direction === "lefttop") {
              newDataVerification["".concat(r3 + count, "_").concat(c3)] = item;
              for (var _i3 = 0; _i3 < count; _i3 += 1) {
                newDataVerification["".concat(r3 + _i3, "_").concat(c3)] = item;
              }
            } else {
              newDataVerification["".concat(r3, "_").concat(c3)] = item;
              for (var _i4 = 0; _i4 < count; _i4 += 1) {
                newDataVerification["".concat(r3 + _i4 + 1, "_").concat(c3)] = item;
              }
            }
          } else {
            newDataVerification["".concat(r3, "_").concat(c3)] = item;
          }
        } else if (type === "column") {
          if (index2 < c3) {
            newDataVerification["".concat(r3, "_").concat(c3 + count)] = item;
          } else if (index2 === c3) {
            if (direction === "lefttop") {
              newDataVerification["".concat(r3, "_").concat(c3 + count)] = item;
              for (var _i5 = 0; _i5 < count; _i5 += 1) {
                newDataVerification["".concat(r3, "_").concat(c3 + _i5)] = item;
              }
            } else {
              newDataVerification["".concat(r3, "_").concat(c3)] = item;
              for (var _i6 = 0; _i6 < count; _i6 += 1) {
                newDataVerification["".concat(r3, "_").concat(c3 + _i6 + 1)] = item;
              }
            }
          } else {
            newDataVerification["".concat(r3, "_").concat(c3)] = item;
          }
        }
      });
    }
    var hyperlink = file.hyperlink;
    var newHyperlink = {};
    if (hyperlink != null) {
      _$1.forEach(hyperlink, function(v2, key) {
        var r3 = Number(key.split("_")[0]);
        var c3 = Number(key.split("_")[1]);
        var item = hyperlink[key];
        if (type === "row") {
          if (index2 < r3) {
            newHyperlink["".concat(r3 + count, "_").concat(c3)] = item;
          } else if (index2 === r3) {
            if (direction === "lefttop") {
              newHyperlink["".concat(r3 + count, "_").concat(c3)] = item;
            } else {
              newHyperlink["".concat(r3, "_").concat(c3)] = item;
            }
          } else {
            newHyperlink["".concat(r3, "_").concat(c3)] = item;
          }
        } else if (type === "column") {
          if (index2 < c3) {
            newHyperlink["".concat(r3, "_").concat(c3 + count)] = item;
          } else if (index2 === c3) {
            if (direction === "lefttop") {
              newHyperlink["".concat(r3, "_").concat(c3 + count)] = item;
            } else {
              newHyperlink["".concat(r3, "_").concat(c3)] = item;
            }
          } else {
            newHyperlink["".concat(r3, "_").concat(c3)] = item;
          }
        }
      });
    }
    if (type === "row") {
      if (cfg.rowlen != null) {
        var rowlen_new = {};
        var rowReadOnly_new = {};
        _$1.forEach(cfg.rowlen, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < index2) {
            rowlen_new[r3] = cfg.rowlen[r3];
          } else if (r3 === index2) {
            if (direction === "lefttop") {
              rowlen_new[r3 + count] = cfg.rowlen[r3];
            } else if (direction === "rightbottom") {
              rowlen_new[r3] = cfg.rowlen[r3];
            }
          } else {
            rowlen_new[r3 + count] = cfg.rowlen[r3];
          }
        });
        _$1.forEach(cfg.rowReadOnly, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < index2) {
            rowReadOnly_new[r3] = cfg.rowReadOnly[r3];
          } else if (r3 > index2) {
            rowReadOnly_new[r3 + count] = cfg.rowReadOnly[r3];
          }
        });
        cfg.rowlen = rowlen_new;
        cfg.rowReadOnly = rowReadOnly_new;
      }
      if (cfg.customHeight != null) {
        var customHeight_new = {};
        _$1.forEach(cfg.customHeight, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < index2) {
            customHeight_new[r3] = cfg.customHeight[r3];
          } else if (r3 === index2) {
            if (direction === "lefttop") {
              customHeight_new[r3 + count] = cfg.customHeight[r3];
            } else if (direction === "rightbottom") {
              customHeight_new[r3] = cfg.customHeight[r3];
            }
          } else {
            customHeight_new[r3 + count] = cfg.customHeight[r3];
          }
        });
        cfg.customHeight = customHeight_new;
      }
      if (cfg.customHeight != null) {
        var _customHeight_new = {};
        _$1.forEach(cfg.customHeight, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < index2) {
            _customHeight_new[r3] = cfg.customHeight[r3];
          } else if (r3 === index2) {
            if (direction === "lefttop") {
              _customHeight_new[r3 + count] = cfg.customHeight[r3];
            } else if (direction === "rightbottom") {
              _customHeight_new[r3] = cfg.customHeight[r3];
            }
          } else {
            _customHeight_new[r3 + count] = cfg.customHeight[r3];
          }
        });
        cfg.customHeight = _customHeight_new;
      }
      if (cfg.rowhidden != null) {
        var rowhidden_new = {};
        _$1.forEach(cfg.rowhidden, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < index2) {
            rowhidden_new[r3] = cfg.rowhidden[r3];
          } else if (r3 === index2) {
            if (direction === "lefttop") {
              rowhidden_new[r3 + count] = cfg.rowhidden[r3];
            } else if (direction === "rightbottom") {
              rowhidden_new[r3] = cfg.rowhidden[r3];
            }
          } else {
            rowhidden_new[r3 + count] = cfg.rowhidden[r3];
          }
        });
        cfg.rowhidden = rowhidden_new;
      }
      var row = [];
      var curRow = _toConsumableArray$1(d2)[index2];
      for (var c2 = 0; c2 < d2[0].length; c2 += 1) {
        var cell = curRow[c2];
        var templateCell = null;
        if ((cell === null || cell === void 0 ? void 0 : cell.mc) && (direction === "rightbottom" || index2 !== cell.mc.r)) {
          var _d, _d$c;
          if (cell.mc.rs) {
            cell.mc.rs += count;
          }
          templateCell = _objectSpread2$1({}, cell);
          if (!(d2 === null || d2 === void 0 ? void 0 : (_d = d2[index2 + 1]) === null || _d === void 0 ? void 0 : (_d$c = _d[c2]) === null || _d$c === void 0 ? void 0 : _d$c.mc)) {
            templateCell.mc = void 0;
          }
          delete templateCell.v;
          delete templateCell.m;
          delete templateCell.ps;
          delete templateCell.f;
        }
        row.push(templateCell);
      }
      var cellBorderConfig = [];
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var borderInfo = [];
        for (var _i7 = 0; _i7 < cfg.borderInfo.length; _i7 += 1) {
          var rangeType = cfg.borderInfo[_i7].rangeType;
          if (rangeType === "range") {
            var borderRange = cfg.borderInfo[_i7].range;
            var emptyRange = [];
            for (var _j = 0; _j < borderRange.length; _j += 1) {
              var bd_r1 = borderRange[_j].row[0];
              var bd_r2 = borderRange[_j].row[1];
              if (direction === "lefttop") {
                if (index2 <= bd_r1) {
                  bd_r1 += count;
                  bd_r2 += count;
                } else if (index2 <= bd_r2) {
                  bd_r2 += count;
                }
              } else {
                if (index2 < bd_r1) {
                  bd_r1 += count;
                  bd_r2 += count;
                } else if (index2 < bd_r2) {
                  bd_r2 += count;
                }
              }
              if (bd_r2 >= bd_r1) {
                emptyRange.push({
                  row: [bd_r1, bd_r2],
                  column: borderRange[_j].column
                });
              }
            }
            if (emptyRange.length > 0) {
              var bd_obj = {
                rangeType: "range",
                borderType: cfg.borderInfo[_i7].borderType,
                style: cfg.borderInfo[_i7].style,
                color: cfg.borderInfo[_i7].color,
                range: emptyRange
              };
              borderInfo.push(bd_obj);
            }
          } else if (rangeType === "cell") {
            var row_index = cfg.borderInfo[_i7].value.row_index;
            if (row_index === index2) {
              cellBorderConfig.push(JSON.parse(JSON.stringify(cfg.borderInfo[_i7])));
            }
            if (direction === "lefttop") {
              if (index2 <= row_index) {
                row_index += count;
              }
            } else {
              if (index2 < row_index) {
                row_index += count;
              }
            }
            cfg.borderInfo[_i7].value.row_index = row_index;
            borderInfo.push(cfg.borderInfo[_i7]);
          }
        }
        cfg.borderInfo = borderInfo;
      }
      var arr = [];
      var _loop = function _loop3(r3) {
        arr.push(JSON.stringify(row));
        if (cellBorderConfig.length) {
          var _cfg$borderInfo;
          var cellBorderConfigCopy = _$1.cloneDeep(cellBorderConfig);
          cellBorderConfigCopy.forEach(function(item) {
            if (direction === "rightbottom") {
              item.value.row_index += r3 + 1;
            } else if (direction === "lefttop") {
              item.value.row_index += r3;
            }
          });
          (_cfg$borderInfo = cfg.borderInfo) === null || _cfg$borderInfo === void 0 ? void 0 : _cfg$borderInfo.push.apply(_cfg$borderInfo, _toConsumableArray$1(cellBorderConfigCopy));
        }
      };
      for (var r2 = 0; r2 < count; r2 += 1) {
        _loop(r2);
      }
      if (direction === "lefttop") {
        if (index2 === 0) {
          new Function("d", "return d.unshift(".concat(arr.join(","), ")"))(d2);
        } else {
          new Function("d", "return d.splice(".concat(index2, ", 0, ").concat(arr.join(","), ")"))(d2);
        }
      } else {
        new Function("d", "return d.splice(".concat(index2 + 1, ", 0, ").concat(arr.join(","), ")"))(d2);
      }
    } else {
      if (cfg.columnlen != null) {
        var columnlen_new = {};
        var columnReadOnly_new = {};
        _$1.forEach(cfg.columnlen, function(v2, cstr) {
          var c3 = parseFloat(cstr);
          if (c3 < index2) {
            columnlen_new[c3] = cfg.columnlen[c3];
          } else if (c3 === index2) {
            if (direction === "lefttop") {
              columnlen_new[c3 + count] = cfg.columnlen[c3];
            } else if (direction === "rightbottom") {
              columnlen_new[c3] = cfg.columnlen[c3];
            }
          } else {
            columnlen_new[c3 + count] = cfg.columnlen[c3];
          }
        });
        _$1.forEach(cfg.colReadOnly, function(v2, cstr) {
          var c3 = parseFloat(cstr);
          if (c3 < index2) {
            columnReadOnly_new[c3] = cfg.colReadOnly[c3];
          } else if (c3 > index2) {
            columnReadOnly_new[c3 + count] = cfg.colReadOnly[c3];
          }
        });
        cfg.columnlen = columnlen_new;
        cfg.colReadOnly = columnReadOnly_new;
      }
      if (cfg.customWidth != null) {
        var customWidth_new = {};
        _$1.forEach(cfg.customWidth, function(v2, cstr) {
          var c3 = parseFloat(cstr);
          if (c3 < index2) {
            customWidth_new[c3] = cfg.customWidth[c3];
          } else if (c3 === index2) {
            if (direction === "lefttop") {
              customWidth_new[c3 + count] = cfg.customWidth[c3];
            } else if (direction === "rightbottom") {
              customWidth_new[c3] = cfg.customWidth[c3];
            }
          } else {
            customWidth_new[c3 + count] = cfg.customWidth[c3];
          }
        });
        cfg.customWidth = customWidth_new;
      }
      if (cfg.customWidth != null) {
        var _customWidth_new = {};
        _$1.forEach(cfg.customWidth, function(v2, cstr) {
          var c3 = parseFloat(cstr);
          if (c3 < index2) {
            _customWidth_new[c3] = cfg.customWidth[c3];
          } else if (c3 === index2) {
            if (direction === "lefttop") {
              _customWidth_new[c3 + count] = cfg.customWidth[c3];
            } else if (direction === "rightbottom") {
              _customWidth_new[c3] = cfg.customWidth[c3];
            }
          } else {
            _customWidth_new[c3 + count] = cfg.customWidth[c3];
          }
        });
        cfg.customWidth = _customWidth_new;
      }
      if (cfg.colhidden != null) {
        var colhidden_new = {};
        _$1.forEach(cfg.colhidden, function(v2, cstr) {
          var c3 = parseFloat(cstr);
          if (c3 < index2) {
            colhidden_new[c3] = cfg.colhidden[c3];
          } else if (c3 === index2) {
            if (direction === "lefttop") {
              colhidden_new[c3 + count] = cfg.colhidden[c3];
            } else if (direction === "rightbottom") {
              colhidden_new[c3] = cfg.colhidden[c3];
            }
          } else {
            colhidden_new[c3 + count] = cfg.colhidden[c3];
          }
        });
        cfg.colhidden = colhidden_new;
      }
      var col = [];
      var curd = _toConsumableArray$1(d2);
      for (var _r = 0; _r < d2.length; _r += 1) {
        var _cell = curd[_r][index2];
        var _templateCell = null;
        if ((_cell === null || _cell === void 0 ? void 0 : _cell.mc) && (direction === "rightbottom" || index2 !== _cell.mc.c)) {
          var _curd$_r, _curd$_r2;
          if (_cell.mc.cs) {
            _cell.mc.cs += count;
          }
          _templateCell = _objectSpread2$1({}, _cell);
          if (!(curd === null || curd === void 0 ? void 0 : (_curd$_r = curd[_r]) === null || _curd$_r === void 0 ? void 0 : (_curd$_r2 = _curd$_r[index2 + 1]) === null || _curd$_r2 === void 0 ? void 0 : _curd$_r2.mc)) {
            _templateCell.mc = void 0;
          }
          delete _templateCell.v;
          delete _templateCell.m;
          delete _templateCell.ps;
          delete _templateCell.f;
        }
        col.push(_templateCell);
      }
      var _cellBorderConfig = [];
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var _borderInfo = [];
        for (var _i8 = 0; _i8 < cfg.borderInfo.length; _i8 += 1) {
          var _rangeType = cfg.borderInfo[_i8].rangeType;
          if (_rangeType === "range") {
            var _borderRange = cfg.borderInfo[_i8].range;
            var _emptyRange = [];
            for (var _j2 = 0; _j2 < _borderRange.length; _j2 += 1) {
              var bd_c1 = _borderRange[_j2].column[0];
              var bd_c2 = _borderRange[_j2].column[1];
              if (direction === "lefttop") {
                if (index2 <= bd_c1) {
                  bd_c1 += count;
                  bd_c2 += count;
                } else if (index2 <= bd_c2) {
                  bd_c2 += count;
                }
              } else {
                if (index2 < bd_c1) {
                  bd_c1 += count;
                  bd_c2 += count;
                } else if (index2 < bd_c2) {
                  bd_c2 += count;
                }
              }
              if (bd_c2 >= bd_c1) {
                _emptyRange.push({
                  row: _borderRange[_j2].row,
                  column: [bd_c1, bd_c2]
                });
              }
            }
            if (_emptyRange.length > 0) {
              var _bd_obj = {
                rangeType: "range",
                borderType: cfg.borderInfo[_i8].borderType,
                style: cfg.borderInfo[_i8].style,
                color: cfg.borderInfo[_i8].color,
                range: _emptyRange
              };
              _borderInfo.push(_bd_obj);
            }
          } else if (_rangeType === "cell") {
            var col_index = cfg.borderInfo[_i8].value.col_index;
            if (col_index === index2) {
              _cellBorderConfig.push(JSON.parse(JSON.stringify(cfg.borderInfo[_i8])));
            }
            if (direction === "lefttop") {
              if (index2 <= col_index) {
                col_index += count;
              }
            } else {
              if (index2 < col_index) {
                col_index += count;
              }
            }
            cfg.borderInfo[_i8].value.col_index = col_index;
            _borderInfo.push(cfg.borderInfo[_i8]);
          }
        }
        cfg.borderInfo = _borderInfo;
      }
      if (_cellBorderConfig.length) {
        var _loop2 = function _loop22(_i92) {
          var _cfg$borderInfo2;
          var cellBorderConfigCopy = _$1.cloneDeep(_cellBorderConfig);
          cellBorderConfigCopy.forEach(function(item) {
            if (direction === "rightbottom") {
              item.value.col_index += _i92 + 1;
            } else if (direction === "lefttop") {
              item.value.col_index += _i92;
            }
          });
          (_cfg$borderInfo2 = cfg.borderInfo) === null || _cfg$borderInfo2 === void 0 ? void 0 : _cfg$borderInfo2.push.apply(_cfg$borderInfo2, _toConsumableArray$1(cellBorderConfigCopy));
        };
        for (var _i9 = 0; _i9 < count; _i9 += 1) {
          _loop2(_i9);
        }
      }
      for (var _r2 = 0; _r2 < d2.length; _r2 += 1) {
        var _row = d2[_r2];
        for (var _i10 = 0; _i10 < count; _i10 += 1) {
          if (direction === "lefttop") {
            if (index2 === 0) {
              _row.unshift(col[_r2]);
            } else {
              _row.splice(index2, 0, col[_r2]);
            }
          } else {
            _row.splice(index2 + 1, 0, col[_r2]);
          }
        }
      }
    }
    file.data = d2;
    file.config = cfg;
    file.calcChain = newCalcChain;
    if (newFilterObj != null) {
      file.filter = newFilterObj.filter;
      file.filter_select = newFilterObj.filter_select;
    }
    file.luckysheet_conditionformat_save = newCFarr;
    file.luckysheet_alternateformat_save = newAFarr;
    file.dataVerification = newDataVerification;
    file.hyperlink = newHyperlink;
    if (file.id === ctx.currentSheetId) {
      ctx.config = cfg;
    }
    var range = null;
    if (type === "row") {
      if (direction === "lefttop") {
        range = [{
          row: [index2, index2 + count - 1],
          column: [0, d2[0].length - 1]
        }];
      } else {
        range = [{
          row: [index2 + 1, index2 + count],
          column: [0, d2[0].length - 1]
        }];
      }
      file.row = file.data.length;
    } else {
      var _file$data$;
      if (direction === "lefttop") {
        range = [{
          row: [0, d2.length - 1],
          column: [index2, index2 + count - 1]
        }];
      } else {
        range = [{
          row: [0, d2.length - 1],
          column: [index2 + 1, index2 + count]
        }];
      }
      file.column = (_file$data$ = file.data[0]) === null || _file$data$ === void 0 ? void 0 : _file$data$.length;
    }
    if (changeSelection) {
      file.luckysheet_select_save = range;
      if (file.id === ctx.currentSheetId) {
        ctx.luckysheet_select_save = range;
      }
    }
    refreshLocalMergeData(merge_new, file);
  }
  function deleteRowCol(ctx, op) {
    var type = op.type;
    var start = op.start, end = op.end, id2 = op.id;
    id2 = id2 || ctx.currentSheetId;
    var curOrder = getSheetIndex(ctx, id2);
    if (curOrder == null) return;
    var file = ctx.luckysheetfile[curOrder];
    if (!file) return;
    var cfg = file.config || {};
    if (type === "row") {
      for (var r2 = start; r2 <= end; r2 += 1) {
        var _cfg$rowReadOnly2;
        if ((_cfg$rowReadOnly2 = cfg.rowReadOnly) === null || _cfg$rowReadOnly2 === void 0 ? void 0 : _cfg$rowReadOnly2[r2]) {
          throw new Error("readOnly");
        }
      }
    } else {
      for (var c2 = start; c2 <= end; c2 += 1) {
        var _cfg$colReadOnly2;
        if ((_cfg$colReadOnly2 = cfg.colReadOnly) === null || _cfg$colReadOnly2 === void 0 ? void 0 : _cfg$colReadOnly2[c2]) {
          throw new Error("readOnly");
        }
      }
    }
    var d2 = file.data;
    if (!d2) return;
    if (start < 0) {
      start = 0;
    }
    if (end < 0) {
      end = 0;
    }
    if (type === "row") {
      if (start > d2.length - 1) {
        start = d2.length - 1;
      }
      if (end > d2.length - 1) {
        end = d2.length - 1;
      }
    } else {
      if (start > d2[0].length - 1) {
        start = d2[0].length - 1;
      }
      if (end > d2[0].length - 1) {
        end = d2[0].length - 1;
      }
    }
    if (start > end) {
      return;
    }
    var slen = end - start + 1;
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    var merge_new = {};
    _$1.forEach(cfg.merge, function(mc2) {
      var r3 = mc2.r;
      var c3 = mc2.c;
      var rs = mc2.rs;
      var cs = mc2.cs;
      if (type === "row") {
        if (r3 < start) {
          if (r3 + rs - 1 < start) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs
            };
          } else if (r3 + rs - 1 >= start && r3 + rs - 1 < end) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs: start - r3,
              cs
            };
          } else if (r3 + rs - 1 >= end) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs: rs - slen,
              cs
            };
          }
        } else if (r3 >= start && r3 <= end) {
          if (r3 + rs - 1 > end) {
            merge_new["".concat(start, "_").concat(c3)] = {
              r: start,
              c: c3,
              rs: r3 + rs - 1 - end,
              cs
            };
          }
        } else if (r3 > end) {
          merge_new["".concat(r3 - slen, "_").concat(c3)] = {
            r: r3 - slen,
            c: c3,
            rs,
            cs
          };
        }
      } else if (type === "column") {
        if (c3 < start) {
          if (c3 + cs - 1 < start) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs
            };
          } else if (c3 + cs - 1 >= start && c3 + cs - 1 < end) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs: start - c3
            };
          } else if (c3 + cs - 1 >= end) {
            merge_new["".concat(r3, "_").concat(c3)] = {
              r: r3,
              c: c3,
              rs,
              cs: cs - slen
            };
          }
        } else if (c3 >= start && c3 <= end) {
          if (c3 + cs - 1 > end) {
            merge_new["".concat(r3, "_").concat(start)] = {
              r: r3,
              c: start,
              rs,
              cs: c3 + cs - 1 - end
            };
          }
        } else if (c3 > end) {
          merge_new["".concat(r3, "_").concat(c3 - slen)] = {
            r: r3,
            c: c3 - slen,
            rs,
            cs
          };
        }
      }
    });
    cfg.merge = merge_new;
    var newCalcChain = [];
    for (var SheetIndex = 0; SheetIndex < ctx.luckysheetfile.length; SheetIndex += 1) {
      if (_$1.isNil(ctx.luckysheetfile[SheetIndex].calcChain) || ctx.luckysheetfile.length === 0) {
        continue;
      }
      var calcChain = ctx.luckysheetfile[SheetIndex].calcChain;
      var data = ctx.luckysheetfile[SheetIndex].data;
      for (var i2 = 0; i2 < calcChain.length; i2 += 1) {
        var calc = _$1.cloneDeep(calcChain[i2]);
        var calc_r = calc.r;
        var calc_c = calc.c;
        var calc_i = calc.id;
        var calc_funcStr = getcellFormula(ctx, calc_r, calc_c, calc_i);
        if (type === "row" && SheetIndex === curOrder) {
          if (calc_r < start || calc_r > end) {
            var _data$calc_r3, _data$calc_r3$calc_c;
            var functionStr = "=".concat(functionStrChange(calc_funcStr, "del", "row", null, start, slen));
            if (((_data$calc_r3 = data[calc_r]) === null || _data$calc_r3 === void 0 ? void 0 : (_data$calc_r3$calc_c = _data$calc_r3[calc_c]) === null || _data$calc_r3$calc_c === void 0 ? void 0 : _data$calc_r3$calc_c.f) === calc_funcStr) {
              data[calc_r][calc_c].f = functionStr;
            }
            if (calc_r > end) {
              calc.r = calc_r - slen;
            }
            newCalcChain.push(calc);
          }
        } else if (type === "row") {
          var _data$calc_r4, _data$calc_r4$calc_c;
          var _functionStr4 = "=".concat(functionStrChange(calc_funcStr, "del", "row", null, start, slen));
          if (((_data$calc_r4 = data[calc_r]) === null || _data$calc_r4 === void 0 ? void 0 : (_data$calc_r4$calc_c = _data$calc_r4[calc_c]) === null || _data$calc_r4$calc_c === void 0 ? void 0 : _data$calc_r4$calc_c.f) === calc_funcStr) {
            data[calc_r][calc_c].f = _functionStr4;
          }
        } else if (type === "column" && SheetIndex === curOrder) {
          if (calc_c < start || calc_c > end) {
            var _data$calc_r5, _data$calc_r5$calc_c;
            var _functionStr5 = "=".concat(functionStrChange(calc_funcStr, "del", "col", null, start, slen));
            if (((_data$calc_r5 = data[calc_r]) === null || _data$calc_r5 === void 0 ? void 0 : (_data$calc_r5$calc_c = _data$calc_r5[calc_c]) === null || _data$calc_r5$calc_c === void 0 ? void 0 : _data$calc_r5$calc_c.f) === calc_funcStr) {
              data[calc_r][calc_c].f = _functionStr5;
            }
            if (calc_c > end) {
              calc.c = calc_c - slen;
            }
            newCalcChain.push(calc);
          }
        } else if (type === "column") {
          var _data$calc_r6, _data$calc_r6$calc_c;
          var _functionStr6 = "=".concat(functionStrChange(calc_funcStr, "del", "col", null, start, slen));
          if (((_data$calc_r6 = data[calc_r]) === null || _data$calc_r6 === void 0 ? void 0 : (_data$calc_r6$calc_c = _data$calc_r6[calc_c]) === null || _data$calc_r6$calc_c === void 0 ? void 0 : _data$calc_r6$calc_c.f) === calc_funcStr) {
            data[calc_r][calc_c].f = _functionStr6;
          }
        }
      }
    }
    var filter_select = file.filter_select;
    var filter = file.filter;
    var newFilterObj = null;
    if (!_$1.isEmpty(filter_select) && filter_select != null) {
      newFilterObj = {
        filter_select: null,
        filter: null
      };
      var f_r1 = filter_select.row[0];
      var f_r2 = filter_select.row[1];
      var f_c1 = filter_select.column[0];
      var f_c2 = filter_select.column[1];
      if (type === "row") {
        if (f_r1 > end) {
          f_r1 -= slen;
          f_r2 -= slen;
          newFilterObj.filter_select = {
            row: [f_r1, f_r2],
            column: [f_c1, f_c2]
          };
        } else if (f_r1 < start) {
          if (f_r2 < start) ;
          else if (f_r2 <= end) {
            f_r2 = start - 1;
          } else {
            f_r2 -= slen;
          }
          newFilterObj.filter_select = {
            row: [f_r1, f_r2],
            column: [f_c1, f_c2]
          };
        }
        if (newFilterObj.filter_select != null && filter != null) {
          _$1.forEach(filter, function(v2, k2) {
            var f_rowhidden = filter[k2].rowhidden;
            var f_rowhidden_new = {};
            _$1.forEach(f_rowhidden, function(v1, nstr) {
              var n2 = parseFloat(nstr);
              if (n2 < start) {
                f_rowhidden_new[n2] = 0;
              } else if (n2 > end) {
                f_rowhidden_new[n2 - slen] = 0;
              }
            });
            if (!_$1.isEmpty(f_rowhidden_new)) {
              if (newFilterObj.filter == null) {
                newFilterObj.filter = {};
              }
              newFilterObj.filter[k2] = _$1.cloneDeep(filter[k2]);
              newFilterObj.filter[k2].rowhidden = f_rowhidden_new;
              newFilterObj.filter[k2].str = f_r1;
              newFilterObj.filter[k2].edr = f_r2;
            }
          });
        }
      } else if (type === "column") {
        if (f_c1 > end) {
          f_c1 -= slen;
          f_c2 -= slen;
          newFilterObj.filter_select = {
            row: [f_r1, f_r2],
            column: [f_c1, f_c2]
          };
        } else if (f_c1 < start) {
          if (f_c2 < start) ;
          else if (f_c2 <= end) {
            f_c2 = start - 1;
          } else {
            f_c2 -= slen;
          }
          newFilterObj.filter_select = {
            row: [f_r1, f_r2],
            column: [f_c1, f_c2]
          };
        } else {
          if (f_c2 > end) {
            f_c1 = start;
            f_c2 -= slen;
            newFilterObj.filter_select = {
              row: [f_r1, f_r2],
              column: [f_c1, f_c2]
            };
          }
        }
        if (newFilterObj.filter_select != null && filter != null) {
          _$1.forEach(filter, function(v2, k2) {
            var f_cindex = filter[k2].cindex;
            if (f_cindex < start) {
              if (newFilterObj.filter == null) {
                newFilterObj.filter = {};
              }
              newFilterObj.filter[f_cindex - f_c1] = _$1.cloneDeep(filter[k2]);
              newFilterObj.filter[f_cindex - f_c1].edc = f_c2;
            } else if (f_cindex > end) {
              f_cindex -= slen;
              if (newFilterObj.filter == null) {
                newFilterObj.filter = {};
              }
              newFilterObj.filter[f_cindex - f_c1] = _$1.cloneDeep(filter[k2]);
              newFilterObj.filter[f_cindex - f_c1].cindex = f_cindex;
              newFilterObj.filter[f_cindex - f_c1].stc = f_c1;
              newFilterObj.filter[f_cindex - f_c1].edc = f_c2;
            }
          });
        }
      }
    }
    if (newFilterObj != null && newFilterObj.filter != null) {
      if (cfg.rowhidden == null) {
        cfg.rowhidden = {};
      }
      _$1.forEach(newFilterObj.filter, function(v2, k2) {
        var f_rowhidden = newFilterObj.filter[k2].rowhidden;
        _$1.forEach(f_rowhidden, function(v1, n2) {
          cfg.rowhidden[n2] = 0;
        });
      });
    }
    var CFarr = file.luckysheet_conditionformat_save;
    var newCFarr = [];
    if (CFarr != null && CFarr.length > 0) {
      for (var _i11 = 0; _i11 < CFarr.length; _i11 += 1) {
        var cf_range = CFarr[_i11].cellrange;
        var cf_new_range = [];
        for (var j2 = 0; j2 < cf_range.length; j2 += 1) {
          var CFr1 = cf_range[j2].row[0];
          var CFr2 = cf_range[j2].row[1];
          var CFc1 = cf_range[j2].column[0];
          var CFc2 = cf_range[j2].column[1];
          if (type === "row") {
            if (!(CFr1 >= start && CFr2 <= end)) {
              if (CFr1 > end) {
                CFr1 -= slen;
                CFr2 -= slen;
              } else if (CFr1 < start) {
                if (CFr2 < start) ;
                else if (CFr2 <= end) {
                  CFr2 = start - 1;
                } else {
                  CFr2 -= slen;
                }
              } else {
                if (CFr2 > end) {
                  CFr1 = start;
                  CFr2 -= slen;
                }
              }
              cf_new_range.push({
                row: [CFr1, CFr2],
                column: [CFc1, CFc2]
              });
            }
          } else if (type === "column") {
            if (!(CFc1 >= start && CFc2 <= end)) {
              if (CFc1 > end) {
                CFc1 -= slen;
                CFc2 -= slen;
              } else if (CFc1 < start) {
                if (CFc2 < start) ;
                else if (CFc2 <= end) {
                  CFc2 = start - 1;
                } else {
                  CFc2 -= slen;
                }
              } else {
                if (CFc2 > end) {
                  CFc1 = start;
                  CFc2 -= slen;
                }
              }
              cf_new_range.push({
                row: [CFr1, CFr2],
                column: [CFc1, CFc2]
              });
            }
          }
        }
        if (cf_new_range.length > 0) {
          var cf2 = _$1.clone(CFarr[_i11]);
          cf2.cellrange = cf_new_range;
          newCFarr.push(cf2);
        }
      }
    }
    var AFarr = file.luckysheet_alternateformat_save;
    var newAFarr = [];
    if (AFarr != null && AFarr.length > 0) {
      for (var _i12 = 0; _i12 < AFarr.length; _i12 += 1) {
        var AFr1 = AFarr[_i12].cellrange.row[0];
        var AFr2 = AFarr[_i12].cellrange.row[1];
        var AFc1 = AFarr[_i12].cellrange.column[0];
        var AFc2 = AFarr[_i12].cellrange.column[1];
        if (type === "row") {
          if (!(AFr1 >= start && AFr2 <= end)) {
            var af2 = _$1.clone(AFarr[_i12]);
            if (AFr1 > end) {
              AFr1 -= slen;
              AFr2 -= slen;
            } else if (AFr1 < start) {
              if (AFr2 < start) ;
              else if (AFr2 <= end) {
                AFr2 = start - 1;
              } else {
                AFr2 -= slen;
              }
            } else {
              if (AFr2 > end) {
                AFr1 = start;
                AFr2 -= slen;
              }
            }
            af2.cellrange = {
              row: [AFr1, AFr2],
              column: [AFc1, AFc2]
            };
            newAFarr.push(af2);
          }
        } else if (type === "column") {
          if (!(AFc1 >= start && AFc2 <= end)) {
            var _af = _$1.clone(AFarr[_i12]);
            if (AFc1 > end) {
              AFc1 -= slen;
              AFc2 -= slen;
            } else if (AFc1 < start) {
              if (AFc2 < start) ;
              else if (AFc2 <= end) {
                AFc2 = start - 1;
              } else {
                AFc2 -= slen;
              }
            } else {
              if (AFc2 > end) {
                AFc1 = start;
                AFc2 -= slen;
              }
            }
            _af.cellrange = {
              row: [AFr1, AFr2],
              column: [AFc1, AFc2]
            };
            newAFarr.push(_af);
          }
        }
      }
    }
    var frozen = file.frozen;
    if (frozen) {
      if (type === "row" && (frozen.type === "rangeRow" || frozen.type === "rangeBoth")) {
        var _frozen$range$row_foc2, _frozen$range3;
        if (((_frozen$range$row_foc2 = (_frozen$range3 = frozen.range) === null || _frozen$range3 === void 0 ? void 0 : _frozen$range3.row_focus) !== null && _frozen$range$row_foc2 !== void 0 ? _frozen$range$row_foc2 : -1) >= start) {
          frozen.range.row_focus -= Math.min(end, frozen.range.row_focus) - start + 1;
        }
      }
      if (type === "column" && (frozen.type === "rangeColumn" || frozen.type === "rangeBoth")) {
        var _frozen$range$column_2, _frozen$range4;
        if (((_frozen$range$column_2 = (_frozen$range4 = frozen.range) === null || _frozen$range4 === void 0 ? void 0 : _frozen$range4.column_focus) !== null && _frozen$range$column_2 !== void 0 ? _frozen$range$column_2 : -1) >= start) {
          frozen.range.column_focus -= Math.min(end, frozen.range.column_focus) - start + 1;
        }
      }
    }
    var dataVerification = file.dataVerification;
    var newDataVerification = {};
    if (dataVerification != null) {
      _$1.forEach(dataVerification, function(v2, key) {
        var r3 = Number(key.split("_")[0]);
        var c3 = Number(key.split("_")[1]);
        var item = dataVerification[key];
        if (type === "row") {
          if (r3 < start) {
            newDataVerification["".concat(r3, "_").concat(c3)] = item;
          } else if (r3 > end) {
            newDataVerification["".concat(r3 - slen, "_").concat(c3)] = item;
          }
        } else if (type === "column") {
          if (c3 < start) {
            newDataVerification["".concat(r3, "_").concat(c3)] = item;
          } else if (c3 > end) {
            newDataVerification["".concat(r3, "_").concat(c3 - slen)] = item;
          }
        }
      });
    }
    var hyperlink = file.hyperlink;
    var newHyperlink = {};
    if (hyperlink != null) {
      _$1.forEach(hyperlink, function(v2, key) {
        var r3 = Number(key.split("_")[0]);
        var c3 = Number(key.split("_")[1]);
        var item = hyperlink[key];
        if (type === "row") {
          if (r3 < start) {
            newHyperlink["".concat(r3, "_").concat(c3)] = item;
          } else if (r3 > end) {
            newHyperlink["".concat(r3 - slen, "_").concat(c3)] = item;
          }
        } else if (type === "column") {
          if (c3 < start) {
            newHyperlink["".concat(r3, "_").concat(c3)] = item;
          } else if (c3 > end) {
            newHyperlink["".concat(r3, "_").concat(c3 - slen)] = item;
          }
        }
      });
    }
    if (type === "row") {
      if (cfg.rowlen == null) {
        cfg.rowlen = {};
      }
      var rowlen_new = {};
      var rowReadOnly_new = {};
      _$1.forEach(cfg.rowlen, function(v2, rstr) {
        var r3 = parseFloat(rstr);
        if (r3 < start) {
          rowlen_new[r3] = cfg.rowlen[r3];
        } else if (r3 > end) {
          rowlen_new[r3 - slen] = cfg.rowlen[r3];
        }
      });
      _$1.forEach(cfg.rowReadOnly, function(v2, rstr) {
        var r3 = parseFloat(rstr);
        if (r3 < start) {
          rowReadOnly_new[r3] = cfg.rowReadOnly[r3];
        } else if (r3 > end) {
          rowReadOnly_new[r3 - slen] = cfg.rowReadOnly[r3];
        }
      });
      cfg.rowlen = rowlen_new;
      cfg.rowReadOnly = rowReadOnly_new;
      if (cfg.rowhidden == null) {
        cfg.rowhidden = {};
      }
      var rowhidden_new = {};
      _$1.forEach(cfg.rowhidden, function(v2, rstr) {
        var r3 = parseFloat(rstr);
        if (r3 < start) {
          rowhidden_new[r3] = cfg.rowhidden[r3];
        } else if (r3 > end) {
          rowhidden_new[r3 - slen] = cfg.rowhidden[r3];
        }
      });
      if (cfg.customHeight == null) {
        cfg.customHeight = {};
        var customHeight_new = {};
        _$1.forEach(cfg.customHeight, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < start) {
            customHeight_new[r3] = cfg.customHeight[r3];
          } else if (r3 > end) {
            customHeight_new[r3 - slen] = cfg.customHeight[r3];
          }
        });
        cfg.customHeight = customHeight_new;
      }
      if (cfg.customHeight == null) {
        cfg.customHeight = {};
        var _customHeight_new2 = {};
        _$1.forEach(cfg.customHeight, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < start) {
            _customHeight_new2[r3] = cfg.customHeight[r3];
          } else if (r3 > end) {
            _customHeight_new2[r3 - slen] = cfg.customHeight[r3];
          }
        });
        cfg.customHeight = _customHeight_new2;
      }
      cfg.rowhidden = rowhidden_new;
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var borderInfo = [];
        for (var _i13 = 0; _i13 < cfg.borderInfo.length; _i13 += 1) {
          var rangeType = cfg.borderInfo[_i13].rangeType;
          if (rangeType === "range") {
            var borderRange = cfg.borderInfo[_i13].range;
            var emptyRange = [];
            for (var _j3 = 0; _j3 < borderRange.length; _j3 += 1) {
              var bd_r1 = borderRange[_j3].row[0];
              var bd_r2 = borderRange[_j3].row[1];
              for (var _r3 = start; _r3 <= end; _r3 += 1) {
                if (_r3 < borderRange[_j3].row[0]) {
                  bd_r1 -= 1;
                  bd_r2 -= 1;
                } else if (_r3 <= borderRange[_j3].row[1]) {
                  bd_r2 -= 1;
                }
              }
              if (bd_r2 >= bd_r1) {
                emptyRange.push({
                  row: [bd_r1, bd_r2],
                  column: borderRange[_j3].column
                });
              }
            }
            if (emptyRange.length > 0) {
              var bd_obj = {
                rangeType: "range",
                borderType: cfg.borderInfo[_i13].borderType,
                style: cfg.borderInfo[_i13].style,
                color: cfg.borderInfo[_i13].color,
                range: emptyRange
              };
              borderInfo.push(bd_obj);
            }
          } else if (rangeType === "cell") {
            var row_index = cfg.borderInfo[_i13].value.row_index;
            if (row_index < start) {
              borderInfo.push(cfg.borderInfo[_i13]);
            } else if (row_index > end) {
              cfg.borderInfo[_i13].value.row_index = row_index - (end - start + 1);
              borderInfo.push(cfg.borderInfo[_i13]);
            }
          }
        }
        cfg.borderInfo = borderInfo;
      }
      d2.splice(start, slen);
      file.row = d2.length;
    } else {
      var _d$;
      if (cfg.columnlen == null) {
        cfg.columnlen = {};
      }
      var columnlen_new = {};
      var columnReadOnly_new = {};
      _$1.forEach(cfg.columnlen, function(v2, cstr) {
        var c3 = parseFloat(cstr);
        if (c3 < start) {
          columnlen_new[c3] = cfg.columnlen[c3];
        } else if (c3 > end) {
          columnlen_new[c3 - slen] = cfg.columnlen[c3];
        }
      });
      _$1.forEach(cfg.colReadOnly, function(v2, cstr) {
        var c3 = parseFloat(cstr);
        if (c3 < start) {
          columnReadOnly_new[c3] = cfg.colReadOnly[c3];
        } else if (c3 > end) {
          columnReadOnly_new[c3 - slen] = cfg.colReadOnly[c3];
        }
      });
      cfg.columnlen = columnlen_new;
      cfg.colReadOnly = columnReadOnly_new;
      if (cfg.customWidth == null) {
        cfg.customWidth = {};
        var customWidth_new = {};
        _$1.forEach(cfg.customWidth, function(v2, rstr) {
          var r3 = parseFloat(rstr);
          if (r3 < start) {
            customWidth_new[r3] = cfg.customWidth[r3];
          } else if (r3 > end) {
            customWidth_new[r3 - slen] = cfg.customWidth[r3];
          }
        });
        cfg.customWidth = customWidth_new;
      }
      cfg.colReadOnly = columnReadOnly_new;
      if (cfg.colhidden == null) {
        cfg.colhidden = {};
      }
      var colhidden_new = {};
      _$1.forEach(cfg.colhidden, function(v2, cstr) {
        var c3 = parseFloat(cstr);
        if (c3 < start) {
          colhidden_new[c3] = cfg.colhidden[c3];
        } else if (c3 > end) {
          colhidden_new[c3 - slen] = cfg.colhidden[c3];
        }
      });
      cfg.colhidden = colhidden_new;
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var _borderInfo2 = [];
        for (var _i14 = 0; _i14 < cfg.borderInfo.length; _i14 += 1) {
          var _rangeType2 = cfg.borderInfo[_i14].rangeType;
          if (_rangeType2 === "range") {
            var _borderRange2 = cfg.borderInfo[_i14].range;
            var _emptyRange2 = [];
            for (var _j4 = 0; _j4 < _borderRange2.length; _j4 += 1) {
              var bd_c1 = _borderRange2[_j4].column[0];
              var bd_c2 = _borderRange2[_j4].column[1];
              for (var _c = start; _c <= end; _c += 1) {
                if (_c < _borderRange2[_j4].column[0]) {
                  bd_c1 -= 1;
                  bd_c2 -= 1;
                } else if (_c <= _borderRange2[_j4].column[1]) {
                  bd_c2 -= 1;
                }
              }
              if (bd_c2 >= bd_c1) {
                _emptyRange2.push({
                  row: _borderRange2[_j4].row,
                  column: [bd_c1, bd_c2]
                });
              }
            }
            if (_emptyRange2.length > 0) {
              var _bd_obj2 = {
                rangeType: "range",
                borderType: cfg.borderInfo[_i14].borderType,
                style: cfg.borderInfo[_i14].style,
                color: cfg.borderInfo[_i14].color,
                range: _emptyRange2
              };
              _borderInfo2.push(_bd_obj2);
            }
          } else if (_rangeType2 === "cell") {
            var col_index = cfg.borderInfo[_i14].value.col_index;
            if (col_index < start) {
              _borderInfo2.push(cfg.borderInfo[_i14]);
            } else if (col_index > end) {
              cfg.borderInfo[_i14].value.col_index = col_index - (end - start + 1);
              _borderInfo2.push(cfg.borderInfo[_i14]);
            }
          }
        }
        cfg.borderInfo = _borderInfo2;
      }
      for (var _r4 = 0; _r4 < d2.length; _r4 += 1) {
        d2[_r4].splice(start, slen);
      }
      file.column = (_d$ = d2[0]) === null || _d$ === void 0 ? void 0 : _d$.length;
    }
    ctx.luckysheet_select_save = void 0;
    file.data = d2;
    file.config = cfg;
    file.calcChain = newCalcChain;
    if (newFilterObj != null) {
      file.filter = newFilterObj.filter;
      file.filter_select = newFilterObj.filter_select;
    }
    file.luckysheet_conditionformat_save = newCFarr;
    file.luckysheet_alternateformat_save = newAFarr;
    file.dataVerification = newDataVerification;
    file.hyperlink = newHyperlink;
    refreshLocalMergeData(merge_new, file);
    if (file.id === ctx.currentSheetId) {
      ctx.config = cfg;
    }
  }
  function hideSelected(ctx, type) {
    if (!ctx.luckysheet_select_save || ctx.luckysheet_select_save.length > 1) return "noMulti";
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (type === "row") {
      var _ctx$config$rowhidden;
      var rowhidden = (_ctx$config$rowhidden = ctx.config.rowhidden) !== null && _ctx$config$rowhidden !== void 0 ? _ctx$config$rowhidden : {};
      var r1 = ctx.luckysheet_select_save[0].row[0];
      var r2 = ctx.luckysheet_select_save[0].row[1];
      var rowhiddenNumber = r2;
      for (var r3 = r1; r3 <= r2; r3 += 1) {
        rowhidden[r3] = 0;
      }
      ctx.config.rowhidden = rowhidden;
      var rowLen = ctx.luckysheetfile[index2].data.length;
      var isEndRow = rowLen - 1 === rowhiddenNumber || Object.keys(rowhidden).findIndex(function(o2) {
        return parseInt(o2, 10) - 1 === rowhiddenNumber;
      }) >= 0;
      if (isEndRow) {
        ctx.luckysheet_select_save[0].row[0] -= 1;
        ctx.luckysheet_select_save[0].row[1] -= 1;
      } else {
        ctx.luckysheet_select_save[0].row[0] += 1;
        ctx.luckysheet_select_save[0].row[1] += 1;
      }
    } else if (type === "column") {
      var _ctx$config$colhidden;
      var colhidden = (_ctx$config$colhidden = ctx.config.colhidden) !== null && _ctx$config$colhidden !== void 0 ? _ctx$config$colhidden : {};
      var c1 = ctx.luckysheet_select_save[0].column[0];
      var c2 = ctx.luckysheet_select_save[0].column[1];
      var colhiddenNumber = c2;
      for (var c3 = c1; c3 <= c2; c3 += 1) {
        colhidden[c3] = 0;
      }
      ctx.config.colhidden = colhidden;
      var columnLen = ctx.luckysheetfile[index2].data[0].length;
      var isEndColumn = columnLen - 1 === colhiddenNumber || Object.keys(colhidden).findIndex(function(o2) {
        return parseInt(o2, 10) - 1 === colhiddenNumber;
      }) >= 0;
      if (isEndColumn) {
        ctx.luckysheet_select_save[0].column[0] -= 1;
        ctx.luckysheet_select_save[0].column[1] -= 1;
      } else {
        ctx.luckysheet_select_save[0].column[0] += 1;
        ctx.luckysheet_select_save[0].column[1] += 1;
      }
    }
    ctx.luckysheetfile[index2].config = ctx.config;
    return "";
  }
  function showSelected(ctx, type) {
    if (!ctx.luckysheet_select_save || ctx.luckysheet_select_save.length > 1) return "noMulti";
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (type === "row") {
      var _ctx$config$rowhidden2;
      var rowhidden = (_ctx$config$rowhidden2 = ctx.config.rowhidden) !== null && _ctx$config$rowhidden2 !== void 0 ? _ctx$config$rowhidden2 : {};
      var r1 = ctx.luckysheet_select_save[0].row[0];
      var r2 = ctx.luckysheet_select_save[0].row[1];
      for (var r3 = r1; r3 <= r2; r3 += 1) {
        delete rowhidden[r3];
      }
      ctx.config.rowhidden = rowhidden;
    } else if (type === "column") {
      var _ctx$config$colhidden2;
      var colhidden = (_ctx$config$colhidden2 = ctx.config.colhidden) !== null && _ctx$config$colhidden2 !== void 0 ? _ctx$config$colhidden2 : {};
      var c1 = ctx.luckysheet_select_save[0].column[0];
      var c2 = ctx.luckysheet_select_save[0].column[1];
      for (var c3 = c1; c3 <= c2; c3 += 1) {
        delete colhidden[c3];
      }
      ctx.config.colhidden = colhidden;
    }
    ctx.luckysheetfile[index2].config = ctx.config;
    return "";
  }
  function isShowHidenCR(ctx) {
    if (!ctx.luckysheet_select_save || !ctx.config.colhidden && !ctx.config.rowhidden) return false;
    if (!!ctx.config.colhidden && _$1.size(ctx.config.colhidden) >= 1) {
      var _ctx$luckysheet_selec, _ctx$luckysheet_selec2;
      var ctxColumn = (_ctx$luckysheet_selec = ctx.luckysheet_select_save[0]) === null || _ctx$luckysheet_selec === void 0 ? void 0 : (_ctx$luckysheet_selec2 = _ctx$luckysheet_selec.column) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2[0];
      var isHidenColumn = Object.keys(ctx.config.colhidden).findIndex(function(o2) {
        return ctxColumn === parseInt(o2, 10);
      }) >= 0;
      if (isHidenColumn) {
        return true;
      }
    }
    if (!!ctx.config.rowhidden && _$1.size(ctx.config.rowhidden) >= 1) {
      var _ctx$luckysheet_selec3, _ctx$luckysheet_selec4;
      var ctxRow = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save[0]) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : (_ctx$luckysheet_selec4 = _ctx$luckysheet_selec3.row) === null || _ctx$luckysheet_selec4 === void 0 ? void 0 : _ctx$luckysheet_selec4[0];
      var isHidenRow = Object.keys(ctx.config.rowhidden).findIndex(function(o2) {
        return ctxRow === parseInt(o2, 10);
      }) >= 0;
      if (isHidenRow) {
        return true;
      }
    }
    return false;
  }
  function hideCRCount(ctx, type) {
    var _ctx$config$rowhidden3, _ctx$config$colhidden3;
    var count = 1;
    if (!ctx.luckysheet_select_save) return 0;
    var section = ctx.luckysheet_select_save[0];
    var rowhidden = (_ctx$config$rowhidden3 = ctx.config.rowhidden) !== null && _ctx$config$rowhidden3 !== void 0 ? _ctx$config$rowhidden3 : {};
    var colhidden = (_ctx$config$colhidden3 = ctx.config.colhidden) !== null && _ctx$config$colhidden3 !== void 0 ? _ctx$config$colhidden3 : {};
    if (type === "ArrowUp" || type === "ArrowDown") {
      var rowArr = Object.keys(rowhidden);
      if (type === "ArrowUp") {
        var row = section.row[0] - 1;
        var rowIndex = rowArr.indexOf(row.toString());
        for (var i2 = rowIndex; i2 >= 0; i2 -= 1) {
          if (parseInt(rowArr[i2], 10) === row) {
            count += 1;
            row -= 1;
          } else {
            return count;
          }
        }
      } else {
        var _row2 = section.row[0] + 1;
        var _rowIndex = rowArr.indexOf("".concat(_row2));
        for (var _i15 = _rowIndex; _i15 < rowArr.length; _i15 += 1) {
          if (parseInt(rowArr[_i15], 10) === _row2) {
            count += 1;
            _row2 += 1;
          } else {
            return count;
          }
        }
      }
    } else if (type === "ArrowLeft" || type === "ArrowRight") {
      var columnArr = Object.keys(colhidden);
      if (type === "ArrowLeft") {
        var column = section.column[0] - 1;
        var columnIndex = columnArr.indexOf(column.toString());
        for (var _i16 = columnIndex; _i16 >= 0; _i16 -= 1) {
          if (parseInt(columnArr[_i16], 10) === column) {
            count += 1;
            column -= 1;
          } else {
            return count;
          }
        }
      } else {
        var _column = section.column[0] + 1;
        var _columnIndex = columnArr.indexOf("".concat(_column));
        for (var _i17 = _columnIndex; _i17 < columnArr.length; _i17 += 1) {
          if (parseInt(columnArr[_i17], 10) === _column) {
            count += 1;
            _column += 1;
          } else {
            return count;
          }
        }
      }
    }
    return count;
  }
  var selectionCache = {
    isPasteAction: false
  };
  function scrollToHighlightCell(ctx, r2, c2) {
    var _sheet$frozen, _sheet$frozen$range, _sheet$frozen2, _sheet$frozen2$range;
    var scrollLeft = ctx.scrollLeft, scrollTop = ctx.scrollTop;
    var winH = ctx.cellmainHeight;
    var winW = ctx.cellmainWidth;
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    var sheet = sheetIndex == null ? null : ctx.luckysheetfile[sheetIndex];
    if (!sheet) return;
    var frozen = sheet === null || sheet === void 0 ? void 0 : sheet.frozen;
    var row_focus = (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen = sheet.frozen) === null || _sheet$frozen === void 0 ? void 0 : (_sheet$frozen$range = _sheet$frozen.range) === null || _sheet$frozen$range === void 0 ? void 0 : _sheet$frozen$range.row_focus) || 0;
    var column_focus = (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen2 = sheet.frozen) === null || _sheet$frozen2 === void 0 ? void 0 : (_sheet$frozen2$range = _sheet$frozen2.range) === null || _sheet$frozen2$range === void 0 ? void 0 : _sheet$frozen2$range.column_focus) || 0;
    var freezeH = frozen && r2 > row_focus ? ctx.visibledatarow[row_focus] : 0;
    var freezeW = frozen && c2 > column_focus ? ctx.visibledatacolumn[column_focus] : 0;
    var row = ctx.visibledatarow[r2];
    var row_pre = r2 - 1 === -1 ? 0 : ctx.visibledatarow[r2 - 1];
    var col = ctx.visibledatacolumn[c2];
    var col_pre = c2 - 1 === -1 ? 0 : ctx.visibledatacolumn[c2 - 1];
    if (col - scrollLeft - winW + 20 > 0) {
      ctx.scrollLeft = col - winW + 20;
    } else if (col_pre - scrollLeft - freezeW < 0) {
      var scrollAmount = Math.max(20, freezeW);
      ctx.scrollLeft = col_pre - scrollAmount;
    }
    if (row - scrollTop - winH + 20 > 0) {
      ctx.scrollTop = row - winH + 20;
    } else if (row_pre - scrollTop - freezeH < 0) {
      var _scrollAmount = Math.max(20, freezeH);
      ctx.scrollTop = row_pre - _scrollAmount;
    }
  }
  function seletedHighlistByindex(ctx, r1, r2, c1, c2) {
    var row = ctx.visibledatarow[r2];
    var row_pre = r1 - 1 === -1 ? 0 : ctx.visibledatarow[r1 - 1];
    var col = ctx.visibledatacolumn[c2];
    var col_pre = c1 - 1 === -1 ? 0 : ctx.visibledatacolumn[c1 - 1];
    if (_$1.isNumber(row) && _$1.isNumber(row_pre) && _$1.isNumber(col) && _$1.isNumber(col_pre)) {
      return {
        left: col_pre,
        width: col - col_pre - 1,
        top: row_pre,
        height: row - row_pre - 1
      };
    }
    return null;
  }
  function normalizeSelection(ctx, selection) {
    if (!selection) return selection;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return selection;
    for (var i2 = 0; i2 < selection.length; i2 += 1) {
      var r1 = selection[i2].row[0];
      var r2 = selection[i2].row[1];
      var c1 = selection[i2].column[0];
      var c2 = selection[i2].column[1];
      var rf2 = void 0;
      var cf2 = void 0;
      if (_$1.isNil(selection[i2].row_focus)) {
        rf2 = r1;
      } else {
        rf2 = selection[i2].row_focus;
      }
      if (_$1.isNil(selection[i2].column_focus)) {
        cf2 = c1;
      } else {
        cf2 = selection[i2].column_focus;
      }
      if (_$1.isNil(rf2) || _$1.isNil(cf2)) {
        console.error("normalizeSelection: rf and cf is nil");
        return selection;
      }
      var row = ctx.visibledatarow[r2];
      var row_pre = r1 - 1 === -1 ? 0 : ctx.visibledatarow[r1 - 1];
      var col = ctx.visibledatacolumn[c2];
      var col_pre = c1 - 1 === -1 ? 0 : ctx.visibledatacolumn[c1 - 1];
      var row_f = ctx.visibledatarow[rf2];
      var row_pre_f = rf2 - 1 === -1 ? 0 : ctx.visibledatarow[rf2 - 1];
      var col_f = ctx.visibledatacolumn[cf2];
      var col_pre_f = cf2 - 1 === -1 ? 0 : ctx.visibledatacolumn[cf2 - 1];
      var margeset = mergeBorder(ctx, flowdata, rf2, cf2);
      if (margeset) {
        var _margeset$row = _slicedToArray$1(margeset.row, 2);
        row_pre_f = _margeset$row[0];
        row_f = _margeset$row[1];
        var _margeset$column = _slicedToArray$1(margeset.column, 2);
        col_pre_f = _margeset$column[0];
        col_f = _margeset$column[1];
      }
      selection[i2].row = [r1, r2];
      selection[i2].column = [c1, c2];
      selection[i2].row_focus = rf2;
      selection[i2].column_focus = cf2;
      selection[i2].left = col_pre_f;
      selection[i2].width = col_f - col_pre_f <= 0 ? 0 : col_f - col_pre_f - 1;
      selection[i2].top = row_pre_f;
      selection[i2].height = row_f - row_pre_f <= 0 ? 0 : row_f - row_pre_f - 1;
      selection[i2].left_move = col_pre;
      selection[i2].width_move = col - col_pre <= 0 ? 0 : col - col_pre - 1;
      selection[i2].top_move = row_pre;
      selection[i2].height_move = row - row_pre <= 0 ? 0 : row - row_pre - 1;
    }
    return selection;
  }
  function selectTitlesMap(rangeMap, range1, range2) {
    var map = rangeMap || {};
    for (var i2 = range1; i2 <= range2; i2 += 1) {
      if (i2 in map) {
        continue;
      }
      map[i2] = 0;
    }
    return map;
  }
  function selectTitlesRange(map) {
    var mapArr = Object.keys(map).map(Number);
    mapArr.sort(function(a2, b2) {
      return a2 - b2;
    });
    var rangeArr;
    var item = [];
    if (mapArr.length > 1) {
      rangeArr = [];
      for (var j2 = 1; j2 < mapArr.length; j2 += 1) {
        if (mapArr[j2] - mapArr[j2 - 1] === 1) {
          item.push(mapArr[j2 - 1]);
          if (j2 === mapArr.length - 1) {
            item.push(mapArr[j2]);
            rangeArr.push(item);
          }
        } else {
          if (j2 === 1) {
            if (j2 === mapArr.length - 1) {
              item.push(mapArr[j2 - 1]);
              rangeArr.push(item);
              rangeArr.push([mapArr[j2]]);
            } else {
              rangeArr.push([mapArr[0]]);
            }
          } else if (j2 === mapArr.length - 1) {
            item.push(mapArr[j2 - 1]);
            rangeArr.push(item);
            rangeArr.push([mapArr[j2]]);
          } else {
            item.push(mapArr[j2 - 1]);
            rangeArr.push(item);
            item = [];
          }
        }
      }
    } else {
      rangeArr = [];
      rangeArr.push([mapArr[0]]);
    }
    return rangeArr;
  }
  function pasteHandlerOfPaintModel(ctx, copyRange) {
    var cfg = ctx.config;
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    if (!copyRange) return;
    var copyHasMC = copyRange.HasMC;
    var copySheetIndex = copyRange.dataSheetId;
    var c_r1 = copyRange.copyRange[0].row[0];
    var c_r2 = copyRange.copyRange[0].row[1];
    var c_c1 = copyRange.copyRange[0].column[0];
    var c_c2 = copyRange.copyRange[0].column[1];
    var copyData = _$1.cloneDeep(getdatabyselection(ctx, {
      row: [c_r1, c_r2],
      column: [c_c1, c_c2]
    }, copySheetIndex));
    if (!ctx.luckysheet_select_save) return;
    var last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
    var minh = last.row[0];
    var maxh = last.row[1];
    var minc = last.column[0];
    var maxc = last.column[1];
    var copyh = copyData.length;
    var copyc = copyData[0].length;
    if (minh === maxh && minc === maxc) {
      var has_PartMC = false;
      if (cfg.merge != null) {
        has_PartMC = hasPartMC(ctx, cfg, minh, minh + copyh - 1, minc, minc + copyc - 1);
      }
      if (has_PartMC) {
        return;
      }
      maxh = minh + copyh - 1;
      maxc = minc + copyc - 1;
    }
    var timesH = Math.ceil((maxh - minh + 1) / copyh);
    var timesC = Math.ceil((maxc - minc + 1) / copyc);
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return;
    var cellMaxLength = flowdata[0].length;
    var rowMaxLength = flowdata.length;
    var borderInfoCompute = getBorderInfoCompute(ctx, copySheetIndex);
    var c_dataVerification = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetIndex)].dataVerification) || {};
    var dataVerification = null;
    var mth = 0;
    var mtc = 0;
    var maxcellCahe = 0;
    var maxrowCache = 0;
    for (var th2 = 1; th2 <= timesH; th2 += 1) {
      for (var tc2 = 1; tc2 <= timesC; tc2 += 1) {
        mth = minh + (th2 - 1) * copyh;
        mtc = minc + (tc2 - 1) * copyc;
        maxrowCache = minh + th2 * copyh > rowMaxLength ? rowMaxLength : minh + th2 * copyh;
        if (maxrowCache > maxh + 1) {
          maxrowCache = maxh + 1;
        }
        maxcellCahe = minc + tc2 * copyc > cellMaxLength ? cellMaxLength : minc + tc2 * copyc;
        if (maxcellCahe > maxc + 1) {
          maxcellCahe = maxc + 1;
        }
        var offsetMC = {};
        var _loop = function _loop2(h3) {
          if (h3 == null) return {
            v: void 0
          };
          if (flowdata[h3] == null) return {
            v: void 0
          };
          var x2 = [];
          x2 = flowdata[h3];
          var _loop22 = function _loop23(c3) {
            if (borderInfoCompute["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)]) {
              var bd_obj = {
                rangeType: "cell",
                value: {
                  row_index: h3,
                  col_index: c3,
                  l: borderInfoCompute["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)].l,
                  r: borderInfoCompute["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)].r,
                  t: borderInfoCompute["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)].t,
                  b: borderInfoCompute["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)].b
                }
              };
              if (cfg.borderInfo == null) {
                cfg.borderInfo = [];
              }
              cfg.borderInfo.push(bd_obj);
            } else if (borderInfoCompute["".concat(h3, "_").concat(c3)]) {
              var _bd_obj = {
                rangeType: "cell",
                value: {
                  row_index: h3,
                  col_index: c3,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              if (cfg.borderInfo == null) {
                cfg.borderInfo = [];
              }
              cfg.borderInfo.push(_bd_obj);
            }
            if (c_dataVerification["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)]) {
              if (dataVerification == null) {
                dataVerification = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification);
              }
              dataVerification["".concat(h3, "_").concat(c3)] = c_dataVerification["".concat(c_r1 + h3 - mth, "_").concat(c_c1 + c3 - mtc)];
            }
            if (lodashExports.isPlainObject(x2[c3]) && x2[c3].mc) {
              if (x2[c3].mc.rs) {
                delete cfg.merge["".concat(x2[c3].mc.r, "_").concat(x2[c3].mc.c)];
              }
              delete x2[c3].mc;
            }
            var value = null;
            if (copyData[h3 - mth] != null && copyData[h3 - mth][c3 - mtc] != null) {
              value = copyData[h3 - mth][c3 - mtc];
            }
            if (lodashExports.isPlainObject(x2[c3])) {
              if (x2[c3].ct && x2[c3].ct.t === "inlineStr" && value) {
                delete value.ct;
              } else {
                var format = ["bg", "fc", "ct", "ht", "vt", "bl", "it", "cl", "un", "fs", "ff", "tb"];
                format.forEach(function(item) {
                  Reflect.deleteProperty(x2[c3], item);
                });
              }
            } else {
              x2[c3] = {
                v: x2[c3]
              };
            }
            if (value != null) {
              delete value.v;
              delete value.m;
              delete value.f;
              delete value.spl;
              if (value.ct && value.ct.t === "inlineStr") {
                delete value.ct;
              }
              x2[c3] = _$1.assign(x2[c3], _$1.cloneDeep(value));
              if (x2[c3].ct && x2[c3].ct.t === "inlineStr") {
                x2[c3].ct.s.forEach(function(item) {
                  return _$1.assign(item, value);
                });
              }
              if (copyHasMC && x2[c3].mc) {
                if (x2[c3].mc.rs != null) {
                  x2[c3].mc.r = h3;
                  if (x2[c3].mc.rs + h3 >= maxrowCache) {
                    x2[c3].mc.rs = maxrowCache - h3;
                  }
                  x2[c3].mc.c = c3;
                  if (x2[c3].mc.cs + c3 >= maxcellCahe) {
                    x2[c3].mc.cs = maxcellCahe - c3;
                  }
                  cfg.merge["".concat(x2[c3].mc.r, "_").concat(x2[c3].mc.c)] = x2[c3].mc;
                  offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)] = [x2[c3].mc.r, x2[c3].mc.c];
                } else {
                  x2[c3] = {
                    mc: {
                      r: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][0],
                      c: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][1]
                    }
                  };
                }
              }
              if (x2[c3].v != null) {
                if (value.ct != null && value.ct.fa != null) {
                  var mask = update(value.ct.fa, x2[c3].v);
                  x2[c3].m = mask;
                }
              }
            }
          };
          for (var c2 = mtc; c2 < maxcellCahe; c2 += 1) {
            _loop22(c2);
          }
          flowdata[h3] = x2;
        };
        for (var h2 = mth; h2 < maxrowCache; h2 += 1) {
          var _ret = _loop(h2);
          if (_typeof(_ret) === "object") return _ret.v;
        }
      }
    }
    var currFile = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)];
    currFile.config = cfg;
    currFile.dataVerification = dataVerification;
    var cdformat = null;
    var copyIndex = getSheetIndex(ctx, copySheetIndex);
    if (!copyIndex) return;
    var ruleArr = _$1.cloneDeep(ctx.luckysheetfile[copyIndex].luckysheet_conditionformat_save);
    if (!_$1.isNil(ruleArr) && ruleArr.length > 0) {
      var currentIndex = getSheetIndex(ctx, ctx.currentSheetId);
      cdformat = _$1.cloneDeep(ctx.luckysheetfile[currentIndex].luckysheet_conditionformat_save);
      for (var i2 = 0; i2 < ruleArr.length; i2 += 1) {
        var cdformat_cellrange = ruleArr[i2].cellrange;
        var emptyRange = [];
        for (var j2 = 0; j2 < cdformat_cellrange.length; j2 += 1) {
          var range = CFSplitRange(cdformat_cellrange[j2], {
            row: [c_r1, c_r2],
            column: [c_c1, c_c2]
          }, {
            row: [minh, maxh],
            column: [minc, maxc]
          }, "operatePart");
          if (range.length > 0) {
            emptyRange = emptyRange.concat(range);
          }
        }
        if (emptyRange.length > 0) {
          ruleArr[i2].cellrange = [{
            row: [minh, maxh],
            column: [minc, maxc]
          }];
          cdformat.push(ruleArr[i2]);
        }
      }
    }
  }
  function selectionCopyShow(range, ctx) {
    if (range == null) {
      range = ctx.luckysheet_selection_range;
    }
    range = JSON.parse(JSON.stringify(range));
  }
  function rowHasMerged(ctx, r2, c1, c2) {
    var hasMerged = false;
    var flowData = getFlowdata(ctx);
    if (_$1.isNil(flowData)) return false;
    for (var c3 = c1; c3 <= c2; c3 += 1) {
      var cell = flowData[r2][c3];
      if (!_$1.isNil(cell) && "mc" in cell) {
        hasMerged = true;
        break;
      }
    }
    return hasMerged;
  }
  function colHasMerged(ctx, c2, r1, r2) {
    var hasMerged = false;
    var flowData = getFlowdata(ctx);
    if (_$1.isNil(flowData)) return false;
    for (var r3 = r1; r3 <= r2; r3 += 1) {
      var cell = flowData[r3][c2];
      if (!_$1.isNil(ctx.config.merge) && !_$1.isNil(cell) && "mc" in cell && !_$1.isNil(cell.mc)) {
        hasMerged = true;
        break;
      }
    }
    return hasMerged;
  }
  function getRowMerge(ctx, rIndex, c1, c2) {
    var flowData = getFlowdata(ctx);
    if (_$1.isNil(flowData)) return [null, null];
    var r2 = flowData.length - 1;
    var str = null;
    if (rIndex > 0) {
      for (var r3 = rIndex; r3 >= 0; r3 -= 1) {
        for (var c3 = c1; c3 <= c2; c3 += 1) {
          var cell = flowData[r3][c3];
          if (!_$1.isNil(cell) && !_$1.isNil(cell.mc) && "mc" in cell && !_$1.isNil(ctx.config.merge)) {
            var mc2 = ctx.config.merge["".concat(cell.mc.r, "_").concat(cell.mc.c)];
            if (_$1.isNil(str) || mc2.r < str) {
              str = mc2.r;
            }
          }
        }
        if (!_$1.isNil(str) && rowHasMerged(ctx, str - 1, c1, c2) && str > 0) {
          r3 = str;
        } else {
          break;
        }
      }
    } else {
      str = 0;
    }
    var end = null;
    if (rIndex < r2) {
      for (var _r = rIndex; _r <= r2; _r += 1) {
        for (var _c = c1; _c <= c2; _c += 1) {
          var _cell = flowData[_r][_c];
          if (!_$1.isNil(_cell) && !_$1.isNil(_cell.mc) && "mc" in _cell && !_$1.isNil(ctx.config.merge)) {
            var _mc = ctx.config.merge["".concat(_cell.mc.r, "_").concat(_cell.mc.c)];
            if (_$1.isNil(end) || _mc.r + _mc.rs - 1 > end) {
              end = _mc.r + _mc.rs - 1;
            }
          }
        }
        if (!_$1.isNil(end) && rowHasMerged(ctx, end + 1, c1, c2) && end < r2) {
          _r = end;
        } else {
          break;
        }
      }
    } else {
      end = r2;
    }
    return [str, end];
  }
  function getColMerge(ctx, cIndex, r1, r2) {
    var flowData = getFlowdata(ctx);
    if (_$1.isNil(flowData)) {
      return [null, null];
    }
    var c2 = flowData[0].length - 1;
    var str = null;
    if (cIndex > 0) {
      for (var c3 = cIndex; c3 >= 0; c3 -= 1) {
        for (var r3 = r1; r3 <= r2; r3 += 1) {
          var cell = flowData[r3][c3];
          if (!_$1.isNil(ctx.config.merge) && !_$1.isNil(cell) && "mc" in cell && !_$1.isNil(cell.mc)) {
            var mc2 = ctx.config.merge["".concat(cell.mc.r, "_").concat(cell.mc.c)];
            if (_$1.isNil(str) || mc2.c < str) {
              str = mc2.c;
            }
          }
        }
        if (!_$1.isNil(str) && colHasMerged(ctx, str - 1, r1, r2) && str > 0) {
          c3 = str;
        } else {
          break;
        }
      }
    } else {
      str = 0;
    }
    var end = null;
    if (cIndex < c2) {
      for (var _c2 = cIndex; _c2 <= c2; _c2 += 1) {
        for (var _r2 = r1; _r2 <= r2; _r2 += 1) {
          var _cell2 = flowData[_r2][_c2];
          if (!_$1.isNil(ctx.config.merge) && !_$1.isNil(_cell2) && "mc" in _cell2 && !_$1.isNil(_cell2.mc)) {
            var _mc2 = ctx.config.merge["".concat(_cell2.mc.r, "_").concat(_cell2.mc.c)];
            if (_$1.isNil(end) || _mc2.c + _mc2.cs - 1 > end) {
              end = _mc2.c + _mc2.cs - 1;
            }
          }
        }
        if (!_$1.isNil(end) && colHasMerged(ctx, end + 1, r1, r2) && end < c2) {
          _c2 = end;
        } else {
          break;
        }
      }
    } else {
      end = c2;
    }
    return [str, end];
  }
  function moveHighlightCell(ctx, postion, index2, type) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var datarowlen = flowdata.length;
    var datacolumnlen = flowdata[0].length;
    var row_index;
    var row_index_ed;
    var col_index;
    var col_index_ed;
    {
      var _ctx$luckysheet_selec;
      var last = (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec[ctx.luckysheet_select_save.length - 1];
      if (!last) {
        console.error("moveHighlightCell: no selection found");
        return;
      }
      var curR;
      if (_$1.isNil(last.row_focus)) {
        var _last$row = _slicedToArray$1(last.row, 1);
        curR = _last$row[0];
      } else {
        curR = last.row_focus;
      }
      var curC;
      if (_$1.isNil(last.column_focus)) {
        var _last$column = _slicedToArray$1(last.column, 1);
        curC = _last$column[0];
      } else {
        curC = last.column_focus;
      }
      var margeset = mergeBorder(ctx, flowdata, curR, curC);
      if (margeset) {
        var str_r = margeset.row[2];
        var end_r = margeset.row[3];
        var str_c = margeset.column[2];
        var end_c = margeset.column[3];
        if (index2 > 0) {
          if (postion === "down") {
            curR = end_r;
            curC = str_c;
          } else if (postion === "right") {
            curR = str_r;
            curC = end_c;
          }
        } else {
          curR = str_r;
          curC = str_c;
        }
      }
      if (_$1.isNil(curR) || _$1.isNil(curC)) {
        console.error("moveHighlightCell: curR or curC is nil");
        return;
      }
      var moveX = _$1.isNil(last.moveXY) ? curR : last.moveXY.x;
      var moveY = _$1.isNil(last.moveXY) ? curC : last.moveXY.y;
      if (postion === "down") {
        curR += index2;
        moveX = curR;
      } else if (postion === "right") {
        curC += index2;
        moveY = curC;
      }
      if (curR >= datarowlen) {
        curR = datarowlen - 1;
        moveX = curR;
      }
      if (curR < 0) {
        curR = 0;
        moveX = curR;
      }
      if (curC >= datacolumnlen) {
        curC = datacolumnlen - 1;
        moveY = curC;
      }
      if (curC < 0) {
        curC = 0;
        moveY = curC;
      }
      var margeset2 = mergeBorder(ctx, flowdata, curR, curC);
      if (margeset2) {
        var _margeset2$row = _slicedToArray$1(margeset2.row, 4);
        _margeset2$row[0];
        _margeset2$row[1];
        row_index = _margeset2$row[2];
        row_index_ed = _margeset2$row[3];
        var _margeset2$column = _slicedToArray$1(margeset2.column, 4);
        _margeset2$column[0];
        _margeset2$column[1];
        col_index = _margeset2$column[2];
        col_index_ed = _margeset2$column[3];
      } else {
        ctx.visibledatarow[moveX];
        moveX - 1 === -1 ? 0 : ctx.visibledatarow[moveX - 1];
        ctx.visibledatacolumn[moveY];
        moveY - 1 === -1 ? 0 : ctx.visibledatacolumn[moveY - 1];
        row_index = curR;
        row_index_ed = curR;
        col_index = curC;
        col_index_ed = curC;
      }
      if (_$1.isNil(row_index) || _$1.isNil(row_index_ed) || _$1.isNil(col_index) || _$1.isNil(col_index_ed)) {
        console.error("moveHighlightCell: row_index or row_index_ed or col_index or col_index_ed is nil");
        return;
      }
      last.row = [row_index, row_index_ed];
      last.column = [col_index, col_index_ed];
      last.row_focus = row_index;
      last.column_focus = col_index;
      last.moveXY = {
        x: moveX,
        y: moveY
      };
      normalizeSelection(ctx, ctx.luckysheet_select_save);
      scrollToHighlightCell(ctx, row_index, col_index);
    }
  }
  function moveHighlightRange(ctx, postion, index2, type) {
    var row;
    var row_pre;
    var col;
    var col_pre;
    var flowData = getFlowdata(ctx);
    if (_$1.isNil(flowData)) return;
    if (_$1.isNil(ctx.luckysheet_select_save)) return;
    {
      var last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
      var curR = last.row[0];
      var endR = last.row[1];
      var curC = last.column[0];
      var endC = last.column[1];
      var rf2 = last.row_focus;
      var cf2 = last.column_focus;
      if (_$1.isNil(rf2) || _$1.isNil(cf2)) return;
      var datarowlen = flowData.length;
      var datacolumnlen = flowData[0].length;
      if (postion === "down") {
        if (rowHasMerged(ctx, rf2, curC, endC)) {
          var rfMerge = getRowMerge(ctx, rf2, curC, endC);
          var rf_str = rfMerge[0];
          var rf_end = rfMerge[1];
          if (!_$1.isNil(rf_str) && rf_str > curR && rf_end === endR) {
            if (index2 > 0 && rowHasMerged(ctx, curR, curC, endC)) {
              var v2 = getRowMerge(ctx, curR, curC, endC)[1];
              if (!_$1.isNil(v2)) {
                curR = v2;
              }
            }
            curR += index2;
          } else if (!_$1.isNil(rf_end) && rf_end < endR && rf_str === curR) {
            if (index2 < 0 && rowHasMerged(ctx, endR, curC, endC)) {
              var _v = getRowMerge(ctx, curR, curC, endC)[0];
              if (!_$1.isNil(_v)) {
                endR = _v;
              }
            }
            endR += index2;
          } else {
            if (index2 > 0) {
              endR += index2;
            } else {
              curR += index2;
            }
          }
        } else {
          if (rf2 > curR && rf2 === endR) {
            if (index2 > 0 && rowHasMerged(ctx, curR, curC, endC)) {
              var _v2 = getRowMerge(ctx, curR, curC, endC)[1];
              if (!_$1.isNil(_v2)) {
                curR = _v2;
              }
            }
            curR += index2;
          } else if (rf2 < endR && rf2 === curR) {
            if (index2 < 0 && rowHasMerged(ctx, endR, curC, endC)) {
              var _v3 = getRowMerge(ctx, endR, curC, endC)[0];
              if (!_$1.isNil(_v3)) {
                endR = _v3;
              }
            }
            endR += index2;
          } else if (rf2 === curR && rf2 === endR) {
            if (index2 > 0) {
              endR += index2;
            } else {
              curR += index2;
            }
          }
        }
        if (endR >= datarowlen) {
          endR = datarowlen - 1;
        }
        if (endR < 0) {
          endR = 0;
        }
        if (curR >= datarowlen) {
          curR = datarowlen - 1;
        }
        if (curR < 0) {
          curR = 0;
        }
      } else {
        if (colHasMerged(ctx, cf2, curR, endR)) {
          var cfMerge = getColMerge(ctx, cf2, curR, endR);
          var cf_str = cfMerge[0];
          var cf_end = cfMerge[1];
          if (!_$1.isNil(cf_str) && cf_str > curC && cf_end === endC) {
            if (index2 > 0 && colHasMerged(ctx, curC, curR, endR)) {
              var _v4 = getColMerge(ctx, curC, curR, endR)[1];
              if (!_$1.isNil(_v4)) {
                curC = _v4;
              }
              curC += index2;
            }
            curC += index2;
          } else if (!_$1.isNil(cf_end) && cf_end < endC && cf_str === curC) {
            if (index2 < 0 && colHasMerged(ctx, endC, curR, endR)) {
              var _v5 = getColMerge(ctx, endC, curR, endR)[0];
              if (!_$1.isNil(_v5)) {
                endC = _v5;
              }
            }
            endC += index2;
          } else {
            if (index2 > 0) {
              endC += index2;
            } else {
              curC += index2;
            }
          }
        } else {
          if (cf2 > curC && cf2 === endC) {
            if (index2 > 0 && colHasMerged(ctx, curC, curR, endR)) {
              var _v6 = getColMerge(ctx, curC, curR, endR)[1];
              if (!_$1.isNil(_v6)) {
                curC = _v6;
              }
              curC += index2;
            }
            curC += index2;
          } else if (cf2 < endC && cf2 === curC) {
            if (index2 < 0 && colHasMerged(ctx, endC, curR, endR)) {
              var _v7 = getColMerge(ctx, endC, curR, endR)[0];
              if (!_$1.isNil(_v7)) {
                endC = _v7;
              }
            }
            endC += index2;
          } else if (cf2 === curC && cf2 === endC) {
            if (index2 > 0) {
              endC += index2;
            } else {
              curC += index2;
            }
          }
        }
        if (endC >= datacolumnlen) {
          endC = datacolumnlen - 1;
        }
        if (endC < 0) {
          endC = 0;
        }
        if (curC >= datacolumnlen) {
          curC = datacolumnlen - 1;
        }
        if (curC < 0) {
          curC = 0;
        }
      }
      var rowseleted = [curR, endR];
      var columnseleted = [curC, endC];
      row = ctx.visibledatarow[endR];
      row_pre = curR - 1 === -1 ? 0 : ctx.visibledatarow[curR - 1];
      col = ctx.visibledatacolumn[endC];
      col_pre = curC - 1 === -1 ? 0 : ctx.visibledatacolumn[curC - 1];
      var changeparam = mergeMoveMain(ctx, columnseleted, rowseleted, last, row_pre, row - row_pre - 1, col_pre, col - col_pre - 1);
      if (!_$1.isNil(changeparam)) {
        var _changeparam = _slicedToArray$1(changeparam, 2);
        columnseleted = _changeparam[0];
        rowseleted = _changeparam[1];
      }
      last.row = rowseleted;
      last.column = columnseleted;
      normalizeSelection(ctx, ctx.luckysheet_select_save);
      if (index2 === -1) {
        scrollToHighlightCell(ctx, last.row[0], last.column[0]);
      } else {
        scrollToHighlightCell(ctx, last.row[1], last.column[1]);
      }
    }
  }
  function getHtmlBorderStyle(type, color) {
    var style = "";
    var borderType = {
      "0": "none",
      "1": "Thin",
      "2": "Hair",
      "3": "Dotted",
      "4": "Dashed",
      "5": "DashDot",
      "6": "DashDotDot",
      "7": "Double",
      "8": "Medium",
      "9": "MediumDashed",
      "10": "MediumDashDot",
      "11": "MediumDashDotDot",
      "12": "SlantedDashDot",
      "13": "Thick"
    };
    type = borderType[type.toString()];
    if (type.indexOf("Medium") > -1) {
      style += "1pt ";
    } else if (type === "Thick") {
      style += "1.5pt ";
    } else {
      style += "0.5pt ";
    }
    if (type === "Hair") {
      style += "double ";
    } else if (type.indexOf("DashDotDot") > -1) {
      style += "dotted ";
    } else if (type.indexOf("DashDot") > -1) {
      style += "dashed ";
    } else if (type.indexOf("Dotted") > -1) {
      style += "dotted ";
    } else if (type.indexOf("Dashed") > -1) {
      style += "dashed ";
    } else {
      style += "solid ";
    }
    return "".concat(style + color, ";");
  }
  function rangeValueToHtml(ctx, sheetId, ranges) {
    var _sheet$config5;
    var idx = getSheetIndex(ctx, sheetId);
    if (idx == null) return "";
    var sheet = ctx.luckysheetfile[idx];
    var rowIndexArr = [];
    var colIndexArr = [];
    for (var s2 = 0; s2 < ((_ranges$length = ranges === null || ranges === void 0 ? void 0 : ranges.length) !== null && _ranges$length !== void 0 ? _ranges$length : 0); s2 += 1) {
      var _ranges$length;
      var range = ranges[s2];
      var r1 = range.row[0];
      var r2 = range.row[1];
      var c1 = range.column[0];
      var c2 = range.column[1];
      for (var copyR = r1; copyR <= r2; copyR += 1) {
        var _sheet$config, _sheet$config2;
        if (!_$1.isNil((_sheet$config = sheet.config) === null || _sheet$config === void 0 ? void 0 : _sheet$config.rowhidden) && !_$1.isNil((_sheet$config2 = sheet.config) === null || _sheet$config2 === void 0 ? void 0 : _sheet$config2.rowhidden[copyR])) {
          continue;
        }
        if (!rowIndexArr.includes(copyR)) {
          rowIndexArr.push(copyR);
        }
        for (var copyC = c1; copyC <= c2; copyC += 1) {
          var _sheet$config3, _sheet$config4;
          if (!_$1.isNil((_sheet$config3 = sheet.config) === null || _sheet$config3 === void 0 ? void 0 : _sheet$config3.colhidden) && !_$1.isNil((_sheet$config4 = sheet.config) === null || _sheet$config4 === void 0 ? void 0 : _sheet$config4.colhidden[copyC])) {
            continue;
          }
          if (!colIndexArr.includes(copyC)) {
            colIndexArr.push(copyC);
          }
        }
      }
    }
    var borderInfoCompute;
    if (((_sheet$config5 = sheet.config) === null || _sheet$config5 === void 0 ? void 0 : _sheet$config5.borderInfo) && sheet.config.borderInfo.length > 0) {
      borderInfoCompute = getBorderInfoCompute(ctx, sheetId);
    }
    var cpdata = "";
    var d2 = sheet.data;
    if (!d2) return null;
    var colgroup = "";
    for (var i2 = 0; i2 < rowIndexArr.length; i2 += 1) {
      var _sheet$config6, _sheet$config7;
      var r3 = rowIndexArr[i2];
      if (!_$1.isNil((_sheet$config6 = sheet.config) === null || _sheet$config6 === void 0 ? void 0 : _sheet$config6.rowhidden) && !_$1.isNil((_sheet$config7 = sheet.config) === null || _sheet$config7 === void 0 ? void 0 : _sheet$config7.rowhidden[r3])) {
        continue;
      }
      cpdata += "<tr>";
      for (var j2 = 0; j2 < colIndexArr.length; j2 += 1) {
        var _sheet$config8, _sheet$config9, _d$r;
        var c3 = colIndexArr[j2];
        if (!_$1.isNil((_sheet$config8 = sheet.config) === null || _sheet$config8 === void 0 ? void 0 : _sheet$config8.colhidden) && !_$1.isNil((_sheet$config9 = sheet.config) === null || _sheet$config9 === void 0 ? void 0 : _sheet$config9.colhidden[c3])) {
          continue;
        }
        var column = '<td ${span} style="${style}">';
        var cell = (_d$r = d2[r3]) === null || _d$r === void 0 ? void 0 : _d$r[c3];
        if (cell != null) {
          var style = "";
          var span = "";
          if (r3 === rowIndexArr[0]) {
            if (_$1.isNil(sheet.config) || _$1.isNil(sheet.config.columnlen) || _$1.isNil(sheet.config.columnlen[c3.toString()])) {
              colgroup += '<colgroup width="72px"></colgroup>';
            } else {
              colgroup += '<colgroup width="'.concat(sheet.config.columnlen[c3.toString()], 'px"></colgroup>');
            }
          }
          if (c3 === colIndexArr[0]) {
            if (_$1.isNil(sheet.config) || _$1.isNil(sheet.config.rowlen) || _$1.isNil(sheet.config.rowlen[r3.toString()])) {
              style += "height:19px;";
            } else {
              style += "height:".concat(sheet.config.rowlen[r3.toString()], "px;");
            }
          }
          var reg = /^(w|W)((0?)|(0\.0+))$/;
          var c_value = void 0;
          if (!_$1.isNil(cell.ct) && !_$1.isNil(cell.ct.fa) && cell.ct.fa.match(reg)) {
            c_value = getCellValue(r3, c3, d2);
          } else {
            c_value = getCellValue(r3, c3, d2, "m");
          }
          var styleObj = getStyleByCell(ctx, d2, r3, c3);
          style += _$1.map(styleObj, function(v2, key) {
            return "".concat(_$1.kebabCase(key), ":").concat(_$1.isNumber(v2) ? "".concat(v2, "px") : v2, ";");
          }).join("");
          if (cell.mc) {
            if ("rs" in cell.mc) {
              span = 'rowspan="'.concat(cell.mc.rs, '" colspan="').concat(cell.mc.cs, '"');
              if (borderInfoCompute && borderInfoCompute["".concat(r3, "_").concat(c3)]) {
                (function() {
                  var bl_obj = {
                    color: {},
                    style: {}
                  };
                  var br_obj = {
                    color: {},
                    style: {}
                  };
                  var bt_obj = {
                    color: {},
                    style: {}
                  };
                  var bb_obj = {
                    color: {},
                    style: {}
                  };
                  for (var bd_r = r3; bd_r < r3 + cell.mc.rs; bd_r += 1) {
                    for (var bd_c = c3; bd_c < c3 + cell.mc.cs; bd_c += 1) {
                      if (bd_r === r3 && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t) {
                        var linetype2 = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t.style;
                        var bcolor2 = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t.color;
                        if (_$1.isNil(bt_obj.style[linetype2])) {
                          bt_obj.style[linetype2] = 1;
                        } else {
                          bt_obj.style[linetype2] += 1;
                        }
                        if (_$1.isNil(bt_obj.color[bcolor2])) {
                          bt_obj.color[bcolor2] = 1;
                        } else {
                          bt_obj.color[bcolor2] += 1;
                        }
                      }
                      if (bd_r === r3 + cell.mc.rs - 1 && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b) {
                        var _linetype = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b.style;
                        var _bcolor = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b.color;
                        if (_$1.isNil(bb_obj.style[_linetype])) {
                          bb_obj.style[_linetype] = 1;
                        } else {
                          bb_obj.style[_linetype] += 1;
                        }
                        if (_$1.isNil(bb_obj.color[_bcolor])) {
                          bb_obj.color[_bcolor] = 1;
                        } else {
                          bb_obj.color[_bcolor] += 1;
                        }
                      }
                      if (bd_c === c3 && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l) {
                        var _linetype2 = borderInfoCompute["".concat(r3, "_").concat(c3)].l.style;
                        var _bcolor2 = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l.color;
                        if (_$1.isNil(bl_obj.style[_linetype2])) {
                          bl_obj.style[_linetype2] = 1;
                        } else {
                          bl_obj.style[_linetype2] += 1;
                        }
                        if (_$1.isNil(bl_obj.color[_bcolor2])) {
                          bl_obj.color[_bcolor2] = 1;
                        } else {
                          bl_obj.color[_bcolor2] += 1;
                        }
                      }
                      if (bd_c === c3 + cell.mc.cs - 1 && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)] && borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r) {
                        var _linetype3 = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r.style;
                        var _bcolor3 = borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r.color;
                        if (_$1.isNil(br_obj.style[_linetype3])) {
                          br_obj.style[_linetype3] = 1;
                        } else {
                          br_obj.style[_linetype3] += 1;
                        }
                        if (_$1.isNil(br_obj.color[_bcolor3])) {
                          br_obj.color[_bcolor3] = 1;
                        } else {
                          br_obj.color[_bcolor3] += 1;
                        }
                      }
                    }
                  }
                  var rowlen = cell.mc.rs;
                  var collen = cell.mc.cs;
                  if (JSON.stringify(bl_obj).length > 23) {
                    var bl_color = null;
                    var bl_style = null;
                    Object.keys(bl_obj.color).forEach(function(x2) {
                      if (bl_obj.color[x2] >= rowlen / 2) {
                        bl_color = x2;
                      }
                    });
                    Object.keys(bl_obj.style).forEach(function(x2) {
                      if (bl_obj.style[x2] >= rowlen / 2) {
                        bl_style = x2;
                      }
                    });
                    if (!_$1.isNil(bl_color) && !_$1.isNil(bl_style)) {
                      style += "border-left:".concat(getHtmlBorderStyle(bl_style, bl_color));
                    }
                  }
                  if (JSON.stringify(br_obj).length > 23) {
                    var br_color = null;
                    var br_style = null;
                    Object.keys(br_obj.color).forEach(function(x2) {
                      if (br_obj.color[x2] >= rowlen / 2) {
                        br_color = x2;
                      }
                    });
                    Object.keys(br_obj.style).forEach(function(x2) {
                      if (br_obj.style[x2] >= rowlen / 2) {
                        br_style = x2;
                      }
                    });
                    if (!_$1.isNil(br_color) && !_$1.isNil(br_style)) {
                      style += "border-right:".concat(getHtmlBorderStyle(br_style, br_color));
                    }
                  }
                  if (JSON.stringify(bt_obj).length > 23) {
                    var bt_color = null;
                    var bt_style = null;
                    Object.keys(bt_obj.color).forEach(function(x2) {
                      if (bt_obj.color[x2] >= collen / 2) {
                        bt_color = x2;
                      }
                    });
                    Object.keys(bt_obj.style).forEach(function(x2) {
                      if (bt_obj.style[x2] >= collen / 2) {
                        bt_style = x2;
                      }
                    });
                    if (!_$1.isNil(bt_color) && !_$1.isNil(bt_style)) {
                      style += "border-top:".concat(getHtmlBorderStyle(bt_style, bt_color));
                    }
                  }
                  if (JSON.stringify(bb_obj).length > 23) {
                    var bb_color = null;
                    var bb_style = null;
                    Object.keys(bb_obj.color).forEach(function(x2) {
                      if (bb_obj.color[x2] >= collen / 2) {
                        bb_color = x2;
                      }
                    });
                    Object.keys(bb_obj.style).forEach(function(x2) {
                      if (bb_obj.style[x2] >= collen / 2) {
                        bb_style = x2;
                      }
                    });
                    if (!_$1.isNil(bb_color) && !_$1.isNil(bb_style)) {
                      style += "border-bottom:".concat(getHtmlBorderStyle(bb_style, bb_color));
                    }
                  }
                })();
              }
            } else {
              continue;
            }
          } else {
            if (borderInfoCompute && borderInfoCompute["".concat(r3, "_").concat(c3)]) {
              if (borderInfoCompute["".concat(r3, "_").concat(c3)].l) {
                var linetype = borderInfoCompute["".concat(r3, "_").concat(c3)].l.style;
                var bcolor = borderInfoCompute["".concat(r3, "_").concat(c3)].l.color;
                style += "border-left:".concat(getHtmlBorderStyle(linetype, bcolor));
              }
              if (borderInfoCompute["".concat(r3, "_").concat(c3)].r) {
                var _linetype4 = borderInfoCompute["".concat(r3, "_").concat(c3)].r.style;
                var _bcolor4 = borderInfoCompute["".concat(r3, "_").concat(c3)].r.color;
                style += "border-right:".concat(getHtmlBorderStyle(_linetype4, _bcolor4));
              }
              if (borderInfoCompute["".concat(r3, "_").concat(c3)].b) {
                var _linetype5 = borderInfoCompute["".concat(r3, "_").concat(c3)].b.style;
                var _bcolor5 = borderInfoCompute["".concat(r3, "_").concat(c3)].b.color;
                style += "border-bottom:".concat(getHtmlBorderStyle(_linetype5, _bcolor5));
              }
              if (borderInfoCompute["".concat(r3, "_").concat(c3)].t) {
                var _linetype6 = borderInfoCompute["".concat(r3, "_").concat(c3)].t.style;
                var _bcolor6 = borderInfoCompute["".concat(r3, "_").concat(c3)].t.color;
                style += "border-top:".concat(getHtmlBorderStyle(_linetype6, _bcolor6));
              }
            }
          }
          column = replaceHtml(column, {
            style,
            span
          });
          if (_$1.isNil(c_value)) {
            c_value = getCellValue(r3, c3, d2);
          }
          if (_$1.isNil(c_value)) {
            c_value = "";
          }
          column += escapeHTMLTag(c_value);
        } else {
          var _style = "";
          if (borderInfoCompute && borderInfoCompute["".concat(r3, "_").concat(c3)]) {
            if (borderInfoCompute["".concat(r3, "_").concat(c3)].l) {
              var _linetype7 = borderInfoCompute["".concat(r3, "_").concat(c3)].l.style;
              var _bcolor7 = borderInfoCompute["".concat(r3, "_").concat(c3)].l.color;
              _style += "border-left:".concat(getHtmlBorderStyle(_linetype7, _bcolor7));
            }
            if (borderInfoCompute["".concat(r3, "_").concat(c3)].r) {
              var _linetype8 = borderInfoCompute["".concat(r3, "_").concat(c3)].r.style;
              var _bcolor8 = borderInfoCompute["".concat(r3, "_").concat(c3)].r.color;
              _style += "border-right:".concat(getHtmlBorderStyle(_linetype8, _bcolor8));
            }
            if (borderInfoCompute["".concat(r3, "_").concat(c3)].b) {
              var _linetype9 = borderInfoCompute["".concat(r3, "_").concat(c3)].b.style;
              var _bcolor9 = borderInfoCompute["".concat(r3, "_").concat(c3)].b.color;
              _style += "border-bottom:".concat(getHtmlBorderStyle(_linetype9, _bcolor9));
            }
            if (borderInfoCompute["".concat(r3, "_").concat(c3)].t) {
              var _linetype10 = borderInfoCompute["".concat(r3, "_").concat(c3)].t.style;
              var _bcolor10 = borderInfoCompute["".concat(r3, "_").concat(c3)].t.color;
              _style += "border-top:".concat(getHtmlBorderStyle(_linetype10, _bcolor10));
            }
          }
          column += "";
          if (r3 === rowIndexArr[0]) {
            if (_$1.isNil(sheet.config) || _$1.isNil(sheet.config.columnlen) || _$1.isNil(sheet.config.columnlen[c3.toString()])) {
              colgroup += '<colgroup width="72px"></colgroup>';
            } else {
              colgroup += '<colgroup width="'.concat(sheet.config.columnlen[c3.toString()], 'px"></colgroup>');
            }
          }
          if (c3 === colIndexArr[0]) {
            if (_$1.isNil(sheet.config) || _$1.isNil(sheet.config.rowlen) || _$1.isNil(sheet.config.rowlen[r3.toString()])) {
              _style += "height:19px;";
            } else {
              _style += "height:".concat(sheet.config.rowlen[r3.toString()], "px;");
            }
          }
          column = replaceHtml(column, {
            style: _style,
            span: ""
          });
          column += "";
        }
        column += "</td>";
        cpdata += column;
      }
      cpdata += "</tr>";
    }
    return '<table data-type="fortune-copy-action-table">'.concat(colgroup).concat(cpdata, "</table>");
  }
  function copy(ctx) {
    var flowdata = getFlowdata(ctx);
    ctx.luckysheet_selection_range = [];
    var copyRange = [];
    var RowlChange = false;
    var HasMC = false;
    for (var s2 = 0; s2 < ((_ctx$luckysheet_selec2 = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3.length) !== null && _ctx$luckysheet_selec2 !== void 0 ? _ctx$luckysheet_selec2 : 0); s2 += 1) {
      var _ctx$luckysheet_selec2, _ctx$luckysheet_selec3;
      var range = ctx.luckysheet_select_save[s2];
      var r1 = range.row[0];
      var r2 = range.row[1];
      var c1 = range.column[0];
      var c2 = range.column[1];
      for (var copyR = r1; copyR <= r2; copyR += 1) {
        if (!_$1.isNil(ctx.config.rowhidden) && !_$1.isNil(ctx.config.rowhidden[copyR])) {
          continue;
        }
        if (!_$1.isNil(ctx.config.rowlen) && copyR in ctx.config.rowlen) {
          RowlChange = true;
        }
        for (var copyC = c1; copyC <= c2; copyC += 1) {
          var _flowdata$copyR, _cell$mc;
          if (!_$1.isNil(ctx.config.colhidden) && !_$1.isNil(ctx.config.colhidden[copyC])) {
            continue;
          }
          var cell = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$copyR = flowdata[copyR]) === null || _flowdata$copyR === void 0 ? void 0 : _flowdata$copyR[copyC];
          if (!_$1.isNil(cell === null || cell === void 0 ? void 0 : (_cell$mc = cell.mc) === null || _cell$mc === void 0 ? void 0 : _cell$mc.rs)) {
            HasMC = true;
          }
        }
      }
      ctx.luckysheet_selection_range.push({
        row: range.row,
        column: range.column
      });
      copyRange.push({
        row: range.row,
        column: range.column
      });
    }
    ctx.luckysheet_copy_save = {
      dataSheetId: ctx.currentSheetId,
      copyRange,
      RowlChange,
      HasMC
    };
    var cpdata = rangeValueToHtml(ctx, ctx.currentSheetId, ctx.luckysheet_select_save);
    if (cpdata) {
      ctx.iscopyself = true;
      clipboard.writeHtml(cpdata);
    }
  }
  function deleteSelectedCellText(ctx) {
    var allowEdit = isAllowEdit(ctx);
    if (allowEdit === false) {
      return "allowEdit";
    }
    var selection = ctx.luckysheet_select_save;
    if (selection && !_$1.isEmpty(selection)) {
      var d2 = getFlowdata(ctx);
      if (!d2) return "dataNullError";
      var has_PartMC = false;
      for (var s2 = 0; s2 < selection.length; s2 += 1) {
        var r1 = selection[s2].row[0];
        var r2 = selection[s2].row[1];
        var c1 = selection[s2].column[0];
        var c2 = selection[s2].column[1];
        if (hasPartMC(ctx, ctx.config, r1, r2, c1, c2)) {
          has_PartMC = true;
          break;
        }
      }
      if (has_PartMC) {
        return "partMC";
      }
      var hyperlinkMap = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].hyperlink;
      for (var _s = 0; _s < selection.length; _s += 1) {
        var _r3 = selection[_s].row[0];
        var _r4 = selection[_s].row[1];
        var _c3 = selection[_s].column[0];
        var _c4 = selection[_s].column[1];
        for (var r3 = _r3; r3 <= _r4; r3 += 1) {
          for (var c3 = _c3; c3 <= _c4; c3 += 1) {
            if (_$1.isPlainObject(d2[r3][c3])) {
              var cell = d2[r3][c3];
              delete cell.m;
              delete cell.v;
              if (cell.f != null) {
                delete cell.f;
                delFunctionGroup(ctx, r3, c3, ctx.currentSheetId);
                delete cell.spl;
              }
              if (cell.ct != null && cell.ct.t === "inlineStr") {
                delete cell.ct;
              }
            } else {
              d2[r3][c3] = null;
            }
            if (hyperlinkMap && hyperlinkMap["".concat(r3, "_").concat(c3)]) {
              delete hyperlinkMap["".concat(r3, "_").concat(c3)];
            }
          }
        }
      }
    }
    return "success";
  }
  function selectIsOverlap(ctx, range) {
    if (range == null) {
      range = ctx.luckysheet_select_save;
    }
    range = _$1.cloneDeep(range);
    var overlap = false;
    var map = {};
    for (var s2 = 0; s2 < range.length; s2 += 1) {
      var str_r = range[s2].row[0];
      var end_r = range[s2].row[1];
      var str_c = range[s2].column[0];
      var end_c = range[s2].column[1];
      for (var r2 = str_r; r2 <= end_r; r2 += 1) {
        for (var c2 = str_c; c2 <= end_c; c2 += 1) {
          if ("".concat(r2, "_").concat(c2) in map) {
            overlap = true;
            break;
          } else {
            map["".concat(r2, "_").concat(c2)] = 0;
          }
        }
      }
    }
    return overlap;
  }
  function selectAll(ctx) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    ctx.luckysheet_select_status = false;
    ctx.luckysheet_select_save = [{
      row: [0, flowdata.length - 1],
      column: [0, flowdata[0].length - 1],
      row_focus: 0,
      column_focus: 0,
      row_select: true,
      column_select: true
    }];
    normalizeSelection(ctx, ctx.luckysheet_select_save);
  }
  function fixRowStyleOverflowInFreeze(ctx, r1, r2, freeze2) {
    var _freeze$horizontal;
    if (!freeze2) return {};
    var ret = {};
    var scrollTop = ctx.scrollTop;
    var freezenhorizontaldata = (_freeze$horizontal = freeze2.horizontal) === null || _freeze$horizontal === void 0 ? void 0 : _freeze$horizontal.freezenhorizontaldata;
    var rangeshow = true;
    if (freezenhorizontaldata != null) {
      var freezenTop = freezenhorizontaldata[0];
      var freezen_rowindex = freezenhorizontaldata[1];
      var offTop = scrollTop - freezenhorizontaldata[2];
      var row = ctx.visibledatarow[r2];
      var row_pre = r1 - 1 === -1 ? 0 : ctx.visibledatarow[r1 - 1];
      var top_move = row_pre;
      var height_move = row - row_pre - 1;
      if (r1 >= freezen_rowindex) {
        if (top_move + height_move < freezenTop + offTop) {
          rangeshow = false;
        } else if (top_move < freezenTop + offTop) {
          ret.top = freezenTop + offTop;
          ret.height = height_move - (freezenTop + offTop - top_move);
        } else ;
      } else if (r2 >= freezen_rowindex) {
        if (top_move + height_move < freezenTop + offTop) {
          ret.top = top_move + offTop;
          ret.height = freezenTop - top_move;
        } else {
          ret.top = top_move + offTop;
          ret.height = height_move - offTop;
        }
      } else {
        ret.top = top_move + offTop;
      }
    }
    if (!rangeshow) {
      ret.display = "none";
    }
    return ret;
  }
  function fixColumnStyleOverflowInFreeze(ctx, c1, c2, freeze2) {
    var _freeze$vertical;
    if (!freeze2) return {};
    var ret = {};
    var scrollLeft = ctx.scrollLeft;
    var freezenverticaldata = (_freeze$vertical = freeze2.vertical) === null || _freeze$vertical === void 0 ? void 0 : _freeze$vertical.freezenverticaldata;
    var rangeshow = true;
    if (freezenverticaldata != null) {
      var freezenLeft = freezenverticaldata[0];
      var freezen_colindex = freezenverticaldata[1];
      var offLeft = scrollLeft - freezenverticaldata[2];
      var col = ctx.visibledatacolumn[c2];
      var col_pre = c1 - 1 === -1 ? 0 : ctx.visibledatacolumn[c1 - 1];
      var left_move = col_pre;
      var width_move = col - col_pre - 1;
      if (c1 >= freezen_colindex) {
        if (left_move + width_move < freezenLeft + offLeft) {
          rangeshow = false;
        } else if (left_move < freezenLeft + offLeft) {
          ret.left = freezenLeft + offLeft;
          ret.width = width_move - (freezenLeft + offLeft - left_move);
        } else ;
      } else if (c2 >= freezen_colindex) {
        if (left_move + width_move < freezenLeft + offLeft) {
          ret.left = left_move + offLeft;
          ret.width = freezenLeft - left_move;
        } else {
          ret.left = left_move + offLeft;
          ret.width = width_move - offLeft;
        }
      } else {
        ret.left = left_move + offLeft;
      }
    }
    if (!rangeshow) {
      ret.display = "none";
    }
    return ret;
  }
  function calcSelectionInfo(ctx, lang) {
    var selection = ctx.luckysheet_select_save;
    var numberC = 0;
    var count = 0;
    var sum = 0;
    var max = -Infinity;
    var min = Infinity;
    for (var s2 = 0; s2 < selection.length; s2 += 1) {
      var data = getDataBySelectionNoCopy(ctx, selection[s2]);
      for (var r2 = 0; r2 < data.length; r2 += 1) {
        for (var c2 = 0; c2 < data[0].length; c2 += 1) {
          var _data$r$c;
          if (r2 >= data.length || c2 >= data[0].length) break;
          var value = (_data$r$c = data[r2][c2]) === null || _data$r$c === void 0 ? void 0 : _data$r$c.m;
          if (parseFloat(value).toString() !== "NaN") {
            var valueNumber = parseFloat(value);
            count += 1;
            sum += valueNumber;
            max = Math.max(valueNumber, max);
            min = Math.min(valueNumber, min);
            numberC += 1;
          } else if (value != null) {
            count += 1;
          }
        }
      }
    }
    var formatString = lang && !["zh", "zh_tw"].includes(lang) ? "0.00" : "w0.00";
    var average = SSF.format(formatString, sum / numberC);
    sum = SSF.format(formatString, sum);
    max = SSF.format(formatString, max);
    min = SSF.format(formatString, min);
    return {
      numberC,
      count,
      sum,
      max,
      min,
      average
    };
  }
  function getAllSheets(ctx) {
    return ctx.luckysheetfile;
  }
  function initSheetData(draftCtx, index2, newData) {
    var _lastRow$r, _lastCol$c;
    var celldata = newData.celldata, row = newData.row, column = newData.column;
    var lastRow = _$1.maxBy(celldata, "r");
    var lastCol = _$1.maxBy(celldata, "c");
    var lastRowNum = ((_lastRow$r = lastRow === null || lastRow === void 0 ? void 0 : lastRow.r) !== null && _lastRow$r !== void 0 ? _lastRow$r : 0) + 1;
    var lastColNum = ((_lastCol$c = lastCol === null || lastCol === void 0 ? void 0 : lastCol.c) !== null && _lastCol$c !== void 0 ? _lastCol$c : 0) + 1;
    if (row != null && column != null && row > 0 && column > 0) {
      lastRowNum = Math.max(lastRowNum, row);
      lastColNum = Math.max(lastColNum, column);
    } else {
      lastRowNum = Math.max(lastRowNum, draftCtx.defaultrowNum);
      lastColNum = Math.max(lastColNum, draftCtx.defaultcolumnNum);
    }
    if (lastRowNum && lastColNum) {
      var expandedData = _$1.times(lastRowNum, function() {
        return _$1.times(lastColNum, function() {
          return null;
        });
      });
      celldata === null || celldata === void 0 ? void 0 : celldata.forEach(function(d2) {
        expandedData[d2.r][d2.c] = d2.v;
      });
      if (draftCtx.luckysheetfile[index2] == null) {
        newData.data = expandedData;
        delete newData.celldata;
        draftCtx.luckysheetfile.push(newData);
      } else {
        draftCtx.luckysheetfile[index2].data = expandedData;
        delete draftCtx.luckysheetfile[index2].celldata;
      }
      return expandedData;
    }
    return null;
  }
  function hideSheet(ctx, sheetId) {
    var index2 = getSheetIndex(ctx, sheetId);
    ctx.luckysheetfile[index2].hide = 1;
    ctx.luckysheetfile[index2].status = 0;
    var shownSheets = ctx.luckysheetfile.filter(function(sheet) {
      return _$1.isUndefined(sheet.hide) || (sheet === null || sheet === void 0 ? void 0 : sheet.hide) !== 1;
    });
    ctx.currentSheetId = shownSheets[0].id;
  }
  function showSheet(ctx, sheetId) {
    var index2 = getSheetIndex(ctx, sheetId);
    ctx.luckysheetfile[index2].hide = void 0;
  }
  function generateCopySheetName(ctx, sheetId) {
    var _locale = locale(ctx), info = _locale.info;
    var copyWord = "(".concat(info.copy);
    var SheetIndex = getSheetIndex(ctx, sheetId);
    var sheetName = ctx.luckysheetfile[SheetIndex].name;
    var copy_i = sheetName.indexOf(copyWord);
    var index2 = 0;
    if (copy_i !== -1) {
      sheetName = sheetName.toString().substring(0, copy_i);
    }
    var nameCopy = sheetName + copyWord;
    var sheetNames = [];
    for (var i2 = 0; i2 < ctx.luckysheetfile.length; i2 += 1) {
      var fileName = ctx.luckysheetfile[i2].name;
      sheetNames.push(fileName);
      var st_i = fileName.indexOf(nameCopy);
      if (st_i === 0) {
        index2 = index2 || 2;
        var ed_i = fileName.indexOf(")", st_i + nameCopy.length);
        var num = fileName.substring(st_i + nameCopy.length, ed_i);
        if (_$1.isNumber(num)) {
          if (Number.parseInt(num, 10) >= index2) {
            index2 = Number.parseInt(num, 10) + 1;
          }
        }
      }
    }
    var sheetCopyName;
    do {
      var postfix = "".concat(copyWord + (index2 || ""), ")");
      var lengthLimit = 31 - postfix.length;
      sheetCopyName = sheetName;
      if (sheetCopyName.length > lengthLimit) {
        sheetCopyName = "".concat(sheetCopyName.slice(0, lengthLimit - 1), "…");
      }
      sheetCopyName += postfix;
      index2 = (index2 || 1) + 1;
    } while (sheetNames.indexOf(sheetCopyName) !== -1);
    return sheetCopyName;
  }
  function copySheet(ctx, sheetId) {
    var index$12 = getSheetIndex(ctx, sheetId);
    var order = ctx.luckysheetfile[index$12].order + 1;
    var sheetName = generateCopySheetName(ctx, sheetId);
    var sheetData = _$1.cloneDeep(ctx.luckysheetfile[index$12]);
    delete sheetData.id;
    delete sheetData.status;
    sheetData.celldata = dataToCelldata(sheetData.data);
    delete sheetData.data;
    addSheet$1(ctx, void 0, v4(), ctx.luckysheetfile[index$12].isPivotTable, sheetName, sheetData);
    var sheetOrderList = {};
    sheetOrderList[ctx.luckysheetfile[ctx.luckysheetfile.length - 1].id] = order;
    setSheetOrder(ctx, sheetOrderList);
  }
  function calculateSheetFromula(ctx, id2) {
    var index$12 = getSheetIndex(ctx, id2);
    if (!ctx.luckysheetfile[index$12].data) return;
    for (var r2 = 0; r2 < ctx.luckysheetfile[index$12].data.length; r2 += 1) {
      for (var c2 = 0; c2 < ctx.luckysheetfile[index$12].data[r2].length; c2 += 1) {
        var _ctx$luckysheetfile$i, _ctx$luckysheetfile$i2;
        if (!((_ctx$luckysheetfile$i = ctx.luckysheetfile[index$12].data[r2][c2]) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i.f)) {
          continue;
        }
        var result = execfunction(ctx, (_ctx$luckysheetfile$i2 = ctx.luckysheetfile[index$12].data[r2][c2]) === null || _ctx$luckysheetfile$i2 === void 0 ? void 0 : _ctx$luckysheetfile$i2.f, r2, c2, id2);
        setCellValue$1(ctx, r2, c2, result[1], null);
        insertUpdateFunctionGroup(ctx, r2, c2, id2);
      }
    }
  }
  function storeSheetParam(ctx) {
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (index2 == null) return;
    var file = ctx.luckysheetfile[index2];
    file.config = ctx.config;
    file.luckysheet_select_save = ctx.luckysheet_select_save;
    file.luckysheet_selection_range = ctx.luckysheet_selection_range;
    file.zoomRatio = ctx.zoomRatio;
  }
  function storeSheetParamALL(ctx) {
    storeSheetParam(ctx);
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (index2 == null) return;
    ctx.luckysheetfile[index2].config = ctx.config;
  }
  function changeSheet(ctx, id2, isPivotInitial, isNewSheet, isCopySheet) {
    var _ctx$hooks$beforeActi, _ctx$hooks;
    if (id2 === ctx.currentSheetId) {
      return;
    }
    var file = ctx.luckysheetfile[getSheetIndex(ctx, id2)];
    if (((_ctx$hooks$beforeActi = (_ctx$hooks = ctx.hooks).beforeActivateSheet) === null || _ctx$hooks$beforeActi === void 0 ? void 0 : _ctx$hooks$beforeActi.call(_ctx$hooks, id2)) === false) {
      return;
    }
    storeSheetParamALL(ctx);
    ctx.currentSheetId = id2;
    if (file.isPivotTable) {
      ctx.luckysheetcurrentisPivotTable = true;
    } else {
      ctx.luckysheetcurrentisPivotTable = false;
    }
    if (ctx.hooks.afterActivateSheet) {
      setTimeout(function() {
        var _ctx$hooks$afterActiv, _ctx$hooks2;
        (_ctx$hooks$afterActiv = (_ctx$hooks2 = ctx.hooks).afterActivateSheet) === null || _ctx$hooks$afterActiv === void 0 ? void 0 : _ctx$hooks$afterActiv.call(_ctx$hooks2, id2);
      });
    }
  }
  function addSheet(ctx, settings) {
    var _ctx$hooks$beforeAddS, _ctx$hooks3;
    var newSheetID = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    var isPivotTable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var sheetName = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    var sheetData = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : void 0;
    if (ctx.allowEdit === false) {
      return;
    }
    var order = ctx.luckysheetfile.length;
    var id2 = newSheetID !== null && newSheetID !== void 0 ? newSheetID : settings === null || settings === void 0 ? void 0 : settings.generateSheetId();
    var sheetname = sheetName || generateRandomSheetName(ctx.luckysheetfile, isPivotTable, ctx);
    if (!_$1.isNil(sheetData)) {
      delete sheetData.data;
      ctx.luckysheetfile.forEach(function(sheet) {
        sheet.order = sheet.order < sheetData.order ? sheet.order : sheet.order + 1;
        return sheet;
      });
    }
    var sheetconfig = _$1.isNil(sheetData) ? {
      name: sheetName === void 0 ? sheetname : sheetName,
      status: 0,
      order,
      id: id2,
      row: ctx.defaultrowNum,
      column: ctx.defaultcolumnNum,
      config: {},
      pivotTable: null,
      isPivotTable: !!isPivotTable,
      zoomRatio: 1
    } : sheetData;
    if (sheetName !== void 0) sheetconfig.name = sheetName;
    if (sheetconfig.id === void 0) sheetconfig.id = v4();
    if (((_ctx$hooks$beforeAddS = (_ctx$hooks3 = ctx.hooks).beforeAddSheet) === null || _ctx$hooks$beforeAddS === void 0 ? void 0 : _ctx$hooks$beforeAddS.call(_ctx$hooks3, sheetconfig)) === false) {
      return;
    }
    ctx.luckysheetfile.push(sheetconfig);
    if (!newSheetID) {
      changeSheet(ctx, id2);
    }
    if (ctx.hooks.afterAddSheet) {
      setTimeout(function() {
        var _ctx$hooks$afterAddSh, _ctx$hooks4;
        (_ctx$hooks$afterAddSh = (_ctx$hooks4 = ctx.hooks).afterAddSheet) === null || _ctx$hooks$afterAddSh === void 0 ? void 0 : _ctx$hooks$afterAddSh.call(_ctx$hooks4, sheetconfig);
      });
    }
  }
  function deleteSheet(ctx, id2) {
    var _ctx$hooks$beforeDele, _ctx$hooks5;
    if (ctx.allowEdit === false) {
      return;
    }
    var arrIndex = getSheetIndex(ctx, id2);
    if (arrIndex == null) {
      return;
    }
    if (((_ctx$hooks$beforeDele = (_ctx$hooks5 = ctx.hooks).beforeDeleteSheet) === null || _ctx$hooks$beforeDele === void 0 ? void 0 : _ctx$hooks$beforeDele.call(_ctx$hooks5, id2)) === false) {
      return;
    }
    ctx.luckysheetfile = ctx.luckysheetfile.map(function(sheet) {
      sheet.order = sheet.order < ctx.luckysheetfile[arrIndex].order ? sheet.order : sheet.order - 1;
      return sheet;
    });
    ctx.luckysheetfile.splice(arrIndex, 1);
    if (id2 === ctx.currentSheetId) {
      var _orderSheets$;
      var shownSheets = _$1.cloneDeep(ctx.luckysheetfile).filter(function(singleSheet) {
        return _$1.isUndefined(singleSheet.hide) || singleSheet.hide !== 1;
      });
      var orderSheets = _$1.sortBy(shownSheets, function(sheet) {
        return sheet.order;
      });
      ctx.currentSheetId = orderSheets === null || orderSheets === void 0 ? void 0 : (_orderSheets$ = orderSheets[0]) === null || _orderSheets$ === void 0 ? void 0 : _orderSheets$.id;
    }
    if (ctx.hooks.afterDeleteSheet) {
      setTimeout(function() {
        var _ctx$hooks$afterDelet, _ctx$hooks6;
        (_ctx$hooks$afterDelet = (_ctx$hooks6 = ctx.hooks).afterDeleteSheet) === null || _ctx$hooks$afterDelet === void 0 ? void 0 : _ctx$hooks$afterDelet.call(_ctx$hooks6, id2);
      });
    }
  }
  function updateSheet(ctx, newData) {
    newData.forEach(function(newDatum) {
      var data = newDatum.data, row = newDatum.row, column = newDatum.column;
      var index2 = getSheetIndex(ctx, newDatum.id);
      if (data != null) {
        var lastRowNum = data.length;
        var lastColNum = data[0].length;
        if (row != null && column != null && row > 0 && column > 0) {
          lastRowNum = Math.max(lastRowNum, row);
          lastColNum = Math.max(lastColNum, column);
        } else {
          lastRowNum = Math.max(lastRowNum, ctx.defaultrowNum);
          lastColNum = Math.max(lastColNum, ctx.defaultcolumnNum);
        }
        var expandedData = _$1.times(lastRowNum, function() {
          return _$1.times(lastColNum, function() {
            return null;
          });
        });
        for (var i2 = 0; i2 < data.length; i2 += 1) {
          for (var j2 = 0; j2 < data[i2].length; j2 += 1) {
            expandedData[i2][j2] = data[i2][j2];
          }
        }
        newDatum.data = expandedData;
        if (ctx.luckysheetfile[index2] == null) {
          ctx.luckysheetfile.push(newDatum);
        } else {
          ctx.luckysheetfile[index2] = newDatum;
        }
      } else if (newDatum.celldata != null) {
        initSheetData(ctx, index2, newDatum);
      }
    });
  }
  function editSheetName(ctx, editable) {
    var _ctx$hooks$beforeUpda, _ctx$hooks7;
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (ctx.allowEdit === false) {
      if (index2 == null) return;
      editable.innerText = ctx.luckysheetfile[index2].name;
      return;
    }
    var _locale = locale(ctx), sheetconfig = _locale.sheetconfig;
    var oldtxt = editable.dataset.oldText || "";
    var txt = editable.innerText;
    if (((_ctx$hooks$beforeUpda = (_ctx$hooks7 = ctx.hooks).beforeUpdateSheetName) === null || _ctx$hooks$beforeUpda === void 0 ? void 0 : _ctx$hooks$beforeUpda.call(_ctx$hooks7, ctx.currentSheetId, oldtxt, txt)) === false) {
      return;
    }
    if (txt.length === 0) {
      editable.innerText = oldtxt;
      throw new Error(sheetconfig.sheetNamecannotIsEmptyError);
    }
    if (txt.length > 31 || txt.charAt(0) === "'" || txt.charAt(txt.length - 1) === "'" || /[：:\\/？?*[\]]+/.test(txt)) {
      editable.innerText = oldtxt;
      throw new Error(sheetconfig.sheetNameSpecCharError);
    }
    if (index2 == null) return;
    for (var i2 = 0; i2 < ctx.luckysheetfile.length; i2 += 1) {
      if (index2 !== i2 && ctx.luckysheetfile[i2].name === txt) {
        editable.innerText = oldtxt;
        return;
      }
    }
    ctx.luckysheetfile[index2].name = txt;
    if (ctx.hooks.afterUpdateSheetName) {
      setTimeout(function() {
        var _ctx$hooks$afterUpdat, _ctx$hooks8;
        (_ctx$hooks$afterUpdat = (_ctx$hooks8 = ctx.hooks).afterUpdateSheetName) === null || _ctx$hooks$afterUpdat === void 0 ? void 0 : _ctx$hooks$afterUpdat.call(_ctx$hooks8, ctx.currentSheetId, oldtxt, txt);
      });
    }
  }
  function expandRowsAndColumns(data, rowsToAdd, columnsToAdd) {
    if (rowsToAdd <= 0 && columnsToAdd <= 0) {
      return data;
    }
    if (data.length + rowsToAdd >= 1e4) {
      throw new Error("This action would increase the number of rows in the workbook above the limit of 10000.");
    }
    if (data[0].length + columnsToAdd >= 1e3) {
      throw new Error("This action would increase the number of columns in the workbook above the limit of 1000.");
    }
    if (rowsToAdd <= 0) {
      rowsToAdd = 0;
    }
    if (columnsToAdd <= 0) {
      columnsToAdd = 0;
    }
    var currentColLen = 0;
    if (data.length > 0) {
      currentColLen = data[0].length;
    }
    for (var r2 = 0; r2 < data.length; r2 += 1) {
      for (var i2 = 0; i2 < columnsToAdd; i2 += 1) {
        data[r2].push(null);
      }
    }
    for (var _r = 0; _r < rowsToAdd; _r += 1) {
      data.push(_$1.times(currentColLen + columnsToAdd, function() {
        return null;
      }));
    }
    return data;
  }
  function mergeCells(ctx, sheetId, ranges, type) {
    var idx = getSheetIndex(ctx, sheetId);
    if (idx == null) return;
    var sheet = ctx.luckysheetfile[idx];
    var cfg = sheet.config || {};
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    var d2 = sheet.data;
    if (type === "merge-cancel") {
      for (var i2 = 0; i2 < ranges.length; i2 += 1) {
        var range = ranges[i2];
        var r1 = range.row[0];
        var r2 = range.row[1];
        var c1 = range.column[0];
        var c2 = range.column[1];
        if (r1 === r2 && c1 === c2) {
          continue;
        }
        var fv = {};
        for (var r3 = r1; r3 <= r2; r3 += 1) {
          for (var c3 = c1; c3 <= c2; c3 += 1) {
            var cell = d2[r3][c3];
            if (cell != null && cell.mc != null) {
              var mc_r = cell.mc.r;
              var mc_c = cell.mc.c;
              if ("rs" in cell.mc) {
                delete cell.mc;
                delete cfg.merge["".concat(mc_r, "_").concat(mc_c)];
                fv["".concat(mc_r, "_").concat(mc_c)] = _$1.cloneDeep(cell) || {};
              } else {
                var cell_clone = _$1.cloneDeep(fv["".concat(mc_r, "_").concat(mc_c)]);
                delete cell_clone.v;
                delete cell_clone.m;
                delete cell_clone.ct;
                delete cell_clone.f;
                delete cell_clone.spl;
                d2[r3][c3] = cell_clone;
              }
            }
          }
        }
      }
    } else {
      var isHasMc = false;
      for (var _i = 0; _i < ranges.length; _i += 1) {
        var _range = ranges[_i];
        var _r = _range.row[0];
        var _r2 = _range.row[1];
        var _c = _range.column[0];
        var _c2 = _range.column[1];
        for (var _r3 = _r; _r3 <= _r2; _r3 += 1) {
          for (var _c3 = _c; _c3 <= _c2; _c3 += 1) {
            var _cell = d2[_r3][_c3];
            if (_cell === null || _cell === void 0 ? void 0 : _cell.mc) {
              isHasMc = true;
              break;
            }
          }
        }
      }
      if (isHasMc) {
        for (var _i2 = 0; _i2 < ranges.length; _i2 += 1) {
          var _range2 = ranges[_i2];
          var _r4 = _range2.row[0];
          var _r5 = _range2.row[1];
          var _c4 = _range2.column[0];
          var _c5 = _range2.column[1];
          if (_r4 === _r5 && _c4 === _c5) {
            continue;
          }
          var _fv = {};
          for (var _r6 = _r4; _r6 <= _r5; _r6 += 1) {
            for (var _c6 = _c4; _c6 <= _c5; _c6 += 1) {
              var _cell2 = d2[_r6][_c6];
              if (_cell2 != null && _cell2.mc != null) {
                var _mc_r = _cell2.mc.r;
                var _mc_c = _cell2.mc.c;
                if ("rs" in _cell2.mc) {
                  delete _cell2.mc;
                  delete cfg.merge["".concat(_mc_r, "_").concat(_mc_c)];
                  _fv["".concat(_mc_r, "_").concat(_mc_c)] = _$1.cloneDeep(_cell2) || {};
                } else {
                  var _cell_clone = _$1.cloneDeep(_fv["".concat(_mc_r, "_").concat(_mc_c)]);
                  delete _cell_clone.v;
                  delete _cell_clone.m;
                  delete _cell_clone.ct;
                  delete _cell_clone.f;
                  delete _cell_clone.spl;
                  d2[_r6][_c6] = _cell_clone;
                }
              }
            }
          }
        }
      } else {
        for (var _i3 = 0; _i3 < ranges.length; _i3 += 1) {
          var _range3 = ranges[_i3];
          var _r7 = _range3.row[0];
          var _r8 = _range3.row[1];
          var _c7 = _range3.column[0];
          var _c8 = _range3.column[1];
          if (_r7 === _r8 && _c7 === _c8) {
            continue;
          }
          if (type === "merge-all") {
            var _fv2 = {};
            var isfirst = false;
            for (var _r9 = _r7; _r9 <= _r8; _r9 += 1) {
              for (var _c9 = _c7; _c9 <= _c8; _c9 += 1) {
                var _cell3 = d2[_r9][_c9];
                if (_cell3 != null && (isInlineStringCT(_cell3.ct) || !_$1.isEmpty(_cell3.v) || _cell3.f != null) && !isfirst) {
                  _fv2 = _$1.cloneDeep(_cell3) || {};
                  isfirst = true;
                }
                d2[_r9][_c9] = {
                  mc: {
                    r: _r7,
                    c: _c7
                  }
                };
              }
            }
            d2[_r7][_c7] = _fv2;
            var a2 = d2[_r7][_c7];
            if (!a2) return;
            a2.mc = {
              r: _r7,
              c: _c7,
              rs: _r8 - _r7 + 1,
              cs: _c8 - _c7 + 1
            };
            cfg.merge["".concat(_r7, "_").concat(_c7)] = {
              r: _r7,
              c: _c7,
              rs: _r8 - _r7 + 1,
              cs: _c8 - _c7 + 1
            };
          } else if (type === "merge-vertical") {
            for (var _c10 = _c7; _c10 <= _c8; _c10 += 1) {
              var _fv3 = {};
              var _isfirst = false;
              for (var _r10 = _r7; _r10 <= _r8; _r10 += 1) {
                var _cell4 = d2[_r10][_c10];
                if (_cell4 != null && (!_$1.isEmpty(_cell4.v) || _cell4.f != null) && !_isfirst) {
                  _fv3 = _$1.cloneDeep(_cell4) || {};
                  _isfirst = true;
                }
                d2[_r10][_c10] = {
                  mc: {
                    r: _r7,
                    c: _c10
                  }
                };
              }
              d2[_r7][_c10] = _fv3;
              var _a = d2[_r7][_c10];
              if (!_a) return;
              _a.mc = {
                r: _r7,
                c: _c10,
                rs: _r8 - _r7 + 1,
                cs: 1
              };
              cfg.merge["".concat(_r7, "_").concat(_c10)] = {
                r: _r7,
                c: _c10,
                rs: _r8 - _r7 + 1,
                cs: 1
              };
            }
          } else if (type === "merge-horizontal") {
            for (var _r11 = _r7; _r11 <= _r8; _r11 += 1) {
              var _fv4 = {};
              var _isfirst2 = false;
              for (var _c11 = _c7; _c11 <= _c8; _c11 += 1) {
                var _cell5 = d2[_r11][_c11];
                if (_cell5 != null && (!_$1.isEmpty(_cell5.v) || _cell5.f != null) && !_isfirst2) {
                  _fv4 = _$1.cloneDeep(_cell5) || {};
                  _isfirst2 = true;
                }
                d2[_r11][_c11] = {
                  mc: {
                    r: _r11,
                    c: _c7
                  }
                };
              }
              d2[_r11][_c7] = _fv4;
              var _a2 = d2[_r11][_c7];
              if (!_a2) return;
              _a2.mc = {
                r: _r11,
                c: _c7,
                rs: 1,
                cs: _c8 - _c7 + 1
              };
              cfg.merge["".concat(_r11, "_").concat(_c7)] = {
                r: _r11,
                c: _c7,
                rs: 1,
                cs: _c8 - _c7 + 1
              };
            }
          }
        }
      }
    }
    sheet.config = cfg;
    if (sheet.id === ctx.currentSheetId) {
      ctx.config = cfg;
    }
  }
  function runExecFunction(ctx, range, index2, data) {
    ctx.formulaCache.execFunctionExist = [];
    for (var s2 = 0; s2 < range.length; s2 += 1) {
      for (var r2 = range[s2].row[0]; r2 <= range[s2].row[1]; r2 += 1) {
        for (var c2 = range[s2].column[0]; c2 <= range[s2].column[1]; c2 += 1) {
          ctx.formulaCache.execFunctionExist.push({
            r: r2,
            c: c2,
            i: index2
          });
        }
      }
    }
    ctx.formulaCache.execFunctionExist.reverse();
    execFunctionGroup(ctx, null, null, null, null, data);
    ctx.formulaCache.execFunctionGlobalData = null;
  }
  function jfrefreshgrid(ctx, data, range) {
    var isRunExecFunction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (data == null) {
      data = getFlowdata(ctx);
    }
    if (range == null) {
      range = ctx.luckysheet_select_save;
      if (range == null) return;
    }
    if (isRunExecFunction) {
      runExecFunction(ctx, range, ctx.currentSheetId, data);
    }
  }
  function orderbydata(isAsc, index2, data) {
    if (isAsc == null) {
      isAsc = true;
    }
    var a2 = function a3(x2, y2) {
      var x1 = x2[index2];
      var y1 = y2[index2];
      if (x2[index2] != null) {
        x1 = x2[index2].v;
      }
      if (y2[index2] != null) {
        y1 = y2[index2].v;
      }
      if (isRealNull(x1)) {
        return isAsc ? 1 : -1;
      }
      if (isRealNull(y1)) {
        return isAsc ? -1 : 1;
      }
      if (isdatetime(x1) && isdatetime(y1)) {
        return diff(x1, y1);
      }
      if (isRealNum(x1) && isRealNum(y1)) {
        var y1Value = numeral(y1).value();
        var x1Value = numeral(x1).value();
        if (y1Value == null || x1Value == null) return null;
        return x1Value - y1Value;
      }
      if (!isRealNum(x1) && !isRealNum(y1)) {
        return x1.localeCompare(y1, "zh");
      }
      if (!isRealNum(x1)) {
        return 1;
      }
      if (!isRealNum(y1)) {
        return -1;
      }
      return 0;
    };
    var d2 = function d3(x2, y2) {
      return a2(y2, x2);
    };
    var sortedData = _$1.clone(data);
    sortedData.sort(isAsc ? a2 : d2);
    var rowOffsets = sortedData.map(function(r2, i2) {
      var origIndex = _$1.findIndex(data, function(origR) {
        return origR === r2;
      });
      return i2 - origIndex;
    });
    return {
      sortedData,
      rowOffsets
    };
  }
  function sortDataRange(ctx, sheetData, dataRange, index2, isAsc, str, edr, stc, edc) {
    var _orderbydata = orderbydata(isAsc, index2, dataRange), sortedData = _orderbydata.sortedData, rowOffsets = _orderbydata.rowOffsets;
    for (var r2 = str; r2 <= edr; r2 += 1) {
      for (var c2 = stc; c2 <= edc; c2 += 1) {
        var cell = sortedData[r2 - str][c2 - stc];
        if (cell === null || cell === void 0 ? void 0 : cell.f) {
          var _cell$ct;
          var moveOffset = rowOffsets[r2 - str];
          var func2 = cell === null || cell === void 0 ? void 0 : cell.f;
          if (moveOffset > 0) {
            func2 = "=".concat(functionCopy(ctx, func2, "down", moveOffset));
          } else if (moveOffset < 0) {
            func2 = "=".concat(functionCopy(ctx, func2, "up", -moveOffset));
          }
          var funcV = execfunction(ctx, func2, r2, c2, void 0, true);
          var _funcV = _slicedToArray$1(funcV, 3);
          cell.v = _funcV[1];
          cell.f = _funcV[2];
          cell.m = update(((_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : _cell$ct.fa) || "General", cell.v);
        }
        sheetData[r2][c2] = cell;
      }
    }
    jfrefreshgrid(ctx, sheetData, [{
      row: [str, edr],
      column: [stc, edc]
    }]);
  }
  function sortSelection(ctx, isAsc) {
    var colIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (ctx.allowEdit === false) return;
    if (ctx.luckysheet_select_save == null) return;
    if (ctx.luckysheet_select_save.length > 1) {
      return;
    }
    if (isAsc == null) {
      isAsc = true;
    }
    var flowdata = getFlowdata(ctx);
    var d2 = flowdata;
    if (d2 == null) return;
    var r1 = ctx.luckysheet_select_save[0].row[0];
    var r2 = ctx.luckysheet_select_save[0].row[1];
    var c1 = ctx.luckysheet_select_save[0].column[0];
    var c2 = ctx.luckysheet_select_save[0].column[1];
    var str = null;
    var edr;
    for (var r3 = r1; r3 <= r2; r3 += 1) {
      if (d2[r3] != null && d2[r3][c1] != null) {
        var cell = d2[r3][c1];
        if (cell == null) return;
        if (cell.mc != null || isRealNull(cell.v)) {
          continue;
        }
        if (str == null && /[\u4e00-\u9fa5]+/g.test("".concat(cell.v))) {
          str = r3 + 1;
          edr = r3 + 1;
          continue;
        }
        if (str == null) {
          str = r3;
        }
        edr = r3;
      }
    }
    if (str == null || str > r2) {
      return;
    }
    var hasMc = false;
    var data = [];
    if (edr == null) return;
    for (var _r = str; _r <= edr; _r += 1) {
      var data_row = [];
      for (var c3 = c1; c3 <= c2; c3 += 1) {
        var _d$_r$c;
        if (d2[_r][c3] != null && ((_d$_r$c = d2[_r][c3]) === null || _d$_r$c === void 0 ? void 0 : _d$_r$c.mc) != null) {
          hasMc = true;
          break;
        }
        data_row.push(d2[_r][c3]);
      }
      data.push(data_row);
    }
    if (hasMc) {
      return;
    }
    sortDataRange(ctx, d2, data, colIndex, isAsc, str, edr, c1, c2);
  }
  function getCellRowColumn(ctx, e, container, scrollX, scrollY) {
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return void 0;
    var scrollLeft = scrollX.scrollLeft;
    var scrollTop = scrollY.scrollTop;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight;
    x2 += scrollLeft;
    y2 += scrollTop;
    var r2 = rowLocation(y2, ctx.visibledatarow)[2];
    var c2 = colLocation(x2, ctx.visibledatacolumn)[2];
    var margeset = mergeBorder(ctx, flowdata, r2, c2);
    if (margeset) {
      var _margeset$row = _slicedToArray$1(margeset.row, 3);
      r2 = _margeset$row[2];
      var _margeset$column = _slicedToArray$1(margeset.column, 3);
      c2 = _margeset$column[2];
    }
    return {
      r: r2,
      c: c2
    };
  }
  function getCellHyperlink(ctx, r2, c2) {
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (sheetIndex != null) {
      var _ctx$luckysheetfile$s;
      return (_ctx$luckysheetfile$s = ctx.luckysheetfile[sheetIndex].hyperlink) === null || _ctx$luckysheetfile$s === void 0 ? void 0 : _ctx$luckysheetfile$s["".concat(r2, "_").concat(c2)];
    }
    return void 0;
  }
  function saveHyperlink(ctx, r2, c2, linkText, linkType, linkAddress) {
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    var flowdata = getFlowdata(ctx);
    if (sheetIndex != null && flowdata != null && linkType && linkAddress) {
      var cell = flowdata[r2][c2];
      if (cell == null) cell = {};
      _$1.set(ctx.luckysheetfile[sheetIndex], ["hyperlink", "".concat(r2, "_").concat(c2)], {
        linkType,
        linkAddress
      });
      cell.fc = "rgb(0, 0, 255)";
      cell.un = 1;
      cell.v = linkText || linkAddress;
      cell.m = linkText || linkAddress;
      cell.hl = {
        r: r2,
        c: c2,
        id: ctx.currentSheetId
      };
      flowdata[r2][c2] = cell;
      ctx.linkCard = void 0;
    }
  }
  function removeHyperlink(ctx, r2, c2) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    var flowdata = getFlowdata(ctx);
    if (flowdata != null && sheetIndex != null) {
      var hyperlink = _$1.omit(ctx.luckysheetfile[sheetIndex].hyperlink, "".concat(r2, "_").concat(c2));
      _$1.set(ctx.luckysheetfile[sheetIndex], "hyperlink", hyperlink);
      var cell = flowdata[r2][c2];
      if (cell != null) {
        flowdata[r2][c2] = {
          v: cell.v,
          m: cell.m
        };
      }
    }
    ctx.linkCard = void 0;
  }
  function showLinkCard(ctx, r2, c2) {
    var _ctx$linkCard, _ctx$linkCard2, _getFlowdata, _getFlowdata$r, _ctx$linkCard3, _ctx$linkCard4, _ctx$linkCard5;
    var isEditing = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var isMouseDown = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    if ((_ctx$linkCard = ctx.linkCard) === null || _ctx$linkCard === void 0 ? void 0 : _ctx$linkCard.selectingCellRange) return;
    if ("".concat(r2, "_").concat(c2) === ((_ctx$linkCard2 = ctx.linkCard) === null || _ctx$linkCard2 === void 0 ? void 0 : _ctx$linkCard2.rc)) return;
    var link = getCellHyperlink(ctx, r2, c2);
    var cell = (_getFlowdata = getFlowdata(ctx)) === null || _getFlowdata === void 0 ? void 0 : (_getFlowdata$r = _getFlowdata[r2]) === null || _getFlowdata$r === void 0 ? void 0 : _getFlowdata$r[c2];
    if (!isEditing && link == null && (isMouseDown || !((_ctx$linkCard3 = ctx.linkCard) === null || _ctx$linkCard3 === void 0 ? void 0 : _ctx$linkCard3.isEditing) || ctx.linkCard.sheetId !== ctx.currentSheetId)) {
      ctx.linkCard = void 0;
      return;
    }
    if (isEditing || link != null && (!((_ctx$linkCard4 = ctx.linkCard) === null || _ctx$linkCard4 === void 0 ? void 0 : _ctx$linkCard4.isEditing) || isMouseDown) || ((_ctx$linkCard5 = ctx.linkCard) === null || _ctx$linkCard5 === void 0 ? void 0 : _ctx$linkCard5.sheetId) !== ctx.currentSheetId) {
      var col_pre = c2 - 1 === -1 ? 0 : ctx.visibledatacolumn[c2 - 1];
      var row = ctx.visibledatarow[r2];
      ctx.linkCard = {
        sheetId: ctx.currentSheetId,
        r: r2,
        c: c2,
        rc: "".concat(r2, "_").concat(c2),
        originText: (cell === null || cell === void 0 ? void 0 : cell.v) == null ? "" : "".concat(cell.v),
        originType: (link === null || link === void 0 ? void 0 : link.linkType) || "webpage",
        originAddress: (link === null || link === void 0 ? void 0 : link.linkAddress) || "",
        position: {
          cellLeft: col_pre,
          cellBottom: row
        },
        isEditing
      };
    }
  }
  function goToLink(ctx, r2, c2, linkType, linkAddress, scrollbarX, scrollbarY) {
    var _ctx$luckysheetfile$c;
    var currSheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (currSheetIndex == null) return;
    if (((_ctx$luckysheetfile$c = ctx.luckysheetfile[currSheetIndex].hyperlink) === null || _ctx$luckysheetfile$c === void 0 ? void 0 : _ctx$luckysheetfile$c["".concat(r2, "_").concat(c2)]) == null) {
      return;
    }
    if (linkType === "webpage") {
      if (!/^http[s]?:\/\//.test(linkAddress)) {
        linkAddress = "https://".concat(linkAddress);
      }
      window.open(linkAddress);
    } else if (linkType === "sheet") {
      var sheetId;
      _$1.forEach(ctx.luckysheetfile, function(f2) {
        if (linkAddress === f2.name) {
          sheetId = f2.id;
        }
      });
      if (sheetId != null) changeSheet(ctx, sheetId);
    } else {
      var range = _$1.cloneDeep(getcellrange(ctx, linkAddress));
      if (range == null) return;
      var row_pre = range.row[0] - 1 === -1 ? 0 : ctx.visibledatarow[range.row[0] - 1];
      var col_pre = range.column[0] - 1 === -1 ? 0 : ctx.visibledatacolumn[range.column[0] - 1];
      scrollbarX.scrollLeft = col_pre;
      scrollbarY.scrollLeft = row_pre;
      ctx.luckysheet_select_save = normalizeSelection(ctx, [range]);
      changeSheet(ctx, range.sheetId);
    }
    ctx.linkCard = void 0;
  }
  function isLinkValid(ctx, linkType, linkAddress) {
    if (!linkAddress) return {
      isValid: false,
      tooltip: ""
    };
    var _locale = locale(ctx), insertLink = _locale.insertLink;
    if (linkType === "webpage") {
      if (!/^http[s]?:\/\//.test(linkAddress)) {
        linkAddress = "https://".concat(linkAddress);
      }
      if (!/^http[s]?:\/\/([\w\-\.]+)+[\w-]*([\w\-\.\/\?%&=]+)?$/gi.test(linkAddress)) return {
        isValid: false,
        tooltip: insertLink.tooltipInfo1
      };
    }
    if (linkType === "cellrange" && !iscelldata(linkAddress)) {
      return {
        isValid: false,
        tooltip: insertLink.invalidCellRangeTip
      };
    }
    return {
      isValid: true,
      tooltip: ""
    };
  }
  function onRangeSelectionModalMoveStart(ctx, globalCache, e) {
    var box = document.querySelector("div.fortune-link-modify-modal.range-selection-modal");
    if (!box) return;
    var _box$getBoundingClien = box.getBoundingClientRect(), width = _box$getBoundingClien.width, height = _box$getBoundingClien.height;
    var left = box.offsetLeft;
    var top = box.offsetTop;
    var initialPosition = {
      left,
      top,
      width,
      height
    };
    _$1.set(globalCache, "linkCard.rangeSelectionModal", {
      cursorMoveStartPosition: {
        x: e.pageX,
        y: e.pageY
      },
      initialPosition
    });
  }
  function onRangeSelectionModalMove(globalCache, e) {
    var _globalCache$linkCard;
    var moveProps = (_globalCache$linkCard = globalCache.linkCard) === null || _globalCache$linkCard === void 0 ? void 0 : _globalCache$linkCard.rangeSelectionModal;
    if (moveProps == null) return;
    var modal = document.querySelector("div.fortune-link-modify-modal.range-selection-modal");
    var _moveProps$cursorMove = moveProps.cursorMoveStartPosition, startX = _moveProps$cursorMove.x, startY = _moveProps$cursorMove.y;
    var _moveProps$initialPos = moveProps.initialPosition, top = _moveProps$initialPos.top, left = _moveProps$initialPos.left;
    left += e.pageX - startX;
    top += e.pageY - startY;
    if (top < 0) top = 0;
    modal.style.left = "".concat(left, "px");
    modal.style.top = "".concat(top, "px");
  }
  function onRangeSelectionModalMoveEnd(globalCache) {
    _$1.set(globalCache, "linkCard.rangeSelectionModal", void 0);
  }
  function cfSplitRange(range1, range2, range3, type) {
    var range = [];
    range3.row[0] - range2.row[0];
    range3.column[0] - range2.column[0];
    var r1 = range1.row[0];
    var r2 = range1.row[1];
    var c1 = range1.column[0];
    var c2 = range1.column[1];
    if (r1 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (c1 >= range2.column[0] && c1 <= range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      {
        range = [{
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }];
      }
    } else if (c2 >= range2.column[0] && c2 <= range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r1 >= range2.row[0] && r2 <= range2.row[1]) {
      {
        range = [{
          row: [r1, r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, r2],
          column: [range2.column[1] + 1, c2]
        }];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (r1 >= range2.row[0] && r1 <= range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }];
      }
    } else if (r2 >= range2.row[0] && r2 <= range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 >= range2.column[0] && c1 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c2 >= range2.column[0] && c2 <= range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r1 >= range2.row[0] && r1 <= range2.row[1]) {
      {
        range = [{
          row: [r1, range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [r1, range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else if (c1 < range2.column[0] && c2 > range2.column[1] && r2 >= range2.row[0] && r2 <= range2.row[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], r2],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], r2],
          column: [range2.column[1] + 1, c2]
        }];
      }
    } else if (r1 < range2.row[0] && r2 > range2.row[1] && c1 < range2.column[0] && c2 > range2.column[1]) {
      {
        range = [{
          row: [r1, range2.row[0] - 1],
          column: [c1, c2]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [c1, range2.column[0] - 1]
        }, {
          row: [range2.row[0], range2.row[1]],
          column: [range2.column[1] + 1, c2]
        }, {
          row: [range2.row[1] + 1, r2],
          column: [c1, c2]
        }];
      }
    } else {
      {
        range = [{
          row: [r1, r2],
          column: [c1, c2]
        }];
      }
    }
    return range;
  }
  function updateFormatCell(ctx, d2, attr, foucsStatus, row_st, row_ed, col_st, col_ed, canvas) {
    if (_$1.isNil(d2) || _$1.isNil(attr)) {
      return;
    }
    if (attr === "ct") {
      for (var r2 = row_st; r2 <= row_ed; r2 += 1) {
        if (!_$1.isNil(ctx.config.rowhidden) && !_$1.isNil(ctx.config.rowhidden[r2])) {
          continue;
        }
        for (var c2 = col_st; c2 <= col_ed; c2 += 1) {
          var cell = d2[r2][c2];
          var value = void 0;
          if (_$1.isPlainObject(cell)) {
            value = cell === null || cell === void 0 ? void 0 : cell.v;
          } else {
            value = cell;
          }
          if (foucsStatus !== "@" && isRealNum(value)) {
            value = Number(value);
          }
          var mask = update(foucsStatus, value);
          var type = "n";
          if (is_date(foucsStatus) || foucsStatus === 14 || foucsStatus === 15 || foucsStatus === 16 || foucsStatus === 17 || foucsStatus === 18 || foucsStatus === 19 || foucsStatus === 20 || foucsStatus === 21 || foucsStatus === 22 || foucsStatus === 45 || foucsStatus === 46 || foucsStatus === 47) {
            type = "d";
          } else if (foucsStatus === "@" || foucsStatus === 49) {
            type = "s";
          } else if (foucsStatus === "General" || foucsStatus === 0) {
            type = isRealNum(value) ? "n" : "g";
          }
          if (cell && _$1.isPlainObject(cell)) {
            cell.m = "".concat(mask);
            if (_$1.isNil(cell.ct)) {
              cell.ct = {};
            }
            cell.ct.fa = foucsStatus;
            cell.ct.t = type;
          } else {
            d2[r2][c2] = {
              ct: {
                fa: foucsStatus,
                t: type
              },
              v: value,
              m: mask
            };
          }
        }
      }
    } else {
      if (attr === "ht") {
        if (foucsStatus === "left") {
          foucsStatus = "1";
        } else if (foucsStatus === "center") {
          foucsStatus = "0";
        } else if (foucsStatus === "right") {
          foucsStatus = "2";
        }
      } else if (attr === "vt") {
        if (foucsStatus === "top") {
          foucsStatus = "1";
        } else if (foucsStatus === "middle") {
          foucsStatus = "0";
        } else if (foucsStatus === "bottom") {
          foucsStatus = "2";
        }
      } else if (attr === "tb") {
        if (foucsStatus === "overflow") {
          foucsStatus = "1";
        } else if (foucsStatus === "clip") {
          foucsStatus = "0";
        } else if (foucsStatus === "wrap") {
          foucsStatus = "2";
        }
      } else if (attr === "tr") {
        if (foucsStatus === "none") {
          foucsStatus = "0";
        } else if (foucsStatus === "angleup") {
          foucsStatus = "1";
        } else if (foucsStatus === "angledown") {
          foucsStatus = "2";
        } else if (foucsStatus === "vertical") {
          foucsStatus = "3";
        } else if (foucsStatus === "rotation-up") {
          foucsStatus = "4";
        } else if (foucsStatus === "rotation-down") {
          foucsStatus = "5";
        }
      }
      var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
      if (sheetIndex == null) {
        return;
      }
      for (var _r = row_st; _r <= row_ed; _r += 1) {
        if (!_$1.isNil(ctx.config.rowhidden) && !_$1.isNil(ctx.config.rowhidden[_r])) {
          continue;
        }
        for (var _c = col_st; _c <= col_ed; _c += 1) {
          var _value = d2[_r][_c];
          if (_value && _$1.isPlainObject(_value)) {
            var _ctx$luckysheetfile$s, _cfg$columnlen;
            updateInlineStringFormatOutside(_value, attr, foucsStatus);
            _value[attr] = foucsStatus;
            (_ctx$luckysheetfile$s = ctx.luckysheetfile[sheetIndex]).config || (_ctx$luckysheetfile$s.config = {});
            var cfg = ctx.luckysheetfile[sheetIndex].config;
            var cellWidth = ((_cfg$columnlen = cfg.columnlen) === null || _cfg$columnlen === void 0 ? void 0 : _cfg$columnlen[_c]) || ctx.luckysheetfile[sheetIndex].defaultColWidth;
            if (attr === "fs" && canvas) {
              var _cfg$rowlen;
              var textInfo = getCellTextInfo(d2[_r][_c], canvas, ctx, {
                r: _r,
                c: _c,
                cellWidth
              });
              if (!textInfo) continue;
              var rowHeight = _$1.round(textInfo.textHeightAll);
              var currentRowHeight = ((_cfg$rowlen = cfg.rowlen) === null || _cfg$rowlen === void 0 ? void 0 : _cfg$rowlen[_r]) || ctx.luckysheetfile[sheetIndex].defaultRowHeight || 19;
              if (!_$1.isUndefined(rowHeight) && rowHeight > currentRowHeight && (!cfg.customHeight || cfg.customHeight[_r] !== 1)) {
                if (_$1.isUndefined(cfg.rowlen)) cfg.rowlen = {};
                _$1.set(cfg, "rowlen.".concat(_r), rowHeight);
              }
            }
          } else {
            d2[_r][_c] = {
              v: _value
            };
            d2[_r][_c][attr] = foucsStatus;
          }
        }
      }
    }
  }
  function updateFormat(ctx, $input, d2, attr, foucsStatus, canvas) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (attr in inlineStyleAffectAttribute) {
      if (ctx.luckysheetCellUpdate.length > 0) {
        var value = $input.innerText;
        if (value.substring(0, 1) !== "=") {
          var cell = d2[ctx.luckysheetCellUpdate[0]][ctx.luckysheetCellUpdate[1]];
          if (cell) {
            updateInlineStringFormat(ctx, cell, attr, foucsStatus, $input);
          }
          return;
        }
      }
    }
    var cfg = _$1.cloneDeep(ctx.config);
    if (_$1.isNil(cfg.rowlen)) {
      cfg.rowlen = {};
    }
    _$1.forEach(ctx.luckysheet_select_save, function(selection) {
      var _selection$row = _slicedToArray$1(selection.row, 2), row_st = _selection$row[0], row_ed = _selection$row[1];
      var _selection$column = _slicedToArray$1(selection.column, 2), col_st = _selection$column[0], col_ed = _selection$column[1];
      updateFormatCell(ctx, d2, attr, foucsStatus, row_st, row_ed, col_st, col_ed, canvas);
    });
  }
  function toggleAttr(ctx, cellInput, attr) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var flag = isAllSelectedCellsInStatus(ctx, attr, 1);
    var foucsStatus = flag ? 0 : 1;
    updateFormat(ctx, cellInput, flowdata, attr, foucsStatus);
  }
  function setAttr(ctx, cellInput, attr, value, canvas) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    updateFormat(ctx, cellInput, flowdata, attr, value, canvas);
  }
  function checkNoNullValue(cell) {
    var v2 = cell;
    if (_$1.isPlainObject(v2)) {
      v2 = v2.v;
    }
    if (!isRealNull(v2) && isdatatypemulti(v2).num && (cell.ct == null || cell.ct.t == null || cell.ct.t === "n" || cell.ct.t === "g")) {
      return true;
    }
    return false;
  }
  function checkNoNullValueAll(cell) {
    var v2 = cell;
    if (_$1.isPlainObject(v2)) {
      v2 = v2.v;
    }
    if (!isRealNull(v2)) {
      return true;
    }
    return false;
  }
  function getNoNullValue(d2, st_x, ed2, type) {
    var hasValueStart = null;
    var nullNum = 0;
    var nullTime = 0;
    for (var r2 = ed2 - 1; r2 >= 0; r2 -= 1) {
      var cell = void 0;
      if (type === "c") {
        cell = d2[st_x][r2];
      } else {
        cell = d2[r2][st_x];
      }
      if (checkNoNullValue(cell)) {
        hasValueStart = r2;
      } else if (cell == null || cell.v == null || cell.v === "") {
        nullNum += 1;
        if (nullNum >= 40) {
          if (nullTime <= 0) {
            nullTime = 1;
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    return hasValueStart;
  }
  function activeFormulaInput(cellInput, fxInput, ctx, row_index, col_index, rowh, columnh, formula, cache, isnull) {
    if (isnull == null) {
      isnull = false;
    }
    ctx.luckysheetCellUpdate = [row_index, col_index];
    cache.doNotUpdateCell = true;
    if (isnull) {
      var _formulaTxt = '<span dir="auto" class="luckysheet-formula-text-color">=</span><span dir="auto" class="luckysheet-formula-text-color">'.concat(formula.toUpperCase(), '</span><span dir="auto" class="luckysheet-formula-text-color">(</span><span dir="auto" class="luckysheet-formula-text-color">)</span>');
      cellInput.innerHTML = _formulaTxt;
      var spanList = cellInput.querySelectorAll("span");
      setCaretPosition(ctx, spanList[spanList.length - 2], 0, 1);
      return;
    }
    var row_pre = rowLocationByIndex(rowh[0], ctx.visibledatarow)[0];
    var row = rowLocationByIndex(rowh[1], ctx.visibledatarow)[1];
    var col_pre = colLocationByIndex(columnh[0], ctx.visibledatacolumn)[0];
    var col = colLocationByIndex(columnh[1], ctx.visibledatacolumn)[1];
    var formulaTxt = '<span dir="auto" class="luckysheet-formula-text-color">=</span><span dir="auto" class="luckysheet-formula-text-color">'.concat(formula.toUpperCase(), '</span><span dir="auto" class="luckysheet-formula-text-color">(</span><span class="fortune-formula-functionrange-cell" rangeindex="0" dir="auto" style="color:').concat(colors[0], ';">').concat(getRangetxt(ctx, ctx.currentSheetId, {
      row: rowh,
      column: columnh
    }, ctx.currentSheetId), '</span><span dir="auto" class="luckysheet-formula-text-color">)</span>');
    cellInput.innerHTML = formulaTxt;
    israngeseleciton(ctx);
    ctx.formulaCache.rangestart = true;
    ctx.formulaCache.rangedrag_column_start = false;
    ctx.formulaCache.rangedrag_row_start = false;
    ctx.formulaCache.rangechangeindex = 0;
    rangeSetValue(ctx, cellInput, {
      row: rowh,
      column: columnh
    }, fxInput);
    ctx.formulaCache.func_selectedrange = {
      left: col_pre,
      width: col - col_pre - 1,
      top: row_pre,
      height: row - row_pre - 1,
      left_move: col_pre,
      width_move: col - col_pre - 1,
      top_move: row_pre,
      height_move: row - row_pre - 1,
      row: [row_index, row_index],
      column: [col_index, col_index]
    };
    createFormulaRangeSelect(ctx, {
      rangeIndex: ctx.formulaCache.rangeIndex || 0,
      left: col_pre,
      width: col - col_pre - 1,
      top: row_pre,
      height: row - row_pre - 1
    });
  }
  function backFormulaInput(d2, r2, c2, rowh, columnh, formula, ctx) {
    var _ctx$formulaCache;
    var f2 = "=".concat(formula.toUpperCase(), "(").concat(getRangetxt(ctx, ctx.currentSheetId, {
      row: rowh,
      column: columnh
    }, ctx.currentSheetId), ")");
    var v2 = execfunction(ctx, f2, r2, c2);
    var value = {
      v: v2[1],
      f: v2[2]
    };
    setCellValue(ctx, r2, c2, d2, value);
    (_ctx$formulaCache = ctx.formulaCache).execFunctionExist || (_ctx$formulaCache.execFunctionExist = []);
    ctx.formulaCache.execFunctionExist.push({
      r: r2,
      c: c2,
      i: ctx.currentSheetId
    });
  }
  function singleFormulaInput(cellInput, fxInput, ctx, d2, _index, fix, st_m, ed_m, formula, type, cache, noNum, noNull) {
    if (type == null) {
      type = "r";
    }
    if (noNum == null) {
      noNum = true;
    }
    if (noNull == null) {
      noNull = true;
    }
    var isNull = true;
    var isNum = false;
    for (var c2 = st_m; c2 <= ed_m; c2 += 1) {
      var cell = null;
      if (type === "c") {
        cell = d2[c2][fix];
      } else {
        cell = d2[fix][c2];
      }
      if (checkNoNullValue(cell)) {
        isNull = false;
        isNum = true;
      } else if (checkNoNullValueAll(cell)) {
        isNull = false;
      }
    }
    if (isNull && noNull) {
      var st_r_r = getNoNullValue(d2, _index, fix, type);
      if (st_r_r == null) {
        if (type === "c") {
          activeFormulaInput(cellInput, fxInput, ctx, _index, fix, null, null, formula, cache, true);
        } else {
          activeFormulaInput(cellInput, fxInput, ctx, fix, _index, null, null, formula, cache, true);
        }
      } else {
        if (_index === st_m) {
          for (var _c2 = st_m; _c2 <= ed_m; _c2 += 1) {
            st_r_r = getNoNullValue(d2, _c2, fix, type);
            if (st_r_r == null) {
              break;
            }
            if (type === "c") {
              backFormulaInput(d2, _c2, fix, [_c2, _c2], [st_r_r, fix - 1], formula, ctx);
            } else {
              backFormulaInput(d2, fix, _c2, [st_r_r, fix - 1], [_c2, _c2], formula, ctx);
            }
          }
        } else {
          for (var _c3 = ed_m; _c3 >= st_m; _c3 -= 1) {
            st_r_r = getNoNullValue(d2, _c3, fix, type);
            if (st_r_r == null) {
              break;
            }
            if (type === "c") {
              backFormulaInput(d2, _c3, fix, [_c3, _c3], [st_r_r, fix - 1], formula, ctx);
            } else {
              backFormulaInput(d2, fix, _c3, [st_r_r, fix - 1], [_c3, _c3], formula, ctx);
            }
          }
        }
      }
      return false;
    }
    if (isNum && noNum) {
      var _cell = null;
      if (type === "c") {
        _cell = d2[ed_m + 1][fix];
      } else {
        _cell = d2[fix][ed_m + 1];
      }
      if (_cell != null && _cell.v != null && _cell.v.toString().length > 0) {
        var _c4 = ed_m + 1;
        if (type === "c") {
          _cell = d2[ed_m + 1][fix];
        } else {
          _cell = d2[fix][ed_m + 1];
        }
        while (_cell != null && _cell.v != null && _cell.v.toString().length > 0) {
          _c4 += 1;
          var len = null;
          if (type === "c") {
            len = d2.length;
          } else {
            len = d2[0].length;
          }
          if (_c4 >= len) {
            return false;
          }
          if (type === "c") {
            _cell = d2[_c4][fix];
          } else {
            _cell = d2[fix][_c4];
          }
        }
        if (type === "c") {
          backFormulaInput(d2, _c4, fix, [st_m, ed_m], [fix, fix], formula, ctx);
        } else {
          backFormulaInput(d2, fix, _c4, [fix, fix], [st_m, ed_m], formula, ctx);
        }
      } else {
        if (type === "c") {
          backFormulaInput(d2, ed_m + 1, fix, [st_m, ed_m], [fix, fix], formula, ctx);
        } else {
          backFormulaInput(d2, fix, ed_m + 1, [fix, fix], [st_m, ed_m], formula, ctx);
        }
      }
      return false;
    }
    return true;
  }
  function autoSelectionFormula(ctx, cellInput, fxInput, formula, cache) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return;
    var isfalse = true;
    ctx.formulaCache.execFunctionExist = [];
    function execFormulaInput_c(d2, st_r, ed_r, st_c, ed_c, _formula) {
      var st_c_c = getNoNullValue(d2, st_r, ed_c, "c");
      if (st_c_c == null) {
        activeFormulaInput(cellInput, fxInput, ctx, st_r, st_c, null, null, _formula, cache, true);
      } else {
        activeFormulaInput(cellInput, fxInput, ctx, st_r, st_c, [st_r, ed_r], [st_c_c, ed_c - 1], _formula, cache);
      }
    }
    function execFormulaInput(d2, st_r, ed_r, st_c, ed_c, _formula) {
      var st_r_c = getNoNullValue(d2, st_c, ed_r, "r");
      if (st_r_c == null) {
        execFormulaInput_c(d2, st_r, ed_r, st_c, ed_c, _formula);
      } else {
        activeFormulaInput(cellInput, fxInput, ctx, st_r, st_c, [st_r_c, ed_r - 1], [st_c, ed_c], _formula, cache);
      }
    }
    if (!ctx.luckysheet_select_save) return;
    _$1.forEach(ctx.luckysheet_select_save, function(selection) {
      var _selection$row2 = _slicedToArray$1(selection.row, 2), st_r = _selection$row2[0], ed_r = _selection$row2[1];
      var _selection$column2 = _slicedToArray$1(selection.column, 2), st_c = _selection$column2[0], ed_c = _selection$column2[1];
      var row_index = selection.row_focus;
      var col_index = selection.column_focus;
      if (st_r === ed_r && st_c === ed_c) {
        if (ed_r - 1 < 0 && ed_c - 1 < 0) {
          activeFormulaInput(cellInput, fxInput, ctx, st_r, st_c, null, null, formula, cache, true);
          return;
        }
        if (ed_r - 1 >= 0 && checkNoNullValue(flowdata[ed_r - 1][st_c])) {
          execFormulaInput(flowdata, st_r, ed_r, st_c, ed_c, formula);
        } else if (ed_c - 1 >= 0 && checkNoNullValue(flowdata[st_r][ed_c - 1])) {
          execFormulaInput_c(flowdata, st_r, ed_r, st_c, ed_c, formula);
        } else {
          execFormulaInput(flowdata, st_r, ed_r, st_c, ed_c, formula);
        }
      } else if (st_r === ed_r) {
        isfalse = singleFormulaInput(cellInput, fxInput, ctx, flowdata, col_index, st_r, st_c, ed_c, formula, "r", cache);
      } else if (st_c === ed_c) {
        isfalse = singleFormulaInput(cellInput, fxInput, ctx, flowdata, row_index, st_c, st_r, ed_r, formula, "c", cache);
      } else {
        var r_false = true;
        for (var r2 = st_r; r2 <= ed_r; r2 += 1) {
          r_false = singleFormulaInput(cellInput, fxInput, ctx, flowdata, col_index, r2, st_c, ed_c, formula, "r", cache, true, false) && r_false;
        }
        var c_false = true;
        for (var c2 = st_c; c2 <= ed_c; c2 += 1) {
          c_false = singleFormulaInput(cellInput, fxInput, ctx, flowdata, row_index, c2, st_r, ed_r, formula, "c", cache, true, false) && c_false;
        }
        isfalse = !!r_false && !!c_false;
      }
      isfalse = isfalse && isfalse;
    });
    if (!isfalse) {
      ctx.formulaCache.execFunctionExist.reverse();
      execFunctionGroup(ctx, null, null, null, null, flowdata);
      ctx.formulaCache.execFunctionGlobalData = null;
    }
  }
  function cancelPaintModel(ctx) {
    var _ctx$luckysheet_copy_;
    if (ctx.luckysheet_copy_save === null) return;
    if (((_ctx$luckysheet_copy_ = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_ === void 0 ? void 0 : _ctx$luckysheet_copy_.dataSheetId) === ctx.currentSheetId) {
      ctx.luckysheet_selection_range = [];
      selectionCopyShow(ctx.luckysheet_selection_range, ctx);
    } else {
      if (!ctx.luckysheet_copy_save) return;
      var index2 = getSheetIndex(ctx, ctx.luckysheet_copy_save.dataSheetId);
      if (!index2) return;
      ctx.luckysheetfile[index2].luckysheet_selection_range = [];
    }
    ctx.luckysheet_copy_save = {
      dataSheetId: "",
      copyRange: [{
        row: [0],
        column: [0]
      }],
      RowlChange: false,
      HasMC: false
    };
    ctx.luckysheetPaintModelOn = false;
  }
  function handleCurrencyFormat(ctx, cellInput) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    updateFormat(ctx, cellInput, flowdata, "ct", "¥ #.00");
  }
  function handlePercentageFormat(ctx, cellInput) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    updateFormat(ctx, cellInput, flowdata, "ct", "0.00%");
  }
  function handleNumberDecrease(ctx, cellInput) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata || !ctx.luckysheet_select_save) return;
    var row_index = ctx.luckysheet_select_save[0].row_focus;
    var col_index = ctx.luckysheet_select_save[0].column_focus;
    if (row_index === void 0 || col_index === void 0) return;
    var foucsStatus = normalizedAttr(flowdata, row_index, col_index, "ct");
    var cell = flowdata[row_index][col_index];
    if (foucsStatus == null || foucsStatus.t !== "n") {
      return;
    }
    if (foucsStatus.fa === "General") {
      if (!cell || !cell.v) return;
      var mask = genarate(cell.v);
      if (!mask || mask.length < 2) return;
      var _mask = _slicedToArray$1(mask, 2);
      foucsStatus = _mask[1];
    }
    var reg = /^(w|W)((0?)|(0\.0+))$/;
    if (reg.test(foucsStatus.fa)) {
      if (foucsStatus.fa.indexOf(".") > -1) {
        if (foucsStatus.fa.substr(-2) === ".0") {
          updateFormat(ctx, cellInput, flowdata, "ct", foucsStatus.fa.split(".")[0]);
        } else {
          updateFormat(ctx, cellInput, flowdata, "ct", foucsStatus.fa.substr(0, foucsStatus.fa.length - 1));
        }
      } else {
        updateFormat(ctx, cellInput, flowdata, "ct", foucsStatus.fa);
      }
      return;
    }
    var prefix = "";
    var main = "";
    var fa2 = [];
    if (foucsStatus.fa.indexOf(".") > -1) {
      fa2 = foucsStatus.fa.split(".");
      var _fa = fa2;
      var _fa2 = _slicedToArray$1(_fa, 2);
      prefix = _fa2[0];
      main = _fa2[1];
    } else {
      return;
    }
    fa2 = main.split("");
    var tail = "";
    for (var i2 = fa2.length - 1; i2 >= 0; i2 -= 1) {
      var c2 = fa2[i2];
      if (c2 !== "#" && c2 !== "0" && c2 !== "," && Number.isNaN(parseInt(c2, 10))) {
        tail = c2 + tail;
      } else {
        break;
      }
    }
    var fmt = "";
    if (foucsStatus.fa.indexOf(".") > -1) {
      var suffix = main;
      if (tail.length > 0) {
        suffix = main.replace(tail, "");
      }
      var pos = suffix.replace(/#/g, "0");
      pos = pos.substr(0, pos.length - 1);
      if (pos === "") {
        fmt = prefix + tail;
      } else {
        fmt = "".concat(prefix, ".").concat(pos).concat(tail);
      }
    }
    updateFormat(ctx, cellInput, flowdata, "ct", fmt);
  }
  function handleNumberIncrease(ctx, cellInput) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    if (!ctx.luckysheet_select_save) return;
    var row_index = ctx.luckysheet_select_save[0].row_focus;
    var col_index = ctx.luckysheet_select_save[0].column_focus;
    if (row_index === void 0 || col_index === void 0) return;
    var foucsStatus = normalizedAttr(flowdata, row_index, col_index, "ct");
    var cell = flowdata[row_index][col_index];
    if (foucsStatus == null || foucsStatus.t !== "n") {
      return;
    }
    if (foucsStatus.fa === "General") {
      if (!cell || !cell.v) return;
      var mask = genarate(cell.v);
      if (!mask || mask.length < 2) return;
      var _mask2 = _slicedToArray$1(mask, 2);
      foucsStatus = _mask2[1];
    }
    if (foucsStatus.fa === "General") {
      updateFormat(ctx, cellInput, flowdata, "ct", "#.0");
      return;
    }
    var reg = /^(w|W)((0?)|(0\.0+))$/;
    if (reg.test(foucsStatus.fa)) {
      if (foucsStatus.fa.indexOf(".") > -1) {
        updateFormat(ctx, cellInput, flowdata, "ct", "".concat(foucsStatus.fa, "0"));
      } else {
        if (foucsStatus.fa.substr(-1) === "0") {
          updateFormat(ctx, cellInput, flowdata, "ct", "".concat(foucsStatus.fa, ".0"));
        } else {
          updateFormat(ctx, cellInput, flowdata, "ct", "".concat(foucsStatus.fa, "0.0"));
        }
      }
      return;
    }
    var prefix = "";
    var main = "";
    var fa2 = [];
    if (foucsStatus.fa.indexOf(".") > -1) {
      fa2 = foucsStatus.fa.split(".");
      var _fa3 = fa2;
      var _fa4 = _slicedToArray$1(_fa3, 2);
      prefix = _fa4[0];
      main = _fa4[1];
    } else {
      main = foucsStatus.fa;
    }
    fa2 = main.split("");
    var tail = "";
    for (var i2 = fa2.length - 1; i2 >= 0; i2 -= 1) {
      var c2 = fa2[i2];
      if (c2 !== "#" && c2 !== "0" && c2 !== "," && Number.isNaN(parseInt(c2, 10))) {
        tail = c2 + tail;
      } else {
        break;
      }
    }
    var fmt = "";
    if (foucsStatus.fa.indexOf(".") > -1) {
      var suffix = main;
      if (tail.length > 0) {
        suffix = main.replace(tail, "");
      }
      var pos = suffix.replace(/#/g, "0");
      pos += "0";
      fmt = "".concat(prefix, ".").concat(pos).concat(tail);
    } else {
      if (tail.length > 0) {
        fmt = "".concat(main.replace(tail, ""), ".0").concat(tail);
      } else {
        fmt = "".concat(main, ".0").concat(tail);
      }
    }
    updateFormat(ctx, cellInput, flowdata, "ct", fmt);
  }
  function handleBold(ctx, cellInput) {
    toggleAttr(ctx, cellInput, "bl");
  }
  function handleItalic(ctx, cellInput) {
    toggleAttr(ctx, cellInput, "it");
  }
  function handleStrikeThrough(ctx, cellInput) {
    toggleAttr(ctx, cellInput, "cl");
  }
  function handleUnderline(ctx, cellInput) {
    toggleAttr(ctx, cellInput, "un");
  }
  function handleHorizontalAlign(ctx, cellInput, value) {
    setAttr(ctx, cellInput, "ht", value);
  }
  function handleVerticalAlign(ctx, cellInput, value) {
    setAttr(ctx, cellInput, "vt", value);
  }
  function handleFormatPainter(ctx) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (ctx.luckysheet_select_save == null || ctx.luckysheet_select_save.length === 0) {
      return;
    }
    if (ctx.luckysheet_select_save.length > 1) {
      return;
    }
    var has_PartMC = false;
    var r1 = ctx.luckysheet_select_save[0].row[0];
    var r2 = ctx.luckysheet_select_save[0].row[1];
    var c1 = ctx.luckysheet_select_save[0].column[0];
    var c2 = ctx.luckysheet_select_save[0].column[1];
    has_PartMC = hasPartMC(ctx, ctx.config, r1, r2, c1, c2);
    if (has_PartMC) {
      return;
    }
    cancelPaintModel(ctx);
    ctx.luckysheet_selection_range = [{
      row: ctx.luckysheet_select_save[0].row,
      column: ctx.luckysheet_select_save[0].column
    }];
    selectionCopyShow(ctx.luckysheet_selection_range, ctx);
    var RowlChange = false;
    var HasMC = false;
    for (var r3 = ctx.luckysheet_select_save[0].row[0]; r3 <= ctx.luckysheet_select_save[0].row[1]; r3 += 1) {
      if (ctx.config.rowhidden != null && ctx.config.rowhidden[r3] != null) {
        continue;
      }
      if (ctx.config.rowlen != null && r3 in ctx.config.rowlen) {
        RowlChange = true;
      }
      for (var c3 = ctx.luckysheet_select_save[0].column[0]; c3 <= ctx.luckysheet_select_save[0].column[1]; c3 += 1) {
        var flowdata = getFlowdata(ctx);
        if (!flowdata) return;
        var cell = flowdata[r3][c3];
        if (cell != null && cell.mc != null && cell.mc.rs != null) {
          HasMC = true;
        }
      }
    }
    ctx.luckysheet_copy_save = {
      dataSheetId: ctx.currentSheetId,
      copyRange: [{
        row: ctx.luckysheet_select_save[0].row,
        column: ctx.luckysheet_select_save[0].column
      }],
      RowlChange,
      HasMC
    };
    ctx.luckysheetPaintModelOn = true;
    ctx.luckysheetPaintSingle = true;
  }
  function handleClearFormat(ctx) {
    var _ctx$luckysheet_selec;
    if (ctx.allowEdit === false) return;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec.every(function(selection) {
      var _selection$row3 = _slicedToArray$1(selection.row, 2), rowSt = _selection$row3[0], rowEd = _selection$row3[1];
      var _selection$column3 = _slicedToArray$1(selection.column, 2), colSt = _selection$column3[0], colEd = _selection$column3[1];
      for (var r2 = rowSt; r2 <= rowEd; r2 += 1) {
        if (!_$1.isNil(ctx.config.rowhidden) && !_$1.isNil(ctx.config.rowhidden[r2])) {
          continue;
        }
        for (var c2 = colSt; c2 <= colEd; c2 += 1) {
          var cell = flowdata[r2][c2];
          if (!cell) continue;
          flowdata[r2][c2] = _$1.pick(cell, "v", "m", "mc", "f", "ct");
        }
      }
      var index2 = getSheetIndex(ctx, ctx.currentSheetId);
      if (index2 == null) return false;
      if (ctx.config.borderInfo == null) return false;
      var cfg = ctx.config || {};
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var source_borderInfo = [];
        for (var i2 = 0; i2 < cfg.borderInfo.length; i2 += 1) {
          var bd_rangeType = cfg.borderInfo[i2].rangeType;
          if (bd_rangeType === "range" && cfg.borderInfo[i2].borderType !== "border-slash") {
            var bd_range = cfg.borderInfo[i2].range;
            var bd_emptyRange = [];
            for (var j2 = 0; j2 < bd_range.length; j2 += 1) {
              bd_emptyRange = bd_emptyRange.concat(cfSplitRange(bd_range[j2], {
                row: [rowSt, rowEd],
                column: [colSt, colEd]
              }, {
                row: [rowSt, rowEd],
                column: [colSt, colEd]
              }));
            }
            cfg.borderInfo[i2].range = bd_emptyRange;
            source_borderInfo.push(cfg.borderInfo[i2]);
          } else if (bd_rangeType === "cell") {
            var bd_r = cfg.borderInfo[i2].value.row_index;
            var bd_c = cfg.borderInfo[i2].value.col_index;
            if (!(bd_r >= rowSt && bd_r <= rowEd && bd_c >= colSt && bd_c <= colEd)) {
              source_borderInfo.push(cfg.borderInfo[i2]);
            }
          } else if (bd_rangeType === "range" && cfg.borderInfo[i2].borderType === "border-slash" && !(cfg.borderInfo[i2].range[0].row[0] >= rowSt && cfg.borderInfo[i2].range[0].row[0] <= rowEd && cfg.borderInfo[i2].range[0].column[0] >= colSt && cfg.borderInfo[i2].range[0].column[0] <= colEd)) {
            source_borderInfo.push(cfg.borderInfo[i2]);
          }
        }
        ctx.luckysheetfile[index2].config.borderInfo = source_borderInfo;
      }
      return true;
    });
  }
  function handleTextColor(ctx, cellInput, color) {
    setAttr(ctx, cellInput, "fc", color);
  }
  function handleTextBackground(ctx, cellInput, color) {
    setAttr(ctx, cellInput, "bg", color);
  }
  function handleBorder(ctx, type, borderColor, borderStyle) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (type == null) {
      type = "border-all";
    }
    var color = borderColor;
    var style = borderStyle;
    if (color == null || color === "") {
      color = "#000";
    }
    if (style == null || style === "") {
      style = "1";
    }
    var cfg = ctx.config;
    if (cfg.borderInfo == null) {
      cfg.borderInfo = [];
    }
    if (type !== "border-slash") {
      var borderInfo = {
        rangeType: "range",
        borderType: type,
        color,
        style,
        range: _$1.cloneDeep(ctx.luckysheet_select_save) || []
      };
      cfg.borderInfo.push(borderInfo);
    } else {
      var rangeList = [];
      _$1.forEach(ctx.luckysheet_select_save, function(selection) {
        for (var r2 = selection.row[0]; r2 <= selection.row[1]; r2 += 1) {
          for (var c2 = selection.column[0]; c2 <= selection.column[1]; c2 += 1) {
            var range = "".concat(r2, "_").concat(c2);
            if (_$1.includes(rangeList, range)) continue;
            var _borderInfo = {
              rangeType: "range",
              borderType: type,
              color,
              style,
              range: normalizeSelection(ctx, [{
                row: [r2, r2],
                column: [c2, c2]
              }])
            };
            cfg.borderInfo.push(_borderInfo);
            rangeList.push(range);
          }
        }
      });
    }
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (index2 == null) return;
    ctx.luckysheetfile[index2].config = ctx.config;
  }
  function handleMerge(ctx, type) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (selectIsOverlap(ctx)) {
      return;
    }
    if (ctx.config.merge != null) {
      var has_PartMC = false;
      if (!ctx.luckysheet_select_save) return;
      for (var s2 = 0; s2 < ctx.luckysheet_select_save.length; s2 += 1) {
        var r1 = ctx.luckysheet_select_save[s2].row[0];
        var r2 = ctx.luckysheet_select_save[s2].row[1];
        var c1 = ctx.luckysheet_select_save[s2].column[0];
        var c2 = ctx.luckysheet_select_save[s2].column[1];
        has_PartMC = hasPartMC(ctx, ctx.config, r1, r2, c1, c2);
        if (has_PartMC) {
          break;
        }
      }
      if (has_PartMC) {
        return;
      }
    }
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    if (!ctx.luckysheet_select_save) return;
    mergeCells(ctx, ctx.currentSheetId, ctx.luckysheet_select_save, type);
  }
  function handleSort(ctx, isAsc) {
    sortSelection(ctx, isAsc);
  }
  function handleFreeze(ctx, type) {
    var _ctx$luckysheet_selec2, _ctx$config$merge;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var file = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)];
    if (!file) return;
    if (type === "freeze-cancel") {
      delete file.frozen;
      return;
    }
    var firstSelection = (_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2[0];
    if (!firstSelection) return;
    var row_focus = firstSelection.row_focus, column_focus = firstSelection.column_focus;
    if (row_focus == null || column_focus == null) return;
    var m2 = (_ctx$config$merge = ctx.config.merge) === null || _ctx$config$merge === void 0 ? void 0 : _ctx$config$merge["".concat(row_focus, "_").concat(column_focus)];
    if (m2) {
      row_focus = m2.r + m2.rs - 1;
      column_focus = m2.c + m2.cs - 1;
    }
    file.frozen = {
      type: "both",
      range: {
        row_focus,
        column_focus
      }
    };
    if (type === "freeze-row") {
      file.frozen.type = "rangeRow";
    } else if (type === "freeze-col") {
      file.frozen.type = "rangeColumn";
    }
  }
  function handleTextSize(ctx, cellInput, size2, canvas) {
    setAttr(ctx, cellInput, "fs", size2, canvas);
  }
  function handleSum(ctx, cellInput, fxInput, cache) {
    autoSelectionFormula(ctx, cellInput, fxInput, "SUM", cache);
  }
  function handleLink(ctx) {
    var _ctx$luckysheet_selec3;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var selection = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3[0];
    var flowdata = getFlowdata(ctx);
    if (flowdata != null && selection != null) {
      showLinkCard(ctx, selection.row[0], selection.column[0], true);
    }
  }
  var handlerMap = {
    "currency-format": handleCurrencyFormat,
    "percentage-format": handlePercentageFormat,
    "number-decrease": handleNumberDecrease,
    "number-increase": handleNumberIncrease,
    "sort-cell": function sortCell(ctx) {
      return handleSort(ctx, true);
    },
    "merge-all": function mergeAll(ctx) {
      return handleMerge(ctx, "mergeAll");
    },
    "border-all": function borderAll(ctx) {
      return handleBorder(ctx, "border-all");
    },
    bold: handleBold,
    italic: handleItalic,
    "strike-through": handleStrikeThrough,
    underline: handleUnderline,
    "clear-format": handleClearFormat,
    "format-painter": handleFormatPainter,
    search: function search(ctx) {
      ctx.showSearch = true;
    },
    link: handleLink
  };
  var selectedMap = {
    bold: function bold(cell) {
      return (cell === null || cell === void 0 ? void 0 : cell.bl) === 1;
    },
    italic: function italic(cell) {
      return (cell === null || cell === void 0 ? void 0 : cell.it) === 1;
    },
    "strike-through": function strikeThrough(cell) {
      return (cell === null || cell === void 0 ? void 0 : cell.cl) === 1;
    },
    underline: function underline(cell) {
      return (cell === null || cell === void 0 ? void 0 : cell.un) === 1;
    }
  };
  function toolbarItemClickHandler(name) {
    return handlerMap[name];
  }
  function toolbarItemSelectedFunc(name) {
    return selectedMap[name];
  }
  function getArrowCanvasSize(fromX, fromY, toX, toY) {
    var left = toX - 5;
    if (fromX < toX) {
      left = fromX - 5;
    }
    var top = toY - 5;
    if (fromY < toY) {
      top = fromY - 5;
    }
    var width = Math.abs(fromX - toX) + 10;
    var height = Math.abs(fromY - toY) + 10;
    var x1 = width - 5;
    var x2 = 5;
    if (fromX < toX) {
      x1 = 5;
      x2 = width - 5;
    }
    var y1 = height - 5;
    var y2 = 5;
    if (fromY < toY) {
      y1 = 5;
      y2 = height - 5;
    }
    return {
      left,
      top,
      width,
      height,
      fromX: x1,
      fromY: y1,
      toX: x2,
      toY: y2
    };
  }
  function drawArrow(rc2, _ref, color, theta, headlen) {
    var left = _ref.left, top = _ref.top, width = _ref.width, height = _ref.height, fromX = _ref.fromX, fromY = _ref.fromY, toX = _ref.toX, toY = _ref.toY;
    var canvas = document.getElementById("arrowCanvas-".concat(rc2));
    var ctx = canvas.getContext("2d");
    if (!canvas || !ctx) return;
    canvas.style.width = "".concat(width, "px");
    canvas.style.height = "".concat(height, "px");
    canvas.width = width;
    canvas.height = height;
    canvas.style.left = "".concat(left, "px");
    canvas.style.top = "".concat(top, "px");
    var _canvas$getBoundingCl = canvas.getBoundingClientRect(), canvasWidth = _canvas$getBoundingCl.width, canvasHeight = _canvas$getBoundingCl.height;
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    theta = theta || 30;
    headlen = headlen || 6;
    var arrowWidth = 1;
    color = color || "#000";
    var angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI;
    var angle1 = (angle + theta) * Math.PI / 180;
    var angle2 = (angle - theta) * Math.PI / 180;
    var topX = headlen * Math.cos(angle1);
    var topY = headlen * Math.sin(angle1);
    var botX = headlen * Math.cos(angle2);
    var botY = headlen * Math.sin(angle2);
    ctx.save();
    ctx.beginPath();
    var arrowX = fromX - topX;
    var arrowY = fromY - topY;
    ctx.moveTo(arrowX, arrowY);
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.lineWidth = arrowWidth;
    ctx.strokeStyle = color;
    ctx.stroke();
    arrowX = toX + topX;
    arrowY = toY + topY;
    ctx.moveTo(arrowX, arrowY);
    ctx.lineTo(toX, toY);
    arrowX = toX + botX;
    arrowY = toY + botY;
    ctx.lineTo(arrowX, arrowY);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }
  var commentBoxProps = {
    defaultWidth: 144,
    defaultHeight: 84
  };
  function getCellTopRightPostion(ctx, flowdata, r2, c2) {
    var row_pre = r2 - 1 === -1 ? 0 : ctx.visibledatarow[r2 - 1];
    var col = ctx.visibledatacolumn[c2];
    var margeset = mergeBorder(ctx, flowdata, r2, c2);
    if (margeset) {
      var _margeset$row = _slicedToArray$1(margeset.row, 1);
      row_pre = _margeset$row[0];
      var _margeset$column = _slicedToArray$1(margeset.column, 2);
      col = _margeset$column[1];
    }
    var toX = col;
    var toY = row_pre;
    return {
      toX,
      toY
    };
  }
  function getCommentBoxByRC(ctx, flowdata, r2, c2) {
    var _flowdata$r$c;
    var comment = (_flowdata$r$c = flowdata[r2][c2]) === null || _flowdata$r$c === void 0 ? void 0 : _flowdata$r$c.ps;
    var _getCellTopRightPosti = getCellTopRightPostion(ctx, flowdata, r2, c2), toX = _getCellTopRightPosti.toX, toY = _getCellTopRightPosti.toY;
    var left = (comment === null || comment === void 0 ? void 0 : comment.left) == null ? toX + 18 * ctx.zoomRatio : comment.left * ctx.zoomRatio;
    var top = (comment === null || comment === void 0 ? void 0 : comment.top) == null ? toY - 18 * ctx.zoomRatio : comment.top * ctx.zoomRatio;
    var width = (comment === null || comment === void 0 ? void 0 : comment.width) == null ? commentBoxProps.defaultWidth * ctx.zoomRatio : comment.width * ctx.zoomRatio;
    var height = (comment === null || comment === void 0 ? void 0 : comment.height) == null ? commentBoxProps.defaultHeight * ctx.zoomRatio : comment.height * ctx.zoomRatio;
    var value = (comment === null || comment === void 0 ? void 0 : comment.value) == null ? "" : comment.value;
    if (top < 0) {
      top = 2;
    }
    var size2 = getArrowCanvasSize(left, top, toX, toY);
    var rc2 = "".concat(r2, "_").concat(c2);
    return {
      r: r2,
      c: c2,
      rc: rc2,
      left,
      top,
      width,
      height,
      value,
      size: size2,
      autoFocus: false
    };
  }
  function setEditingComment(ctx, flowdata, r2, c2) {
    ctx.editingCommentBox = getCommentBoxByRC(ctx, flowdata, r2, c2);
  }
  function removeEditingComment(ctx, globalCache) {
    var _ctx$hooks$beforeUpda, _ctx$hooks;
    var editingCommentBoxEle = globalCache.editingCommentBoxEle;
    ctx.editingCommentBox = void 0;
    var r2 = editingCommentBoxEle === null || editingCommentBoxEle === void 0 ? void 0 : editingCommentBoxEle.dataset.r;
    var c2 = editingCommentBoxEle === null || editingCommentBoxEle === void 0 ? void 0 : editingCommentBoxEle.dataset.c;
    if (!r2 || !c2 || !editingCommentBoxEle) return;
    r2 = parseInt(r2, 10);
    c2 = parseInt(c2, 10);
    var value = editingCommentBoxEle.innerHTML || "";
    var flowdata = getFlowdata(ctx);
    globalCache.editingCommentBoxEle = void 0;
    if (!flowdata) return;
    if (((_ctx$hooks$beforeUpda = (_ctx$hooks = ctx.hooks).beforeUpdateComment) === null || _ctx$hooks$beforeUpda === void 0 ? void 0 : _ctx$hooks$beforeUpda.call(_ctx$hooks, r2, c2, value)) === false) {
      return;
    }
    var cell = flowdata === null || flowdata === void 0 ? void 0 : flowdata[r2][c2];
    if (!(cell === null || cell === void 0 ? void 0 : cell.ps)) return;
    var oldValue = cell.ps.value;
    cell.ps.value = value;
    if (!cell.ps.isShow) {
      ctx.commentBoxes = _$1.filter(ctx.commentBoxes, function(v2) {
        return v2.rc !== "".concat(r2, "_").concat(c2);
      });
    }
    if (ctx.hooks.afterUpdateComment) {
      setTimeout(function() {
        var _ctx$hooks$afterUpdat, _ctx$hooks2;
        (_ctx$hooks$afterUpdat = (_ctx$hooks2 = ctx.hooks).afterUpdateComment) === null || _ctx$hooks$afterUpdat === void 0 ? void 0 : _ctx$hooks$afterUpdat.call(_ctx$hooks2, r2, c2, oldValue, value);
      });
    }
  }
  function newComment(ctx, globalCache, r2, c2) {
    var _ctx$hooks$beforeInse, _ctx$hooks3;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (((_ctx$hooks$beforeInse = (_ctx$hooks3 = ctx.hooks).beforeInsertComment) === null || _ctx$hooks$beforeInse === void 0 ? void 0 : _ctx$hooks$beforeInse.call(_ctx$hooks3, r2, c2)) === false) {
      return;
    }
    removeEditingComment(ctx, globalCache);
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var cell = flowdata[r2][c2];
    if (cell == null) {
      cell = {};
      flowdata[r2][c2] = cell;
    }
    cell.ps = {
      left: null,
      top: null,
      width: null,
      height: null,
      value: "",
      isShow: false
    };
    ctx.editingCommentBox = _objectSpread2$1(_objectSpread2$1({}, getCommentBoxByRC(ctx, flowdata, r2, c2)), {}, {
      autoFocus: true
    });
    if (ctx.hooks.afterInsertComment) {
      setTimeout(function() {
        var _ctx$hooks$afterInser, _ctx$hooks4;
        (_ctx$hooks$afterInser = (_ctx$hooks4 = ctx.hooks).afterInsertComment) === null || _ctx$hooks$afterInser === void 0 ? void 0 : _ctx$hooks$afterInser.call(_ctx$hooks4, r2, c2);
      });
    }
  }
  function editComment(ctx, globalCache, r2, c2) {
    var _flowdata$r$c2;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var flowdata = getFlowdata(ctx);
    removeEditingComment(ctx, globalCache);
    var comment = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$r$c2 = flowdata[r2][c2]) === null || _flowdata$r$c2 === void 0 ? void 0 : _flowdata$r$c2.ps;
    var commentBoxes = _$1.concat(ctx.commentBoxes, ctx.editingCommentBox);
    if (_$1.findIndex(commentBoxes, function(v2) {
      return (v2 === null || v2 === void 0 ? void 0 : v2.rc) === "".concat(r2, "_").concat(c2);
    }) !== -1) {
      var editCommentBox = document.getElementById("comment-editor-".concat(r2, "_").concat(c2));
      editCommentBox === null || editCommentBox === void 0 ? void 0 : editCommentBox.focus();
    }
    if (comment) {
      ctx.editingCommentBox = _objectSpread2$1(_objectSpread2$1({}, getCommentBoxByRC(ctx, flowdata, r2, c2)), {}, {
        autoFocus: true
      });
    }
  }
  function deleteComment(ctx, globalCache, r2, c2) {
    var _ctx$hooks$beforeDele, _ctx$hooks5;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (((_ctx$hooks$beforeDele = (_ctx$hooks5 = ctx.hooks).beforeDeleteComment) === null || _ctx$hooks$beforeDele === void 0 ? void 0 : _ctx$hooks$beforeDele.call(_ctx$hooks5, r2, c2)) === false) {
      return;
    }
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var cell = flowdata[r2][c2];
    if (!cell) return;
    cell.ps = void 0;
    if (ctx.hooks.afterDeleteComment) {
      setTimeout(function() {
        var _ctx$hooks$afterDelet, _ctx$hooks6;
        (_ctx$hooks$afterDelet = (_ctx$hooks6 = ctx.hooks).afterDeleteComment) === null || _ctx$hooks$afterDelet === void 0 ? void 0 : _ctx$hooks$afterDelet.call(_ctx$hooks6, r2, c2);
      });
    }
  }
  function showComments(ctx, commentShowCells) {
    var flowdata = getFlowdata(ctx);
    if (flowdata) {
      var commentBoxes = commentShowCells.map(function(_ref2) {
        var r2 = _ref2.r, c2 = _ref2.c;
        return getCommentBoxByRC(ctx, flowdata, r2, c2);
      });
      ctx.commentBoxes = commentBoxes;
    }
  }
  function showHideComment(ctx, globalCache, r2, c2) {
    var _flowdata$r$c3;
    var flowdata = getFlowdata(ctx);
    var comment = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$r$c3 = flowdata[r2][c2]) === null || _flowdata$r$c3 === void 0 ? void 0 : _flowdata$r$c3.ps;
    if (!comment) return;
    var isShow = comment.isShow;
    var rc2 = "".concat(r2, "_").concat(c2);
    if (isShow) {
      comment.isShow = false;
      ctx.commentBoxes = _$1.filter(ctx.commentBoxes, function(v2) {
        return v2.rc !== rc2;
      });
    } else {
      comment.isShow = true;
    }
  }
  function showHideAllComments(ctx) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var isAllShow = true;
    var allComments = [];
    for (var r2 = 0; r2 < flowdata.length; r2 += 1) {
      for (var c2 = 0; c2 < flowdata[0].length; c2 += 1) {
        var cell = flowdata[r2][c2];
        if (cell === null || cell === void 0 ? void 0 : cell.ps) {
          allComments.push({
            r: r2,
            c: c2
          });
          if (!cell.ps.isShow) {
            isAllShow = false;
          }
        }
      }
    }
    if (allComments.length > 0) {
      if (isAllShow) {
        for (var i2 = 0; i2 < allComments.length; i2 += 1) {
          var _flowdata$_r$_c;
          var _allComments$i = allComments[i2], _r = _allComments$i.r, _c = _allComments$i.c;
          var comment = (_flowdata$_r$_c = flowdata[_r][_c]) === null || _flowdata$_r$_c === void 0 ? void 0 : _flowdata$_r$_c.ps;
          if (comment === null || comment === void 0 ? void 0 : comment.isShow) {
            comment.isShow = false;
          }
        }
        ctx.commentBoxes = [];
      } else {
        for (var _i = 0; _i < allComments.length; _i += 1) {
          var _flowdata$_r2$_c;
          var _allComments$_i = allComments[_i], _r2 = _allComments$_i.r, _c2 = _allComments$_i.c;
          var _comment = (_flowdata$_r2$_c = flowdata[_r2][_c2]) === null || _flowdata$_r2$_c === void 0 ? void 0 : _flowdata$_r2$_c.ps;
          if (_comment && !_comment.isShow) {
            _comment.isShow = true;
          }
        }
      }
    }
  }
  function overShowComment(ctx, e, scrollX, scrollY, container) {
    var _flowdata$r, _flowdata$r$c4, _ctx$editingCommentBo, _ctx$hoveredCommentBo;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var scrollLeft = scrollX.scrollLeft;
    var scrollTop = scrollY.scrollTop;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight;
    var offsetX = 0;
    var offsetY = 0;
    x2 += scrollLeft;
    y2 += scrollTop;
    var r2 = rowLocation(y2, ctx.visibledatarow)[2];
    var c2 = colLocation(x2, ctx.visibledatacolumn)[2];
    var margeset = mergeBorder(ctx, flowdata, r2, c2);
    if (margeset) {
      var _margeset$row2 = _slicedToArray$1(margeset.row, 3);
      r2 = _margeset$row2[2];
      var _margeset$column2 = _slicedToArray$1(margeset.column, 3);
      c2 = _margeset$column2[2];
    }
    var rc2 = "".concat(r2, "_").concat(c2);
    var comment = (_flowdata$r = flowdata[r2]) === null || _flowdata$r === void 0 ? void 0 : (_flowdata$r$c4 = _flowdata$r[c2]) === null || _flowdata$r$c4 === void 0 ? void 0 : _flowdata$r$c4.ps;
    if (comment == null || comment.isShow || _$1.findIndex(ctx.commentBoxes, function(v2) {
      return v2.rc === rc2;
    }) !== -1 || ((_ctx$editingCommentBo = ctx.editingCommentBox) === null || _ctx$editingCommentBo === void 0 ? void 0 : _ctx$editingCommentBo.rc) === rc2) {
      ctx.hoveredCommentBox = void 0;
      return;
    }
    if (((_ctx$hoveredCommentBo = ctx.hoveredCommentBox) === null || _ctx$hoveredCommentBo === void 0 ? void 0 : _ctx$hoveredCommentBo.rc) === rc2) return;
    var row_pre = r2 - 1 === -1 ? 0 : ctx.visibledatarow[r2 - 1];
    var col = ctx.visibledatacolumn[c2];
    if (margeset) {
      var _margeset$row3 = _slicedToArray$1(margeset.row, 1);
      row_pre = _margeset$row3[0];
      var _margeset$column3 = _slicedToArray$1(margeset.column, 2);
      col = _margeset$column3[1];
    }
    var toX = col + offsetX;
    var toY = row_pre + offsetY;
    var left = comment.left == null ? toX + 18 * ctx.zoomRatio : comment.left * ctx.zoomRatio;
    var top = comment.top == null ? toY - 18 * ctx.zoomRatio : comment.top * ctx.zoomRatio;
    if (top < 0) {
      top = 2;
    }
    var width = comment.width == null ? commentBoxProps.defaultWidth * ctx.zoomRatio : comment.width * ctx.zoomRatio;
    var height = comment.height == null ? commentBoxProps.defaultHeight * ctx.zoomRatio : comment.height * ctx.zoomRatio;
    var size2 = getArrowCanvasSize(left, top, toX, toY);
    var value = comment.value == null ? "" : comment.value;
    ctx.hoveredCommentBox = {
      r: r2,
      c: c2,
      rc: rc2,
      left,
      top,
      width,
      height,
      size: size2,
      value,
      autoFocus: false
    };
  }
  function getCommentBoxPosition(commentId) {
    var box = document.getElementById(commentId);
    if (!box) return void 0;
    var _box$getBoundingClien = box.getBoundingClientRect(), width = _box$getBoundingClien.width, height = _box$getBoundingClien.height;
    var left = box.offsetLeft;
    var top = box.offsetTop;
    return {
      left,
      top,
      width,
      height
    };
  }
  function onCommentBoxResizeStart(ctx, globalCache, e, _ref3, resizingId, resizingSide) {
    var r2 = _ref3.r, c2 = _ref3.c, rc2 = _ref3.rc;
    var position = getCommentBoxPosition(resizingId);
    if (position) {
      _$1.set(globalCache, "commentBox", {
        cursorMoveStartPosition: {
          x: e.pageX,
          y: e.pageY
        },
        resizingId,
        resizingSide,
        commentRC: {
          r: r2,
          c: c2,
          rc: rc2
        },
        boxInitialPosition: position
      });
    }
  }
  function onCommentBoxResize(ctx, globalCache, e) {
    if (ctx.allowEdit === false) return false;
    var commentBox = globalCache === null || globalCache === void 0 ? void 0 : globalCache.commentBox;
    if ((commentBox === null || commentBox === void 0 ? void 0 : commentBox.resizingId) && commentBox.resizingSide) {
      var box = document.getElementById(commentBox.resizingId);
      var _commentBox$cursorMov = commentBox.cursorMoveStartPosition, startX = _commentBox$cursorMov.x, startY = _commentBox$cursorMov.y;
      var _commentBox$boxInitia = commentBox.boxInitialPosition, top = _commentBox$boxInitia.top, left = _commentBox$boxInitia.left, width = _commentBox$boxInitia.width, height = _commentBox$boxInitia.height;
      var dx = e.pageX - startX;
      var dy = e.pageY - startY;
      var minHeight = 60 * ctx.zoomRatio;
      var minWidth = 1.5 * 60 * ctx.zoomRatio;
      if (["lm", "lt", "lb"].includes(commentBox.resizingSide)) {
        if (width - dx < minWidth) {
          left += width - minWidth;
          width = minWidth;
        } else {
          left += dx;
          width -= dx;
        }
        if (left < 0) left = 0;
        box.style.left = "".concat(left, "px");
      }
      if (["rm", "rt", "rb"].includes(commentBox.resizingSide)) {
        width = width + dx < minWidth ? minWidth : width + dx;
      }
      if (["mt", "lt", "rt"].includes(commentBox.resizingSide)) {
        if (height - dy < minHeight) {
          top += height - minHeight;
          height = minHeight;
        } else {
          top += dy;
          height -= dy;
        }
        if (top < 0) top = 0;
        box.style.top = "".concat(top, "px");
      }
      if (["mb", "lb", "rb"].includes(commentBox.resizingSide)) {
        height = height + dy < minHeight ? minHeight : height + dy;
      }
      box.style.width = "".concat(width, "px");
      box.style.height = "".concat(height, "px");
      return true;
    }
    return false;
  }
  function onCommentBoxResizeEnd(ctx, globalCache) {
    var _globalCache$commentB;
    if ((_globalCache$commentB = globalCache.commentBox) === null || _globalCache$commentB === void 0 ? void 0 : _globalCache$commentB.resizingId) {
      var _globalCache$commentB2 = globalCache.commentBox, resizingId = _globalCache$commentB2.resizingId, _globalCache$commentB3 = _globalCache$commentB2.commentRC, r2 = _globalCache$commentB3.r, c2 = _globalCache$commentB3.c;
      globalCache.commentBox.resizingId = void 0;
      var position = getCommentBoxPosition(resizingId);
      if (position) {
        var top = position.top, left = position.left, width = position.width, height = position.height;
        var flowdata = getFlowdata(ctx);
        var cell = flowdata === null || flowdata === void 0 ? void 0 : flowdata[r2][c2];
        if (!flowdata || !(cell === null || cell === void 0 ? void 0 : cell.ps)) return;
        cell.ps.left = left / ctx.zoomRatio;
        cell.ps.top = top / ctx.zoomRatio;
        cell.ps.width = width / ctx.zoomRatio;
        cell.ps.height = height / ctx.zoomRatio;
        setEditingComment(ctx, flowdata, r2, c2);
      }
    }
  }
  function onCommentBoxMoveStart(ctx, globalCache, e, _ref4, movingId) {
    var r2 = _ref4.r, c2 = _ref4.c, rc2 = _ref4.rc;
    var position = getCommentBoxPosition(movingId);
    if (position) {
      var top = position.top, left = position.left;
      _$1.set(globalCache, "commentBox", {
        cursorMoveStartPosition: {
          x: e.pageX,
          y: e.pageY
        },
        movingId,
        commentRC: {
          r: r2,
          c: c2,
          rc: rc2
        },
        boxInitialPosition: {
          left,
          top
        }
      });
    }
  }
  function onCommentBoxMove(ctx, globalCache, e) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return false;
    var commentBox = globalCache === null || globalCache === void 0 ? void 0 : globalCache.commentBox;
    if (commentBox === null || commentBox === void 0 ? void 0 : commentBox.movingId) {
      var box = document.getElementById(commentBox.movingId);
      var _commentBox$cursorMov2 = commentBox.cursorMoveStartPosition, startX = _commentBox$cursorMov2.x, startY = _commentBox$cursorMov2.y;
      var _commentBox$boxInitia2 = commentBox.boxInitialPosition, top = _commentBox$boxInitia2.top, left = _commentBox$boxInitia2.left;
      left += e.pageX - startX;
      top += e.pageY - startY;
      if (top < 0) top = 0;
      box.style.left = "".concat(left, "px");
      box.style.top = "".concat(top, "px");
      return true;
    }
    return false;
  }
  function onCommentBoxMoveEnd(ctx, globalCache) {
    var _globalCache$commentB4;
    if ((_globalCache$commentB4 = globalCache.commentBox) === null || _globalCache$commentB4 === void 0 ? void 0 : _globalCache$commentB4.movingId) {
      var _globalCache$commentB5 = globalCache.commentBox, movingId = _globalCache$commentB5.movingId, _globalCache$commentB6 = _globalCache$commentB5.commentRC, r2 = _globalCache$commentB6.r, c2 = _globalCache$commentB6.c;
      globalCache.commentBox.movingId = void 0;
      var position = getCommentBoxPosition(movingId);
      if (position) {
        var top = position.top, left = position.left;
        var flowdata = getFlowdata(ctx);
        var cell = flowdata === null || flowdata === void 0 ? void 0 : flowdata[r2][c2];
        if (!flowdata || !(cell === null || cell === void 0 ? void 0 : cell.ps)) return;
        cell.ps.left = left / ctx.zoomRatio;
        cell.ps.top = top / ctx.zoomRatio;
        setEditingComment(ctx, flowdata, r2, c2);
      }
    }
  }
  function generateRandomId(prefix) {
    var userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
    var mid = "";
    for (var i2 = 0; i2 < 12; i2 += 1) {
      mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
    }
    var time = (/* @__PURE__ */ new Date()).getTime();
    return "".concat(prefix, "_").concat(mid, "_").concat(time);
  }
  function showImgChooser() {
    var chooser = document.getElementById("fortune-img-upload");
    if (chooser) chooser.click();
  }
  function saveImage(ctx) {
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (index2 == null) return;
    var file = ctx.luckysheetfile[index2];
    file.images = ctx.insertedImgs;
  }
  function removeActiveImage(ctx) {
    ctx.insertedImgs = _$1.filter(ctx.insertedImgs, function(image) {
      return image.id !== ctx.activeImg;
    });
    ctx.activeImg = void 0;
    saveImage(ctx);
  }
  function insertImage(ctx, image) {
    try {
      var _ctx$luckysheet_selec;
      var last = (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec[ctx.luckysheet_select_save.length - 1];
      var rowIndex = last === null || last === void 0 ? void 0 : last.row_focus;
      var colIndex = last === null || last === void 0 ? void 0 : last.column_focus;
      if (!last) {
        rowIndex = 0;
        colIndex = 0;
      } else {
        if (rowIndex == null) {
          var _last$row = _slicedToArray$1(last.row, 1);
          rowIndex = _last$row[0];
        }
        if (colIndex == null) {
          var _last$column = _slicedToArray$1(last.column, 1);
          colIndex = _last$column[0];
        }
      }
      var flowdata = getFlowdata(ctx);
      var left = colIndex === 0 ? 0 : ctx.visibledatacolumn[colIndex - 1];
      var top = rowIndex === 0 ? 0 : ctx.visibledatarow[rowIndex - 1];
      if (flowdata) {
        var margeset = mergeBorder(ctx, flowdata, rowIndex, colIndex);
        if (margeset) {
          var _margeset$row = _slicedToArray$1(margeset.row, 1);
          top = _margeset$row[0];
          var _margeset$column = _slicedToArray$1(margeset.column, 1);
          left = _margeset$column[0];
        }
      }
      var width = image.width;
      var height = image.height;
      var img = {
        id: generateRandomId("img"),
        src: image.src,
        left,
        top,
        width: width * 0.5,
        height: height * 0.5,
        originWidth: width,
        originHeight: height
      };
      ctx.insertedImgs = (ctx.insertedImgs || []).concat(img);
      saveImage(ctx);
    } catch (err) {
      console.info(err);
    }
  }
  function getImagePosition() {
    var box = document.getElementById("luckysheet-modal-dialog-activeImage");
    if (!box) return void 0;
    var _box$getBoundingClien = box.getBoundingClientRect(), width = _box$getBoundingClien.width, height = _box$getBoundingClien.height;
    var left = box.offsetLeft;
    var top = box.offsetTop;
    return {
      left,
      top,
      width,
      height
    };
  }
  function cancelActiveImgItem(ctx, globalCache) {
    ctx.activeImg = void 0;
    globalCache.image = void 0;
  }
  function onImageMoveStart(ctx, globalCache, e) {
    var position = getImagePosition();
    if (position) {
      var top = position.top, left = position.left;
      _$1.set(globalCache, "image", {
        cursorMoveStartPosition: {
          x: e.pageX,
          y: e.pageY
        },
        imgInitialPosition: {
          left,
          top
        }
      });
    }
  }
  function onImageMove(ctx, globalCache, e) {
    if (ctx.allowEdit === false) return false;
    var image = globalCache === null || globalCache === void 0 ? void 0 : globalCache.image;
    var img = document.getElementById("luckysheet-modal-dialog-activeImage");
    if (img && image && !image.resizingSide) {
      var _image$cursorMoveStar = image.cursorMoveStartPosition, startX = _image$cursorMoveStar.x, startY = _image$cursorMoveStar.y;
      var _image$imgInitialPosi = image.imgInitialPosition, top = _image$imgInitialPosi.top, left = _image$imgInitialPosi.left;
      left += e.pageX - startX;
      top += e.pageY - startY;
      if (top < 0) top = 0;
      img.style.left = "".concat(left, "px");
      img.style.top = "".concat(top, "px");
      return true;
    }
    return false;
  }
  function onImageMoveEnd(ctx, globalCache) {
    var _globalCache$image;
    var position = getImagePosition();
    if (!((_globalCache$image = globalCache.image) === null || _globalCache$image === void 0 ? void 0 : _globalCache$image.resizingSide)) {
      globalCache.image = void 0;
      if (position) {
        var img = _$1.find(ctx.insertedImgs, function(v2) {
          return v2.id === ctx.activeImg;
        });
        if (img) {
          img.left = position.left / ctx.zoomRatio;
          img.top = position.top / ctx.zoomRatio;
          saveImage(ctx);
        }
      }
    }
  }
  function onImageResizeStart(globalCache, e, resizingSide) {
    var position = getImagePosition();
    if (position) {
      _$1.set(globalCache, "image", {
        cursorMoveStartPosition: {
          x: e.pageX,
          y: e.pageY
        },
        resizingSide,
        imgInitialPosition: position
      });
    }
  }
  function onImageResize(ctx, globalCache, e) {
    if (ctx.allowEdit === false) return false;
    var image = globalCache === null || globalCache === void 0 ? void 0 : globalCache.image;
    if (image === null || image === void 0 ? void 0 : image.resizingSide) {
      var imgContainer = document.getElementById("luckysheet-modal-dialog-activeImage");
      var img = imgContainer === null || imgContainer === void 0 ? void 0 : imgContainer.querySelector(".luckysheet-modal-dialog-content");
      if (img == null) return false;
      var _image$cursorMoveStar2 = image.cursorMoveStartPosition, startX = _image$cursorMoveStar2.x, startY = _image$cursorMoveStar2.y;
      var _image$imgInitialPosi2 = image.imgInitialPosition, top = _image$imgInitialPosi2.top, left = _image$imgInitialPosi2.left, width = _image$imgInitialPosi2.width, height = _image$imgInitialPosi2.height;
      var dx = e.pageX - startX;
      var dy = e.pageY - startY;
      var minHeight = 60 * ctx.zoomRatio;
      var minWidth = 1.5 * 60 * ctx.zoomRatio;
      if (["lm", "lt", "lb"].includes(image.resizingSide)) {
        if (width - dx < minWidth) {
          left += width - minWidth;
          width = minWidth;
        } else {
          left += dx;
          width -= dx;
        }
        if (left < 0) left = 0;
        img.style.left = "".concat(left, "px");
        imgContainer.style.left = "".concat(left, "px");
      }
      if (["rm", "rt", "rb"].includes(image.resizingSide)) {
        width = width + dx < minWidth ? minWidth : width + dx;
      }
      if (["mt", "lt", "rt"].includes(image.resizingSide)) {
        if (height - dy < minHeight) {
          top += height - minHeight;
          height = minHeight;
        } else {
          top += dy;
          height -= dy;
        }
        if (top < 0) top = 0;
        img.style.top = "".concat(top, "px");
        imgContainer.style.top = "".concat(top, "px");
      }
      if (["mb", "lb", "rb"].includes(image.resizingSide)) {
        height = height + dy < minHeight ? minHeight : height + dy;
      }
      img.style.width = "".concat(width, "px");
      imgContainer.style.width = "".concat(width, "px");
      img.style.height = "".concat(height, "px");
      imgContainer.style.height = "".concat(height, "px");
      img.style.backgroundSize = "".concat(width, "px ").concat(height, "px");
      return true;
    }
    return false;
  }
  function onImageResizeEnd(ctx, globalCache) {
    var _globalCache$image2;
    if ((_globalCache$image2 = globalCache.image) === null || _globalCache$image2 === void 0 ? void 0 : _globalCache$image2.resizingSide) {
      globalCache.image = void 0;
      var position = getImagePosition();
      if (position) {
        var img = _$1.find(ctx.insertedImgs, function(v2) {
          return v2.id === ctx.activeImg;
        });
        if (img) {
          img.left = position.left / ctx.zoomRatio;
          img.top = position.top / ctx.zoomRatio;
          img.width = position.width / ctx.zoomRatio;
          img.height = position.height / ctx.zoomRatio;
          saveImage(ctx);
        }
      }
    }
  }
  function handleOverlayTouchStart(ctx, e, globalCache) {
    globalCache.touchMoveStatus = true;
    var touch = e.targetTouches[0];
    globalCache.touchMoveStartPos = {
      x: touch.pageX,
      y: touch.pageY,
      vy: 0,
      moveType: "y"
    };
  }
  function handleOverlayTouchMove(ctx, e, globalCache, scrollbarX, scrollbarY) {
    if (e.targetTouches.length > 1) return;
    var touch = e.targetTouches[0];
    if (globalCache.touchMoveStatus) {
      if (!globalCache.touchMoveStartPos) return;
      var slideX = touch.pageX - globalCache.touchMoveStartPos.x;
      var slideY = touch.pageY - globalCache.touchMoveStartPos.y;
      var scrollLeft = ctx.scrollLeft;
      var scrollTop = ctx.scrollTop;
      scrollLeft -= slideX;
      scrollTop -= slideY;
      scrollbarY.scrollTop = scrollTop;
      globalCache.touchMoveStartPos.vy_y = slideY;
      globalCache.touchMoveStartPos.scrollTop = scrollTop;
      scrollbarX.scrollLeft = scrollLeft;
      globalCache.touchMoveStartPos.vy_x = slideX;
      globalCache.touchMoveStartPos.scrollLeft = scrollLeft;
    }
  }
  function handleOverlayTouchEnd(globalCache) {
    globalCache.touchMoveStatus = false;
    globalCache.touchHandleStatus = false;
  }
  function toPx(v2) {
    return "".concat(v2, "px");
  }
  var dropCellCache = {
    copyRange: {},
    applyRange: {},
    applyType: null,
    direction: null,
    chnNumChar: {
      零: 0,
      一: 1,
      二: 2,
      三: 3,
      四: 4,
      五: 5,
      六: 6,
      七: 7,
      八: 8,
      九: 9
    },
    chnNameValue: {
      十: {
        value: 10,
        secUnit: false
      },
      百: {
        value: 100,
        secUnit: false
      },
      千: {
        value: 1e3,
        secUnit: false
      },
      万: {
        value: 1e4,
        secUnit: true
      },
      亿: {
        value: 1e8,
        secUnit: true
      }
    },
    chnNumChar2: ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"],
    chnUnitSection: ["", "万", "亿", "万亿", "亿亿"],
    chnUnitChar: ["", "十", "百", "千"]
  };
  function chineseToNumber(chnStr) {
    var rtn = 0;
    var section = 0;
    var number = 0;
    var secUnit = false;
    var str = chnStr.split("");
    for (var i2 = 0; i2 < str.length; i2 += 1) {
      var num = dropCellCache.chnNumChar[str[i2]];
      if (typeof num !== "undefined") {
        number = num;
        if (i2 === str.length - 1) {
          section += number;
        }
      } else {
        var unit = dropCellCache.chnNameValue[str[i2]].value;
        secUnit = dropCellCache.chnNameValue[str[i2]].secUnit;
        if (secUnit) {
          section = (section + number) * unit;
          rtn += section;
          section = 0;
        } else {
          section += number * unit;
        }
        number = 0;
      }
    }
    return rtn + section;
  }
  function sectionToChinese(section) {
    var strIns = "";
    var chnStr = "";
    var unitPos = 0;
    var zero = true;
    while (section > 0) {
      var v2 = section % 10;
      if (v2 === 0) {
        if (!zero) {
          zero = true;
          chnStr = dropCellCache.chnNumChar2[v2] + chnStr;
        }
      } else {
        zero = false;
        strIns = dropCellCache.chnNumChar2[v2];
        strIns += dropCellCache.chnUnitChar[unitPos];
        chnStr = strIns + chnStr;
      }
      unitPos += 1;
      section = Math.floor(section / 10);
    }
    return chnStr;
  }
  function numberToChinese(num) {
    var strIns = "";
    var chnStr = "";
    var unitPos = 0;
    var needZero = false;
    if (num === 0) {
      return dropCellCache.chnNumChar2[0];
    }
    while (num > 0) {
      var section = num % 1e4;
      if (needZero) {
        chnStr = dropCellCache.chnNumChar2[0] + chnStr;
      }
      strIns = sectionToChinese(section);
      strIns += section !== 0 ? dropCellCache.chnUnitSection[unitPos] : dropCellCache.chnUnitSection[0];
      chnStr = strIns + chnStr;
      needZero = section < 1e3 && section > 0;
      num = Math.floor(num / 1e4);
      unitPos += 1;
    }
    return chnStr;
  }
  function isChnNumber(txt) {
    if (typeof txt === "number") {
      txt = "".concat(txt);
    }
    var result = true;
    if (txt == null) {
      result = false;
    } else if (txt.length === 1) {
      if (txt === "日" || txt in dropCellCache.chnNumChar) {
        result = true;
      } else {
        result = false;
      }
    } else {
      var str = txt.split("");
      for (var i2 = 0; i2 < str.length; i2 += 1) {
        if (!(str[i2] in dropCellCache.chnNumChar || str[i2] in dropCellCache.chnNameValue)) {
          result = false;
          break;
        }
      }
    }
    return result;
  }
  function isExtendNumber(txt) {
    if (txt == null) return [false];
    if (typeof txt === "number") {
      txt = "".concat(txt);
    }
    var reg = /0|([1-9]+[0-9]*)/g;
    var result = reg.test(txt);
    if (result) {
      var match = txt.match(reg);
      if (match) {
        var matchTxt = match[match.length - 1];
        var matchIndex = txt.lastIndexOf(matchTxt);
        var beforeTxt = txt.slice(0, matchIndex);
        var afterTxt = txt.slice(matchIndex + matchTxt.length);
        return [result, Number(matchTxt), beforeTxt, afterTxt];
      }
    }
    return [result];
  }
  function isChnWeek2(txt) {
    var result = false;
    if (typeof txt === "number") {
      txt = "".concat(txt);
    }
    if (txt !== void 0 && txt.length === 2) {
      if (txt === "周一" || txt === "周二" || txt === "周三" || txt === "周四" || txt === "周五" || txt === "周六" || txt === "周日") {
        result = true;
      }
    }
    return result;
  }
  function isChnWeek3(txt) {
    if (typeof txt === "number") {
      txt = "".concat(txt);
    }
    var result = false;
    if (txt !== void 0 && txt.length === 3) {
      if (txt === "星期一" || txt === "星期二" || txt === "星期三" || txt === "星期四" || txt === "星期五" || txt === "星期六" || txt === "星期日") {
        result = true;
      }
    }
    return result;
  }
  function isEqualDiff(arr) {
    var diff2 = true;
    var step = arr[1] - arr[0];
    for (var i2 = 1; i2 < arr.length; i2 += 1) {
      if (arr[i2] - arr[i2 - 1] !== step) {
        diff2 = false;
        break;
      }
    }
    return diff2;
  }
  function isEqualRatio(arr) {
    var ratio = true;
    var step = arr[1] / arr[0];
    for (var i2 = 1; i2 < arr.length; i2 += 1) {
      if (arr[i2] / arr[i2 - 1] !== step) {
        ratio = false;
        break;
      }
    }
    return ratio;
  }
  function getXArr(len) {
    var xArr = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      xArr.push(i2);
    }
    return xArr;
  }
  function forecast(x2, yArr, xArr) {
    function getAverage(arr) {
      var sum = 0;
      for (var i2 = 0; i2 < arr.length; i2 += 1) {
        sum += arr[i2];
      }
      return sum / arr.length;
    }
    var ax = getAverage(xArr);
    var ay = getAverage(yArr);
    var sum_d = 0;
    var sum_n = 0;
    for (var j2 = 0; j2 < xArr.length; j2 += 1) {
      sum_d += (xArr[j2] - ax) * (yArr[j2] - ay);
      sum_n += (xArr[j2] - ax) * (xArr[j2] - ax);
    }
    var b2;
    if (sum_n === 0) {
      b2 = 1;
    } else {
      b2 = sum_d / sum_n;
    }
    var a2 = ay - b2 * ax;
    return Math.round((a2 + b2 * x2) * 1e5) / 1e5;
  }
  function judgeDate(data) {
    var isSameDay = true;
    var isSameMonth = true;
    var isEqualDiffDays = true;
    var isEqualDiffMonths = true;
    var isEqualDiffYears = true;
    if (data[0] == null || data[1] == null) return [false, false, false, false, false];
    var sameDay = dayjs(data[0].m).date();
    var sameMonth = dayjs(data[0].m).month();
    var equalDiffDays = dayjs(data[1].m).diff(dayjs(data[0].m), "days");
    var equalDiffMonths = dayjs(data[1].m).diff(dayjs(data[0].m), "months");
    var equalDiffYears = dayjs(data[1].m).diff(dayjs(data[0].m), "years");
    for (var i2 = 1; i2 < data.length; i2 += 1) {
      var _data$i, _data$i2, _data$i3, _data, _data$i4, _data2, _data$i5, _data3;
      if (dayjs((_data$i = data[i2]) === null || _data$i === void 0 ? void 0 : _data$i.m).date() !== sameDay) {
        isSameDay = false;
      }
      if (dayjs((_data$i2 = data[i2]) === null || _data$i2 === void 0 ? void 0 : _data$i2.m).month() !== sameMonth) {
        isSameMonth = false;
      }
      if (dayjs((_data$i3 = data[i2]) === null || _data$i3 === void 0 ? void 0 : _data$i3.m).diff(dayjs((_data = data[i2 - 1]) === null || _data === void 0 ? void 0 : _data.m), "days") !== equalDiffDays) {
        isEqualDiffDays = false;
      }
      if (dayjs((_data$i4 = data[i2]) === null || _data$i4 === void 0 ? void 0 : _data$i4.m).diff(dayjs((_data2 = data[i2 - 1]) === null || _data2 === void 0 ? void 0 : _data2.m), "months") !== equalDiffMonths) {
        isEqualDiffMonths = false;
      }
      if (dayjs((_data$i5 = data[i2]) === null || _data$i5 === void 0 ? void 0 : _data$i5.m).diff(dayjs((_data3 = data[i2 - 1]) === null || _data3 === void 0 ? void 0 : _data3.m), "years") !== equalDiffYears) {
        isEqualDiffYears = false;
      }
    }
    if (equalDiffDays === 0) {
      isEqualDiffDays = false;
    }
    if (equalDiffMonths === 0) {
      isEqualDiffMonths = false;
    }
    if (equalDiffYears === 0) {
      isEqualDiffYears = false;
    }
    return [isSameDay, isSameMonth, isEqualDiffDays, isEqualDiffMonths, isEqualDiffYears];
  }
  function showDropCellSelection(_ref, container) {
    var width = _ref.width, height = _ref.height, top = _ref.top, left = _ref.left;
    var selectedExtend = container.querySelector(".fortune-cell-selected-extend");
    if (selectedExtend) {
      selectedExtend.style.left = toPx(left);
      selectedExtend.style.width = toPx(width);
      selectedExtend.style.top = toPx(top);
      selectedExtend.style.height = toPx(height);
      selectedExtend.style.display = "block";
    }
  }
  function hideDropCellSelection(container) {
    var selectedExtend = container.querySelector(".fortune-cell-selected-extend");
    if (selectedExtend) {
      selectedExtend.style.display = "none";
    }
  }
  function createDropCellRange(ctx, e, container) {
    ctx.luckysheet_cell_selected_extend = true;
    ctx.luckysheet_scroll_status = true;
    var scrollLeft = ctx.scrollLeft, scrollTop = ctx.scrollTop;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollLeft;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row_pre = row_location[0];
    var row = row_location[1];
    var row_index = row_location[2];
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col_pre = col_location[0];
    var col = col_location[1];
    var col_index = col_location[2];
    ctx.luckysheet_cell_selected_extend_index = [row_index, col_index];
    showDropCellSelection({
      left: col_pre,
      width: col - col_pre - 1,
      top: row_pre,
      height: row - row_pre - 1
    }, container);
  }
  function onDropCellSelect(ctx, e, scrollX, scrollY, container) {
    var scrollLeft = scrollX.scrollLeft;
    var scrollTop = scrollY.scrollTop;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollLeft;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row = row_location[1];
    var row_pre = row_location[0];
    var row_index = row_location[2];
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col = col_location[1];
    var col_pre = col_location[0];
    var col_index = col_location[2];
    var row_index_original = ctx.luckysheet_cell_selected_extend_index[0];
    var col_index_original = ctx.luckysheet_cell_selected_extend_index[1];
    if (!ctx.luckysheet_select_save) return;
    var row_s = ctx.luckysheet_select_save[0].row[0];
    var row_e = ctx.luckysheet_select_save[0].row[1];
    var col_s = ctx.luckysheet_select_save[0].column[0];
    var col_e = ctx.luckysheet_select_save[0].column[1];
    var top = ctx.luckysheet_select_save[0].top_move;
    var height = ctx.luckysheet_select_save[0].height_move;
    var left = ctx.luckysheet_select_save[0].left_move;
    var width = ctx.luckysheet_select_save[0].width_move;
    if (top == null || height == null || left == null || width == null) return;
    if (Math.abs(row_index_original - row_index) > Math.abs(col_index_original - col_index)) {
      if (!(row_index >= row_s && row_index <= row_e)) {
        if (top >= row_pre) {
          height += top - row_pre;
          top = row_pre;
        } else {
          height = row - top - 1;
        }
      }
    } else {
      if (!(col_index >= col_s && col_index <= col_e)) {
        if (left >= col_pre) {
          width += left - col_pre;
          left = col_pre;
        } else {
          width = col - left - 1;
        }
      }
    }
    if (y2 < 0) {
      row_s = 0;
      var _ctx$luckysheet_selec = _slicedToArray$1(ctx.luckysheet_select_save[0].row, 1);
      row_e = _ctx$luckysheet_selec[0];
    }
    if (x2 < 0) {
      col_s = 0;
      var _ctx$luckysheet_selec2 = _slicedToArray$1(ctx.luckysheet_select_save[0].column, 1);
      col_e = _ctx$luckysheet_selec2[0];
    }
    showDropCellSelection({
      left,
      width,
      top,
      height
    }, container);
  }
  function fillCopy(data, len) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      if (!_$1.isUndefined(d2)) {
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function fillSeries(data, len, direction) {
    var applyData = [];
    var dataNumArr = [];
    for (var j2 = 0; j2 < data.length; j2 += 1) {
      var d2 = _$1.cloneDeep(data[j2]);
      if (d2 != null) {
        dataNumArr.push(Number(d2.v));
      }
    }
    if (data.length > 2 && isEqualRatio(dataNumArr) && data[0] != null && data[1] != null) {
      for (var i2 = 1; i2 <= len; i2 += 1) {
        var index2 = (i2 - 1) % data.length;
        var _d = _$1.cloneDeep(data[index2]);
        if (_d != null) {
          var num = void 0;
          if (direction === "down" || direction === "right") {
            num = Number(data[data.length - 1].v) * Math.pow(Number(data[1].v) / Number(data[0].v), i2);
          } else {
            num = Number(data[0].v) / Math.pow(Number(data[1].v) / Number(data[0].v), i2);
          }
          _d.v = num;
          if (_d.ct != null && _d.ct.fa != null) {
            _d.m = update(_d.ct.fa, num);
          }
          applyData.push(_d);
        }
      }
    } else {
      var xArr = getXArr(data.length);
      for (var _i = 1; _i <= len; _i += 1) {
        var _index = (_i - 1) % data.length;
        var _d2 = _$1.cloneDeep(data[_index]);
        if (_d2 != null) {
          var y2 = void 0;
          if (direction === "down" || direction === "right") {
            y2 = forecast(data.length + _i, dataNumArr, xArr);
          } else if (direction === "up" || direction === "left") {
            y2 = forecast(1 - _i, dataNumArr, xArr);
          }
          _d2.v = y2;
          if (_d2.ct != null && _d2.ct.fa != null) {
            _d2.m = update(_d2.ct.fa, y2);
          }
          applyData.push(_d2);
        }
      }
    }
    return applyData;
  }
  function fillExtendNumber(data, len, step) {
    var applyData = [];
    var reg = /0|([1-9]+[0-9]*)/g;
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var _data4;
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      var last = (_data4 = data[data.length - 1]) === null || _data4 === void 0 ? void 0 : _data4.m;
      if (d2 != null && last != null) {
        last = "".concat(last);
        var match = last.match(reg) || "";
        var lastTxt = match[match.length - 1];
        var num = Math.abs(Number(lastTxt) + step * i2);
        var lastIndex = last.lastIndexOf(lastTxt);
        var valueTxt = last.slice(0, lastIndex) + num.toString() + last.slice(lastIndex + lastTxt.length);
        d2.v = valueTxt;
        d2.m = valueTxt;
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function fillDays(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var d2 = _$1.cloneDeep(data[data.length - 1]);
      if (d2 != null) {
        var _genarate;
        var date = update("yyyy-MM-dd", d2.v);
        date = dayjs(date).add(step * i2, "days").format("YYYY-MM-DD");
        d2.v = (_genarate = genarate(date)) === null || _genarate === void 0 ? void 0 : _genarate[2];
        if (d2.ct != null && d2.ct.fa != null) {
          d2.m = update(d2.ct.fa, d2.v);
        }
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function fillMonths(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var d2 = _$1.cloneDeep(data[data.length - 1]);
      if (d2 != null) {
        var _genarate2;
        var date = update("yyyy-MM-dd", d2.v);
        date = dayjs(date).add(step * i2, "months").format("YYYY-MM-DD");
        d2.v = (_genarate2 = genarate(date)) === null || _genarate2 === void 0 ? void 0 : _genarate2[2];
        if (d2.ct != null && d2.ct.fa != null) {
          d2.m = update(d2.ct.fa, d2.v);
        }
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function fillYears(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var d2 = _$1.cloneDeep(data[data.length - 1]);
      if (d2 != null) {
        var _genarate3;
        var date = update("yyyy-MM-dd", d2.v);
        date = dayjs(date).add(step * i2, "years").format("YYYY-MM-DD");
        d2.v = (_genarate3 = genarate(date)) === null || _genarate3 === void 0 ? void 0 : _genarate3[2];
        if (d2.ct != null && d2.ct.fa != null) {
          d2.m = update(d2.ct.fa, d2.v);
        }
      }
      applyData.push(d2);
    }
    return applyData;
  }
  function fillChnWeek(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var _data5;
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      var num = void 0;
      var m2 = (_data5 = data[data.length - 1]) === null || _data5 === void 0 ? void 0 : _data5.m;
      if (m2 != null && d2 != null) {
        if (m2 === "日") {
          num = 7 + step * i2;
        } else {
          num = chineseToNumber("".concat(m2)) + step * i2;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        var rsd = num % 7;
        if (rsd === 0) {
          d2.m = "日";
          d2.v = "日";
        } else if (rsd === 1) {
          d2.m = "一";
          d2.v = "一";
        } else if (rsd === 2) {
          d2.m = "二";
          d2.v = "二";
        } else if (rsd === 3) {
          d2.m = "三";
          d2.v = "三";
        } else if (rsd === 4) {
          d2.m = "四";
          d2.v = "四";
        } else if (rsd === 5) {
          d2.m = "五";
          d2.v = "五";
        } else if (rsd === 6) {
          d2.m = "六";
          d2.v = "六";
        }
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function fillChnWeek2(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var _data6;
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      var num = void 0;
      var m2 = (_data6 = data[data.length - 1]) === null || _data6 === void 0 ? void 0 : _data6.m;
      if (m2 != null && d2 != null) {
        if (m2 === "周日") {
          num = 7 + step * i2;
        } else {
          var last = "".concat(m2);
          var txt = last.slice(last.length - 1, 1);
          num = chineseToNumber(txt) + step * i2;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        var rsd = num % 7;
        if (rsd === 0) {
          d2.m = "周日";
          d2.v = "周日";
        } else if (rsd === 1) {
          d2.m = "周一";
          d2.v = "周一";
        } else if (rsd === 2) {
          d2.m = "周二";
          d2.v = "周二";
        } else if (rsd === 3) {
          d2.m = "周三";
          d2.v = "周三";
        } else if (rsd === 4) {
          d2.m = "周四";
          d2.v = "周四";
        } else if (rsd === 5) {
          d2.m = "周五";
          d2.v = "周五";
        } else if (rsd === 6) {
          d2.m = "周六";
          d2.v = "周六";
        }
      }
      applyData.push(d2);
    }
    return applyData;
  }
  function fillChnWeek3(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var _data7;
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      var num = void 0;
      var m2 = (_data7 = data[data.length - 1]) === null || _data7 === void 0 ? void 0 : _data7.m;
      if (m2 != null && d2 != null) {
        if (m2 === "星期日") {
          num = 7 + step * i2;
        } else {
          var last = "".concat(m2);
          var txt = last.slice(last.length - 1, 1);
          num = chineseToNumber(txt) + step * i2;
        }
        if (num < 0) {
          num = Math.ceil(Math.abs(num) / 7) * 7 + num;
        }
        var rsd = num % 7;
        if (rsd === 0) {
          d2.m = "星期日";
          d2.v = "星期日";
        } else if (rsd === 1) {
          d2.m = "星期一";
          d2.v = "星期一";
        } else if (rsd === 2) {
          d2.m = "星期二";
          d2.v = "星期二";
        } else if (rsd === 3) {
          d2.m = "星期三";
          d2.v = "星期三";
        } else if (rsd === 4) {
          d2.m = "星期四";
          d2.v = "星期四";
        } else if (rsd === 5) {
          d2.m = "星期五";
          d2.v = "星期五";
        } else if (rsd === 6) {
          d2.m = "星期六";
          d2.v = "星期六";
        }
      }
      applyData.push(d2);
    }
    return applyData;
  }
  function fillChnNumber(data, len, step) {
    var applyData = [];
    for (var i2 = 1; i2 <= len; i2 += 1) {
      var _data8;
      var index2 = (i2 - 1) % data.length;
      var d2 = _$1.cloneDeep(data[index2]);
      var m2 = (_data8 = data[data.length - 1]) === null || _data8 === void 0 ? void 0 : _data8.m;
      if (m2 != null && d2 != null) {
        var num = chineseToNumber("".concat(m2)) + step * i2;
        var txt = void 0;
        if (num <= 0) {
          txt = "零";
        } else {
          txt = numberToChinese(num);
        }
        d2.v = txt;
        d2.m = txt.toString();
        applyData.push(d2);
      }
    }
    return applyData;
  }
  function getTypeItemHide(ctx) {
    var copyRange = dropCellCache.copyRange;
    var str_r = copyRange.row[0];
    var end_r = copyRange.row[1];
    var str_c = copyRange.column[0];
    var end_c = copyRange.column[1];
    var hasNumber = false;
    var hasExtendNumber = false;
    var hasDate = false;
    var hasChn = false;
    var hasChnWeek1 = false;
    var hasChnWeek2 = false;
    var hasChnWeek3 = false;
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return [];
    for (var r2 = str_r; r2 <= end_r; r2 += 1) {
      for (var c2 = str_c; c2 <= end_c; c2 += 1) {
        if (flowdata[r2][c2]) {
          var cell = flowdata[r2][c2];
          if (cell !== null && cell.v != null && cell.f == null) {
            if (cell.ct != null && cell.ct.t === "n") {
              hasNumber = true;
            } else if (cell.ct != null && cell.ct.t === "d") {
              hasDate = true;
            } else if (isExtendNumber(cell.m)[0]) {
              hasExtendNumber = true;
            } else if (isChnNumber(cell.m) && cell.m !== "日") {
              hasChn = true;
            } else if (cell.m != null && cell.m === "日") {
              hasChnWeek1 = true;
            } else if (isChnWeek2(cell.m)) {
              hasChnWeek2 = true;
            } else if (isChnWeek3(cell.m)) {
              hasChnWeek3 = true;
            }
          }
        }
      }
    }
    return [hasNumber, hasExtendNumber, hasDate, hasChn, hasChnWeek1, hasChnWeek2, hasChnWeek3];
  }
  function getLenS(indexArr, rsd) {
    var s2 = 0;
    for (var j2 = 0; j2 < indexArr.length; j2 += 1) {
      if (indexArr[j2] <= rsd) {
        s2 += 1;
      } else {
        break;
      }
    }
    return s2;
  }
  function getDataIndex(csLen, asLen, indexArr) {
    var obj = {};
    var num = Math.floor(asLen / csLen);
    var rsd = asLen % csLen;
    var sum = 0;
    if (num > 0) {
      for (var i2 = 1; i2 <= num; i2 += 1) {
        for (var j2 = 0; j2 < indexArr.length; j2 += 1) {
          obj[indexArr[j2] + (i2 - 1) * csLen] = sum;
          sum += 1;
        }
      }
      for (var a2 = 0; a2 < indexArr.length; a2 += 1) {
        if (indexArr[a2] <= rsd) {
          obj[indexArr[a2] + csLen * num] = sum;
          sum += 1;
        } else {
          break;
        }
      }
    } else {
      for (var _a = 0; _a < indexArr.length; _a += 1) {
        if (indexArr[_a] <= rsd) {
          obj[indexArr[_a]] = sum;
          sum += 1;
        } else {
          break;
        }
      }
    }
    return obj;
  }
  function getDataByType(data, len, direction, type, dataType) {
    data = _$1.cloneDeep(data);
    var applyData = [];
    if (type === "0" || data.length === 1) {
      if (direction === "up" || direction === "left") {
        data.reverse();
      }
      applyData = fillCopy(data, len);
    } else if (type === "1") {
      var _data$5;
      if (dataType === "number") {
        applyData = fillSeries(data, len, direction);
      } else if (dataType === "extendNumber") {
        var dataNumArr = [];
        for (var i2 = 0; i2 < data.length; i2 += 1) {
          var _data$i6;
          var txt = (_data$i6 = data[i2]) === null || _data$i6 === void 0 ? void 0 : _data$i6.m;
          var _isExtendNumber = isExtendNumber(txt);
          if (_isExtendNumber[0]) {
            dataNumArr.push(_isExtendNumber[1]);
          }
        }
        if (direction === "up" || direction === "left") {
          data.reverse();
          dataNumArr.reverse();
        }
        if (isEqualDiff(dataNumArr)) {
          var step = dataNumArr[1] - dataNumArr[0];
          applyData = fillExtendNumber(data, len, step);
        } else {
          applyData = fillCopy(data, len);
        }
      } else if (dataType === "date") {
        if (direction === "up" || direction === "left") {
          data.reverse();
        }
        var _judgeDate = judgeDate(data);
        if (_judgeDate[0] && _judgeDate[3]) {
          var _data$, _data$2;
          var _step = dayjs((_data$ = data[1]) === null || _data$ === void 0 ? void 0 : _data$.m).diff(dayjs((_data$2 = data[0]) === null || _data$2 === void 0 ? void 0 : _data$2.m), "months");
          applyData = fillMonths(data, len, _step);
        } else if (!_judgeDate[0] && _judgeDate[2]) {
          var _data$3, _data$4;
          var _step2 = dayjs((_data$3 = data[1]) === null || _data$3 === void 0 ? void 0 : _data$3.m).diff(dayjs((_data$4 = data[0]) === null || _data$4 === void 0 ? void 0 : _data$4.m), "days");
          applyData = fillDays(data, len, _step2);
        } else {
          applyData = fillCopy(data, len);
        }
      } else if (dataType === "chnNumber" && ((_data$5 = data[0]) === null || _data$5 === void 0 ? void 0 : _data$5.m) != null) {
        var hasweek = false;
        for (var _i2 = 0; _i2 < data.length; _i2 += 1) {
          var _data$_i;
          if (((_data$_i = data[_i2]) === null || _data$_i === void 0 ? void 0 : _data$_i.m) === "日") {
            hasweek = true;
            break;
          }
        }
        var _dataNumArr = [];
        var weekIndex = 0;
        for (var _i3 = 0; _i3 < data.length; _i3 += 1) {
          var _data$_i2;
          var m2 = (_data$_i2 = data[_i3]) === null || _data$_i2 === void 0 ? void 0 : _data$_i2.m;
          if (m2 != null) {
            m2 = "".concat(m2);
            if (m2 === "日") {
              if (_i3 === 0) {
                _dataNumArr.push(0);
              } else {
                weekIndex += 1;
                _dataNumArr.push(weekIndex * 7);
              }
            } else if (hasweek && chineseToNumber(m2) > 0 && chineseToNumber(m2) < 7) {
              _dataNumArr.push(chineseToNumber(m2) + weekIndex * 7);
            } else {
              _dataNumArr.push(chineseToNumber(m2));
            }
          }
        }
        if (direction === "up" || direction === "left") {
          data.reverse();
          _dataNumArr.reverse();
        }
        if (isEqualDiff(_dataNumArr)) {
          if (hasweek || _dataNumArr[_dataNumArr.length - 1] < 6 && _dataNumArr[0] > 0 || _dataNumArr[0] < 6 && _dataNumArr[_dataNumArr.length - 1] > 0) {
            var _step3 = _dataNumArr[1] - _dataNumArr[0];
            applyData = fillChnWeek(data, len, _step3);
          } else {
            var _step4 = _dataNumArr[1] - _dataNumArr[0];
            applyData = fillChnNumber(data, len, _step4);
          }
        } else {
          applyData = fillCopy(data, len);
        }
      } else if (dataType === "chnWeek2") {
        var _dataNumArr2 = [];
        var _weekIndex = 0;
        for (var _i4 = 0; _i4 < data.length; _i4 += 1) {
          var _data$_i3;
          var _m = (_data$_i3 = data[_i4]) === null || _data$_i3 === void 0 ? void 0 : _data$_i3.m;
          if (_m != null) {
            _m = "".concat(_m);
            var lastTxt = _m.slice(_m.length - 1, 1);
            if (_m === "周日") {
              if (_i4 === 0) {
                _dataNumArr2.push(0);
              } else {
                _weekIndex += 1;
                _dataNumArr2.push(_weekIndex * 7);
              }
            } else {
              _dataNumArr2.push(chineseToNumber(lastTxt) + _weekIndex * 7);
            }
          }
        }
        if (direction === "up" || direction === "left") {
          data.reverse();
          _dataNumArr2.reverse();
        }
        if (isEqualDiff(_dataNumArr2)) {
          var _step5 = _dataNumArr2[1] - _dataNumArr2[0];
          applyData = fillChnWeek2(data, len, _step5);
        } else {
          applyData = fillCopy(data, len);
        }
      } else if (dataType === "chnWeek3") {
        var _dataNumArr3 = [];
        var _weekIndex2 = 0;
        for (var _i5 = 0; _i5 < data.length; _i5 += 1) {
          var _data$_i4;
          var _m2 = (_data$_i4 = data[_i5]) === null || _data$_i4 === void 0 ? void 0 : _data$_i4.m;
          if (_m2 != null) {
            _m2 = "".concat(_m2);
            var _lastTxt = _m2.slice(_m2.length - 1, 1);
            if (_m2 === "星期日") {
              if (_i5 === 0) {
                _dataNumArr3.push(0);
              } else {
                _weekIndex2 += 1;
                _dataNumArr3.push(_weekIndex2 * 7);
              }
            } else {
              _dataNumArr3.push(chineseToNumber(_lastTxt) + _weekIndex2 * 7);
            }
          }
        }
        if (direction === "up" || direction === "left") {
          data.reverse();
          _dataNumArr3.reverse();
        }
        if (isEqualDiff(_dataNumArr3)) {
          var _step6 = _dataNumArr3[1] - _dataNumArr3[0];
          applyData = fillChnWeek3(data, len, _step6);
        } else {
          applyData = fillCopy(data, len);
        }
      } else {
        if (direction === "up" || direction === "left") {
          data.reverse();
        }
        applyData = fillCopy(data, len);
      }
    } else if (type === "4") {
      if (data.length === 2) {
        var _data$6, _data$7;
        if (direction === "up" || direction === "left") {
          data.reverse();
        }
        var _step7 = dayjs((_data$6 = data[1]) === null || _data$6 === void 0 ? void 0 : _data$6.m).diff(dayjs((_data$7 = data[0]) === null || _data$7 === void 0 ? void 0 : _data$7.m), "days");
        applyData = fillDays(data, len, _step7);
      } else {
        if (direction === "up" || direction === "left") {
          data.reverse();
        }
        var _judgeDate2 = judgeDate(data);
        if (_judgeDate2[0] && _judgeDate2[3]) {
          var _data$8, _data$9;
          var _step8 = dayjs((_data$8 = data[1]) === null || _data$8 === void 0 ? void 0 : _data$8.m).diff(dayjs((_data$9 = data[0]) === null || _data$9 === void 0 ? void 0 : _data$9.m), "months");
          applyData = fillMonths(data, len, _step8);
        } else if (!_judgeDate2[0] && _judgeDate2[2]) {
          var _data$10, _data$11;
          var _step9 = dayjs((_data$10 = data[1]) === null || _data$10 === void 0 ? void 0 : _data$10.m).diff(dayjs((_data$11 = data[0]) === null || _data$11 === void 0 ? void 0 : _data$11.m), "days");
          applyData = fillDays(data, len, _step9);
        } else {
          applyData = fillCopy(data, len);
        }
      }
    } else if (type === "5") {
      if (data.length === 2) {
        var _data$12, _data$13, _data$14, _data$15;
        if (dayjs((_data$12 = data[1]) === null || _data$12 === void 0 ? void 0 : _data$12.m).date() === dayjs((_data$13 = data[0]) === null || _data$13 === void 0 ? void 0 : _data$13.m).date() && dayjs((_data$14 = data[1]) === null || _data$14 === void 0 ? void 0 : _data$14.m).diff(dayjs((_data$15 = data[0]) === null || _data$15 === void 0 ? void 0 : _data$15.m), "months") !== 0) {
          var _data$16, _data$17;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step10 = dayjs((_data$16 = data[1]) === null || _data$16 === void 0 ? void 0 : _data$16.m).diff(dayjs((_data$17 = data[0]) === null || _data$17 === void 0 ? void 0 : _data$17.m), "months");
          for (var _i6 = 1; _i6 <= len; _i6 += 1) {
            var _data9;
            var index2 = (_i6 - 1) % data.length;
            var d2 = _$1.cloneDeep(data[index2]);
            var last = (_data9 = data[data.length - 1]) === null || _data9 === void 0 ? void 0 : _data9.m;
            if (d2 != null && last != null) {
              var _genarate4;
              var day = dayjs(last).add(_step10 * _i6, "months").day();
              var date = void 0;
              if (day === 0) {
                date = dayjs(last).add(_step10 * _i6, "months").subtract(2, "days").format("YYYY-MM-DD");
              } else if (day === 6) {
                date = dayjs(last).add(_step10 * _i6, "months").subtract(1, "days").format("YYYY-MM-DD");
              } else {
                date = dayjs(last).add(_step10 * _i6, "months").format("YYYY-MM-DD");
              }
              d2.m = date;
              d2.v = (_genarate4 = genarate(date)) === null || _genarate4 === void 0 ? void 0 : _genarate4[2];
              applyData.push(d2);
            }
          }
        } else {
          var _data$18, _data$19;
          if (Math.abs(dayjs((_data$18 = data[1]) === null || _data$18 === void 0 ? void 0 : _data$18.m).diff(dayjs((_data$19 = data[0]) === null || _data$19 === void 0 ? void 0 : _data$19.m))) > 7) {
            var step_month;
            if (direction === "down" || direction === "right") {
              step_month = 1;
            } else {
              step_month = -1;
              data.reverse();
            }
            var _step11;
            for (var _i7 = 1; _i7 <= len; _i7 += 1) {
              var _index2 = (_i7 - 1) % data.length;
              var _d3 = _$1.cloneDeep(data[_index2]);
              if (_d3 != null) {
                var _genarate5;
                var num = Math.ceil(_i7 / data.length);
                if (_index2 === 0) {
                  _step11 = dayjs(_d3.m).add(step_month * num, "months").diff(dayjs(_d3.m), "days");
                }
                var _day = dayjs(_d3.m).add(_step11, "days").day();
                var _date = void 0;
                if (_day === 0) {
                  _date = dayjs(_d3.m).add(_step11, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (_day === 6) {
                  _date = dayjs(_d3.m).add(_step11, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  _date = dayjs(_d3.m).add(_step11, "days").format("YYYY-MM-DD");
                }
                _d3.m = _date;
                _d3.v = (_genarate5 = genarate(_date)) === null || _genarate5 === void 0 ? void 0 : _genarate5[2];
                applyData.push(_d3);
              }
            }
          } else {
            var step_day;
            if (direction === "down" || direction === "right") {
              step_day = 7;
            } else {
              step_day = -7;
              data.reverse();
            }
            var _step12;
            for (var _i8 = 1; _i8 <= len; _i8 += 1) {
              var _index3 = (_i8 - 1) % data.length;
              var _d4 = _$1.cloneDeep(data[_index3]);
              if (_d4 != null) {
                var _genarate6;
                var _num = Math.ceil(_i8 / data.length);
                if (_index3 === 0) {
                  _step12 = dayjs(_d4.m).add(step_day * _num, "days").diff(dayjs(_d4.m), "days");
                }
                var _day2 = dayjs(_d4.m).add(_step12, "days").day();
                var _date2 = void 0;
                if (_day2 === 0) {
                  _date2 = dayjs(_d4.m).add(_step12, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (_day2 === 6) {
                  _date2 = dayjs(_d4.m).add(_step12, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  _date2 = dayjs(_d4.m).add(_step12, "days").format("YYYY-MM-DD");
                }
                _d4.m = _date2;
                _d4.v = (_genarate6 = genarate(_date2)) === null || _genarate6 === void 0 ? void 0 : _genarate6[2];
                applyData.push(_d4);
              }
            }
          }
        }
      } else {
        var _judgeDate3 = judgeDate(data);
        if (_judgeDate3[0] && _judgeDate3[3]) {
          var _data$20, _data$21;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step13 = dayjs((_data$20 = data[1]) === null || _data$20 === void 0 ? void 0 : _data$20.m).diff(dayjs((_data$21 = data[0]) === null || _data$21 === void 0 ? void 0 : _data$21.m), "months");
          for (var _i9 = 1; _i9 <= len; _i9 += 1) {
            var _data10;
            var _index4 = (_i9 - 1) % data.length;
            var _d5 = _$1.cloneDeep(data[_index4]);
            var _last = (_data10 = data[data.length - 1]) === null || _data10 === void 0 ? void 0 : _data10.m;
            if (_d5 != null) {
              var _genarate7;
              var _day3 = dayjs(_last).add(_step13 * _i9, "months").day();
              var _date3 = void 0;
              if (_day3 === 0) {
                _date3 = dayjs(_last).add(_step13 * _i9, "months").subtract(2, "days").format("YYYY-MM-DD");
              } else if (_day3 === 6) {
                _date3 = dayjs(_last).add(_step13 * _i9, "months").subtract(1, "days").format("YYYY-MM-DD");
              } else {
                _date3 = dayjs(_last).add(_step13 * _i9, "months").format("YYYY-MM-DD");
              }
              _d5.m = _date3;
              _d5.v = (_genarate7 = genarate(_date3)) === null || _genarate7 === void 0 ? void 0 : _genarate7[2];
              applyData.push(_d5);
            }
          }
        } else if (!_judgeDate3[0] && _judgeDate3[2]) {
          var _data$22, _data$23;
          if (Math.abs(dayjs((_data$22 = data[1]) === null || _data$22 === void 0 ? void 0 : _data$22.m).diff(dayjs((_data$23 = data[0]) === null || _data$23 === void 0 ? void 0 : _data$23.m))) > 7) {
            var _step_month;
            if (direction === "down" || direction === "right") {
              _step_month = 1;
            } else {
              _step_month = -1;
              data.reverse();
            }
            var _step14;
            for (var _i10 = 1; _i10 <= len; _i10 += 1) {
              var _index5 = (_i10 - 1) % data.length;
              var _d6 = _$1.cloneDeep(data[_index5]);
              if (_d6 != null) {
                var _genarate8;
                var _num2 = Math.ceil(_i10 / data.length);
                if (_index5 === 0) {
                  _step14 = dayjs(_d6.m).add(_step_month * _num2, "months").diff(dayjs(_d6.m), "days");
                }
                var _day4 = dayjs(_d6.m).add(_step14, "days").day();
                var _date4 = void 0;
                if (_day4 === 0) {
                  _date4 = dayjs(_d6.m).add(_step14, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (_day4 === 6) {
                  _date4 = dayjs(_d6.m).add(_step14, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  _date4 = dayjs(_d6.m).add(_step14, "days").format("YYYY-MM-DD");
                }
                _d6.m = _date4;
                _d6.v = (_genarate8 = genarate(_date4)) === null || _genarate8 === void 0 ? void 0 : _genarate8[2];
                applyData.push(_d6);
              }
            }
          } else {
            var _step_day;
            if (direction === "down" || direction === "right") {
              _step_day = 7;
            } else {
              _step_day = -7;
              data.reverse();
            }
            var _step15;
            for (var _i11 = 1; _i11 <= len; _i11 += 1) {
              var _index6 = (_i11 - 1) % data.length;
              var _d7 = _$1.cloneDeep(data[_index6]);
              if (_d7 != null) {
                var _genarate9;
                var _num3 = Math.ceil(_i11 / data.length);
                if (_index6 === 0) {
                  _step15 = dayjs(_d7.m).add(_step_day * _num3, "days").diff(dayjs(_d7.m), "days");
                }
                var _day5 = dayjs(_d7.m).add(_step15, "days").day();
                var _date5 = void 0;
                if (_day5 === 0) {
                  _date5 = dayjs(_d7.m).add(_step15, "days").subtract(2, "days").format("YYYY-MM-DD");
                } else if (_day5 === 6) {
                  _date5 = dayjs(_d7.m).add(_step15, "days").subtract(1, "days").format("YYYY-MM-DD");
                } else {
                  _date5 = dayjs(_d7.m).add(_step15, "days").format("YYYY-MM-DD");
                }
                _d7.m = _date5;
                _d7.v = (_genarate9 = genarate(_date5)) === null || _genarate9 === void 0 ? void 0 : _genarate9[2];
                applyData.push(_d7);
              }
            }
          }
        } else {
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          applyData = fillCopy(data, len);
        }
      }
    } else if (type === "6") {
      if (data.length === 2) {
        var _data$24, _data$25, _data$26, _data$27;
        if (dayjs((_data$24 = data[1]) === null || _data$24 === void 0 ? void 0 : _data$24.m).date() === dayjs((_data$25 = data[0]) === null || _data$25 === void 0 ? void 0 : _data$25.m).date() && dayjs((_data$26 = data[1]) === null || _data$26 === void 0 ? void 0 : _data$26.m).diff(dayjs((_data$27 = data[0]) === null || _data$27 === void 0 ? void 0 : _data$27.m), "months") !== 0) {
          var _data$28, _data$29;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step16 = dayjs((_data$28 = data[1]) === null || _data$28 === void 0 ? void 0 : _data$28.m).diff(dayjs((_data$29 = data[0]) === null || _data$29 === void 0 ? void 0 : _data$29.m), "months");
          applyData = fillMonths(data, len, _step16);
        } else {
          var _step_month2;
          if (direction === "down" || direction === "right") {
            _step_month2 = 1;
          } else {
            _step_month2 = -1;
            data.reverse();
          }
          var _step17;
          for (var _i12 = 1; _i12 <= len; _i12 += 1) {
            var _index7 = (_i12 - 1) % data.length;
            var _d8 = _$1.cloneDeep(data[_index7]);
            if (_d8 != null) {
              var _genarate10;
              var _num4 = Math.ceil(_i12 / data.length);
              if (_index7 === 0) {
                _step17 = dayjs(_d8.m).add(_step_month2 * _num4, "months").diff(dayjs(_d8.m), "days");
              }
              var _date6 = dayjs(_d8.m).add(_step17, "days").format("YYYY-MM-DD");
              _d8.m = _date6;
              _d8.v = (_genarate10 = genarate(_date6)) === null || _genarate10 === void 0 ? void 0 : _genarate10[2];
              applyData.push(_d8);
            }
          }
        }
      } else {
        var _judgeDate4 = judgeDate(data);
        if (_judgeDate4[0] && _judgeDate4[3]) {
          var _data$30, _data$31;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step18 = dayjs((_data$30 = data[1]) === null || _data$30 === void 0 ? void 0 : _data$30.m).diff(dayjs((_data$31 = data[0]) === null || _data$31 === void 0 ? void 0 : _data$31.m), "months");
          applyData = fillMonths(data, len, _step18);
        } else if (!_judgeDate4[0] && _judgeDate4[2]) {
          var _step_month3;
          if (direction === "down" || direction === "right") {
            _step_month3 = 1;
          } else {
            _step_month3 = -1;
            data.reverse();
          }
          var _step19;
          for (var _i13 = 1; _i13 <= len; _i13 += 1) {
            var _index8 = (_i13 - 1) % data.length;
            var _d9 = _$1.cloneDeep(data[_index8]);
            if (_d9 != null) {
              var _genarate11;
              var _num5 = Math.ceil(_i13 / data.length);
              if (_index8 === 0) {
                _step19 = dayjs(_d9.m).add(_step_month3 * _num5, "months").diff(dayjs(_d9.m), "days");
              }
              var _date7 = dayjs(_d9.m).add(_step19, "days").format("YYYY-MM-DD");
              _d9.m = _date7;
              _d9.v = (_genarate11 = genarate(_date7)) === null || _genarate11 === void 0 ? void 0 : _genarate11[2];
              applyData.push(_d9);
            }
          }
        } else {
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          applyData = fillCopy(data, len);
        }
      }
    } else if (type === "7") {
      if (data.length === 2) {
        var _data$32, _data$33, _data$34, _data$35, _data$36, _data$37;
        if (dayjs((_data$32 = data[1]) === null || _data$32 === void 0 ? void 0 : _data$32.m).date() === dayjs((_data$33 = data[0]) === null || _data$33 === void 0 ? void 0 : _data$33.m).date() && dayjs((_data$34 = data[1]) === null || _data$34 === void 0 ? void 0 : _data$34.m).month() === dayjs((_data$35 = data[0]) === null || _data$35 === void 0 ? void 0 : _data$35.m).month() && dayjs((_data$36 = data[1]) === null || _data$36 === void 0 ? void 0 : _data$36.m).diff(dayjs((_data$37 = data[0]) === null || _data$37 === void 0 ? void 0 : _data$37.m), "years") !== 0) {
          var _data$38, _data$39;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step20 = dayjs((_data$38 = data[1]) === null || _data$38 === void 0 ? void 0 : _data$38.m).diff(dayjs((_data$39 = data[0]) === null || _data$39 === void 0 ? void 0 : _data$39.m), "years");
          applyData = fillYears(data, len, _step20);
        } else {
          var step_year;
          if (direction === "down" || direction === "right") {
            step_year = 1;
          } else {
            step_year = -1;
            data.reverse();
          }
          var _step21;
          for (var _i14 = 1; _i14 <= len; _i14 += 1) {
            var _index9 = (_i14 - 1) % data.length;
            var _d10 = _$1.cloneDeep(data[_index9]);
            if (_d10 != null) {
              var _genarate12;
              var _num6 = Math.ceil(_i14 / data.length);
              if (_index9 === 0) {
                _step21 = dayjs(_d10.m).add(step_year * _num6, "years").diff(dayjs(_d10.m), "days");
              }
              var _date8 = dayjs(_d10.m).add(_step21, "days").format("YYYY-MM-DD");
              _d10.m = _date8;
              _d10.v = (_genarate12 = genarate(_date8)) === null || _genarate12 === void 0 ? void 0 : _genarate12[2];
              applyData.push(_d10);
            }
          }
        }
      } else {
        var _judgeDate5 = judgeDate(data);
        if (_judgeDate5[0] && _judgeDate5[1] && _judgeDate5[4]) {
          var _data$40, _data$41;
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          var _step22 = dayjs((_data$40 = data[1]) === null || _data$40 === void 0 ? void 0 : _data$40.m).diff(dayjs((_data$41 = data[0]) === null || _data$41 === void 0 ? void 0 : _data$41.m), "years");
          applyData = fillYears(data, len, _step22);
        } else if (_judgeDate5[0] && _judgeDate5[3] || _judgeDate5[2]) {
          var _step_year;
          if (direction === "down" || direction === "right") {
            _step_year = 1;
          } else {
            _step_year = -1;
            data.reverse();
          }
          var _step23;
          for (var _i15 = 1; _i15 <= len; _i15 += 1) {
            var _index10 = (_i15 - 1) % data.length;
            var _d11 = _$1.cloneDeep(data[_index10]);
            var _num7 = Math.ceil(_i15 / data.length);
            if (_d11 != null) {
              var _genarate13;
              if (_index10 === 0) {
                _step23 = dayjs(_d11.m).add(_step_year * _num7, "years").diff(dayjs(_d11.m), "days");
              }
              var _date9 = dayjs(_d11.m).add(_step23, "days").format("YYYY-MM-DD");
              _d11.m = _date9;
              _d11.v = (_genarate13 = genarate(_date9)) === null || _genarate13 === void 0 ? void 0 : _genarate13[2];
              applyData.push(_d11);
            }
          }
        } else {
          if (direction === "up" || direction === "left") {
            data.reverse();
          }
          applyData = fillCopy(data, len);
        }
      }
    } else if (type === "8") {
      var _dataNumArr4 = [];
      for (var _i16 = 0; _i16 < data.length; _i16 += 1) {
        var _data$_i5;
        var _m3 = (_data$_i5 = data[_i16]) === null || _data$_i5 === void 0 ? void 0 : _data$_i5.m;
        if (_m3 != null) {
          _m3 = "".concat(_m3);
          _dataNumArr4.push(chineseToNumber(_m3));
        }
      }
      if (direction === "up" || direction === "left") {
        data.reverse();
        _dataNumArr4.reverse();
      }
      if (isEqualDiff(_dataNumArr4)) {
        var _step24 = _dataNumArr4[1] - _dataNumArr4[0];
        applyData = fillChnNumber(data, len, _step24);
      } else {
        applyData = fillCopy(data, len);
      }
    }
    return applyData;
  }
  function getCopyData(d2, r1, r2, c1, c2, direction) {
    var copyData = [];
    var a1;
    var a2;
    var b1;
    var b2;
    if (direction === "down" || direction === "up") {
      a1 = c1;
      a2 = c2;
      b1 = r1;
      b2 = r2;
    } else {
      a1 = r1;
      a2 = r2;
      b1 = c1;
      b2 = c2;
    }
    for (var a3 = a1; a3 <= a2; a3 += 1) {
      var obj = {};
      var arrData = [];
      var arrIndex = [];
      var text2 = "";
      var extendNumberBeforeStr = null;
      var extendNumberAfterStr = null;
      var isSameStr = true;
      for (var b3 = b1; b3 <= b2; b3 += 1) {
        var _data11;
        var data = void 0;
        if (direction === "down" || direction === "up") {
          data = d2[b3][a3];
        } else if (direction === "right" || direction === "left") {
          data = d2[a3][b3];
        }
        var str = void 0;
        if (((_data11 = data) === null || _data11 === void 0 ? void 0 : _data11.v) != null && data.f == null) {
          if (!!data.ct && data.ct.t === "n") {
            str = "number";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          } else if (!!data.ct && data.ct.t === "d") {
            str = "date";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          } else if (isExtendNumber(data.m)[0]) {
            str = "extendNumber";
            var _isExtendNumber = isExtendNumber(data.m);
            if (extendNumberBeforeStr == null || extendNumberAfterStr == null) {
              isSameStr = true;
              var _isExtendNumber2 = _slicedToArray$1(_isExtendNumber, 4);
              extendNumberBeforeStr = _isExtendNumber2[2];
              extendNumberAfterStr = _isExtendNumber2[3];
            } else {
              if (_isExtendNumber[2] !== extendNumberBeforeStr || _isExtendNumber[3] !== extendNumberAfterStr) {
                isSameStr = false;
                var _isExtendNumber3 = _slicedToArray$1(_isExtendNumber, 4);
                extendNumberBeforeStr = _isExtendNumber3[2];
                extendNumberAfterStr = _isExtendNumber3[3];
              } else {
                isSameStr = true;
              }
            }
          } else if (isChnNumber(data.m)) {
            str = "chnNumber";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          } else if (isChnWeek2(data.m)) {
            str = "chnWeek2";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          } else if (isChnWeek3(data.m)) {
            str = "chnWeek3";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          } else {
            str = "other";
            extendNumberBeforeStr = null;
            extendNumberAfterStr = null;
          }
        } else {
          str = "other";
          extendNumberBeforeStr = null;
          extendNumberAfterStr = null;
        }
        if (str === "extendNumber") {
          if (b3 === b1) {
            if (b1 === b2) {
              text2 = str;
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
              obj[text2] = [];
              obj[text2].push({
                data: arrData,
                index: arrIndex
              });
            } else {
              text2 = str;
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
            }
          } else if (b3 === b2) {
            if (text2 === str && isSameStr) {
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
            } else {
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
              text2 = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b3 - b1 + 1);
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
            }
          } else {
            if (text2 === str && isSameStr) {
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
            } else {
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
              text2 = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b3 - b1 + 1);
            }
          }
        } else {
          if (b3 === b1) {
            if (b1 === b2) {
              text2 = str;
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
              obj[text2] = [];
              obj[text2].push({
                data: arrData,
                index: arrIndex
              });
            } else {
              text2 = str;
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
            }
          } else if (b3 === b2) {
            if (text2 === str) {
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
            } else {
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
              text2 = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b3 - b1 + 1);
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
            }
          } else {
            if (text2 === str) {
              arrData.push(data);
              arrIndex.push(b3 - b1 + 1);
            } else {
              if (text2 in obj) {
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              } else {
                obj[text2] = [];
                obj[text2].push({
                  data: arrData,
                  index: arrIndex
                });
              }
              text2 = str;
              arrData = [];
              arrData.push(data);
              arrIndex = [];
              arrIndex.push(b3 - b1 + 1);
            }
          }
        }
      }
      copyData.push(obj);
    }
    return copyData;
  }
  function getApplyData(copyD, csLen, asLen) {
    var applyData = [];
    var direction = dropCellCache.direction;
    var type = dropCellCache.applyType;
    var num = Math.floor(asLen / csLen);
    var rsd = asLen % csLen;
    var copyD_number = copyD.number;
    var applyD_number = [];
    if (copyD_number) {
      for (var i2 = 0; i2 < copyD_number.length; i2 += 1) {
        var s2 = getLenS(copyD_number[i2].index, rsd);
        var len = copyD_number[i2].index.length * num + s2;
        var arrData = void 0;
        if (type === "1" || type === "3") {
          arrData = getDataByType(copyD_number[i2].data, len, direction, type, "number");
        } else if (type === "2") {
          arrData = getDataByType(copyD_number[i2].data, len, direction, type);
        } else {
          arrData = getDataByType(copyD_number[i2].data, len, direction, "0");
        }
        var arrIndex = getDataIndex(csLen, asLen, copyD_number[i2].index);
        applyD_number.push({
          data: arrData,
          index: arrIndex
        });
      }
    }
    var copyD_extendNumber = copyD.extendNumber;
    var applyD_extendNumber = [];
    if (copyD_extendNumber) {
      for (var _i17 = 0; _i17 < copyD_extendNumber.length; _i17 += 1) {
        var _s = getLenS(copyD_extendNumber[_i17].index, rsd);
        var _len = copyD_extendNumber[_i17].index.length * num + _s;
        var _arrData = void 0;
        if (type === "1" || type === "3") {
          _arrData = getDataByType(copyD_extendNumber[_i17].data, _len, direction, type, "extendNumber");
        } else if (type === "2") {
          _arrData = getDataByType(copyD_extendNumber[_i17].data, _len, direction, type);
        } else {
          _arrData = getDataByType(copyD_extendNumber[_i17].data, _len, direction, "0");
        }
        var _arrIndex = getDataIndex(csLen, asLen, copyD_extendNumber[_i17].index);
        applyD_extendNumber.push({
          data: _arrData,
          index: _arrIndex
        });
      }
    }
    var copyD_date = copyD.date;
    var applyD_date = [];
    if (copyD_date) {
      for (var _i18 = 0; _i18 < copyD_date.length; _i18 += 1) {
        var _s2 = getLenS(copyD_date[_i18].index, rsd);
        var _len2 = copyD_date[_i18].index.length * num + _s2;
        var _arrData2 = void 0;
        if (type === "1" || type === "3") {
          _arrData2 = getDataByType(copyD_date[_i18].data, _len2, direction, type, "date");
        } else if (type === "8") {
          _arrData2 = getDataByType(copyD_date[_i18].data, _len2, direction, "0");
        } else {
          _arrData2 = getDataByType(copyD_date[_i18].data, _len2, direction, type);
        }
        var _arrIndex2 = getDataIndex(csLen, asLen, copyD_date[_i18].index);
        applyD_date.push({
          data: _arrData2,
          index: _arrIndex2
        });
      }
    }
    var copyD_chnNumber = copyD.chnNumber;
    var applyD_chnNumber = [];
    if (copyD_chnNumber) {
      for (var _i19 = 0; _i19 < copyD_chnNumber.length; _i19 += 1) {
        var _s3 = getLenS(copyD_chnNumber[_i19].index, rsd);
        var _len3 = copyD_chnNumber[_i19].index.length * num + _s3;
        var _arrData3 = void 0;
        if (type === "1" || type === "3") {
          _arrData3 = getDataByType(copyD_chnNumber[_i19].data, _len3, direction, type, "chnNumber");
        } else if (type === "2" || type === "8") {
          _arrData3 = getDataByType(copyD_chnNumber[_i19].data, _len3, direction, type);
        } else {
          _arrData3 = getDataByType(copyD_chnNumber[_i19].data, _len3, direction, "0");
        }
        var _arrIndex3 = getDataIndex(csLen, asLen, copyD_chnNumber[_i19].index);
        applyD_chnNumber.push({
          data: _arrData3,
          index: _arrIndex3
        });
      }
    }
    var copyD_chnWeek2 = copyD.chnWeek2;
    var applyD_chnWeek2 = [];
    if (copyD_chnWeek2) {
      for (var _i20 = 0; _i20 < copyD_chnWeek2.length; _i20 += 1) {
        var _s4 = getLenS(copyD_chnWeek2[_i20].index, rsd);
        var _len4 = copyD_chnWeek2[_i20].index.length * num + _s4;
        var _arrData4 = void 0;
        if (type === "1" || type === "3") {
          _arrData4 = getDataByType(copyD_chnWeek2[_i20].data, _len4, direction, type, "chnWeek2");
        } else if (type === "2") {
          _arrData4 = getDataByType(copyD_chnWeek2[_i20].data, _len4, direction, type);
        } else {
          _arrData4 = getDataByType(copyD_chnWeek2[_i20].data, _len4, direction, "0");
        }
        var _arrIndex4 = getDataIndex(csLen, asLen, copyD_chnWeek2[_i20].index);
        applyD_chnWeek2.push({
          data: _arrData4,
          index: _arrIndex4
        });
      }
    }
    var copyD_chnWeek3 = copyD.chnWeek3;
    var applyD_chnWeek3 = [];
    if (copyD_chnWeek3) {
      for (var _i21 = 0; _i21 < copyD_chnWeek3.length; _i21 += 1) {
        var _s5 = getLenS(copyD_chnWeek3[_i21].index, rsd);
        var _len5 = copyD_chnWeek3[_i21].index.length * num + _s5;
        var _arrData5 = void 0;
        if (type === "1" || type === "3") {
          _arrData5 = getDataByType(copyD_chnWeek3[_i21].data, _len5, direction, type, "chnWeek3");
        } else if (type === "2") {
          _arrData5 = getDataByType(copyD_chnWeek3[_i21].data, _len5, direction, type);
        } else {
          _arrData5 = getDataByType(copyD_chnWeek3[_i21].data, _len5, direction, "0");
        }
        var _arrIndex5 = getDataIndex(csLen, asLen, copyD_chnWeek3[_i21].index);
        applyD_chnWeek3.push({
          data: _arrData5,
          index: _arrIndex5
        });
      }
    }
    var copyD_other = copyD.other;
    var applyD_other = [];
    if (copyD_other) {
      for (var _i22 = 0; _i22 < copyD_other.length; _i22 += 1) {
        var _s6 = getLenS(copyD_other[_i22].index, rsd);
        var _len6 = copyD_other[_i22].index.length * num + _s6;
        var _arrData6 = void 0;
        if (type === "2" || type === "3") {
          _arrData6 = getDataByType(copyD_other[_i22].data, _len6, direction, type);
        } else {
          _arrData6 = getDataByType(copyD_other[_i22].data, _len6, direction, "0");
        }
        var _arrIndex6 = getDataIndex(csLen, asLen, copyD_other[_i22].index);
        applyD_other.push({
          data: _arrData6,
          index: _arrIndex6
        });
      }
    }
    for (var x2 = 1; x2 <= asLen; x2 += 1) {
      if (applyD_number.length > 0) {
        for (var y2 = 0; y2 < applyD_number.length; y2 += 1) {
          if (x2 in applyD_number[y2].index) {
            applyData.push(applyD_number[y2].data[applyD_number[y2].index[x2]]);
          }
        }
      }
      if (applyD_extendNumber.length > 0) {
        for (var _y = 0; _y < applyD_extendNumber.length; _y += 1) {
          if (x2 in applyD_extendNumber[_y].index) {
            applyData.push(applyD_extendNumber[_y].data[applyD_extendNumber[_y].index[x2]]);
          }
        }
      }
      if (applyD_date.length > 0) {
        for (var _y2 = 0; _y2 < applyD_date.length; _y2 += 1) {
          if (x2 in applyD_date[_y2].index) {
            applyData.push(applyD_date[_y2].data[applyD_date[_y2].index[x2]]);
          }
        }
      }
      if (applyD_chnNumber.length > 0) {
        for (var _y3 = 0; _y3 < applyD_chnNumber.length; _y3 += 1) {
          if (x2 in applyD_chnNumber[_y3].index) {
            applyData.push(applyD_chnNumber[_y3].data[applyD_chnNumber[_y3].index[x2]]);
          }
        }
      }
      if (applyD_chnWeek2.length > 0) {
        for (var _y4 = 0; _y4 < applyD_chnWeek2.length; _y4 += 1) {
          if (x2 in applyD_chnWeek2[_y4].index) {
            applyData.push(applyD_chnWeek2[_y4].data[applyD_chnWeek2[_y4].index[x2]]);
          }
        }
      }
      if (applyD_chnWeek3.length > 0) {
        for (var _y5 = 0; _y5 < applyD_chnWeek3.length; _y5 += 1) {
          if (x2 in applyD_chnWeek3[_y5].index) {
            applyData.push(applyD_chnWeek3[_y5].data[applyD_chnWeek3[_y5].index[x2]]);
          }
        }
      }
      if (applyD_other.length > 0) {
        for (var _y6 = 0; _y6 < applyD_other.length; _y6 += 1) {
          if (x2 in applyD_other[_y6].index) {
            applyData.push(applyD_other[_y6].data[applyD_other[_y6].index[x2]]);
          }
        }
      }
    }
    return applyData;
  }
  function updateDropCell(ctx) {
    var d2 = getFlowdata(ctx);
    var allowEdit = isAllowEdit(ctx);
    if (allowEdit === false || d2 == null) {
      return;
    }
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    if (index2 == null) return;
    var file = ctx.luckysheetfile[index2];
    var cfg = _$1.cloneDeep(ctx.config);
    if (cfg.borderInfo == null) {
      cfg.borderInfo = [];
    }
    var borderInfoCompute = getBorderInfoCompute(ctx, ctx.currentSheetId);
    var dataVerification = _$1.cloneDeep(file.dataVerification);
    var direction = dropCellCache.direction;
    var copyRange = dropCellCache.copyRange;
    var copy_str_r = copyRange.row[0];
    var copy_end_r = copyRange.row[1];
    var copy_str_c = copyRange.column[0];
    var copy_end_c = copyRange.column[1];
    var copyData = getCopyData(d2, copy_str_r, copy_end_r, copy_str_c, copy_end_c, direction);
    var csLen;
    if (direction === "down" || direction === "up") {
      csLen = copy_end_r - copy_str_r + 1;
    } else {
      csLen = copy_end_c - copy_str_c + 1;
    }
    var applyRange = dropCellCache.applyRange;
    var apply_str_r = applyRange.row[0];
    var apply_end_r = applyRange.row[1];
    var apply_str_c = applyRange.column[0];
    var apply_end_c = applyRange.column[1];
    if (direction === "down" || direction === "up") {
      var asLen = apply_end_r - apply_str_r + 1;
      for (var i2 = apply_str_c; i2 <= apply_end_c; i2 += 1) {
        var copyD = copyData[i2 - apply_str_c];
        var applyData = getApplyData(copyD, csLen, asLen);
        if (direction === "down") {
          for (var j2 = apply_str_r; j2 <= apply_end_r; j2 += 1) {
            var cell = applyData[j2 - apply_str_r];
            if ((cell === null || cell === void 0 ? void 0 : cell.f) != null) {
              var f2 = "=".concat(functionCopy(ctx, cell.f, "down", j2 - apply_str_r + 1));
              var v2 = execfunction(ctx, f2, j2, i2);
              execFunctionGroup(ctx, j2, i2, v2[1], void 0, d2);
              var _v = _slicedToArray$1(v2, 3);
              cell.v = _v[1];
              cell.f = _v[2];
              if (cell.spl != null) {
                cell.spl = v2[3].data;
              } else if (cell.v != null) {
                if (isRealNum(cell.v) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test("".concat(cell.v))) {
                  if (cell.v === Infinity || cell.v === -Infinity) {
                    cell.m = cell.v.toString();
                  } else {
                    if (cell.v.toString().indexOf("e") > -1) {
                      var len = cell.v.toString().split(".")[1].split("e")[0].length;
                      if (len > 5) {
                        len = 5;
                      }
                      cell.m = cell.v.toExponential(len).toString();
                    } else {
                      var _cell$ct;
                      var mask = void 0;
                      if (((_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : _cell$ct.fa) === "##0.00") {
                        mask = genarate("".concat(Math.round(cell.v * 1e9) / 1e9, ".00"));
                        cell.m = mask[0].toString();
                      } else {
                        mask = genarate(Math.round(cell.v * 1e9) / 1e9);
                        cell.m = mask[0].toString();
                      }
                    }
                  }
                  cell.ct = cell.ct || {
                    fa: "General",
                    t: "n"
                  };
                } else {
                  var _mask = genarate(cell.v);
                  cell.m = _mask[0].toString();
                  var _mask2 = _slicedToArray$1(_mask, 2);
                  cell.ct = _mask2[1];
                }
              }
            }
            d2[j2][i2] = cell || null;
            var bd_r = copy_str_r + (j2 - apply_str_r) % csLen;
            var bd_c = i2;
            if (borderInfoCompute["".concat(bd_r, "_").concat(bd_c)]) {
              var bd_obj = {
                rangeType: "cell",
                value: {
                  row_index: j2,
                  col_index: i2,
                  l: borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].l,
                  r: borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].r,
                  t: borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].t,
                  b: borderInfoCompute["".concat(bd_r, "_").concat(bd_c)].b
                }
              };
              cfg.borderInfo.push(bd_obj);
            } else if (borderInfoCompute["".concat(j2, "_").concat(i2)]) {
              var _bd_obj = {
                rangeType: "cell",
                value: {
                  row_index: j2,
                  col_index: i2,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              cfg.borderInfo.push(_bd_obj);
            }
            if (dataVerification != null && dataVerification["".concat(bd_r, "_").concat(bd_c)]) {
              dataVerification["".concat(j2, "_").concat(i2)] = dataVerification["".concat(bd_r, "_").concat(bd_c)];
            }
          }
        }
        if (direction === "up") {
          for (var _j = apply_end_r; _j >= apply_str_r; _j -= 1) {
            var _cell = applyData[apply_end_r - _j];
            if ((_cell === null || _cell === void 0 ? void 0 : _cell.f) != null) {
              var _f = "=".concat(functionCopy(ctx, _cell.f, "up", apply_end_r - _j + 1));
              var _v2 = execfunction(ctx, _f, _j, i2);
              execFunctionGroup(ctx, _j, i2, _v2[1], void 0, d2);
              var _v3 = _slicedToArray$1(_v2, 3);
              _cell.v = _v3[1];
              _cell.f = _v3[2];
              if (_cell.spl != null) {
                _cell.spl = _v2[3].data;
              } else if (_cell.v != null) {
                if (isRealNum(_cell.v) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test("".concat(_cell.v))) {
                  if (_cell.v === Infinity || _cell.v === -Infinity) {
                    _cell.m = _cell.v.toString();
                  } else {
                    if (_cell.v.toString().indexOf("e") > -1) {
                      var _len7 = _cell.v.toString().split(".")[1].split("e")[0].length;
                      if (_len7 > 5) {
                        _len7 = 5;
                      }
                      _cell.m = _cell.v.toExponential(_len7).toString();
                    } else {
                      var _mask3 = genarate(Math.round(_cell.v * 1e9) / 1e9);
                      _cell.m = _mask3[0].toString();
                    }
                  }
                  _cell.ct = {
                    fa: "General",
                    t: "n"
                  };
                } else {
                  var _mask4 = genarate(_cell.v);
                  _cell.m = _mask4[0].toString();
                  var _mask5 = _slicedToArray$1(_mask4, 2);
                  _cell.ct = _mask5[1];
                }
              }
            }
            d2[_j][i2] = _cell || null;
            var _bd_r = copy_end_r - (apply_end_r - _j) % csLen;
            var _bd_c = i2;
            if (borderInfoCompute["".concat(_bd_r, "_").concat(_bd_c)]) {
              var _bd_obj2 = {
                rangeType: "cell",
                value: {
                  row_index: _j,
                  col_index: i2,
                  l: borderInfoCompute["".concat(_bd_r, "_").concat(_bd_c)].l,
                  r: borderInfoCompute["".concat(_bd_r, "_").concat(_bd_c)].r,
                  t: borderInfoCompute["".concat(_bd_r, "_").concat(_bd_c)].t,
                  b: borderInfoCompute["".concat(_bd_r, "_").concat(_bd_c)].b
                }
              };
              cfg.borderInfo.push(_bd_obj2);
            } else if (borderInfoCompute["".concat(_j, "_").concat(i2)]) {
              var _bd_obj3 = {
                rangeType: "cell",
                value: {
                  row_index: _j,
                  col_index: i2,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              cfg.borderInfo.push(_bd_obj3);
            }
            if (dataVerification != null && dataVerification["".concat(_bd_r, "_").concat(_bd_c)]) {
              dataVerification["".concat(_j, "_").concat(i2)] = dataVerification["".concat(_bd_r, "_").concat(_bd_c)];
            }
          }
        }
      }
    } else if (direction === "right" || direction === "left") {
      var _asLen = apply_end_c - apply_str_c + 1;
      for (var _i23 = apply_str_r; _i23 <= apply_end_r; _i23 += 1) {
        var _copyD = copyData[_i23 - apply_str_r];
        var _applyData = getApplyData(_copyD, csLen, _asLen);
        if (direction === "right") {
          for (var _j2 = apply_str_c; _j2 <= apply_end_c; _j2 += 1) {
            var _cell2 = _applyData[_j2 - apply_str_c];
            if ((_cell2 === null || _cell2 === void 0 ? void 0 : _cell2.f) != null) {
              var _f2 = "=".concat(functionCopy(ctx, _cell2.f, "right", _j2 - apply_str_c + 1));
              var _v4 = execfunction(ctx, _f2, _i23, _j2);
              execFunctionGroup(ctx, _j2, _i23, _v4[1], void 0, d2);
              var _v5 = _slicedToArray$1(_v4, 3);
              _cell2.v = _v5[1];
              _cell2.f = _v5[2];
              if (_cell2.spl != null) {
                _cell2.spl = _v4[3].data;
              } else if (_cell2.v != null) {
                if (isRealNum(_cell2.v) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test("".concat(_cell2.v))) {
                  if (_cell2.v === Infinity || _cell2.v === -Infinity) {
                    _cell2.m = _cell2.v.toString();
                  } else {
                    if (_cell2.v.toString().indexOf("e") > -1) {
                      var _len8 = _cell2.v.toString().split(".")[1].split("e")[0].length;
                      if (_len8 > 5) {
                        _len8 = 5;
                      }
                      _cell2.m = _cell2.v.toExponential(_len8).toString();
                    } else {
                      var _mask6 = genarate(Math.round(_cell2.v * 1e9) / 1e9);
                      _cell2.m = _mask6[0].toString();
                    }
                  }
                  _cell2.ct = {
                    fa: "General",
                    t: "n"
                  };
                } else {
                  var _mask7 = genarate(_cell2.v);
                  _cell2.m = _mask7[0].toString();
                  var _mask8 = _slicedToArray$1(_mask7, 2);
                  _cell2.ct = _mask8[1];
                }
              }
            }
            d2[_i23][_j2] = _cell2 || null;
            var _bd_r2 = _i23;
            var _bd_c2 = copy_str_c + (_j2 - apply_str_c) % csLen;
            if (borderInfoCompute["".concat(_bd_r2, "_").concat(_bd_c2)]) {
              var _bd_obj4 = {
                rangeType: "cell",
                value: {
                  row_index: _i23,
                  col_index: _j2,
                  l: borderInfoCompute["".concat(_bd_r2, "_").concat(_bd_c2)].l,
                  r: borderInfoCompute["".concat(_bd_r2, "_").concat(_bd_c2)].r,
                  t: borderInfoCompute["".concat(_bd_r2, "_").concat(_bd_c2)].t,
                  b: borderInfoCompute["".concat(_bd_r2, "_").concat(_bd_c2)].b
                }
              };
              cfg.borderInfo.push(_bd_obj4);
            } else if (borderInfoCompute["".concat(_i23, "_").concat(_j2)]) {
              var _bd_obj5 = {
                rangeType: "cell",
                value: {
                  row_index: _i23,
                  col_index: _j2,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              cfg.borderInfo.push(_bd_obj5);
            }
            if (dataVerification != null && dataVerification["".concat(_bd_r2, "_").concat(_bd_c2)]) {
              dataVerification["".concat(_i23, "_").concat(_j2)] = dataVerification["".concat(_bd_r2, "_").concat(_bd_c2)];
            }
          }
        }
        if (direction === "left") {
          for (var _j3 = apply_end_c; _j3 >= apply_str_c; _j3 -= 1) {
            var _cell3 = _applyData[apply_end_c - _j3];
            if ((_cell3 === null || _cell3 === void 0 ? void 0 : _cell3.f) != null) {
              var _f3 = "=".concat(functionCopy(ctx, _cell3.f, "left", apply_end_c - _j3 + 1));
              var _v6 = execfunction(ctx, _f3, _i23, _j3);
              execFunctionGroup(ctx, _j3, _i23, _v6[1], void 0, d2);
              var _v7 = _slicedToArray$1(_v6, 3);
              _cell3.v = _v7[1];
              _cell3.f = _v7[2];
              if (_cell3.spl != null) {
                _cell3.spl = _v6[3].data;
              } else if (_cell3.v != null) {
                if (isRealNum(_cell3.v) && !/^\d{6}(18|19|20)?\d{2}(0[1-9]|1[12])(0[1-9]|[12]\d|3[01])\d{3}(\d|X)$/i.test("".concat(_cell3.v))) {
                  if (_cell3.v === Infinity || _cell3.v === -Infinity) {
                    _cell3.m = _cell3.v.toString();
                  } else {
                    if (_cell3.v.toString().indexOf("e") > -1) {
                      var _len9 = _cell3.v.toString().split(".")[1].split("e")[0].length;
                      if (_len9 > 5) {
                        _len9 = 5;
                      }
                      _cell3.m = _cell3.v.toExponential(_len9).toString();
                    } else {
                      var _mask9 = genarate(Math.round(_cell3.v * 1e9) / 1e9);
                      _cell3.m = _mask9[0].toString();
                    }
                  }
                  _cell3.ct = {
                    fa: "General",
                    t: "n"
                  };
                } else {
                  var _mask10 = genarate(_cell3.v);
                  _cell3.m = _mask10[0].toString();
                  var _mask11 = _slicedToArray$1(_mask10, 2);
                  _cell3.ct = _mask11[1];
                }
              }
            }
            d2[_i23][_j3] = _cell3 || null;
            var _bd_r3 = _i23;
            var _bd_c3 = copy_end_c - (apply_end_c - _j3) % csLen;
            if (borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)]) {
              var _bd_obj6 = {
                rangeType: "cell",
                value: {
                  row_index: _i23,
                  col_index: _j3,
                  l: borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].l,
                  r: borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].r,
                  t: borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].t,
                  b: borderInfoCompute["".concat(_bd_r3, "_").concat(_bd_c3)].b
                }
              };
              cfg.borderInfo.push(_bd_obj6);
            } else if (borderInfoCompute["".concat(_i23, "_").concat(_j3)]) {
              var _bd_obj7 = {
                rangeType: "cell",
                value: {
                  row_index: _i23,
                  col_index: _j3,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              cfg.borderInfo.push(_bd_obj7);
            }
            if (dataVerification != null && dataVerification["".concat(_bd_r3, "_").concat(_bd_c3)]) {
              dataVerification["".concat(_i23, "_").concat(_j3)] = dataVerification["".concat(_bd_r3, "_").concat(_bd_c3)];
            }
          }
        }
      }
    }
    var cdformat = file.luckysheet_conditionformat_save;
    if (cdformat != null && cdformat.length > 0) {
      for (var _i24 = 0; _i24 < cdformat.length; _i24 += 1) {
        var cdformat_cellrange = cdformat[_i24].cellrange;
        var emptyRange = [];
        for (var _j4 = 0; _j4 < cdformat_cellrange.length; _j4 += 1) {
          var range = CFSplitRange(cdformat_cellrange[_j4], {
            row: copyRange.row,
            column: copyRange.column
          }, {
            row: applyRange.row,
            column: applyRange.column
          }, "operatePart");
          if (range.length > 0) {
            emptyRange = emptyRange.concat(range);
          }
        }
        if (emptyRange.length > 0) {
          cdformat[_i24].cellrange.push(applyRange);
        }
      }
    }
  }
  function onDropCellSelectEnd(ctx, e, container) {
    var _ctx$luckysheet_selec3;
    ctx.luckysheet_cell_selected_extend = false;
    hideDropCellSelection(container);
    var scrollLeft = ctx.scrollLeft, scrollTop = ctx.scrollTop;
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollLeft;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row_pre = row_location[0];
    var row_index = row_location[2];
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col_pre = col_location[0];
    var col_index = col_location[2];
    var row_index_original = ctx.luckysheet_cell_selected_extend_index[0];
    var col_index_original = ctx.luckysheet_cell_selected_extend_index[1];
    var last = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3[ctx.luckysheet_select_save.length - 1];
    if (last && last.top != null && last.left != null && last.height != null && last.width != null && last.row_focus != null && last.column_focus != null) {
      var row_s = last.row[0];
      var row_e = last.row[1];
      var col_s = last.column[0];
      var col_e = last.column[1];
      dropCellCache.copyRange = _$1.cloneDeep(_$1.pick(last, ["row", "column"]));
      var typeItemHide = getTypeItemHide(ctx);
      if (!typeItemHide[0] && !typeItemHide[1] && !typeItemHide[2] && !typeItemHide[3] && !typeItemHide[4] && !typeItemHide[5] && !typeItemHide[6]) {
        dropCellCache.applyType = "0";
      } else {
        dropCellCache.applyType = "1";
      }
      if (ctx.luckysheet_select_save == null) return;
      var _ctx$luckysheet_selec4 = ctx.luckysheet_select_save[0], top_move = _ctx$luckysheet_selec4.top_move, left_move = _ctx$luckysheet_selec4.left_move;
      if (Math.abs(row_index_original - row_index) > Math.abs(col_index_original - col_index)) {
        if (!(row_index >= row_s && row_index <= row_e)) {
          if (top_move != null && top_move >= row_pre) {
            dropCellCache.applyRange = {
              row: [row_index, last.row[0] - 1],
              column: last.column
            };
            dropCellCache.direction = "up";
            row_s -= last.row[0] - row_index;
          } else {
            dropCellCache.applyRange = {
              row: [last.row[1] + 1, row_index],
              column: last.column
            };
            dropCellCache.direction = "down";
            row_e += row_index - last.row[1];
          }
        } else {
          return;
        }
      } else {
        if (!(col_index >= col_s && col_index <= col_e)) {
          if (left_move != null && left_move >= col_pre) {
            dropCellCache.applyRange = {
              row: last.row,
              column: [col_index, last.column[0] - 1]
            };
            dropCellCache.direction = "left";
            col_s -= last.column[0] - col_index;
          } else {
            dropCellCache.applyRange = {
              row: last.row,
              column: [last.column[1] + 1, col_index]
            };
            dropCellCache.direction = "right";
            col_e += col_index - last.column[1];
          }
        } else {
          return;
        }
      }
      if (y2 < 0) {
        row_s = 0;
        var _last$row = _slicedToArray$1(last.row, 1);
        row_e = _last$row[0];
      }
      if (x2 < 0) {
        col_s = 0;
        var _last$column = _slicedToArray$1(last.column, 1);
        col_e = _last$column[0];
      }
      var flowdata = getFlowdata(ctx);
      if (flowdata == null) return;
      if (ctx.config.merge != null) {
        var HasMC = false;
        for (var r2 = last.row[0]; r2 <= last.row[1]; r2 += 1) {
          for (var c2 = last.column[0]; c2 <= last.column[1]; c2 += 1) {
            var _flowdata$r;
            var cell = (_flowdata$r = flowdata[r2]) === null || _flowdata$r === void 0 ? void 0 : _flowdata$r[c2];
            if (cell != null && cell.mc != null) {
              HasMC = true;
              break;
            }
          }
        }
        if (HasMC) {
          return;
        }
        for (var _r = row_s; _r <= row_e; _r += 1) {
          for (var _c = col_s; _c <= col_e; _c += 1) {
            var _flowdata$_r;
            var _cell4 = (_flowdata$_r = flowdata[_r]) === null || _flowdata$_r === void 0 ? void 0 : _flowdata$_r[_c];
            if (_cell4 != null && _cell4.mc != null) {
              HasMC = true;
              break;
            }
          }
        }
        if (HasMC) {
          return;
        }
      }
      last.row = [row_s, row_e];
      last.column = [col_s, col_e];
      ctx.luckysheet_select_save = normalizeSelection(ctx, [{
        row: [row_s, row_e],
        column: [col_s, col_e]
      }]);
      try {
        updateDropCell(ctx);
      } catch (err) {
        console.error(err);
      }
      var selectedMoveEle = container.querySelector(".fortune-cell-selected-move");
      if (selectedMoveEle) {
        selectedMoveEle.style.display = "none";
      }
    }
  }
  var defaultStyle = {
    fillStyle: "#000000",
    textBaseline: "middle",
    strokeStyle: "#dfdfdf"
  };
  function isRealNum$1(val) {
    return !Number.isNaN(Number(val));
  }
  var cfIconsImg;
  function getCfIconsImg() {
    if (cfIconsImg) return cfIconsImg;
    cfIconsImg = new Image();
    cfIconsImg.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZoAAAGACAYAAACUS6SeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAHBbSURBVHja7J13mFxV+cc/M7OzLbvpjZBKQhISUgAhgAlVkADSRcDyky4iYAAhAmpQQtMIiqigYkV6FRHphgBBKSGBkB5IIb1sdrO72dmZ+f3xniGTzZR755a5s/t+nmefTGbuPec7Z8497ynveU9on5m3YJMuwNnAt4B9gA3A48CPgY0UyPxJUzN/MLMShxwDXAMcAmwGbgD+UlBKhzVn/+yqqwrVFwIuBL7tZnkyYwaK98yaNb/QW6uBk4DLgfHAduDfwI+ApYUmOnHiKC+0AowAfgh8EYgAvwF+AMTd1OlQ40nAtcB+QIMpzx8Cy70oT8U6YZvXn2x+tN8A44ByYE/gMmA18B9g7wB9v58AzwNfADoBA4A/m4c5KPwWuCdDef4X6KVVtF1yGPAx8IDpAFUBPYGvAguBucCRAdJ7CvAecA7QA+gKfB94DKgMiMargaeAQ0159gK+BrwNqLUoIUNzFPAw0C3L5+XmAXoZ6B+A7/ZNM3rJxDTgl2Y0UUwmAxdl+WwI8HOtou2OzwFP5+hERIAxwDPAhADoHQvcbxrvTB3PZ4HaImscDmSbmukO/F6rXWkYmgnAP4wxyUd/U/m6FPF7lQO35bnmMuCvQLSIOs/J8/npQIVW03bDPjaejWrgn8boFJPpRks2jgReKfLo+yygLMfnhwCDtPoF29CMMUam2ka6Y8wDVV2k73Uw0NvCdV9F1kOqiqQzX+WvQqfP2gsDkWlcO79nD/McFWuGoAJZk8nHAcBM8x2LwRAL1+ytVTC4hmawqeiFNHaHInPQkSJ8rxob156ILBp2LYLOkAu/kRJ8egEvFWgw+iPT0cXocJTnGSmkMxJ4zfxbDJ1WjKYSQEPTC3jBYW/qJODX+L8WMhuos3H9JDP876NVQnGZLsbIDHOQxt5mVqGTz9rrgTdtjtpmmhGOouQ1NF2MkRnmQh4XATf7/L02GyO3zcY944FZZhSnKG5QDfwLd9ZZJiBOBOU+f4evAAtsjt5eIVhec0oADU21qdDjXMxnKnCJz99tJuIpt97GPcOA14HRWjUUh5QDTyAL0W5xFPAn/J2OXoV4k75j455aZMr9ZK0GSiZDE0XWVQ7zIK+7kI2efvKO+S6f2LinnzFSB2v1UAokAvwNONaDtM82z5KfbDBG7lUb91Qi+2z+T6uDkm5oQsAfkSknrx6+P5kK6ycLkTWYj2zc0x14EYkqoCh2CCGbcL/sYR6XIDve/WQbsu/rKZvP/B+BKVotOjbpHiW/RNx9vZ5OeByZv32vwDQmG51DsOdJYne/TCdk09xXgUcdfN9DkE2urwGbXCjDLsDvEG+5rcCTSASENVqdA8HtwAU+5HOjGWn8psD7RxmDNRZ7TgZ2p+1CyMbjzkZzoR3izyGOSf8DVrrUFv0S2cvWgqyl3Qgs0SrsnaH5IfAdn/LsgrgTH2rzR031FC/ysXzKzSjsBex5sQGci2wa7ZXWIzzZ5vRDW6oR76NJ5v9VprE4wxie/2qVLirXIaFQ/OIu03l52OZ93wTuxd/NytOQdZv/2bzvGMRzNeWY1Aqch2y2djLqvK9Nx/prSKidc8wzprhI2PxoN/qcby/Tg7CzN+BbPhuZ9JHNWTbvmW4qcvr362xGH/sXqCOCrJ9NylKezwB9tUoXjfPM7+4nEdPg2pmOHoXE1itGRIyLbV7/VdNODGvTOXY6xf8rMs/e1AAPoc5Anhia64uU9zDsxSD6VhHL6ds2e2DX5RjNPYd9t/GQeThOymO8r9cqXTSKVfblyNRuZ4vXX4D/LtLpowarcdGGmPYhksXAPkhh671T8zzPVfi/HaNDGJo9LF77EWAlhvetNvK342s/oojlZGe387UWRnN2A4/ebNHQnqpVumhYfY5WIfu18vFzZO3ACt2QfWBW2KeIZVSB9ZhjV5A7MnQVst5rZ3PoNy0akckUL3xWuzU0b1h8OI5FNkLm4zc2jI2dDZUbi1hOG2xce6iFawYg61TdLVx7iemFWaGzVumi8YbFenQcsMLCtS8jrsxWz3tpKIHnCGCLxeusRK7ugkytWYl1dpIZIVmJUhLFXhgrxYKhud3Cw3GUMTZWuQ5ZuM/HEzbSfLqI5fSkjWuten+Nwto5GVNt5P2KVumike8EwTrEYeNDG2k+jkQZz8cyrHtxPlHEMnoLObfKTYPUC2ubYi/Cusfc+9jb6K1YMDTP5xhO1plh5GKb6SYRL7an8/Ss7Cye/gg5LMpvmhCPGatML9JvuQR/3GqVzLyU47dvBE6jMK/A35B9zS/1rH3X/GvV0DxVpDK6zsa1P8H61KHbsxdnaHV239CALGSex65TRNsQd793Ckw7bob+r2X5MU8E1tqsABOQHdfNPpbRbJvTDffZNExuPRyTsTfFp7jPDchO+LVtjMyZyFSYk9HS3VmesSuw546bRDaT3oi/02hbsrQF2XgT2SIQ91FjI/AldC+N66Rv2PwjcpLeoUjI/FkuVMTUD/d7Y1i24GyD4Xrg66bn3gfrIcwxUxDftZnfJxTmUn2jGdJf6sNvmBp16sMRDP6CuKEfjBzP/KbNDlWu+rsNcQqJIGGSbkKmo+wSM52hn5jnyM5xzIcj0+J2PNe2m05nzKbOvyPrML/24XdrQQKIvqVV2FtDkyrsVz1oCN0Ox7EDawuqIIt/PynAyHyALNyudtAwdMXbaAstZkrmHa3KgSJms/dudSRyHfamn6zMOnxq4/pTTaNvx8hsAk5w0ID/BnGaucnD3yuJzOg8o1XXG9r7oVoRJFyL3T0Os5BgnKtdqLxeOTHETfovazVWfOAi4BGbo5+V5jlyOkqYDvzCw+92HTKbo6ihsU3Kz/58m/c9jbhyb3FBQwvZ16mccpk+HIpP/BCJJmAnztl84PNY23tnhSke1fefYW/vn6KG5jO6IN50dsNU/AGZimpyUUtqnWqei2neSuHBFBXFKiHECcFuiKo3kVBJK13UkkQ2XLo5Q3A/cI3+zGpoCuVeYGIBw/ML8cbLpQ44GncW7H+Hu/P0ipKNb2Mv/BLIOscXsLa52y6tZobgPy6k9SIy9ZzUn1kNTaF80ca1CeByxDXVy0q3AZmSW+UgjaeRSAH6cCh+MNnm9X9CHAYaPdTUiERBn+sgjbdMGi36EwfT0Fhp4BIB+F5Wp75akLDgfp1YuBw4nsLOpXkDeyFJFMUp221ce5sZIbT6oKvOjJoKmSFYgkxlN+rPG1xDk8+luIlgbBq0Emaj3jT6D/msbR7i7tlo857j9eFoN6x04VnzAysRBJLIQv1Un0fahcwQrEK2LOjG5oAbmnxeH48he1yKzfQ8lWkdEjn6pSLpewtxVGix+HAcj/2D15Tg8mCekf/7uOs84kTnm3lmBL4G3FkkfXZmCOrMtUu1+vlPmc3r/4UsRl+Y5Ue/MiDfa7UZNfyT3Q9XW4as4RR7J/1LyE7k+5Aw722JmYf8Apyt6yjBYw4Su+8nGT7bioSxCQIJJAzVv9j9wL4G4HTEu7OYzEPWkv6BRDloS9xcc4mbxnvWrPmB+IEmThxVEhW+EGeAi82PNtf0aFYju4UPCtiQ9H/AOGT9ZRUyrfcY4tsflHAtTyIhzi/NUJ79kHAfi1HaIzchMdBmI7H7NpsRxEFmRBMU1iMenFORM6l2GM2HB8DIpD/rQ0x5vmnKcxMyA7M3sJ/RrJTIiAZkHva3WDsGoNisQTzKLg+wxjpjWH6t1bFDUY1sgEyav4TpfScCqLUJWey/LcDl2YRELnikBH77k5EDEsebkeG/KF50en8MzfxJU/WRd4MZM7QMFKschhy/nD6tW4XExTsL2U1/BR3wfKHUVFCxp6Y8nJK6po3BrgK+gawfTQIW6IimKI9kM4rSjvgcsh+qS5bPI8AYZOPjUbgYTXjixFFWGvAIsmbY3fzb9nWuz3Yga7h3k8VrzmEDPhwYbUYBb2L9VNFUg/4dY8hHmbZvCTKd/jNkbcxrRpL97K+eSJifw9XQKIrihH2AZ3MYmXSqEWeWI/HOA60PEl7mc0APYzScHAdebXrs1yBrjlchO/Cd0h/4K3BE2nv1yHTTneR3q+6OBJ8dl6Hhv96MJCfhvdPN2eSOF3cYMJBguLa7a2hGvVb8eHLtYvruqquCo0Wn8YLIQGTxvJeNe3oYw3SIB41gZyRK+TCPvu9Y4DkkUsA/HKTTAwlKO7jN+7XAz5HF/kvzGJvpGYxMOoMR54xvelwHBlu4ZkB7NDRhff4VxXN6Ie7s/Qvszb9s00BZ4bseGpkUEeTQw04O0rg+TwN9CRIMN9dIYYKFfD7nR8fewjWh9vgAhB1WgM3m73qUFF8CPkRCcSR9+ms1eZ6kxR84uhgj46RR39uMCjq5qOsMn75/byQieqGcbuGac5GTTbMZGysLvT20qgbP0HzJDDVTi4A3aSP3GX9GFhsjPuYZMXn+RYs/UFQjrqtjXEhrAuJEUO6StmE+lsP3HdxrdRR4DvBwlvKxEkm6m1bXYBma/mTe8zHDg+F9KfJQB81b2ZVyJObeIS6meRQSIdmNToyf+3VGOrjXztrUaYgXWUUBhqYC8UxTAmBouiCLk/2z9JAecrHHVapcgr1z2N3ieiRqg1J8IsDfkKCPbnM27kQb93OjipN1h6dsXn8iMs1Ynfae1dNydVTjEWU2H57780wDHImc7X2JawpnVgantKzv6TkTWcD1y+g+CNyi1TkQhJCoGV/2uDOzFvixgzQeBg70qUycbIb7MbKTfqCNe44xHeITkb02dgzNp1qFizuiuQsJVJmPb2H/VL72xuv4d3rf28D56GFoQeF2JBCq19zosEP3K5wdHmYHJxHdNxrDYfdY6FQsti42DI1Th4Awspb2JSRWoRuUIxs5601Z/AUY2l4NzVSblfpOZD7ZbWqR8A2fIHPMXnlxJUwet5k8C+F+vD9y+VO8P9FQsc51wNU+5neXGT0XOso4GtnJPx8JTPk8Mv39G2QH+/eQTZfFrl+LjOH42OZ9hyAef1an7pxMnU0GFiLBO59Gotmf5fB7p6ZgLwJqjCH8OhL9e3IpPRhWps5OQjY82SFqKuwhuBcpuRqYiQSi82P6YyCyw/lYJOJzIQ/brchu8G94NB1xGnqEQFA4r4DnxCkRZMf8RmSqtpDRwkU5Pu9sjE91AMp3ObJz/kUkFI1VDjDPoJeG5qtmpBFuMxL5i2k3nnbQkcg0BVuDxMo7gBKJjZZvRDMBeIDCvNN6Il43XVzSer1PRqYt43G2T+jCAhsBK+m+hRIUirWXrNw0Op1dTrcaibc2IUBlvBIJQ/NRAd/FK0OzN7JhNJylw/2AMZB2yTeLVF2Ejo0nhmYvdvfesMu+Zujnhjvm2UUsJyd5t5iRh5vxqm435aoEhz0sXrcKCf2Sj59j7QTWVAPpZiesCvH2mhTAcl6DTKPN8SDtQgzNVezuTt3WIDyNhOSxyiVkD76ZzomzZs0vD8ohbIUYmi7IoVxu7Is50WKh5WPPIpaT07zrkLUUNw6Gewbv134U+7xh4ZoNyJn1VmJZvWw6OHGL+Te49D1SI6QvBLisNyDrS28HwNAcYOGaLsiU3xAL156ETJmFLP5WnUrh4QhnEf847uxmTnENcra4E1YXsZzcyHsp4o3iZGH1Q1OOcZSgkc+9vM50uj60kebjwGUWrlsGvOfCdyhDXOWPd7ls6jwo783GGL7uYprdC7hnq8XremFt8+73sD4D9DbWPeoCZ2juxRuPsd/hbL73gSKWk1t5v2V6qYW4Im9Czm+vQwkiL5F9zrwRmT79bwHp/ibPCDaJBMh06t6e8nA6tYTKvM6MEP9TREPzQ6xPcbo9qju7VH6otoZmKvB/HuVVaXpo/Qu8fzrezMvmYw7uLro9jf2pr1bEjXUJSpC5wTw/a9sYmdQGXiejpbszvB9HTuL8h0PdISTK8lds3vc84tJbTBrMCOzfLqRVyNTZm/i3Zy69Tn2plNqDdEPzVdxZS8lFP2Nsqgss3MOQmGp+nNewAlmQPQz39xHcanqqVvku3niuKe7zF8Q1/jAzihmKHGDmlMuMwdkCbEPW6j6P83A0IVMXv2nzvv+Y0Y9fvfnO5rvOR6ahlwLvINNHM3FnDbdQ9+b7kdM7/aDFzGyUlMdpah/NocB9+HMWwoGIO+A5BfQC6pENcVdT+lyGnLORb+PVPVl6s0pwiSGHdblJ0oyE3XYE+Tn2Y+S9ifP1Rrsd4ieREFde4mTD5q+RdZhpHupLmtHTC6X2QKQMzSP4GwzzLMTdN/8I6rBm2ilxZI71NbI7XrwCXK7ttuIRl5vRsh3eMZ2jeh91nuaDkXFqaEDCAvVCTvz0gmvN6KnkCJthc78i5D0dCT7YkalD5pcz7e5fisyZt6Ao7lNlGkY7zAO+yK4OKVY2czvtLZ7uU5m40au9zCNjcCvw01KtbGG8jTJrZWTT0VlF5iCkV+LOvhtFycQEoKuN6z9C9q5savO+lViAOxxqHe5TmfzZhTRS01vPuKjLj7iJnhua85EFNj/3ZsRNnv+nzzsgXkM3ID75683rp7VYFA+xEyx2CRJBeUOBowCnbUvYpzL5lUvptJjZCDf2+PwT/73aXKcMCTXxlD53RWc6JRS7SCl5rG4c/QTZV5dt0/LLFkYcTj2kluB9nMMluOuq3Ygcq5JrDRYL5XYm7WD6vEyfN5eYMUPLQCklliFhUXKFmlllPs91FsxU05B+PsvnryOL2E54AjjDw7JIIjvy3R411CHR319DTiC2a/j89Ozz1tDMnzRVHzlF8Rcrh3j5sVfsXNMIDs6i8RjybwqsQ/YMnYl4h40w7y9FTvF8GDnfyQkPIftUDvGgDLYi3ndPelTGaxEvvVexvtdnFeJl127WaHVEoyj+86DpQWdbe3gfd6N952rQPocccfBlJGrHKmRT9XRkvdAKCfOdHvRIZxyZhrrNGLVo2mchcjs1VJM5uvJyxJPrYazHKyuUJcbYvEb+Y1NyeaKWrqEZ9dqtgRCiIyufuOqqYOnpmFOOc4AfAT/J0sP200lmE+LheGVQCidL2Pst5D6kzRMNEyeOcivJecg02jNkjorfYurFFW52MoJyhEDpjGhmVhY3//a7cVQpDjchi89XIgvdjUjssB8Ci7V42iX/RaYpT0M2dY4HtgP/An6A/aOqS2dEU8A9XZAd7d9CjkjdYIbaP0aOhu3YtF+DGEJO9fy2/u6uUI1ETE6avwQyRZTQonHEPsZYH2PK91dIWJigHK3RiETJLoWDC7+JbEAdbUa+T5myXG83IbuG5mTgj+waqmFPI+ZiYDZwgY89sj2Rk0ArkXnaKvOXel1ptKa/rmxzTRVyBvd7wJ3I/pXt+rzuxm/bTF2kfvcTkc1/urnUOocjYZ/Sp1CqkMC2ZyF7zK5AQhAp1jkN2dyY3tu7ARiFxFbc4VZGqSm1Yk9NuTi115Y7TR1M0Q85+fN4YCI215DsGJqjkIWzbDHRypGFupcR7xAvF7MipuE7H/cCgR4E/N00mBfizt6iEOLZc4Xpae1AFgSnYf9skqh5YHoCnwKLfOylTSb7/PgQJDDj17Wds8SBpm51yVG3xyBz+UfhfZTersjR4HYX2TtlaQuWIlGmH0GiTPvFOPP8VmQxQM8iUY/9iNE2wjyrDUgAUjunn1aZ9uJMk0YYcSZ4xDxnfpxHdVgbI5POIKPjTDsJWt1xOwHZvW4l8GZ/86N28bAgrjYjJy+iTfcCHjOF7dTI3IdEqh5rHuIa02i/bvRboQb4mTGAc5C9D/ONsbkO66fxOeGcPJ+fTu5z05Wd0zr/tPhsVJtrx3ioJ2Ke1QtN47hX2t8QMwOQ7S9bWzAUOdtmKd7ufWnLLXnq4FHI4XQ9PNTQ34xCFyDTys+b5/S7Fu/vaTqgtwD7me8TZed04DvAHj6UZb4D1U7B5hHSVgzNGGNk7JwhM8ZU4GqPHg6vPWQipnF32jh/M8dI8l5knSsX5UhI8KsyNE69ERfUe32oeIMs9MJ6qR3JW4bP2yynHuY56u+Rpq/gzd6UVKP5EOJp5TVVFvM50MwoeFGePUzaR7R5vxa4A1krytcxvhnYN8fnQ43B8ZoBFmZXbJVhPkMz2FT0QhqRQ5EjkN3uce9jGlk/pjic9B7yGZEQcoZFrgOTTgUOzpPOuRYqhlNCLtSljkxvMxItpIHrj0xHe2HIvT62OYwcVOg1lTbamX2AWbgfqPN6Mm98TXEpcrZUrufkIAv5HBSQOl1utyJko5fpTTux/ieZxtTNKa4ePhbmjx0aRCsN+C/JfubMEItpDEIJKl2MkRnmII29zaxCJ5e1DfXh++9rsR47YQty0qad0eVMZHrKLawcZXAhEiE6m1GMWUijWyk+BOEcD8cLDh+OFBfh7hHRW30sHyfHGFhdAAwBvyDzdGCTxTRqUYJINbJHwo11lgmIR6SbBxT6FRH4Uh/yOANxkLFKHyQszOEu5W+1Q/41xGkhmsVg5qN7ezE01aZCj3Mxn6mIa5wbzMe/0/2cjMRetHn9DHY/otpqQL1qlKBRjgSDdHMN5CjgT7g3Hb3Ip7I414c8PkEceN61cU9n0xH4kgv52/GyPZPMpxpbMTRd8McByFNDE0XWVQ7zIK+7yO/NYIUY8DufysdJ5NRbsO+K+FNjlFNY3c+jhiZYRJD9HF4shJ9tniU3eMyn8vBrF/M6JBjlf2zcU4V4iH3NYd52t0OcbO6psmlooASnz8Jteu9/RNZVvHr4/mR6ZU6ZhvinB9nQLEWm3pps3ncLO0/Ts7oPoUbb9sAQQhZ9vXTtvQR3vI8eR6aPvGaLj+W/DdlC8A8b95QBfyH7WqkVfoz9vYPHsatH76b2amjSN2z+EtmZ7PV0wuOm1/Geg3TqETfCVMTZHcYo1JmGvRHx5jrZhUrrhOcQn/MnbI46ppvfZpbF62td+F0OMRX4NRsVPt8Q/3dI5ICtSBj2nwBr2rmhuR3ZSOw1NyJ7q37jII2EeUamI8c0p/ah1LEzFE4lEoLECZsd3LsvEnVkLPacIexGPUmtldZQ2JryRuTsHrvehUcD/0aiU/s1ooki3qw9gTfMSNApnZGtFieZ+vOPdOOb+jF+SG43WzfpYgr2UPKfdZGLFjM9kYkfuWBkwJ1QNM+bwn/aprG5EXEtt4KTqbNzkfDrvdKM68kOe7rVpqJNSpueuMT08k/EflSEUuE6dl9n85K7TKfgYYedqcty/I5PFtHQnGdGh34G//0JslH2/QLuXcjO6CiDbdw30bQTj/hgaL6C7Ozvl9bGnWmjrcnWUX2CnbNVVYiH3anGgP43bH7MG31+IHshi3Be7A24HplacwO3Trd7yRS43fSO99jQTEeiF/Rq0zN5Eti/wDQjyDrfpCy/+zNA33ZoZM7D/6O4I8BfcWc6ui01pvE5xoW0Cpk6G10EIwOynODEcWk54slmtxM9AevbKQo1NNcgZwb1S3uvkzFwBzuog/dnqYM9U8972DTMxWAYEqrCTaYi4dfdws1jVF9F5o4bPGoU7HIMO9eCMo06n8O+e3sI2QF9Up5ORrHqnJcU6zuVA4+aDoKbsw7P457rbyGG5iKKd4zJN3G2Z2mFKbuPCpgJsEIhLs4HI+u/2fJ9jsLc8O8i93pkL+AHYazvfv8IcS3Oh52T1I50sXJcnaMgnUwruMlMY2zcds8uZI0m3znuvcwUgJ355pvJHxEBvN+RXgysPkersLb29nNkethqD3e8S9+juxmBu+mWXYih2aeIv2UFzjdBf4qsI8/1QF8hI5qryb1Bv5DOpdVtKyeHkcUgKw/HsViba/2NDWPjVkM+BXENdhsvjguYZYyNm1FYC5k6O9TCNQOQ9TQrPahL2NU1OxedaX9YeY42IJ5GKyxc+zLiymw1QrcbI+XeJt8DXC6bQgzNpiL/nm7kvx6ZUnrXZW3dPHre+yFLGr0tPu9WO/a9w4iXTL6H4yjsue5dh4Txz8cTLhT6Fab3ZwerD2+jR5X4ddPguGVsCjE0Vr2/Rpk/K70bq7THc1byPXR1iCPEhzbSfJzsC/XpLMOZF2dqRPYq7m7UdmJonijib/km7nhipQzWUbi7HaMQQ7PW4nXDkDiPVgyNVf4RRuZib87xcEzG/kFmScSL7ekc12zE+eLpZUhkVDvUYX0+vdHDyjzbjBK3upBWIWs004v0EC/B+hEJpcRLOcq0ETkTpRBvu9+QfS0t9ax9F2fhZAYaI2N3usrq81HI6OARZCG5GHzf5fTqgC8iWweKZWhuxr+QQ+ksBS5Pzdldj3jNpJ+SuA3ZA/JOgRnEzdD/tSyjpBNtWNlsFvUX2AsTU4csgltdpHM6tRdBDgSbgUwnXofENLsI2czZz7zvtAIUskZzH+5551llg+m4tNfTOG8A/q9NvW5E3EdfdjhaujvLM3YF9jYntmUIspPebjTj/2F902ghI5qkMc434e802mbTCXSbejOL8aILaRViaB5Fjhvx+3k/Dlid7tXxR8RN7VDkZL1ZOD8LvhGJI/R7Y1i24M7GvQvMg2fXyBxnHpBzLN7jZI0mjIT4ONmHH7RQ9+YbkUV/P4IepkbHS2jf/AVx705tiHvTYYcqffS+DXG2iCCOJTfh7ATO4abhs3vMxCzzPFsdmRY6ao8BPzAdoj7YC2VzpBkNRm3csx3nRz53ZvcNsFvTOpNuhOMp1L35DvO8f9+H5yDV9i+B3d0HW3A/JEUdsoPfLQ4yFciOkalH9qTMtjkCcDJ19nWfjIwTQ5NqwLribVSIFtM7fYeOQczFaZL0Hv515J5Gs0NPJEK7XSPzimlAttto8JyGoIkjXlxWOcN0RO0YmU3IXjcnhjuMxC87wuP65eSolOvM836Jx8/7yellWYqHVV2PPf/6BmNk3iigYXZiaM7zsUycxDpLGq1Pe6QtbtJ/GSVI/ABZm7HDv81IJjXSt7qfw89YZ99GNiXaOVr8E2R3/lsO8z7NByPjZEST3rl80CNtqfbkxbYWuNSws/em0fRSZhU4AnCyRrOfj2VS5UIP5GwPeuGpSn2/tuuB4xSb1z+NbMRN73wFzdDcaEYydsLofwB8HljgQv6n+/Q9dzi8P46sJb7ggbZrMz3vpWhorM5xNpqRzEwHIwAnazRVPpbJHBfSSM2pznNR1604C/qoeEc/G9c+ikx/txTQs64HWj3+LqmI2XYjWs9CYpOtdknHCJ9+u/tcSKPFdDbecvl5z7ifsRQNjZWGsNH0vv7j0Ag4MTQrfSwTt85lr0MWMd1YsP8d7q0nKO5jdc3jfsRDMlOUAiuGxg+PscsRT067I7RjXR5thXz67e52KZ1UZ9yNzuX9uZ73UjQ0v87zeZOx1C/luMbK5rbN2Ntc15YXfSqPjTiLvNqWDeYBXOUgjaeRxcYkSlCxcujZH5AplmwbnK0cK+3HtJndEzL/gKynNLmsww+Pyg+Aj11Mb7MxNssdpPFPZF0m6ZahsdJwJHwYNv4xxzD9FPLPPf6N3HsPms0D5sQZ4Kd4u+ET0wCcj/uBOpebyldIb/QN7IVOUYrD9DwN1m+QUO+5fkcr0y7/8+G71Nn83hd6VD+9jmaQwJu9MKkQY4Xsb3sL2SeWMy6fXUOTL0ZTE95vxkuaxvUbSCiXTUbXn5AF+OctNtCnGGPyH2Og4ubBuxeJYup0V/Ji0+Bu9qgc3jaVwytvsXnYP9pgnjFQjSi5WOnCs+aUTchRDq9m6KxdieytytexvN70sLOxDH+OILHSwCeQKbYbPBxpP4Q3mz1TMxdnWmzfCh2NfcGm0V5iRpN5n3e7YbjvJ/d+i8dw7hFh1dj81fw56R38xfx5xdPIPoXhyL6FSmR9qFva667m39TrSsQrLv11F/N5Ajnk6gfY21dQKG8ha13PWpgmWWWMTB1KPh4Evpejo/c+7jpl5PrNjjT1c7QZGb9pY4S8EdnXdoVpBEchHl9LTFvwM9wJsZSPBxC35mwRp1tMx/QhH2YYjkcOEjyMXffxhMwznY1OWZ6xpUhkiEdwP5p8W+aa5/1f5PfMTdUdSwMLu4bmX8gi74VZpluu7LBNx8ysznCNuOMVZl3HYc1upvgScirffWRe/I2ZxukCnK3r7MpVVwXr950xw83U5iCnwP4kw2dbzUjbTxaZv0JoQryNbi3irxNHNmlmOlOlHjmW4iWftGzBvmNCoFoyxMPw76aDm+l5fxuZVbL8vBdysNDFSNjrS4CRxqI9ZR6cjZ59fXcbT8UeTyI7wr9qfn//fvf2y03I0b9XImfJNJppkR9iP4itIiP8CWZ09Q1gr7R26n0tHls8i5xDdZYZKY5GplqfMbMptiNbF2JoUmeJJNv0KIo1YvAH7w3dMchRq4cg6zo34O20nl3qEI+/Xwf8IQmZEfe3kWjEG5Bw+z8OoEF8BOvnxLvCxImjaMf4Prpqx+XZgMSodOUUZLuG5mTE4yt9CmVPZPf3xchC2AXaI7PNT4xhSdEJ+DMSWdfdxdTUFFD7Ndy/bTN1kaqfJ5oer6vOKu284VZKnKDUTzuG5ihkITrbonA5sgD2sumVr/JB/56mMU5fVK80hjD9db5F+Bpkb82diNtzg4+/wTfbGJl0piEB9K7A2z0pIeBck88+iEPHayZ/u2eoRJFF4Z5mOmMR/rk6Tyb7/PgQ5IC8r2vzo42jEkxDM8E0wFY2aPVH5vgm4Z0HUgj4pZkecWvT6UHIAthGMyp7yofyL0c8VHJxGRJT6lxkIc6LsrzPGLx0YzEZmc67xOLwucYYpgvYdRFxPXJu0G0+GJx8xz+cbvTt0EdfUfzDSiM9xhgZO6HoxxhjU+2R7suREzy9iGzQE3HNPMyH8j8Ya+dzfxVZZ/Aifto5bYxM247IvcgZKPkM5gvIZrK2niq9kU1y9/pQnoPyfF6FnMehKEqADM1gYzAKeTgPRfzbIy5rDgFXe1wuEWQPgNfYCe9/IhKmvavLGr5lobx/bQx7Nk41RjMX52L/7JNC6oYbnStFUXwyNL1ML7W/g/RPMo2Um8HmhjrUZJUDgT08zmM29qYXJyFuxn1c1GDlnPjUVOXlWT4fYjGNQfrIKYoamhRdjJEZ5kIeFwE3u6i5t4/l82OP099sjLGdHb/jkfDmg13SYNXxIYSstWTalGs1OGGtPnKKooYGZF3laWCci/lMxb2jQ/3cC3GWD3nMRDz61tu4ZxgS5220C/nbjTI9g92nLq3GNqvWR05R1NBEkXUVLxbC70KCTDplCf6ccZHqxfvBO6bMP7FxTz9jpA52mPct2PcO/KnpPKSwem6PGhpF6eCGJoRsxjzJo7wiSITloxymk0A25fmBn1GIFyJrMB/ZuKe7GZEc4yDfpWbkZvdsjlvYedCR1am/Gn3kFKXjkb6P5pfkjszsBuWIm+6RWDt8LBs3mxHApAAbmsmmPIcAFTbui9rMpxMSg+iryJG7hfAccmzCEzZHHdNNHZpl8fpaF+rPIcjG29dcGtl2QQLFnogEtHwSidSwRpsHRXHX0PyQ3O6rbtIFcdM9lMJPpGtEjhz+MuIyu8O8V4ccWrYdWRM6zaHWQsJyh9g9DIrXlJvR4gsUvkn2eTOafdqmsbkR6yd8Opk6OxfZ9Nkr7bc5md3PU7FDNbJHLNVhqTL15gxjeP6rTYSiuGNozsOfw4nS6YUcOXAohceeiiE7+TPxfReMDFhfe0jnWxQnTHgnZArsHgdpvIQcdvZPm0bheI8NzXR2P4+8sxl9HIVE6bVLBFmPnJSlfj4DjAXWajOhKM4II6fkFYNhuBQZtA3fwz136kKmzr5VxN/z2y6k8Soy7edFvLdC1miOyWBk0kfHz2HfDT8E/Irc65G9ivhsKEq7MzRWNyV+BMy3cJ2dEN1Huvx9pgC3u5heIYZmRBF/z5EupTPTGJt6l/UVskYz1cLo+GXsbeK92WKH4FRtIhTFHUPzhoXrViHn02+2cO1vbBgbN48mvQKJzusmhegr5pknbobAn2WMjZuBUQuZOjvEwjUDkHW/7hauvcSC8UrRWZsIRXHH0OQbAWxA5sHthP2/DmsuyE+49D2+A9zhQfkUskbzdBF/zyddTu914DgXjU0hhsaq99co8+d0hJTOK9pEKIo7huZ5sq9p1Jlerd2DzJKm8X86T89/ugvf4RLENTtkU58VCpk6+xHwcRF+yyYkTL/bzDaj2a0upFXIGs30Ij0bS5AjBRRFcUjKvfl682C1dR89Bdm1XghxJBLAc+zu2bMB+BLOPXouBO62aWTqTONlZS2nEEOzATm/ZwbiJuvXUZazKXzaLoIcFzAe8ebbhriJN6S9vhXZpOkkWkIhazT3IVNj03x8LjaYDtYGbSIUxT1DAxIV4H7E5bgrMkfvdL2h0RiU3yP7Erbg3oa48xBXXrtGZjLW5vJTxrYQ1iMnOV6ARFq2c5LpZcB3beb3CYW7VIeR83dO9qG+FerefKPpAF3qg8ZUHVmizYOiuG9oAFpwtgEu24P7ZZfT/Bqym9uOkalH9nu8ifWYa9sd6twBrLB4bcgYYLtG5gNkHWV1gRq/7pORcWJoUga4K95Gr2hB9l+9o02DonhnaEqB/YE/YO8Aq+3GyLxhs8HzK9ZZxIzOzrd53yxkL8gWhyNDv3AS6yxptNbiTTy+uEn/ZW0WFMVdSvG0weuQkCtWaTRGZlYBPWs/DE0VEv/NrpF5Glmk3+Iw//18/O2cHkXdYkajr3mg7TJk6lhRFDU0tgJpNiJrQzPbvN/J4v3bPP4uXdgZY8wOf0CmeJpc0FDl4283x4U0Uut+81zUdSuy/0tRFDU0toxEI+I1l2kvhNWNeNs9/i73AhNt3jMd8baLu6RhpY+/3QyX0qlDgqq6sWD/O7KHuFEUpYMamrkWrmk2Pf4XsnxudW3Ka0PzRRvXJoDLgRuwvg/ICi/69LttxHqUZytsQKYOVzlI42lkH1ZSmwJFCY6hsfJAJjzWfFeez1uQGFX/znGNlbNwNgMfevxdrE59tSD7XO7yQMNP8X4tKo6sQbkdqHM5sv5WyLk0byDrPXFtBhQlWIYmn6tuE95vcnsAme7IRIMxMs/lSeNhcoe/aQb+z4cG2EoInpRb9kMeaVhsGtzNHqX/thl5eBWaZx5ytEGjzXuOx98TVBWlw2LXvfl+cu9jeAzZO+I1FyFuqJcAo02D8Qqyc32BxR72Gch+nHMRl+lOyHrF86aX78eGvelGR68sn68zjajX+zqeRnbfDwd6ItEMqpCTLFOvu5p/U68rEe+99NddzOcJY8x/AHzqQzm+hThUPEt+j8RVxsjU6eOvKME0NP8yo4kLs0xjXOm6wplZI7g8aP4KJQH8xfxZ03FYc/bPnypo0/pqTr47ddBYW2OzDPgiT11q3+AdVlB5NOKOV1ixeAn4ChKypluGz2PIZt0LcLauo3jMxRdfHBgt99xzj/4gRTA0ABcjJxpegpx/sgF4CgkmuVGL1CZPXfo/Tr57HHIq6KlAD9Mz/w5PXaqnO9rjSTOy/aqpp57Xz1JpFLXxVkrF0NQg0zhHIsEX+yLOAT2R6Z8DTI/4FdNDbyjSd2qrcwgypQMyXbI8cDqfurStzkmm0fROZ67RWWlTB/za/BWDPZCp3QPwbo9SEzKdei+FxwwsFZ19kaC/JyKH25UhzjG5PEIbzAg2E0l2j0QeQyKuP4Ksm6oXYhEMzTDgWmTBONselt7mb4LpSW5HFu1vw8Jax/xJU934Lp7rdIlS0VlcZswoRdWnIFOxtT7k9SXgKiRW3VPtVOcYxP2+d5v3y8m9FtetAJ0HA2eZTt2ZqKOIq+TyOqtEdkx/iMxrd7KRbidzz4emcfQyVL7qVILAvsiaYa2PedYi3oj7tkOd5WZ00dvn3/EE3NtYrOQxNEORhdNrsRdXLFNlucakNcwD/apTCQo/ACqKkG+Fybu96TzJPDfF4EJkmk7x0NDsjxzhO97FfMYjQS33dzFN1emuTsUZRxUx7yPboc4Di6gzQqG+m0pG2q7RDEM2O/byIK8+Ju1Dcb7OoDrd1ak4p6edi+NlYbb0q6KuTyVNtVGSYQgloKo+Rpd1zXT7tIlIq+UgG7280llR1srofqsZ0WctvWrqiYQTxBNhNjTUsnBdXz78dE92tJZ5odPW1F6nUIgxkQj7lpWxRzhMp1CIeDJJXTLJikSCD1pbmR+P2wlb0kWrtDeGpgp41KNGMb2iPYYsvBUaeVh1uqtT8ZGWqggrxnRl3dBaEpHdz+3bQhWfjuhMOJ6kz9J6Bs7bSnmT/1FyOlc1ccK+7/P5oUuIRjLnf8TwBcTiEV5fOox/fjCObU1VvuvsFApxXHk5R0ajRNt+GArRExgaiXBkNMrmZJJnW1qYFYupW5nPpE+dTQPG+ZDnWJyd/6463dWp+MSGwZ14++T+rBneOaORSScRCbFmeGfePrk/GwZ38lXngYOWc9NJj3PE8IVZjUyKaCTOEcMXctNJj3PgoOW+6hwdiXBjdTXHZjIyGegeCvG1igqmVFXRORTSClkEQzMUmOJjvlMobDFbdbqrU/GJT8Z1Y8HE3sTL7IUXjJeFWTCxN5+M6+aLzi+NncP5E2dSUdZq676KslbOnziTk8bO8ccYlpXxnaoqagswGCMiEa6tqqKbGhvfDc1UsNQpcIuoydMuqtNdnYoPrN6nCyvGdHWUxooxXVm9j7fLBl8YOZ8Tx7xPoc1vCDhhzPt8YeR8N+RkXfjZOxLhm5WVjs446RkOc1lVVS4XUJ1dc9nQ1CKbB/3mLOwt+KlOd3UqPrC9WznL93NnNLJ8v25s71buic7+3TZz6n7uxG49db93GNDNcTDwjPOFFaEQ51VWFhQ7qy17hsOcWpHV03ub1l53Dc3x2Ns86BadTN5WUZ3u6lR8YNkB3UmG3ZmiSYZDLDuguyc6v7z/25SF3TlKqiyc4Iz93/ZE59HRKN1dnPI6IhqldzisFdUHQ3N0EfM/2qNrVadSdBq6l7O1r7ueWFv7VtHQ3d1RzYBumxnZd42raY7su8aNUc1ujdWR0Wjg01Qyl/PYIuY/1qNrVadSdDYMqimJdA8c7I23mNvpDotEPPEW26+sTCurD4ZmaBHzH+rRtapTKTp1fSpLIt29e6/zRKfb6Q6NRDzR2S0Uood6oHluaDoXMf/OHl2rOpWi01xbVhLp9q71Zt3b7XR7e2gMdJ3Ge0OjKIoHxMq96YHHKtxNt1N5iyc6O1U4OtV9t8WtMg8NTYa0m7UGu2toiunGt82ja1WnUnQicW+2YkRa3U23Je6NQWxpdTTy2s3jwctAPK3J3cp0h9Zgdw3N0iLmv9Sja1WnUnQqtreWRLqbt3vjje92uhsTCc9+q01J3Z/ptaGZW8T853p0repUik7N5h0lke6KzT080el2usvj3oxp6pNJNnhoxBQxNC8VMf+XPLpWdSpFp8dKb04D7rHK3XTnrBroic73Vw1wNb2F8TjbPRh5zGlt1XgzPhiaZ5Ez6f2m0eRtFdXprk7Fa0OzqtH1EP/lTXHXDdjcVQPY2lTtappbm6p532UD1grMisVcTTMJvOpymkpmQ1OPnCHuNw+YvC2PcFWnqzoVjwklkgx6f4uraQ56fwuhhLv979ZEmGfmunuixTNzx9GacN+p9d+xGPUujmr+29rKKp0288XQANwK+GnWY8BtBdynOt3VqXhM3yX1dPvUnTPpun3aRN+l3vQlZi0Zzodr+rmS1odr+jFr6d5Ok8kYIHZ7Mslfd+xwZaprUzLJQzuyrnepB6cHhmYJcIeP+d4JLC7gPtXprk7FB0a+tp5OW5ztVem0pYWRr633LHh9Evjda4ezaquzSNOrtnbjd68dTjLpeM9L1uHQ+62tPObQ2NQnk/yqqSnXmo8u23hgaEBOafTDa2kuzk+uVJ3u6VQ8piyWYOwLa+i6rrA9gF3XNTP2hTWUxbyd4mmKlfPzF77IwnV9C7p/4bq+/PyFL9IUK/e8TF+IxfhTczOFmO9PEwlub2riU50yK4qhaQJOBzZ4mN8Gk4eT1UzV6a5OxQ9j05Jg3xfXsNc7mylrSVi+Z693NrPvi2ss3+OU7S0V3PnSsTzyzoE0tlgzGI0t5TzyzoHc+dKxbG+p8K1MZ7e2cmNjI/+z6DXWnEzyj5YWbm5sZL0aGX/rf5v/LwGOQ7yX+ric1zrkvJQlLqSlOt3VqTinGcgZ7TKUhD0/qqPvknrW7VXDpv7V1PesIB7d2d+LxBLUbtxBj1WN9FnWQMTaKKbZTZ2JZIgXF4xi1tK9OXjIUsYPWMGQHhupjO5cdmyORVm+qSdzVg5k9vKhNMeibuu0tEayMZHg983NPB0Os19ZGaMjEXqGQnQxscu2JhKsTCT4MB7n7dZWmqw7EmzXKu2doQF4F5gIPIZ7Yefnmp63m42i6lQjEyTmAAdbuTASS9Bv4Tb6LZS2NFYZIV4WItKaJNocLzRv13U2x6K8umgkry4aCUBtZTMVZTF2tEapb670Wucb2DjIb30iwb9bWvi3O79lE7BQq7R7hHP0xCcAt+PMeypm0pjgUaOoOpWgcG+hN0ab41Q2tBZqZOzmXbDO+uZKNjbUFmpk7OZ9D7C5SL/lfeh0tC+GJjXMvRYYDfzeZsE3AX8w916Lt5FQVWdbrrpKa7b//Am4vwj53m/ybm86NwKnAVt91vkOMFWrs7tYCa+6GLgQmAKcCBwJjAeGAF3NNVuB5WZo/ArwDNDghsBRoWlWL10MXDg/Oc2WzlGhaZZ1znenzItanopnJIFvAP8Fvmt+Ty9ZjrjQ3409V9xg69y1k/QfYIx5Vo5G9tZUA7k8DroChfhWrzYjmVutdAJnzZofmIo3ceKodmFo2lbS9L9ElveLhjEcD1Kc3fl2SNc5wlTwY035zQKuBpZp+11SJIBfmr8eQJe2F8Sj4fDy/bqNbexafmhrNDwyGQ7tmQzJdaEkdaFEcnVZLLGgemvszSHvbX4/EsvoHlUHbPJSZ2U0Fj51/Dtj9+y69dDKaGxkWTixZziU7AKQSIbqWhPh1c2x6II1dV3ffOy9A95vjkW90AmwCsg6RL+npiYMHGgM0ThgEJDaDLQF+AR4H3j5rqam9z6IxzPF2on50JGzrNN0AtqVW5wVQzPMTNecDWSL+93b/E0ALkY8Nh5AdqsXey3hOGTaqRm4FHguYL/B54Dn0yodwKnAJOAY7C2gKsFhU3oj+9rXhnQz9e9CIFcQsPHACXW9K1kzvHYF8Dvg7kl/W77FD533fPXPtnTu3Xsdh+298DOdF9//f1v8KNx7amqs6pwAnAlwWVXVTp0NDVt8qge2dQKf6TRGqOQJ7TPzlmyfVSIbAaeQ4RAii7Qgu9Z/RI51hfmTsk+JjnrtViffr4cZFaSOON5mpgoKWmTMpbPAdZHPAS+wc8qsLRsLNjYzZmhT78cIOn/9DAHfBm7K8TvnYyvwA+DXuXq6OevnzMrA6OSwZifPkX86czxDFqbOfNNZClNn2ZwBhgJvmpGMk22+5cA1Jq1hRfh+J6UZGczrEwM0knkhTyXsaa4Zr016SVIDPAH8ykFjg7n3LuBxk6bqVJ0lRSZDsz/wusuN23hk3WF/H79b1Bi5tlxOYYuFfhsZNTalzWDTwTrZxTRPNmkOVp2qs5QNzTBkDaOPB3n1MWn7NbK5FBiZ4f0DgHNKxMiosSlNepnfa18P0t7XpN1LdarOUjQ0VcCjHn+RXsgO+SqPv1dPZF0oG9PJ7SIZJCOjxqa0iJg67mWHahgynVKmOlVnqRmaaYjbndeMxftowz/O05gPAr5TQkZGjU3pcC3iMeg1E8k8Naw6VWdgDc1QxLvML6Z4aPn3RVwJ83E90L2EjIwam+DT39Qrv7je5Kk6VWdJGJqpyOK5X0TxLszDnRaHlt2AG0rMyKixCTZXIzvX/aLa5Kk6VWfgDU0tshnTb84iy3GtDjgF2XlrlW/jrSeHF0ZGjU0wqQTOLUK+52JvzVN1dkydRTc0x5N9x7+XdMJGGHALVCCRje3ec3MJGhk1NsFjMrvu2fKLziZv1ak6A21oji5i/m7mfRmwd4EjqwNL0MiosQkWXyiR50h1dkydRTc0Y4uYv1t590FCNRRCqICRUC729tHIpBub54G9tL0vGsU09ONUp+oMuqEZWsT83cr7JofD1yNwLzTNz3w2Mil6IRGgleKwdxHzHq46VWfQDU3nIubvRt7jgfNcSOc23NkIVcyh9LHa3pd0XfYjb9XZMXUW3dCUOne69D1GuWSwikkcpSM+S2HVqTqD/nBsK2L+TvP+MnC4i3puxLkH3vNFLM8Xtb0v2brsV96qs2PqLLqhWVrE/J3kXYlMd7lJX5xvhLoa2FCEstxACYamaEcsL2Ley1Sn6gy6oZlbxPyd5H0l3px3frUxOE6M57E4P8LWrpE5EjkOVim9uuxn3qqzY+osuqF5qYj5F5r3HsD3PdJUg0yhOWEO4hTgh7FJGZkPta0vKi8XMe9XVKfqDLqheRbYXoS8G03ehXAL3p44dx6wTwkYGzUyweEfQFMR8m0GnlGdqjPohqYeeLAIeT9g8rbL54BveKytDHf2pHhpbNTIBIttwMNFyPchoE51qs6gGxpMoxrzMd8YhS3kh4Bf4M9RzCfhjkebF8ZGjUwwuQVo9TG/1gI7RKqzY+osuqFZAtzhY753AosLuO8s4FAfdf7UJaPmprFRIxNcFgJ3+ZjfXcAC1ak6S8XQgJx66YcXw1wKP2Fzms/lcyBwpktpuWFs1MgEnxuA+T7kMx9n5ympzo6ps+iGpgk4HW/3gGwweTQWcO9eFCe2z624F6zSibFRI1MaNAIn+/AcnVzgc6Q6O7bOohsakCm044B1HuS1zqS9pMD77y1SGQ0G7nMxvUKMzXo1MiXFEuSsEC8anQ0m7SWqU3WWqqEBeBeYiLvTaHNNmu86SGNCEcvpEJfTs2Ns1gNHqZEpOd4BPg984GKaH5g031GdqrPUDU3KMk9Azmlx4o0WM2lMcMES/7eI5TTbgzStGBs1MqXNYlP3Z+DMK6kV+LlJa7HqVJ2lRq6w+M3AtcDvkRha5wDVFtNtAv6OuDC7VUAXAn82lj3kU/kkgdfx7kzwlLF5EejR5rN1yAl6rhqZiy++ODCV75577ukIxqYRCWt0DzAVOBvrZ703IfvNbvWhoVGdHVNn0Q1NunW+EJiCHA52JHIGzBB2HvC1FQkuNwcJi/AM0OCy1mXApHbYEM0BDjIjv6ONcXsOuA74WAcF7Wp0cz7wXeAEM1Idl+U5eh8JbfIs/kfoVZ0dU2fRDU3bHn76XyLL+0Vj/pMbaswPmm4Qu5iP69oYxH+OOqVXQzF0zjr1/Ew6Uz2eo5FoDZ/pnPjEHxqKVKS2ytODDkZ7IxWJ40HVqTo7CqF9Zt6S75phyBTa2Vg/q2W7GfrdhoW1mfmTpmb/8KqrrH4Xz3UyY4ZjnbNOPd+RzolP/MHaWlcWrTamzjwvzw4ydaYoHZ5cI5pKZIPkFKDcZrqdgAuQmGR3Aj9C1ny8IBA6Z516vi86Z516fl6dEyeOKvnyVBSl/ZDN62wo8Kbp0ZY7SL8ccSR40/SQ3UZ1dkydiqKUuKHZH/G0Gu9iPuOBWSZtt1CdHVOnoiglbmiGIR5PfTzIq49J240erursmDoVRSlxQ1MFPAr08jC/XsBjWPcnz4Tq7Jg6FUVpB4ZmGuLf7TVjcRaFWXV2TJ2KopS4oRmKeBn5xRQKm0pRnR1Tp6Io7cDQTAWiPuYbNXnaRXV2TJ2KopS4oalFNuX5zVkmb6uozo6pU1GUdmBojsf6zm836WTytorq7Jg6FUVpB4bm6CLmf7RH16rO9qNTUZR2YGjGFjH/sR5dqzrbj05FUdqBoRlaxPyHenSt6mw/OhVFaQeGpnMR8+/s0bWqs/3oVBSlHRgaRVEURfHU0BTzJLdtHl2rOtuPTkVR2oGhWVrE/Jd6dK3qbD86FUVpB4ZmbhHzn+vRtaqz/ehUFKUdGJqXipj/Sx5dqzrbj05FUdqBoXkWOevdbxpN3lZRnR1Tp6Io7cDQ1AMPFiHvB0zeVlGdHVOnoijtwNAA3ArEfMw3BtxWwH2qs2PqVBSlHRiaJcAdPuZ7J7C4gPtUZ8fUqShKOzA0IKcf+uENNBfnJ0Kqzo6nU1GUdmBomoDTgQ0e5rfB5NHoIA3V2TF1KorSDgwNyFTKccA6D/JaZ9Je4kJaqrNj6lQUpR0YGoB3gYm4O50y16T5rotpqs6OqVNRlHZgaFI93AnA7TjzSoqZNCZ41KNVnR1Tp6IoJURon5m35Ltmb+Aa4Byg2mK6TcDfEVdWS15G8ydNzfzBzEprOT51qTOdJ99tzRvqsObM7191laXbZ516viOdE5/4gzWdM2ZkfPviiy+2Wjc8/93vuecefQKVgp4j38jyHCn2KLNwzWLgQmAKcCJwJDAeGAJ0NddsBZYDc4BXgGeABl+/iRiKC3nqUns6T77bV53GUFw469Tzbemc+MQfGnyuG6XxuyveYLWDZ7UjpqihaVecfHdJyJz4xB9KpUQbkAgCD+rj0mEZCnwPmAz0BdYD/7YzY1EghwJTgdHARuBfyF6srS6lvwdwHXAS0AP4ELgBeEF/cv8NzTDgWnJPofQyfwcBFyFTKPcj8/R+bdBTnRbQ6SrFJieYTkZN2nv9gfNNHf4G8KgH+U5Cgq9Gzf/3Ms/DhcBpwFsO0z8GeDhtdI5J/1/A4cDr+tP7Y2gqgRuB7wLl5r1VSEDE2cBCYLN5vzswAjgYON5UxAtMJbwT+BHg1Zi6ves8AdjTR52KDUa9dmug9GRd6yyM4aYxztYhqjIdoI/MaMBNbkwzMun0A140z+9rBaZ9LPCk0d+WiOkInqS123tDMwx4DBhr/j8LuNkMlxNZ7nkD+CPiyfZFMySdiCwoH4ds2HPbAymfzu7AZaaHAvAf4K4A6gxKeSpKOt8nvyNIOXC9Gd24ybgcn9WYkcfxwEyb6X4BeCKLkUmxj/707pLJvXl/0xCOReZCv2aGsf/K0SimkzDXHmbu3WrSmmXSdot8Oochi9TTkIXsI83rOeazoOgMSnkqweeL5ndvMqPfv5hRuVcca6Pxdpu6PJ93Ms/FUTbSPBJ4yoLx3KRVzVtDMwx4DugDLAIOMEPjQkiaew8w00J9TNrDXBoh5NP5B2BAhnsHmM+CorOQ8lzksk4l+HwbmWb9PDIN2w34OvBfZGrVC/aweF0vD/J+0cI11cA/LBq6wxGvSCuu+s9rdfPO0FQhi3q9zJTMJGCZC3ksM73xJSbtx/IMW/NhRedgk2c2DkPcdIuhM4TsUdnHvM5HCBiFeN6ETRqTXNSpBJ9LgV9lmYHYA++OXggV8Tv/FGixaGyeMqO9XM/7sxaNzFZkel3xyNBMQ+ZF65A1gPUu5rPeVIStyLTPNAdpWdFppZc/tAg6RyELp4uA+UholiE50hgCvI0stH5g/kaZtCabtJ3qVILNd0zDl6vRP6Edfu/FwHlmJG/F2DxpnrO2TLJhZFqBr+JtgNkObWiGIhvzUhV7qYt5VCOLd8uQhXlMXoVM+VjVWWEhrYocIzAvdIaQRcgRadeNRxYzh2ZJYya7rsPsY0ZJITOi+Y5DnUqwuRz4pYWRRXU7/f73I1OGVoxNpTE2x6e9N9EYmU4W7o8jDg16zLiHhmYq4ko4i8LXENrSHXgE2Gb+/o3sHp9l8irED/P7HujMVsHd1jkMcRdtS39TLkPbGJlXybzQu0+aUXGqUwkuVyCu7Famr95qx+XwW+Bii8amwnTmvoSsZT3Lrvt/8hmZR7TaeWdoaoGzzf9vtviDWjEyLwBnIH7pIcSD5QkgFVztbJO3VbzQmY2kyQPgLJd0xnPcMyDN2Aw1r/vneTDa6rRbnkpw+S5y8qkVIxNH9py0Z36H7COz4qVZbkb9z1p8HuKIN+fDWu28NTTHm6HlajPqcMvIZHK9PRBYaf6qkRhaVjnB3OOWznz82+js1GY4XqjOZYhrdT5j8wqZveVSvMeuzg//LrA8Fe/oCQwke3T0XEyxYWSSprf/Ugco0/uQNZu4RWPT2aKR+QYaXskXQ3O0ef2MxR5DoUYmvRKk5kGPtJH2US7qtEIiTefRLuk8A4kGkMvY5DIyq4Azc+g8Uqt0UdkfeBNZTP4EWMPOdTQrXAn83Eb9vIBdXfXbO38GzrVobKwYmW8i0cYVHwxNarf6bB+MzErkMKw3zf/H2UjfLZ12eLNN3k51LgWOyGNschmZI8gcDaCQ8lTcZTQSEuXgtPd6Ix5j+bzGAK4GrMakTxmZ+zpgOf/VjEKcGJu4GR39Tautf4YmtQi9oM1nZWSONVSokakHvowcirXIvLeXDa3ZdBaKlTWeRW3ydkNnIcYmZWSW5tG5l1bponET2b2/voPsg8lmbL6H7Bux2khegIQn8ppkQMv674gbciHGJlV+f9Eq66+hSc1lpkI+9EHcBOuQEPF/IfeimhUjsw3Z95Hyjtli/u1sQ2tbnblYa+EaK/uEvNJpx9iszGNkCtWpuEu+UCjfBu7OYGyuQaJyW20kz/fJyIBM/VmhGPtOHkIcYOycBJtAoj//Saur/4amLY8CJ5veWTkS5uJ5oIsDI3M8/obdnpun8m8E3g9A+Sddvk4JNpcAv04zNlOxvqs/Nd3zZx/1Wg3F8mKRynMJsN3m85bQalgcQ7PNvO6C7DqfmOG6g5G4Wl1cMjLd0j63SrrOfMTIva/kWos9Ia90plyYB1hIbwCyp2Yvl3Uq7vKyxeu+hewNuY6drv5WjMy5+D/dcyv5j6NoYaeLvZ+MN+1PVxv3RBDniXO1uvpvaFJTMiPIvYM23dg4Hcnsbf61E0stXacV7jOjsfTpqVXmPauLqHu3ydsNnanNmANspJkyNkPz6FymVbpoXA80Wrz2ImC6DSPzf8giuN8sRDYyZhs1NCFrJR/4rGucaX96FHBvythcoFXWX0Mz17w+BJlOWm3B2DidLjvU/DvXhtZ0nVb5GzDINPojzGs7niZu6xxG9h3/VozNK1mMTSE6FXeZj+yhanQxzdQ+j/uL+L2eMKOHe5H1wphpI+4z7z/qs56xpv3p6SCNkPk+F2m19c/QpDZ7ncjOoHKNeYyNEyOT2iRqZ7oB08imdFrdCNcJ8fi5xfx9B2txj9rqfMklnY/kMTIryb/P5mGXylNxn1fNb+GGsYmb0XcQ9nksQTaGDkTWbVNHOS/yWce+yHqQG8cShJApzG9rtfXH0DxrhsZ7IpGL/2MayUIeFisL/8eaBrMR2dRolWfMPSmd+egPvAP8Ajlj/DTz+h2LI4p0nc+6oHMv0wPMZWRSB7TlMjb7s+t6TaHlqXjDfxAPy+0O0oibDt8DAflOIeTMl5+ZGYGfI5GS/TxGYLTpSFkxMklgh8Xv9SvsbapVCjQ09ewMwXBdWq/c7jSAVe+y682/D5i8rVKf9uBdZ+H635N5nWSE+QyfdUZy3LPKGJilpveYz9hEXNCpeMdMY2waCjQyZyPuu0FgD2M8XwCuMgZwCnK65evYW2sslFE2jcwUJLCmlfYrhETIvkKrrbeGBsS7JIZ4nH0tbRrAqrGxamS+avKIUdhhTZl0ZhvN5Br1fDHPA+KFziXI4momI3MEuzocLCH7PpuF7IwO4FSn4h2vmWfCjrFpNUYmKFGEOyGx9CZl+fwQYwC83L+1j8mjt8XrrzQzFy/YNDZ3mnsVDw3NEiSQH0i4jCE2jI1VIzPEDFMxP+riAvRm05kpr3wM8llnEpm++yjtuneR0/8yebUtRY6fndPGyJxm0trLBZ2K98ZmssWRZixgRgYkivSYPNcMQyIbeMEAY2T62DAyd6b9/2XTflmdxpyB7HVSPDI0IKc0zkX80p9P60HkMjapHf/5jExv0zPqavKY5kBzNp3prLSQzuoi6JyPzDUPN9MBnwOW50hjGbImsy8y5TfKpOGmTsVbZplnZJsFI/NowLSfbfG6r3iQdwiZ0u9r8fqr0zp36byKvWnMu9CYgZ4amibgdGRH/TAkKOS+aT/W8ey62z517PEbefLYFwn6uLe5/3SceeXk0pniY9ObzPXwLy+SzqQZfXyEtR3/SeQo50XIruYxJq1hLulUvOd18/xkCku0wzTojwVQt9VTW4d4kPcX2Om2n49ryB2Q1M7IMoIcXKh4ZGhSUz7HAetM5XkDWQcAWRAchoSnOdZ8ni+S8tdMGnuZNI8jc/Rhu+TSmeK8LCObley+M7iYOu3wNdNoDXFZp+KPsZmA7EupM9M5LyDrH48FVPMmi9dt8SDvYy1eNxVrAUlnmefFSqzEL2h19dbQgKwbTDRTMrWIO2O6F83T5gFpzJHmZHPPX00ac02a77qoPZfOsGmA90OmlV41f9PMe0sCpNPKb+SHTsV7UmtsXZEjho8F/hdgvcWMdWZlQ+Z12HOCecOisemiVdVdynL0xCcgR8ROMb2uScAKJDLAG2b6J9Xj6Y6sOxxiGsWB5v0YMm/6I/LHTCp0xJBP5wvsdN/ujuwRCqLOTOV5qNE5wCedipLOrchR5pU5rvEq1tlHeT6/Aeux4tKZDRxjjGjXLNdohA2XCe0zM+9vtTcyB3oO2c/baEsTsqP5Nix6Q82flCUG5sxKq9/FF50clqV9v+qqYOmcMUNrt1I4O5+7U81IulOWevkN0p0YDnPY/9n5HPVAYqi1dQZIkH9NxgrjgKfY3fs0DpxEapO2PkeejmjSWYyc4TDFjAaORHa4D0nrEWxFFtfnIJs9n6GwzWpOUJ2K4j6pWGffQ6ad+iKOQM+bjo9XYWg2Ia7/M8wz0oJMH9+GO6fsvo8451yBeNX2Mc/mT7EXckqxYWgms/Ps8fORXb9nmh+5GtkA9QQyBfVgEfWqTkXxn1SsM79ZbEYXXtGARNGerj+xt6Smzj5FQk2AnKrXD9jMznNOUryKrDO86rYQi1NnRddpceqs+Dp1yK+UItanoP1BnyNXDU3b/Rwhcu/xmGkaSMfRgrMamMzGpmg6Lc0973xIiqdTHwxFUQJGuMD7DkPmMV9DPDiCiupUFEUpUUOTYiKyKPg6slAYVFSnoihKiRqaFIciC96z2XkIVxBRnYqiKCVqaFJMAP4J/Bdx3Q0F9HurTkVRlBI1NCkOBP6BhNc4KcANpOpUFEUpUUOT4gBk9+07wCkBbiBVp6IoSokamhT7IRsU30PC2tcEtDxUp6IoSokamhTjkLhI64BLA1wuqlNRFMUHQxP3MN9qJAKxG6hOd3UqiqL4Zmi8DOIYY9ezvZ2gOt3VqSiK4iplPuc3F7gdOSNmfYDLRXUqiqKUmKF5Azmk6J/kjvlVbFSnoihKiRma55BT+v4T8HJQnYqiKCVkaBLA48jxru8F+LurTkVRlBIzNC3A3/D21D3VqSiK0gENzXbg98jpkSsD/F1Vp6IoSokZmi3A3cixxBsD/B1Vp6IoSokZmrXAz4HfAvUB/m6qU1EUJeCGZivQJe3/y4CfAn8CmgP0HVSnoihKgMkVGeAyZI2gHnGpHWF63UFrFFWnoihKiY5o/mH+go7qVBRFKdERjaIoiqKooVEURVHU0CiKoihqaBRFURRFDY2iKIqihkZRFEVRdiWU/E8Fo0LTPgX2MO+tnZ+ctofvSg7Lsp1kZmX6/3bRmfY6WDqfunRXnSffHRydiqIoRRrRXGAa7tXA+QHWqzoVRVFKcUTjwEg9D4SAY5BzU7we0ahOHdEEkilXrPUzu0OQI7yHAzOBKXf8ou+qYuls2B5mwIAYx03eSjwO8Xgo9VE34FFgLHLc+LkTJ47a4YXObdsijB7dxJFHb6OxMUzS3rmzruls2RGiulOCE760lepOCVp2hNws6oJ1Fhsn0ZvPAI42r78MPBTQ76g6lfZEGXAHMMH8/xRgA/DtYgmKhGFHc4jWVohEIB7/7KOngEnm9dmmE3V2AMtUdXqME2eAi7O8DhqqU2lP7JVmZFKGp6iNTUV5gk2byti4sYyqqs8G4kPTGsUUpwWwPFVngA1NH+DwtP8fZt4LGqpTaW/0zvBe16I2ImXQ3BxmyeJKQjtblJ4ZLo0HsDxVZ4ANzalABJgPLDCvTw3g91OdSqnRBTgPuBQYk+HzUIC0HgGcQhKqq+OsXFHBpo0RKisTIEeRt6XVSzGhUB6dmfFdZ97yDL5O3wzNmebfR4CHzesvB/D7qU6llKgBbgamAz8BbkMW/NNJBkTrr4FXgCeAuRUVyZ5btkRYtqySikr/JaYW/8Ph3DqzjAwCV54B1umboRmITO2AeEA8Yl4fDgwI0HdTnUqpMQlZ1O+LeBhNBs4NoM7jgEvS/j8GmBEOw7o1UVpjoVyjC08oiyTZVh8mFttlZJNRZ6mUZ0c3NNciUztzgA/N33vmvakB+m5tdX5QAjo/CLBOxXsOyfDeoQHUeUSG9yaEw5BIiNeZ34amsirBmk/LWbMmSk1NPDXCyaizVMqzIxuak4Bvmdc/Ar5o/m40733LXFNsMumkBHQSUJ2Ku0SyvF9u49piEsvw3g6QqatQEVaRysqguSnM4oVVhMPJlIasOkulPDuiobkQmdYJA38GnjY97qmIf/efzGePmGuLRTadlIBOAqhTcdfA7Ad8BTgggxHJtLhRrDWZPoj77OAMn8UtvuebzmSSwTU1cZYvq2Dt2ijV1Ymi6QyF5C9ZmuVZFENTARwPvAzca3pczyD7PA5B1hEON68vNp+Vm2tfNvdW+PA9rOhMEVSdbSmmTsUbJpvf9PfIsd4nBlTnocBi4DHz7wmloLO8InnCtvoIixdWEo0W32ciVHrl6d2I01T+84D+QNS838181jdtOB8DbjXTOnF2XT+4FnHLO8VMAU0FjjR/LUjcr1ZgS1paq4A/As/aeEid6sToCaJOfNapeDNiCZtRSCbX0+lAP/O6CvEqeyZgvdcw8CBQm9ZGPAp0B5qCrDOZ5NFoWbL7+g3RpuYdIVJrRr5WgDLYvj3M9u0hunZN0LIjUirl6bmheRhxq8zGZuBxxAtigXlvFPCltGtOMu/NB34I/B24ygwVuyOeVZk4Lu0HyEchOke30Zk+LA2Szmx4qVNxl1rgeuBgYDnwY/Nvih5IjKp0RiBurOt81noVEu5oBXA5u+7R6Mfu3o6VwEjESSXQOiPh5MhkkvcS8RChUBKfth19pjMSSV5eXx9p+eTjCgYMaAlaeRbV0PwWuNr8f7lp2NaZXtla4CPT4NUi88rDgYva/IIh4G4zxbPI/F2ILGbvY3ryIWSe8sfAEHPfvTa02tH5OaPzwjw1bUERddrBC52Ku0xBNlnWABOR3fqnszM4aqcs91X6rPNaM5JOsTc7Y+xBZoeE1Ggt8DqTEPHZIWE3nRXlyaM/Xl7JmLFNRKPJ8lgsFITyLLqhuQbxcLjONFiXmQdklRkRPG96XnvmSesIdnXTWw0sND2RF41Vv8nkkUQ2pv3AhlYrOkemTU3YIc5O12IvdTrFTZ2Ku1ycNpKNINOeg9JGNdmaPr8XE65r8/+jzEhrblody1b3VKcFndHy5NimpvDchoYwvXu3xrMYmnhHejhS88k3INGD64GDgHeRRfQPjZHYs4C09wReMmkcArxj0q43ed1g8yGzorOfw/LwWqdbuKFTcZd+ed4Lym9TleG9/gEsz5LVmUzSPxIRF+ukPpGfGZoUjyObhBYAvUzDvR9wCzCtgLSnmV7255CzE3qZEc4Ek1ehuK0zhV86neK2TsWf5ysoZNqf0aI63dcZCukDkO1B+Mj0lucA1ciZKFWIZ9R0G+nebO6pBh5A5qffRxZKP3JBdyad1QXoTO+V/N3onOODTie9Jy90Kt6QLBFNqrP96wxcj2srspN+PbIAd5l5/wbgLgtp/grxvsHcO8ykdaxJ2y3a6vyOTZ3pXG7SWG/S9ENnIXipU1EUxdeh/Xp2hkH5Ttp1cyyk+V5a2pea1zeaNN3GiU4CoJOA6VQURfHN0AD8BdlQNAA40Ly3j4U0U9ccaO5tMml5RaE6CYBOAqhTURTFN0PTAMw2rw8y/46ykOaoNvfMNml5RaE6CYBOAqhTURTFN0MD8LH5d2CGBnwJslP9NPO6raEZ2CYNL7GiMxupe5YXQacd/NSpKIrim6HZbv6NIJ5Og4CNyCL/aOQ0uCfM68vMZ4PMtZG0nrzXWNGZjUibNPzSaRc/dSqKovhmaIaaf9eYxvs2xOvpV+zq095i3tsbuN30vteYz/by4XtY1ZmJlM5hPuu0i586FUVRXKMsx2flyNGyAP9FAmZ+HwmzcQayZtDHfL7OXPMcO6Ml9zb/TkSiGMc8+g6F6mxIuweThp86U9QgwTCDolNRFMU3Q/N50wjWAW8gmwW/j+zl6JLlnjrgl8gu/TfM/7sYY/OKR99BdSqKopSooUkdzvM8srj+ADvdhj9FwqCkFqaHAMcgsZ1+YEYSZ5l7v2zS8qphVJ1KUAlleY2F93HpekUpCUPTF3GprUQW2K8G/sbu0UcjwNeAn5kG9C12TvecwM7Q+V414KpTCRrpoUiyRetNtPnN8z2jTsObRPO8V2bhvvJsn6fF94rabG981Zknn/aos6hkcwYYhITcB1kTqDQ96PHI+fbZzrj+s7nmFXPPYeazkSZNt1GdSlCoy/DehrTX29oYlZTRSPfKzHQA2uY2/88UEWKrDZ2ZjFlDG52ZSH8/li3dROKziMV1DhtGT3Xm+d3ao87ijmhmhd/d7c2Jif3T96G0IscJ3zor/K6Vg1FXT0zs/wVk/WFaWmGMmhV+95MMeTnRn1Fnhgc6o04go07gE5fLuVR0lhyzZs13dP/EiaPckvIAcEHa7/MWsLRNw/I0cDI7p7+eZedx3CDHaqxjp1PIduDJNvksM2lPSKtPD9jQ+ZAZKadYC/yvjXF8AZm6TfEBu54G+whyoF86fw2FksQTIRKJEKFQciGE5rLrqaIvBkFnm/8vRM64ae86AzmiWWJ6Uq8Ch84Kv3uzRSMjD3/43cSs8LvTgUNNGpvZdVOnW+yiE4kabeeU8AQS7Vl1Kk6ZbozCemAWcKUxAulch6yzrTdG5Zo2n8811yw0HYzfAfe3uaYVOc1zlknnSVOfrHIBsq9ss8nvKHYPdf8Vo3OzyWdym88/AM5BNiBvRE7XvSUUgkQilH4Gy5dMo7sZ+HebBrloOjPk1RF0FndEk8VQLEbOOP+MjRsX1SBrA0ea6Zwh7PSWqkMWsueYaZ5/9uw5vGFW+N3/mesd8+TmBzO9vYvOUChEMpm0pdMMc/PqPKX7Wa7pNNjSGQ6HGxKJhHs6n3wy62emHAmHwyQSiULKMy+nnHKKqxW5kPrp8rO0CnHUyMVHiCt7rg7FfebPK3aQO1IGZpT1RQsjuAcAGraHGTAgxtlf3UQ8DmknStabv4RpHLd7pXPbtgijRzdx5NHbaGwM09IS2k1nDlzT2bIjRHWnBCd8aSvVnRI0NYVtl6cXOp2O/G1yCLKfcjgwE5hSZuEBHgZcC6Gzy8urO0WjnYhGKwmHo4RCMiBKJhO9E4lY71iseUIstv3ilpbG7Rs3LnoAuK1nz+F+9byHAddWVFSe06NH7+q+ffegS5daKisriETCvPnmgow6IfkAssHTV53ZyvOQQ0YSjyd6Nzfv6F1XVz9h/fp1F69fv6axtTX2oOnl+Knz+2Vl0bN69uxd3bt3b7p160KnTtU0NcVYtmwd9fXbfSnPjz7aeeROeXk54XCY1tZWamtr2bhx0bBIJPL9aLT8rJ49U797Z6qrqygrk/rZ2pro3djY1LuubtuEtWvXXLxx4/rGLVuWPhiPx29Zu7b7kvr6esrKykgkErS07Nzfu88++xBAyoA70qbOTjHTM98ulqBIGHY0h2hthUgE4jtXHJ9i596xs82U4dkBLFPV6XH9LMthYCqBaaFQeEpVVbfyysquhMORLD3gCOFwhLKySqqqupJIxDs1N2+9oKlpyzc2blx0J/Cjnj2HN2e8+bDm3LJTn2fvgVcC02pqaq8cOHCv6MCB/ams3NVBI5lMEgqFcupMJhN3ImsnnurMV56RSJiysggVFVG6dKlh4MA9iMX2rV6x4tPzPv54ydfr67fd4UhnfiqBH1dVVX934MDB0UGD+lNdvetZbS0tccLhEOGwg/J0yIcfflgJTKuu7nTlgAGDo4MGDaCyspxQKLzbyYbl5WHKy2vp0qWWAQP2oLm5pfqTT1aet3Llx1+fPXv2HcCPxo0b10xpsFfaQ5x6sM8upqGpKE+waVMZGzeWMXhwC7FYBCQKxqQ2l54WwPJUnT7Uz7IsRmYo8GhFRe34Tp16EQ7bc24IhyNUV/egsrJL+fbtG67ZsaP+2I0bF33Zg9HN0HA4/NigQUPHDR8+jKqqCsc6zfTHEg8qScHlGY2WMXToQAYO7BddtGjpNR9/vGRyLBY7zQud4XD48X79BowdOXI4NTWdAlme77///tBQKPTYnnsOHDdy5AiqqysJh/Mf8RMKQSgUprq6khEjhjJgwJ7RBQsWXrN69Yovvv/++2eMGTOmFNa9emd4r2sxBYXLoHlbmCWLKxmy12cjwp4ZLo0HsDxVpw/1M5zByOwPvF5T03t8be0ethvFXRueMmpr96Cmpvd4YJZJ2y32j0ajb4wf/7lx48aNtm1kcukEXNXpVnlGo2WMHj2C/fc/aExlZeUbbuuMRqNvjho1Zuz48WNsGxm/ynPevHn7R6PRN0ePHjduzJjR1NRUWzIyu2sMU1NTzZgxoxk9ety4aDT6xrx58/YPwIPaBTgPOeRuTCZ7GaBG5QjgFJJQXR1n5YoKNm2MUFmZgMwxBlu9FBMK5dGZGd915i3PYOssqH6G2xiZYcBztbV79KmsdK+TVFnZldraPfoAz5k8nDIsGo3+e7/9Duo9cGA/T3TiTvBKT8pzjz16cdBBh/SqrKx83i2d0Wj0hX33HddryJBBlJWVBbI8Fy5cOCwajT6/777jew0e3J+KinLn0z4V5Qwe3J999x3fKxqNPr9w4cJiBi2tQTzIpgM/Qda6hre5Jijn0f8acax4AphbUZHsuWVLhGXLKqmo9F9iytMtQ59jF51ZRgaBK8+A6iy4fobTjEwV8GhNTe9eFRW1riusqKilpqZ3L+Axk1ehVIXD4cf23Xe/nv369fJUJxKPrGCdXpZn9+5dOOCAg3qUlZU94VRnOBx+bMSIUd3799+DSCQcyPJcuHBhFfDoyJH79thzzz6uGUOAsrIy9tyzLyNH7tsDeMzkVQwmIWstfYFuiBvsuQFscI4DLkn7/xhgRjgM69ZEaY2Fco0uPKEskmRbfZhYbJeRTUadpVKeAdRZcP1Mb1WmVVTUjnOz552ph1tRUTsW2XhYKNMGDRo6duDAPQKv0+vy7NWrO3vvPXLfcDj848KnG0I37rnnwLEDB/YnEokEsjzLy8sBpvXvP2jcgAH9XDUyO41NhAED+tG//6CxwDSTp98ckuG9QwPY4ByR4b0J4bBEBojH8d3QVFYlWPNpOWvWRKmpiadGOBl1lkp5BlBnwfUzbEYzQ0Oh8JROnXp5rrRTp96EQuEpBU6hDa2pqb1y+PBhhDyuySmdBU75+Faew4btRW1t5+8WqrOysmrKiBF7U14eDWx5zps3b2hVVdWVw4cP91RneXmU4cOHU1VVfeW8efO8nELLZtHLbVxbTDKFTNkBMnUVKsIqUlkZNDeFWbywinA4mdKQVWeplGeRcL1+pkY0U6uqukWdLFRbJRyOUFXVLcrOc2vs9L6nDhy4V5mThX8/dPpZnpFImOHD9ymLRCLX2f+O4esHDBhUVlVVGfTf/bqBA/cqq6mp9lxnTU01AwcOKQuFQtd59ADvh+wUPyDDQ5ppfrtYazJ9EPfZwRk+i1t8zzedySSDa2riLF9Wwdq1UaqrE0XTKd6Nu/1wpVCentXP8MaNi2ohdLaXUzyZplIgdJbkbZna8vKKcwYO3NN3nYAtnX6X5x579Ka8vOIrdnVGImVfGTx4oGdTZm6U55NPPlkbiZSdNXjwQMJh77vK4XAIKZOyrzz55JNuL65NBp4Bfg/8AziRYHIoEs3iMfPvCaWgs7wiecK2+giLF1YSjRbfZyJUeuXpWf0MA8eXl1d3yrYZ06vebXl5dSfgeBu3Hd+zZ+/qysrywOv0vzxD9OvXv9quzl69eldXVlYEvjx79epT7ccodqdBrKBXrz52yzPVI4ySParudOSMoSpgD8RrJ2hTY2HgwbTOQBnwKM4cTnzRmUzyaLQsWbV+Q5TmHSHCYf9FRcpg+/Yw27eHqChPBK08i1Y/w8DR0Wgn37+xyfNoG7cc3afPHiWhsxjl2atXb9s6e/fu7flalxvl2bdvX397oiEwedrRWWse1BeQYJhD2nzeg10j7wKMoDhurFchkaN/y+7z7v2AAW1tLzuPuQi0zkg4OTKZhEQ8RCiU9F1nJJIsb2wM88nHFYTDySCVZ1HrZxkwtqyswvcaZPIca+OWsZ0715aEzmKUZ21tp3Zbnl27dvFdp8nTjs4pyCa2GuSo7a7A6eyM0p2t91Hp81e7FjmiIsXebQxqeY7ecOB1JiHis0PCbjorypNHf7y8kjFjm4hGk+VpQUaLWZ5FrZ9hYGgk4r8rp8lzqI1bhlZXV5SEzmKUp9m8aLM8q30f0RRSnlVV/s8ymDzt6LzYPMSpRuQUdj2cLltB+72Y0NbJ4ag2BjXbInRcdVrTGS1Pjm1qCtPQECYaTQZFZ1HrZxjoHC7CZKbJs7ONWzqHw2GSyaTtv0Qi6bvOUijPaLRwr7iUgZJgpdb/jOOBLZ2pKMz+jrxsl2e/PO8FZUd/Jqvdn+BRsjqTSfpHIuJinUwGRmdR62fJHAUKMHv2AoIV6ik4JBIJ3/KqqalizJjCTpKOx+M888yijvKzhAOoaQe7nz/fojrd1xkKaf1Mz2ibn41Um4Zxm41bVGcOWlpitnXGYoXH5LM7kkn9tbbGbetsbfW/PE2e2xwmkwxg45JUnR1SZ1HrZxhYGo/731EweS61cYvqzEF9faNtnY2NjSR9HNsnk0kaG+3rbGpq8r08TZ5LURTFFUMzt7XV/2gH8fgOkCilVlGdOdi8eYttndu21fuu0+RpS+fWrXW+6zR5ztUmQlHcMTQvxWLbfc+4pWU7wEs2blGdWUgkkqxZ86ltnevXr/d9RLN+/XrbOteuXevromoyCWvXrrWrU1GUHIbm2ZaWxu2JhH/edolEnJaWxkZkk5NVVGcW1q/fSkPDVts6N2xY39jc7N/oq7l5Bxs2rG+yr3NdEXSus6tTUZRshqZnz+H1kHywuXmrjw/yViD5gORtmaLplLyDqTMeT7Bs2XISibhtnfF468OffLKSeDzug844klfrQ3Z0nnLKKfXxeOtDH3+8wpGbup3R4ccfryAeb33wlFNOqdcmQlHcGdEA3NrUtCXmRy88kYjT1LQlhsTRsYvqbMOKFevZuHF1QToTicT0FSs+bm1qavZcZ1NTMytXftyaSCRutntvMpm8ecWK5a0NDY2e69y+vZEVK5a3JpPJW7R5UBQXDU3PnsOXJJOJO7ZvX+/Dg7yeZDJxZ8+ewxcXcLvvOpFoq4HUuWlTPYsXLyCRiBess7m56Y6FCxen3KM9oaUlxsKFi2lsbLyjEJ1jxoxZ0tTU+PNFixb5orOpqfGOMWPGLNbmQVHcHdEATNuxo36ul1M+zc1b2bGjfi4OT65UnbB163bmz19IY+NWRzqTyeSPVq9eMW/FilWeTKHF43FWrFjF6tUr5hWqs6WlBWDaqlWfzF258tPUXhxXaW1tZeXKT1m9+pN5wDSTp6Iobhqanj2HNwGnNzSs37Bjh/tT0zt21NPQsH4DcHrPnsOdzIH4phMIpM716+v44IOFbNq0yhWdiUTitIUL529etWoN8bh7myPj8QSrVq1h4cL5mxOJxGlOdI4YMaIJOH3Bgg82rV691lVj09oaZ/XqdSxY8MGmZDJ52ogRIxq1aVAUb0Y09Ow5fAlwXH39mnVu9sSbm7dSX79mHXCcycMpnus0eQRKZyzWytKla5g/fwEbN65wVWcsFjvmgw/e37h8+Se0trY6TrC1tZXlyz/hgw/e3xiLxY5xQ+eIESOWxGKxYz/4YM6Gjz9eyY4dzkcdO3a08PHHK/nggzkbYrHYsSNGjFji4vMVyvIaC+/j0vWKUvT6uVusm549h78LTGxoWD+3vn4NiUThjU4iEae+fg0NDevnAhNN2m7hmU6TdmB0xmJxVqzYwJw5y1i0aD5bt67xRGcsFjtk/vx5H8yZM4+GhsL3AjU0bGfOnHnMnz/vg1gsdoibOseMGfNuLBY7dP78ufPmzfuQhobGguK8JRIJGhoamTfvQ+bPnzsvFosdOmbMmHddfpDT3eSyDcHSxWcKHV+WI81CiOZ5r8zCfeXZPk+L7xW18F2KpjNPPu1RZ1HrZ8agambUMWHHjvrbt2z5ONbYuAk7HlSJRJzGxk1s2bI8tmNH/e3ABJdGMplGDK7qdGmEULDOeDxJS0sr27Y18umnm5k/fyVvv72QhQsX8umnCzzXmUgkDly9esXPXn/99daPPlqUChljicbGRj76aBGvv/566+rVK36WSCQO9ELnuHHjliQSiYNWrfrk9jfeeL114cKlNDY2k0gkcm7sTCbFwDQ2NrNw4VLeeOP11lWrPrk9kUgcNG7cOKc6M4Uv2JD2elubhzb1UDak/X9dhjQ2t/l/Jg8TO8PlTI1FQxudmUh/P5Yt3UTis4jFdQ4bRk915vnd2qPOotbPrEJ79hzeDFy7ceOi3zc2brqmsXHzOeXl1dXRaCei0UrC4WgqND2JRIJEIkYs1kwstp2WlsYmSP4duK1A7zJbM17AtclkwpFOCvPacl3n7NkfBUHn95qaGu9dvHjB1KVLF5/ds2fvqt69e9OtWxeqq6soKyv7bHqssbGJLVvqWL9+PRs3rm9OJOIPJBKJW0KhkKc6R48e3VxbW3vt7Nmzf79kyYKpy5aJzr59+9K1axeqqqooK4sYnXGamprYurWOtWvXfqYzHo/fcvDBBy+ur3dlDe0B4IK0h/8tdo2Vtg14Gjg5bXrhWWBL2jUvmYe5j/n/duDJNvksM2lPSM1Smryt8hDwtbT/rwX+16bxeQE4Ju29D4AFaf9/BPhhm3T/GgoliSdCJBIhQqHkQgjNZdczZF4Mgs42/1+IhBpq7zqLWj9Dr732oSWVGzcuqgFOBI4ExiNHgXZN61EtB+YArwDP9Ow5vMFKuo890p07fpH9qN4pV6wF4PAjZ1stUFs621js7K1vUwVnnT056+cPPvAvACqrdpS8zlAoRDKZJBwOk0gkbOkMh8MNiUTiszSc6sxH/wGDHNXPVSs/yZtHLp1p9bQ/cAdwGLAIOXnxjTaX7WOu2Q+YB1wOzG8zw/BN4BpTPx4Brmd3J4pDgNuB4cBMYModv+i7ykp5TblibYVpdA4HVgFnAR+1uawbcs7954y+s8216ZwN3Gx0PgR8Z/v2MHv2j3Hc5K0kEhCPhwYCjyIHyP0POGfixFGbvdS5vSG8qv/AFo6bXEc8DvF4aDedGbJzVWcsFvooGk0y+YSt9OjRSlNTuKDydFPnrFnzi1o/Q9+9fE034H7gWKwdL9oCPAycf/qXN7cYY1GJnEP9lSxziW1pNVb+bKDOiqExlaognUDLhIPfAzmWtGCdFhtGRzrNe6rTBZ39BwxqMcbEM52KouQnDPwCmIz1M6zLzVDx+sce6c5jj3QH+IF5L2oxjTKT5502tBasM+091dmBdK5a+UlqxOKHTkVRchiaQrtr6fcd50Iabl6rOlWn3zoVRclhaHoWeG+ftNdupJEP1ak6g6xTUZQchkZRlCzo+oyiqKFRFEVR1NAoiqIoamgURVEURQ2NoiiKooZGURRFUdTQKIqiKGpoFEVRlHZlaOoKvDc9mJsbaeRDdarOIOtUFCWHoXm0wHsfS3vtRhr5UJ2qM8g6FUXJQhlwFVALfAFrx3a2mgfw9rT3bgX6IefXWwl+mEDOUvieDa2qU3UGWaeiKDkMTR0SPt0JLcC3zJ9XqE7VGWSdiqLkMDQdgrdm7+c4jbPO9jZ9t/BDpznfR1EUxZKh6QLci/WpiTgyNXE5Ow/AKgfuAk6zODWRRA6WuhjrC7WqU3UGWaeiKDkMzQzgTJv3XYwcRXqT+f9U4CKbaXwFOafa6n2qU3UGWaeiKFkIA2cUeO/paa/dSCMfqlN1Blmnoig5DE2XAu/t3mZ6w2ka+VCdqjPIOhVFyWFoFEVRFEUNjaIoiqKGRlEURVHU0CiKoihqaBRFURQ1NIqiKIqihkZRFEVRQ6MoiqJ0BEOzscB716W9diONfKhO1RlknYqi5DA0/yrw3mfTXj/nQhr5UJ2qM8g6FUXJYWguNw9zq8V7WoC/Ajenvfdj4G/sjJabj1bzEE+xoVV1qs4g61QUJQv/PwAlukJhy2ScjQAAAABJRU5ErkJggg==";
    return cfIconsImg;
  }
  function getBorderFix() {
    return [-1, 0, 0, -1];
  }
  function setLineDash(canvasborder, type, hv, moveX, moveY, toX, toY) {
    var borderType = {
      "0": "none",
      "1": "Thin",
      "2": "Hair",
      "3": "Dotted",
      "4": "Dashed",
      "5": "DashDot",
      "6": "DashDotDot",
      "7": "Double",
      "8": "Medium",
      "9": "MediumDashed",
      "10": "MediumDashDot",
      "11": "MediumDashDotDot",
      "12": "SlantedDashDot",
      "13": "Thick"
    };
    type = borderType[type.toString()];
    try {
      if (type === "Hair") {
        canvasborder.setLineDash([1, 2]);
      } else if (type.indexOf("DashDotDot") > -1) {
        canvasborder.setLineDash([2, 2, 5, 2, 2]);
      } else if (type.indexOf("DashDot") > -1) {
        canvasborder.setLineDash([2, 5, 2]);
      } else if (type.indexOf("Dotted") > -1) {
        canvasborder.setLineDash([2]);
      } else if (type.indexOf("Dashed") > -1) {
        canvasborder.setLineDash([3]);
      } else {
        canvasborder.setLineDash([0]);
      }
    } catch (e) {
      console.error(e);
    }
    canvasborder.beginPath();
    if (type.indexOf("Medium") > -1) {
      if (hv === "h") {
        canvasborder.moveTo(moveX, moveY - 0.5);
        canvasborder.lineTo(toX, toY - 0.5);
      } else {
        canvasborder.moveTo(moveX - 0.5, moveY);
        canvasborder.lineTo(toX - 0.5, toY);
      }
      canvasborder.lineWidth = 2;
    } else if (type === "Thick") {
      canvasborder.moveTo(moveX, moveY);
      canvasborder.lineTo(toX, toY);
      canvasborder.lineWidth = 3;
    } else {
      canvasborder.moveTo(moveX, moveY);
      canvasborder.lineTo(toX, toY);
      canvasborder.lineWidth = 1;
    }
  }
  var Canvas = /* @__PURE__ */ function() {
    function Canvas2(canvasElement, ctx) {
      _classCallCheck(this, Canvas2);
      this.canvasElement = void 0;
      this.sheetCtx = void 0;
      this.measureTextCacheTimeOut = void 0;
      this.cellOverflowMapCache = void 0;
      this.canvasElement = canvasElement;
      this.sheetCtx = ctx;
      this.cellOverflowMapCache = {};
    }
    _createClass(Canvas2, [{
      key: "drawRowHeader",
      value: function drawRowHeader(scrollHeight, drawHeight, offsetTop) {
        if (_$1.isNil(drawHeight)) {
          var _this$sheetCtx$luckys = _slicedToArray$1(this.sheetCtx.luckysheetTableContentHW, 2);
          drawHeight = _this$sheetCtx$luckys[1];
        }
        if (_$1.isNil(offsetTop)) {
          offsetTop = this.sheetCtx.columnHeaderHeight;
        }
        var renderCtx = this.canvasElement.getContext("2d");
        if (!renderCtx) return;
        renderCtx.save();
        renderCtx.scale(this.sheetCtx.devicePixelRatio, this.sheetCtx.devicePixelRatio);
        renderCtx.clearRect(0, offsetTop, this.sheetCtx.rowHeaderWidth - 1, drawHeight);
        renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
        renderCtx.textBaseline = defaultStyle.textBaseline;
        renderCtx.fillStyle = defaultStyle.fillStyle;
        var dataset_row_st;
        var dataset_row_ed;
        dataset_row_st = _$1.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight);
        dataset_row_ed = _$1.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight + drawHeight);
        if (dataset_row_st === -1) {
          dataset_row_st = 0;
        }
        if (dataset_row_ed === -1) {
          dataset_row_ed = this.sheetCtx.visibledatarow.length - 1;
        }
        renderCtx.save();
        renderCtx.beginPath();
        renderCtx.rect(0, offsetTop - 1, this.sheetCtx.rowHeaderWidth - 1, drawHeight - 2);
        renderCtx.clip();
        var end_r;
        var start_r;
        var bodrder05 = 0.5;
        var preEndR;
        for (var r2 = dataset_row_st; r2 <= dataset_row_ed; r2 += 1) {
          var _this$sheetCtx$hooks$, _this$sheetCtx$hooks, _this$sheetCtx$config, _this$sheetCtx$config2, _this$sheetCtx$config3, _this$sheetCtx$config4, _this$sheetCtx$hooks$2, _this$sheetCtx$hooks2;
          if (r2 === 0) {
            start_r = -scrollHeight - 1;
          } else {
            start_r = this.sheetCtx.visibledatarow[r2 - 1] - scrollHeight - 1;
          }
          end_r = this.sheetCtx.visibledatarow[r2] - scrollHeight;
          var firstOffset = dataset_row_st === r2 ? -2 : 0;
          var lastOffset = dataset_row_ed === r2 ? -2 : 0;
          if (((_this$sheetCtx$hooks$ = (_this$sheetCtx$hooks = this.sheetCtx.hooks).beforeRenderRowHeaderCell) === null || _this$sheetCtx$hooks$ === void 0 ? void 0 : _this$sheetCtx$hooks$.call(_this$sheetCtx$hooks, "".concat(r2 + 1), r2, start_r + offsetTop + firstOffset, this.sheetCtx.rowHeaderWidth - 1, end_r - start_r + 1 + lastOffset - firstOffset, renderCtx)) === false) {
            continue;
          }
          if (((_this$sheetCtx$config = this.sheetCtx.config) === null || _this$sheetCtx$config === void 0 ? void 0 : (_this$sheetCtx$config2 = _this$sheetCtx$config.rowhidden) === null || _this$sheetCtx$config2 === void 0 ? void 0 : _this$sheetCtx$config2[r2]) == null) {
            renderCtx.fillStyle = "#ffffff";
            renderCtx.fillRect(0, start_r + offsetTop + firstOffset, this.sheetCtx.rowHeaderWidth - 1, end_r - start_r + 1 + lastOffset - firstOffset);
            renderCtx.fillStyle = "#000000";
            renderCtx.save();
            renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
            var textMetrics = getMeasureText(r2 + 1, renderCtx, this.sheetCtx);
            var horizonAlignPos = (this.sheetCtx.rowHeaderWidth - textMetrics.width) / 2;
            var verticalAlignPos = start_r + (end_r - start_r) / 2 + offsetTop;
            renderCtx.fillText("".concat(r2 + 1), horizonAlignPos / this.sheetCtx.zoomRatio, verticalAlignPos / this.sheetCtx.zoomRatio);
            renderCtx.restore();
          }
          renderCtx.beginPath();
          renderCtx.moveTo(this.sheetCtx.rowHeaderWidth - 2 + bodrder05, start_r + offsetTop - 2);
          renderCtx.lineTo(this.sheetCtx.rowHeaderWidth - 2 + bodrder05, end_r + offsetTop - 2);
          renderCtx.lineWidth = 1;
          renderCtx.strokeStyle = defaultStyle.strokeStyle;
          renderCtx.stroke();
          renderCtx.closePath();
          if (this.sheetCtx.config.rowhidden && this.sheetCtx.config.rowhidden[r2] == null && this.sheetCtx.config.rowhidden[r2 + 1] != null) {
            renderCtx.beginPath();
            renderCtx.moveTo(-1, end_r + offsetTop - 4 + bodrder05);
            renderCtx.lineTo(this.sheetCtx.rowHeaderWidth - 1, end_r + offsetTop - 4 + bodrder05);
            renderCtx.closePath();
            renderCtx.stroke();
          } else if (this.sheetCtx.config.rowhidden == null || this.sheetCtx.config.rowhidden[r2] == null) {
            renderCtx.beginPath();
            renderCtx.moveTo(-1, end_r + offsetTop - 2 + bodrder05);
            renderCtx.lineTo(this.sheetCtx.rowHeaderWidth - 1, end_r + offsetTop - 2 + bodrder05);
            renderCtx.closePath();
            renderCtx.stroke();
          }
          if (((_this$sheetCtx$config3 = this.sheetCtx.config) === null || _this$sheetCtx$config3 === void 0 ? void 0 : (_this$sheetCtx$config4 = _this$sheetCtx$config3.rowhidden) === null || _this$sheetCtx$config4 === void 0 ? void 0 : _this$sheetCtx$config4[r2 - 1]) != null && preEndR !== void 0) {
            renderCtx.beginPath();
            renderCtx.moveTo(-1, preEndR + offsetTop + bodrder05);
            renderCtx.lineTo(this.sheetCtx.rowHeaderWidth - 1, preEndR + offsetTop + bodrder05);
            renderCtx.closePath();
            renderCtx.stroke();
          }
          preEndR = end_r;
          (_this$sheetCtx$hooks$2 = (_this$sheetCtx$hooks2 = this.sheetCtx.hooks).afterRenderRowHeaderCell) === null || _this$sheetCtx$hooks$2 === void 0 ? void 0 : _this$sheetCtx$hooks$2.call(_this$sheetCtx$hooks2, "".concat(r2 + 1), r2, start_r + offsetTop + firstOffset, this.sheetCtx.rowHeaderWidth - 1, end_r - start_r + 1 + lastOffset - firstOffset, renderCtx);
        }
        renderCtx.restore();
        renderCtx.restore();
      }
    }, {
      key: "drawColumnHeader",
      value: function drawColumnHeader(scrollWidth, drawWidth, offsetLeft) {
        if (drawWidth === void 0) {
          var _this$sheetCtx$luckys2 = _slicedToArray$1(this.sheetCtx.luckysheetTableContentHW, 1);
          drawWidth = _this$sheetCtx$luckys2[0];
        }
        if (offsetLeft === void 0) {
          offsetLeft = this.sheetCtx.rowHeaderWidth;
        }
        var renderCtx = this.canvasElement.getContext("2d");
        if (!renderCtx) return;
        renderCtx.save();
        renderCtx.scale(this.sheetCtx.devicePixelRatio, this.sheetCtx.devicePixelRatio);
        renderCtx.clearRect(offsetLeft, 0, drawWidth, this.sheetCtx.columnHeaderHeight - 1);
        renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
        renderCtx.textBaseline = defaultStyle.textBaseline;
        renderCtx.fillStyle = defaultStyle.fillStyle;
        var dataset_col_st;
        var dataset_col_ed;
        dataset_col_st = _$1.sortedIndex(this.sheetCtx.visibledatacolumn, scrollWidth);
        dataset_col_ed = _$1.sortedIndex(this.sheetCtx.visibledatacolumn, scrollWidth + drawWidth);
        if (dataset_col_st === -1) {
          dataset_col_st = 0;
        }
        if (dataset_col_ed === -1) {
          dataset_col_ed = this.sheetCtx.visibledatacolumn.length - 1;
        }
        renderCtx.save();
        renderCtx.beginPath();
        renderCtx.rect(offsetLeft - 1, 0, drawWidth, this.sheetCtx.columnHeaderHeight - 1);
        renderCtx.clip();
        var end_c;
        var start_c;
        var bodrder05 = 0.5;
        var preEndC;
        for (var c2 = dataset_col_st; c2 <= dataset_col_ed; c2 += 1) {
          var _this$sheetCtx$hooks$3, _this$sheetCtx$hooks3, _this$sheetCtx$config5, _this$sheetCtx$config6, _this$sheetCtx$config7, _this$sheetCtx$config8, _this$sheetCtx$hooks$4, _this$sheetCtx$hooks4;
          if (c2 === 0) {
            start_c = -scrollWidth;
          } else {
            start_c = this.sheetCtx.visibledatacolumn[c2 - 1] - scrollWidth;
          }
          end_c = this.sheetCtx.visibledatacolumn[c2] - scrollWidth;
          var abc = indexToColumnChar(c2);
          if (((_this$sheetCtx$hooks$3 = (_this$sheetCtx$hooks3 = this.sheetCtx.hooks).beforeRenderColumnHeaderCell) === null || _this$sheetCtx$hooks$3 === void 0 ? void 0 : _this$sheetCtx$hooks$3.call(_this$sheetCtx$hooks3, abc, c2, start_c + offsetLeft - 1, end_c - start_c, this.sheetCtx.columnHeaderHeight - 1, renderCtx)) === false) {
            continue;
          }
          if (((_this$sheetCtx$config5 = this.sheetCtx.config) === null || _this$sheetCtx$config5 === void 0 ? void 0 : (_this$sheetCtx$config6 = _this$sheetCtx$config5.colhidden) === null || _this$sheetCtx$config6 === void 0 ? void 0 : _this$sheetCtx$config6[c2]) == null) {
            renderCtx.fillStyle = "#ffffff";
            renderCtx.fillRect(start_c + offsetLeft - 1, 0, end_c - start_c, this.sheetCtx.columnHeaderHeight - 1);
            renderCtx.fillStyle = "#000000";
            renderCtx.save();
            renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
            var textMetrics = getMeasureText(abc, renderCtx, this.sheetCtx);
            var horizonAlignPos = Math.round(start_c + (end_c - start_c) / 2 + offsetLeft - textMetrics.width / 2);
            var verticalAlignPos = Math.round(this.sheetCtx.columnHeaderHeight / 2);
            renderCtx.fillText(abc, horizonAlignPos / this.sheetCtx.zoomRatio, verticalAlignPos / this.sheetCtx.zoomRatio);
            renderCtx.restore();
          }
          if (this.sheetCtx.config.colhidden && this.sheetCtx.config.colhidden[c2] != null && this.sheetCtx.config.colhidden[c2 + 1] != null) {
            renderCtx.beginPath();
            renderCtx.moveTo(end_c + offsetLeft - 4 + bodrder05, 0);
            renderCtx.lineTo(end_c + offsetLeft - 4 + bodrder05, this.sheetCtx.columnHeaderHeight - 2);
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = defaultStyle.strokeStyle;
            renderCtx.closePath();
            renderCtx.stroke();
          } else if (this.sheetCtx.config.colhidden == null || this.sheetCtx.config.colhidden[c2] == null) {
            renderCtx.beginPath();
            renderCtx.moveTo(end_c + offsetLeft - 2 + bodrder05, 0);
            renderCtx.lineTo(end_c + offsetLeft - 2 + bodrder05, this.sheetCtx.columnHeaderHeight - 2);
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = defaultStyle.strokeStyle;
            renderCtx.closePath();
            renderCtx.stroke();
          }
          if (((_this$sheetCtx$config7 = this.sheetCtx.config) === null || _this$sheetCtx$config7 === void 0 ? void 0 : (_this$sheetCtx$config8 = _this$sheetCtx$config7.colhidden) === null || _this$sheetCtx$config8 === void 0 ? void 0 : _this$sheetCtx$config8[c2 - 1]) != null && preEndC !== void 0) {
            renderCtx.beginPath();
            renderCtx.moveTo(preEndC + offsetLeft + bodrder05, 0);
            renderCtx.lineTo(preEndC + offsetLeft + bodrder05, this.sheetCtx.columnHeaderHeight - 2);
            renderCtx.closePath();
            renderCtx.stroke();
          }
          renderCtx.beginPath();
          renderCtx.moveTo(start_c + offsetLeft - 1, this.sheetCtx.columnHeaderHeight - 2 + bodrder05);
          renderCtx.lineTo(end_c + offsetLeft - 1, this.sheetCtx.columnHeaderHeight - 2 + bodrder05);
          renderCtx.stroke();
          renderCtx.closePath();
          preEndC = end_c;
          (_this$sheetCtx$hooks$4 = (_this$sheetCtx$hooks4 = this.sheetCtx.hooks).afterRenderColumnHeaderCell) === null || _this$sheetCtx$hooks$4 === void 0 ? void 0 : _this$sheetCtx$hooks$4.call(_this$sheetCtx$hooks4, abc, c2, start_c + offsetLeft - 1, end_c - start_c, this.sheetCtx.columnHeaderHeight - 1, renderCtx);
        }
        renderCtx.restore();
        renderCtx.restore();
      }
    }, {
      key: "drawMain",
      value: function drawMain(_ref) {
        var _this$sheetCtx$hooks$5, _this$sheetCtx$hooks5, _this$sheetCtx$config15, _this$sheetCtx$config16, _this$sheetCtx$config17, _this = this;
        var scrollWidth = _ref.scrollWidth, scrollHeight = _ref.scrollHeight, drawWidth = _ref.drawWidth, drawHeight = _ref.drawHeight, offsetLeft = _ref.offsetLeft, offsetTop = _ref.offsetTop, columnOffsetCell = _ref.columnOffsetCell, rowOffsetCell = _ref.rowOffsetCell, clear = _ref.clear;
        var flowdata = getFlowdata(this.sheetCtx);
        if (_$1.isNil(flowdata)) {
          return;
        }
        clearTimeout(this.measureTextCacheTimeOut);
        if (drawWidth === void 0) {
          var _this$sheetCtx$luckys3 = _slicedToArray$1(this.sheetCtx.luckysheetTableContentHW, 1);
          drawWidth = _this$sheetCtx$luckys3[0];
        }
        if (drawHeight === void 0) {
          var _this$sheetCtx$luckys4 = _slicedToArray$1(this.sheetCtx.luckysheetTableContentHW, 2);
          drawHeight = _this$sheetCtx$luckys4[1];
        }
        if (offsetLeft === void 0) {
          offsetLeft = this.sheetCtx.rowHeaderWidth;
        }
        if (offsetTop === void 0) {
          offsetTop = this.sheetCtx.columnHeaderHeight;
        }
        if (columnOffsetCell === void 0) {
          columnOffsetCell = 0;
        }
        if (rowOffsetCell === void 0) {
          rowOffsetCell = 0;
        }
        var renderCtx = this.canvasElement.getContext("2d");
        if (!renderCtx) return;
        renderCtx.save();
        renderCtx.scale(this.sheetCtx.devicePixelRatio, this.sheetCtx.devicePixelRatio);
        if (clear) {
          renderCtx.clearRect(0, 0, this.sheetCtx.luckysheetTableContentHW[0], this.sheetCtx.luckysheetTableContentHW[1]);
        }
        var rowStart;
        var rowEnd;
        var colStart;
        var colEnd;
        rowStart = _$1.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight);
        rowEnd = _$1.sortedIndex(this.sheetCtx.visibledatarow, scrollHeight + drawHeight);
        if (rowStart === -1) {
          rowStart = 0;
        }
        rowStart += rowOffsetCell;
        if (rowEnd === -1) {
          rowEnd = this.sheetCtx.visibledatarow.length - 1;
        }
        rowEnd += rowOffsetCell;
        if (rowEnd >= this.sheetCtx.visibledatarow.length) {
          rowEnd = this.sheetCtx.visibledatarow.length - 1;
        }
        colStart = _$1.sortedIndex(this.sheetCtx.visibledatacolumn, scrollWidth);
        colEnd = _$1.sortedIndex(this.sheetCtx.visibledatacolumn, scrollWidth + drawWidth);
        if (colStart === -1) {
          colStart = 0;
        }
        colStart += columnOffsetCell;
        if (colEnd === -1) {
          colEnd = this.sheetCtx.visibledatacolumn.length - 1;
        }
        colEnd += columnOffsetCell;
        if (colEnd >= this.sheetCtx.visibledatacolumn.length) {
          colEnd = this.sheetCtx.visibledatacolumn.length - 1;
        }
        var rowEndY = this.sheetCtx.visibledatarow[rowEnd];
        var colEndX = this.sheetCtx.visibledatacolumn[colEnd];
        renderCtx.fillStyle = "#ffffff";
        renderCtx.fillRect(offsetLeft - 1, offsetTop - 1, colEndX - scrollWidth, rowEndY - scrollHeight);
        renderCtx.font = defaultFont(this.sheetCtx.defaultFontSize);
        renderCtx.fillStyle = defaultStyle.fillStyle;
        var cellupdate = [];
        var mergeCache = {};
        var borderOffset = {};
        var bodrder05 = 0.5;
        (_this$sheetCtx$hooks$5 = (_this$sheetCtx$hooks5 = this.sheetCtx.hooks).beforeRenderCellArea) === null || _this$sheetCtx$hooks$5 === void 0 ? void 0 : _this$sheetCtx$hooks$5.call(_this$sheetCtx$hooks5, flowdata, renderCtx);
        for (var r2 = rowStart; r2 <= rowEnd; r2 += 1) {
          var _this$sheetCtx$config9, _this$sheetCtx$config10;
          var startY = void 0;
          if (r2 === 0) {
            startY = -scrollHeight - 1;
          } else {
            startY = this.sheetCtx.visibledatarow[r2 - 1] - scrollHeight - 1;
          }
          var endY = this.sheetCtx.visibledatarow[r2] - scrollHeight;
          if (((_this$sheetCtx$config9 = this.sheetCtx.config) === null || _this$sheetCtx$config9 === void 0 ? void 0 : (_this$sheetCtx$config10 = _this$sheetCtx$config9.rowhidden) === null || _this$sheetCtx$config10 === void 0 ? void 0 : _this$sheetCtx$config10[r2]) != null) {
            continue;
          }
          for (var c2 = colStart; c2 <= colEnd; c2 += 1) {
            var _this$sheetCtx$config11, _this$sheetCtx$config12, _this$sheetCtx$config13, _this$sheetCtx$config14, _flowdata$r;
            var startX = void 0;
            if (c2 === 0) {
              startX = -scrollWidth;
            } else {
              startX = this.sheetCtx.visibledatacolumn[c2 - 1] - scrollWidth;
            }
            var endX = this.sheetCtx.visibledatacolumn[c2] - scrollWidth;
            if (((_this$sheetCtx$config11 = this.sheetCtx.config) === null || _this$sheetCtx$config11 === void 0 ? void 0 : (_this$sheetCtx$config12 = _this$sheetCtx$config11.colhidden) === null || _this$sheetCtx$config12 === void 0 ? void 0 : _this$sheetCtx$config12[c2]) != null) {
              continue;
            }
            var firstcolumnlen = this.sheetCtx.defaultcollen;
            if ((_this$sheetCtx$config13 = this.sheetCtx.config) === null || _this$sheetCtx$config13 === void 0 ? void 0 : (_this$sheetCtx$config14 = _this$sheetCtx$config13.columnlen) === null || _this$sheetCtx$config14 === void 0 ? void 0 : _this$sheetCtx$config14[c2]) {
              firstcolumnlen = this.sheetCtx.config.columnlen[c2];
            }
            if (flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$r = flowdata[r2]) === null || _flowdata$r === void 0 ? void 0 : _flowdata$r[c2]) {
              var value = flowdata[r2][c2];
              if (value === null || value === void 0 ? void 0 : value.mc) {
                borderOffset["".concat(r2, "_").concat(c2)] = {
                  startY,
                  startX,
                  endY,
                  endX
                };
                if ("rs" in value.mc) {
                  var key = "r".concat(r2, "c").concat(c2);
                  mergeCache[key] = cellupdate.length;
                } else {
                  var _key = "r".concat(value.mc.r, "c").concat(value.mc.c);
                  var margeMain = cellupdate[mergeCache[_key]];
                  if (_$1.isNil(margeMain)) {
                    mergeCache[_key] = cellupdate.length;
                    cellupdate.push({
                      r: r2,
                      c: c2,
                      startX,
                      startY,
                      endY,
                      endX,
                      firstcolumnlen
                    });
                  } else {
                    if (margeMain.c === c2) {
                      margeMain.endY += endY - startY - 1;
                    }
                    if (margeMain.r === r2) {
                      margeMain.endX += endX - startX;
                      margeMain.firstcolumnlen += firstcolumnlen;
                    }
                  }
                  continue;
                }
              }
            }
            cellupdate.push({
              r: r2,
              c: c2,
              startY,
              startX,
              endY,
              endX,
              firstcolumnlen
            });
            borderOffset["".concat(r2, "_").concat(c2)] = {
              startY,
              startX,
              endY,
              endX
            };
          }
        }
        var dynamicArrayCompute = {};
        var afCompute = {};
        var cfCompute = getComputeMap(this.sheetCtx);
        var cellOverflowMap = this.getCellOverflowMap(renderCtx, colStart, colEnd, rowStart, rowEnd);
        var mcArr = [];
        for (var cud = 0; cud < cellupdate.length; cud += 1) {
          var item = cellupdate[cud];
          var _r = item.r;
          var _c = item.c;
          var _startY = item.startY;
          var _startX = item.startX;
          var _endY = item.endY;
          var _endX = item.endX;
          if (_$1.isNil(flowdata[_r])) {
            continue;
          }
          if (_$1.isNil(flowdata[_r][_c])) {
            this.nullCellRender(_r, _c, _startY, _startX, _endY, _endX, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05);
          } else {
            var cell = flowdata[_r][_c];
            var _value2 = null;
            if (cell === null || cell === void 0 ? void 0 : cell.mc) {
              mcArr.push(cellupdate[cud]);
            } else {
              _value2 = getRealCellValue(_r, _c, flowdata);
            }
            if (_$1.isNil(_value2) || _value2.toString().length === 0) {
              this.nullCellRender(_r, _c, _startY, _startX, _endY, _endX, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05);
            } else {
              if ("".concat(_r, "_").concat(_c) in dynamicArrayCompute) {
                _value2 = dynamicArrayCompute["".concat(_r, "_").concat(_c)].v;
              }
              this.cellRender(_r, _c, _startY, _startX, _endY, _endX, _value2, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05);
            }
          }
        }
        for (var m2 = 0; m2 < mcArr.length; m2 += 1) {
          var _mainCell$mc, _mainCell$mc2;
          var _item = mcArr[m2];
          var _r2 = _item.r;
          var _c2 = _item.c;
          var _startY2 = _item.startY;
          var _startX2 = _item.startX;
          var _endY2 = _item.endY - 1;
          var _endX2 = _item.endX - 1;
          var _cell = flowdata[_r2][_c2];
          if (!_cell) continue;
          var _value3 = null;
          var mergeMaindata = _cell.mc;
          if (!mergeMaindata) continue;
          _value3 = getRealCellValue(mergeMaindata.r, mergeMaindata.c, flowdata);
          _r2 = mergeMaindata.r;
          _c2 = mergeMaindata.c;
          var mainCell = flowdata[_r2][_c2];
          if (!(mainCell === null || mainCell === void 0 ? void 0 : (_mainCell$mc = mainCell.mc) === null || _mainCell$mc === void 0 ? void 0 : _mainCell$mc.rs) || !((_mainCell$mc2 = mainCell.mc) === null || _mainCell$mc2 === void 0 ? void 0 : _mainCell$mc2.cs)) {
            continue;
          }
          if (_c2 === 0) {
            _startX2 = -scrollWidth;
          } else {
            _startX2 = this.sheetCtx.visibledatacolumn[_c2 - 1] - scrollWidth;
          }
          if (_r2 === 0) {
            _startY2 = -scrollHeight - 1;
          } else {
            _startY2 = this.sheetCtx.visibledatarow[_r2 - 1] - scrollHeight - 1;
          }
          _endY2 = this.sheetCtx.visibledatarow[_r2 + mainCell.mc.rs - 1] - scrollHeight;
          _endX2 = this.sheetCtx.visibledatacolumn[_c2 + mainCell.mc.cs - 1] - scrollWidth;
          if (_$1.isNil(_value3) || _value3.toString().length === 0) {
            this.nullCellRender(_r2, _c2, _startY2, _startX2, _endY2, _endX2, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05, true);
          } else {
            if ("".concat(_r2, "_").concat(_c2) in dynamicArrayCompute) {
              _value3 = dynamicArrayCompute["".concat(_r2, "_").concat(_c2)].v;
            }
            this.cellRender(_r2, _c2, _startY2, _startX2, _endY2, _endX2, _value3, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05, true);
          }
        }
        if (((_this$sheetCtx$config15 = (_this$sheetCtx$config16 = this.sheetCtx.config) === null || _this$sheetCtx$config16 === void 0 ? void 0 : (_this$sheetCtx$config17 = _this$sheetCtx$config16.borderInfo) === null || _this$sheetCtx$config17 === void 0 ? void 0 : _this$sheetCtx$config17.length) !== null && _this$sheetCtx$config15 !== void 0 ? _this$sheetCtx$config15 : 0) > 0) {
          var borderSlashRender = function borderSlashRender2(style, color, startY2, startX2, endY2, endX2, _offsetLeft, _offsetTop, canvas) {
            var linetype = style;
            var moveX = startX2 - 2 + bodrder05 + _offsetLeft;
            var moveY = startY2 + _offsetTop;
            var toX = endX2 - 2 + bodrder05 + _offsetLeft;
            var toY = endY2 - 2 + bodrder05 + _offsetTop;
            canvas.save();
            setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);
            canvas.strokeStyle = color;
            canvas.stroke();
            canvas.closePath();
            canvas.restore();
          };
          var borderLeftRender = function borderLeftRender2(style, color, startY2, startX2, endY2, endX2, _offsetLeft, _offsetTop, canvas) {
            var linetype = style;
            var moveX = startX2 - 2 + bodrder05 + _offsetLeft;
            var moveY = startY2 + _offsetTop - 1;
            var toX = startX2 - 2 + bodrder05 + _offsetLeft;
            var toY = endY2 - 2 + bodrder05 + _offsetTop;
            canvas.save();
            setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);
            canvas.strokeStyle = color;
            canvas.stroke();
            canvas.closePath();
            canvas.restore();
          };
          var borderRightRender = function borderRightRender2(style, color, startY2, startX2, endY2, endX2, _offsetLeft, _offsetTop, canvas) {
            var linetype = style;
            var moveX = endX2 - 2 + bodrder05 + _offsetLeft;
            var moveY = startY2 + _offsetTop - 1;
            var toX = endX2 - 2 + bodrder05 + _offsetLeft;
            var toY = endY2 - 2 + bodrder05 + _offsetTop;
            canvas.save();
            setLineDash(canvas, linetype, "v", moveX, moveY, toX, toY);
            canvas.strokeStyle = color;
            canvas.stroke();
            canvas.closePath();
            canvas.restore();
          };
          var borderBottomRender = function borderBottomRender2(style, color, startY2, startX2, endY2, endX2, _offsetLeft, _offsetTop, canvas) {
            var linetype = style;
            var moveX = startX2 - 2 + bodrder05 + _offsetLeft;
            var moveY = endY2 - 2 + bodrder05 + _offsetTop;
            var toX = endX2 - 2 + bodrder05 + _offsetLeft;
            var toY = endY2 - 2 + bodrder05 + _offsetTop;
            canvas.save();
            setLineDash(canvas, linetype, "h", moveX, moveY, toX, toY);
            canvas.strokeStyle = color;
            canvas.stroke();
            canvas.closePath();
            canvas.restore();
          };
          var borderTopRender = function borderTopRender2(style, color, startY2, startX2, endY2, endX2, _offsetLeft, _offsetTop, canvas) {
            var linetype = style;
            var moveX = startX2 - 2 + bodrder05 + _offsetLeft;
            var moveY = startY2 - 1 + bodrder05 + _offsetTop;
            var toX = endX2 - 2 + bodrder05 + _offsetLeft;
            var toY = startY2 - 1 + bodrder05 + _offsetTop;
            canvas.save();
            setLineDash(canvas, linetype, "h", moveX, moveY, toX, toY);
            canvas.strokeStyle = color;
            canvas.stroke();
            canvas.closePath();
            canvas.restore();
          };
          var borderInfoCompute = getBorderInfoComputeRange(this.sheetCtx, rowStart, rowEnd, colStart, colEnd);
          Object.keys(borderInfoCompute).forEach(function(x2) {
            var bdRow = Number(x2.substring(0, x2.indexOf("_")));
            var bdCol = Number(x2.substring(x2.indexOf("_") + 1));
            if (borderOffset["".concat(bdRow, "_").concat(bdCol)]) {
              var _startY3 = borderOffset["".concat(bdRow, "_").concat(bdCol)].startY;
              var _startX3 = borderOffset["".concat(bdRow, "_").concat(bdCol)].startX;
              var _endY3 = borderOffset["".concat(bdRow, "_").concat(bdCol)].endY;
              var _endX3 = borderOffset["".concat(bdRow, "_").concat(bdCol)].endX;
              var cellOverflow_colInObj = _this.cellOverflow_colIn(cellOverflowMap, bdRow, bdCol, colStart, colEnd);
              var borderSlash = borderInfoCompute[x2].s;
              if (borderSlash && (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.stc === bdCol)) {
                var _mergeCellEndY, _mergeCellEndX;
                var mergeMap = _this.sheetCtx.config.merge;
                var mergeCell = mergeMap === null || mergeMap === void 0 ? void 0 : mergeMap["".concat(bdRow, "_").concat(bdCol)];
                var mergeCellEndX;
                var mergeCellEndY;
                if (mergeCell) {
                  var mergeCellOffset = borderOffset["".concat(bdRow + mergeCell.rs - 1, "_").concat(bdCol + mergeCell.cs - 1)];
                  mergeCellEndX = mergeCellOffset.endX;
                  mergeCellEndY = mergeCellOffset.endY;
                }
                borderSlashRender(borderSlash.style, borderSlash.color, _startY3, _startX3, (_mergeCellEndY = mergeCellEndY) !== null && _mergeCellEndY !== void 0 ? _mergeCellEndY : _endY3, (_mergeCellEndX = mergeCellEndX) !== null && _mergeCellEndX !== void 0 ? _mergeCellEndX : _endX3, offsetLeft, offsetTop, renderCtx);
              }
              var borderLeft = borderInfoCompute[x2].l;
              if (borderLeft && (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.stc === bdCol)) {
                borderLeftRender(borderLeft.style, borderLeft.color, _startY3, _startX3, _endY3, _endX3, offsetLeft, offsetTop, renderCtx);
              }
              var borderRight = borderInfoCompute[x2].r;
              if (borderRight && (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.colLast)) {
                borderRightRender(borderRight.style, borderRight.color, _startY3, _startX3, _endY3, _endX3, offsetLeft, offsetTop, renderCtx);
              }
              var borderTop = borderInfoCompute[x2].t;
              if (borderTop) {
                borderTopRender(borderTop.style, borderTop.color, _startY3, _startX3, _endY3, _endX3, offsetLeft, offsetTop, renderCtx);
              }
              var borderBottom = borderInfoCompute[x2].b;
              if (borderBottom) {
                borderBottomRender(borderBottom.style, borderBottom.color, _startY3, _startX3, _endY3, _endX3, offsetLeft, offsetTop, renderCtx);
              }
            }
          });
        }
        if (colEnd === this.sheetCtx.visibledatacolumn.length - 1) {
          renderCtx.clearRect(colEndX - scrollWidth + offsetLeft - 1, offsetTop - 1, this.sheetCtx.ch_width - this.sheetCtx.visibledatacolumn[colEnd], rowEndY - scrollHeight);
        }
        renderCtx.restore();
        this.measureTextCacheTimeOut = setTimeout(function() {
          clearMeasureTextCache();
          _this.cellOverflowMapCache = {};
        }, 100);
      }
    }, {
      key: "getCellOverflowMap",
      value: function getCellOverflowMap(canvas, colStart, colEnd, rowStart, rowEnd) {
        var flowdata = getFlowdata(this.sheetCtx);
        var map = {};
        var data = flowdata;
        if (!data) {
          return map;
        }
        for (var r2 = rowStart; r2 <= rowEnd; r2 += 1) {
          if (_$1.isNil(data[r2])) {
            continue;
          }
          if (this.cellOverflowMapCache[r2]) {
            map[r2] = this.cellOverflowMapCache[r2];
            continue;
          }
          var hasCellOver = false;
          for (var c2 = 0; c2 < data[r2].length; c2 += 1) {
            var _this$sheetCtx$config18, _this$sheetCtx$config19;
            var cell = data[r2][c2];
            if (((_this$sheetCtx$config18 = this.sheetCtx.config) === null || _this$sheetCtx$config18 === void 0 ? void 0 : (_this$sheetCtx$config19 = _this$sheetCtx$config18.colhidden) === null || _this$sheetCtx$config19 === void 0 ? void 0 : _this$sheetCtx$config19[c2]) != null) {
              continue;
            }
            if (cell && (!_$1.isEmpty(cell.v) || isInlineStringCell(cell)) && _$1.isNil(cell.mc) && cell.tb === "1") {
              var horizonAlign = normalizedAttr(data, r2, c2, "ht");
              var textMetricsObj = getCellTextInfo(cell, canvas, this.sheetCtx, {
                r: r2,
                c: c2
              });
              var textMetrics = 0;
              if (textMetricsObj) {
                textMetrics = textMetricsObj.textWidthAll;
              }
              var startX = c2 - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[c2 - 1];
              var endX = this.sheetCtx.visibledatacolumn[c2];
              var stc = void 0;
              var edc = void 0;
              if (endX - startX < textMetrics) {
                if (horizonAlign === "0") {
                  var trace_forward = this.cellOverflow_trace(r2, c2, c2 - 1, "forward", horizonAlign, textMetrics);
                  var trace_backward = this.cellOverflow_trace(r2, c2, c2 + 1, "backward", horizonAlign, textMetrics);
                  if (trace_forward.success) {
                    stc = trace_forward.c;
                  } else {
                    stc = trace_forward.c + 1;
                  }
                  if (trace_backward.success) {
                    edc = trace_backward.c;
                  } else {
                    edc = trace_backward.c - 1;
                  }
                } else if (horizonAlign === "1") {
                  var trace = this.cellOverflow_trace(r2, c2, c2 + 1, "backward", horizonAlign, textMetrics);
                  stc = c2;
                  if (trace.success) {
                    edc = trace.c;
                  } else {
                    edc = trace.c - 1;
                  }
                } else if (horizonAlign === "2") {
                  var _trace = this.cellOverflow_trace(r2, c2, c2 - 1, "forward", horizonAlign, textMetrics);
                  edc = c2;
                  if (_trace.success) {
                    stc = _trace.c;
                  } else {
                    stc = _trace.c + 1;
                  }
                }
              } else {
                stc = c2;
                edc = c2;
              }
              if ((stc <= colEnd || edc >= colStart) && stc < edc) {
                var item = {
                  r: r2,
                  stc,
                  edc
                };
                if (_$1.isNil(map[r2])) {
                  map[r2] = {};
                }
                map[r2][c2] = item;
                hasCellOver = true;
              }
            }
          }
          if (hasCellOver) {
            this.cellOverflowMapCache[r2] = map[r2];
          }
        }
        return map;
      }
    }, {
      key: "nullCellRender",
      value: function nullCellRender(r2, c2, startY, startX, endY, endX, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05) {
        var _this$sheetCtx$hooks$6, _this$sheetCtx$hooks6, _flowdata$r2, _flowdata$r2$c, _this$sheetCtx$hooks$7, _this$sheetCtx$hooks7;
        var isMerge = arguments.length > 18 && arguments[18] !== void 0 ? arguments[18] : false;
        var checksCF = checkCF(r2, c2, cfCompute);
        var flowdata = getFlowdata(this.sheetCtx);
        if (!flowdata) return;
        var borderfix = getBorderFix();
        var fillStyle = normalizedAttr(flowdata, r2, c2, "bg");
        if (!_$1.isNil(checksCF) && !_$1.isNil(checksCF.cellColor)) {
          fillStyle = checksCF.cellColor;
        }
        if (!fillStyle) {
          renderCtx.fillStyle = "#FFFFFF";
        } else {
          renderCtx.fillStyle = fillStyle;
        }
        var cellsize = [startX + offsetLeft + borderfix[0], startY + offsetTop + borderfix[1], endX - startX + borderfix[2] - (isMerge ? 1 : 0), endY - startY + borderfix[3]];
        if (((_this$sheetCtx$hooks$6 = (_this$sheetCtx$hooks6 = this.sheetCtx.hooks).beforeRenderCell) === null || _this$sheetCtx$hooks$6 === void 0 ? void 0 : _this$sheetCtx$hooks$6.call(_this$sheetCtx$hooks6, flowdata[r2][c2], {
          row: r2,
          column: c2,
          startX: cellsize[0],
          startY: cellsize[1],
          endX: cellsize[2] + cellsize[0],
          endY: cellsize[3] + cellsize[1]
        }, renderCtx)) === false) {
          return;
        }
        renderCtx.fillRect(cellsize[0], cellsize[1], cellsize[2], cellsize[3]);
        if ("".concat(r2, "_").concat(c2) in dynamicArrayCompute) {
          var value = dynamicArrayCompute["".concat(r2, "_").concat(c2)].v;
          renderCtx.fillStyle = "#000000";
          var fontset = defaultFont(this.sheetCtx.defaultFontSize);
          renderCtx.font = fontset;
          var horizonAlignPos = startX + 4 + offsetLeft;
          var verticalAlignPos = endY + offsetTop - 2;
          renderCtx.textBaseline = "bottom";
          renderCtx.fillText(_$1.isNil(value) ? "" : value, horizonAlignPos, verticalAlignPos);
        }
        if (flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$r2 = flowdata[r2]) === null || _flowdata$r2 === void 0 ? void 0 : (_flowdata$r2$c = _flowdata$r2[c2]) === null || _flowdata$r2$c === void 0 ? void 0 : _flowdata$r2$c.ps) {
          var ps_w = 8 * this.sheetCtx.zoomRatio;
          var ps_h = 8 * this.sheetCtx.zoomRatio;
          renderCtx.beginPath();
          renderCtx.moveTo(endX + offsetLeft - 1 - ps_w, startY + offsetTop);
          renderCtx.lineTo(endX + offsetLeft - 1, startY + offsetTop);
          renderCtx.lineTo(endX + offsetLeft - 1, startY + offsetTop + ps_h);
          renderCtx.fillStyle = "#FC6666";
          renderCtx.fill();
          renderCtx.closePath();
        }
        var cellOverflow_colInObj = this.cellOverflow_colIn(cellOverflowMap, r2, c2, colStart, colEnd);
        if (cellOverflow_colInObj.colLast && !_$1.isNil(cellOverflow_colInObj.rowIndex) && !_$1.isNil(cellOverflow_colInObj.colIndex) && !_$1.isNil(cellOverflow_colInObj.stc) && !_$1.isNil(cellOverflow_colInObj.edc)) {
          this.cellOverflowRender(cellOverflow_colInObj.rowIndex, cellOverflow_colInObj.colIndex, cellOverflow_colInObj.stc, cellOverflow_colInObj.edc, renderCtx, scrollHeight, scrollWidth, offsetLeft, offsetTop, afCompute, cfCompute);
        }
        if (!cellOverflow_colInObj.colIn || cellOverflow_colInObj.colLast) {
          if (!this.sheetCtx.luckysheetcurrentisPivotTable && this.sheetCtx.showGridLines) {
            renderCtx.beginPath();
            renderCtx.moveTo(endX + offsetLeft - 2 + bodrder05, startY + offsetTop);
            renderCtx.lineTo(endX + offsetLeft - 2 + bodrder05, endY + offsetTop);
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = defaultStyle.strokeStyle;
            renderCtx.stroke();
            renderCtx.closePath();
          }
        }
        if (!this.sheetCtx.luckysheetcurrentisPivotTable && this.sheetCtx.showGridLines) {
          renderCtx.beginPath();
          renderCtx.moveTo(startX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
          renderCtx.lineTo(endX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
          renderCtx.lineWidth = 1;
          renderCtx.strokeStyle = defaultStyle.strokeStyle;
          renderCtx.stroke();
          renderCtx.closePath();
        }
        (_this$sheetCtx$hooks$7 = (_this$sheetCtx$hooks7 = this.sheetCtx.hooks).afterRenderCell) === null || _this$sheetCtx$hooks$7 === void 0 ? void 0 : _this$sheetCtx$hooks$7.call(_this$sheetCtx$hooks7, flowdata[r2][c2], {
          row: r2,
          column: c2,
          startY: cellsize[1],
          startX: cellsize[0],
          endY: cellsize[3] + cellsize[1],
          endX: cellsize[2] + cellsize[0]
        }, renderCtx);
      }
    }, {
      key: "cellRender",
      value: function cellRender(r2, c2, startY, startX, endY, endX, value, renderCtx, afCompute, cfCompute, offsetLeft, offsetTop, dynamicArrayCompute, cellOverflowMap, colStart, colEnd, scrollHeight, scrollWidth, bodrder05) {
        var _this$sheetCtx$hooks$8, _this$sheetCtx$hooks8, _dataVerification$, _this$sheetCtx$hooks$9, _this$sheetCtx$hooks9, _flowdata$r3;
        var isMerge = arguments.length > 19 && arguments[19] !== void 0 ? arguments[19] : false;
        var flowdata = getFlowdata(this.sheetCtx);
        if (!flowdata) {
          return;
        }
        var cell = flowdata[r2][c2];
        var cellWidth = endX - startX - 2;
        var cellHeight = endY - startY - 2;
        var space_width = 2;
        var space_height = 2;
        var horizonAlign = Number(normalizedAttr(flowdata, r2, c2, "ht"));
        var verticalAlign = Number(normalizedAttr(flowdata, r2, c2, "vt"));
        var checksCF = checkCF(r2, c2, cfCompute);
        var fillStyle = normalizedAttr(flowdata, r2, c2, "bg");
        if (!_$1.isNil(checksCF) && !_$1.isNil(checksCF.cellColor)) {
          fillStyle = checksCF.cellColor;
        }
        if (!fillStyle) {
          renderCtx.fillStyle = "#FFFFFF";
        } else {
          renderCtx.fillStyle = fillStyle;
        }
        var borderfix = getBorderFix();
        var cellsize = [startX + offsetLeft + borderfix[0], startY + offsetTop + borderfix[1], endX - startX + borderfix[2] - (isMerge ? 1 : 0), endY - startY + borderfix[3]];
        if (((_this$sheetCtx$hooks$8 = (_this$sheetCtx$hooks8 = this.sheetCtx.hooks).beforeRenderCell) === null || _this$sheetCtx$hooks$8 === void 0 ? void 0 : _this$sheetCtx$hooks$8.call(_this$sheetCtx$hooks8, flowdata[r2][c2], {
          row: r2,
          column: c2,
          startY: cellsize[1],
          startX: cellsize[0],
          endY: cellsize[3] + cellsize[1],
          endX: cellsize[2] + cellsize[0]
        }, renderCtx)) === false) {
          return;
        }
        renderCtx.fillRect(cellsize[0], cellsize[1], cellsize[2], cellsize[3]);
        var index2 = getSheetIndex(this.sheetCtx, this.sheetCtx.currentSheetId);
        var dataVerification = this.sheetCtx.luckysheetfile[index2].dataVerification;
        if ((dataVerification === null || dataVerification === void 0 ? void 0 : dataVerification["".concat(r2, "_").concat(c2)]) && !validateCellData(this.sheetCtx, dataVerification["".concat(r2, "_").concat(c2)], value)) {
          var dv_w = 5 * this.sheetCtx.zoomRatio;
          var dv_h = 5 * this.sheetCtx.zoomRatio;
          renderCtx.beginPath();
          renderCtx.moveTo(startX + offsetLeft, startY + offsetTop);
          renderCtx.lineTo(startX + offsetLeft + dv_w, startY + offsetTop);
          renderCtx.lineTo(startX + offsetLeft, startY + offsetTop + dv_h);
          renderCtx.fillStyle = "#FC6666";
          renderCtx.fill();
          renderCtx.closePath();
        }
        if (cell === null || cell === void 0 ? void 0 : cell.ps) {
          var ps_w = 8 * this.sheetCtx.zoomRatio;
          var ps_h = 8 * this.sheetCtx.zoomRatio;
          renderCtx.beginPath();
          renderCtx.moveTo(endX + offsetLeft - ps_w, startY + offsetTop);
          renderCtx.lineTo(endX + offsetLeft, startY + offsetTop);
          renderCtx.lineTo(endX + offsetLeft, startY + offsetTop + ps_h);
          renderCtx.fillStyle = "#FC6666";
          renderCtx.fill();
          renderCtx.closePath();
        }
        if ((cell === null || cell === void 0 ? void 0 : cell.qp) === 1 && isRealNum$1(cell === null || cell === void 0 ? void 0 : cell.v)) {
          var _ps_w = 6 * this.sheetCtx.zoomRatio;
          var _ps_h = 6 * this.sheetCtx.zoomRatio;
          renderCtx.beginPath();
          renderCtx.moveTo(startX + offsetLeft + _ps_w - 1, startY + offsetTop);
          renderCtx.lineTo(startX + offsetLeft - 1, startY + offsetTop);
          renderCtx.lineTo(startX + offsetLeft - 1, startY + offsetTop + _ps_h);
          renderCtx.fillStyle = "#487f1e";
          renderCtx.fill();
          renderCtx.closePath();
        }
        var cellOverflow_bd_r_render = true;
        var cellOverflow_colInObj = this.cellOverflow_colIn(cellOverflowMap, r2, c2, colStart, colEnd);
        if ((cell === null || cell === void 0 ? void 0 : cell.tb) === "1" && cellOverflow_colInObj.colIn) {
          if (cellOverflow_colInObj.colLast && !_$1.isNil(cellOverflow_colInObj.rowIndex) && !_$1.isNil(cellOverflow_colInObj.colIndex) && !_$1.isNil(cellOverflow_colInObj.stc) && !_$1.isNil(cellOverflow_colInObj.edc)) {
            this.cellOverflowRender(cellOverflow_colInObj.rowIndex, cellOverflow_colInObj.colIndex, cellOverflow_colInObj.stc, cellOverflow_colInObj.edc, renderCtx, scrollHeight, scrollWidth, offsetLeft, offsetTop, afCompute, cfCompute);
          } else {
            cellOverflow_bd_r_render = false;
          }
        } else if ((dataVerification === null || dataVerification === void 0 ? void 0 : (_dataVerification$ = dataVerification["".concat(r2, "_").concat(c2)]) === null || _dataVerification$ === void 0 ? void 0 : _dataVerification$.type) === "checkbox") {
          var pos_x = startX + offsetLeft;
          var pos_y = startY + offsetTop + 1;
          renderCtx.save();
          renderCtx.beginPath();
          renderCtx.rect(pos_x, pos_y, cellWidth, cellHeight);
          renderCtx.clip();
          renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
          var measureText = getMeasureText(value, renderCtx, this.sheetCtx);
          var textMetrics = measureText.width + 14;
          var oneLineTextHeight = measureText.actualBoundingBoxDescent + measureText.actualBoundingBoxAscent;
          var horizonAlignPos = pos_x + space_width;
          if (horizonAlign === 0) {
            horizonAlignPos = pos_x + cellWidth / 2 - textMetrics / 2;
          } else if (horizonAlign === 2) {
            horizonAlignPos = pos_x + cellWidth - space_width - textMetrics;
          }
          var verticalCellHeight = cellHeight > oneLineTextHeight ? cellHeight : oneLineTextHeight;
          var verticalAlignPos_text = pos_y + verticalCellHeight - space_height;
          renderCtx.textBaseline = "bottom";
          var verticalAlignPos_checkbox = verticalAlignPos_text - 13 * this.sheetCtx.zoomRatio;
          if (verticalAlign === 0) {
            verticalAlignPos_text = pos_y + verticalCellHeight / 2;
            renderCtx.textBaseline = "middle";
            verticalAlignPos_checkbox = verticalAlignPos_text - 6 * this.sheetCtx.zoomRatio;
          } else if (verticalAlign === 1) {
            verticalAlignPos_text = pos_y + space_height;
            renderCtx.textBaseline = "top";
            verticalAlignPos_checkbox = verticalAlignPos_text + 1 * this.sheetCtx.zoomRatio;
          }
          horizonAlignPos /= this.sheetCtx.zoomRatio;
          verticalAlignPos_text /= this.sheetCtx.zoomRatio;
          verticalAlignPos_checkbox /= this.sheetCtx.zoomRatio;
          renderCtx.lineWidth = 1;
          renderCtx.strokeStyle = "#000";
          renderCtx.strokeRect(horizonAlignPos, verticalAlignPos_checkbox, 10, 10);
          if (dataVerification["".concat(r2, "_").concat(c2)].checked) {
            renderCtx.beginPath();
            renderCtx.lineTo(horizonAlignPos + 1, verticalAlignPos_checkbox + 6);
            renderCtx.lineTo(horizonAlignPos + 4, verticalAlignPos_checkbox + 9);
            renderCtx.lineTo(horizonAlignPos + 9, verticalAlignPos_checkbox + 2);
            renderCtx.stroke();
            renderCtx.closePath();
          }
          renderCtx.fillStyle = normalizedAttr(flowdata, r2, c2, "fc");
          renderCtx.fillText(_$1.isNil(value) ? "" : value, horizonAlignPos + 14, verticalAlignPos_text);
          renderCtx.restore();
        } else {
          var _checksCF$dataBar, _checksCF$dataBar2, _checksCF$dataBar2$va, _cell$ct$fa$indexOf, _cell$ct, _cell$ct$fa, _cell$ct2;
          if ((checksCF === null || checksCF === void 0 ? void 0 : (_checksCF$dataBar = checksCF.dataBar) === null || _checksCF$dataBar === void 0 ? void 0 : _checksCF$dataBar.valueLen) && (checksCF === null || checksCF === void 0 ? void 0 : (_checksCF$dataBar2 = checksCF.dataBar) === null || _checksCF$dataBar2 === void 0 ? void 0 : (_checksCF$dataBar2$va = _checksCF$dataBar2.valueLen) === null || _checksCF$dataBar2$va === void 0 ? void 0 : _checksCF$dataBar2$va.toString()) !== "NaN") {
            var x2 = startX + offsetLeft + space_width;
            var y2 = startY + offsetTop + space_height;
            var w2 = cellWidth - space_width * 2;
            var h2 = cellHeight - space_height * 2;
            var valueType = checksCF.dataBar.valueType;
            var valueLen = checksCF.dataBar.valueLen;
            var format = checksCF.dataBar.format;
            if (valueType === "minus") {
              var minusLen = checksCF.dataBar.minusLen;
              if (format.length > 1) {
                var my_gradient = renderCtx.createLinearGradient(x2 + w2 * minusLen * (1 - valueLen), y2, x2 + w2 * minusLen, y2);
                my_gradient.addColorStop(0, "#ffffff");
                my_gradient.addColorStop(1, "#ff0000");
                renderCtx.fillStyle = my_gradient;
              } else {
                renderCtx.fillStyle = "#ff0000";
              }
              renderCtx.fillRect(x2 + w2 * minusLen * (1 - valueLen), y2, w2 * minusLen * valueLen, h2);
              renderCtx.beginPath();
              renderCtx.moveTo(x2 + w2 * minusLen * (1 - valueLen), y2);
              renderCtx.lineTo(x2 + w2 * minusLen * (1 - valueLen), y2 + h2);
              renderCtx.lineTo(x2 + w2 * minusLen, y2 + h2);
              renderCtx.lineTo(x2 + w2 * minusLen, y2);
              renderCtx.lineTo(x2 + w2 * minusLen * (1 - valueLen), y2);
              renderCtx.lineWidth = 1;
              renderCtx.strokeStyle = "#ff0000";
              renderCtx.stroke();
              renderCtx.closePath();
            } else if (valueType === "plus") {
              var plusLen = checksCF.dataBar.plusLen;
              if (plusLen === 1) {
                if (format.length > 1) {
                  var _my_gradient = renderCtx.createLinearGradient(x2, y2, x2 + w2 * valueLen, y2);
                  _my_gradient.addColorStop(0, format[0]);
                  _my_gradient.addColorStop(1, format[1]);
                  renderCtx.fillStyle = _my_gradient;
                } else {
                  var _format = _slicedToArray$1(format, 1);
                  renderCtx.fillStyle = _format[0];
                }
                renderCtx.fillRect(x2, y2, w2 * valueLen, h2);
                renderCtx.beginPath();
                renderCtx.moveTo(x2, y2);
                renderCtx.lineTo(x2, y2 + h2);
                renderCtx.lineTo(x2 + w2 * valueLen, y2 + h2);
                renderCtx.lineTo(x2 + w2 * valueLen, y2);
                renderCtx.lineTo(x2, y2);
                renderCtx.lineWidth = 1;
                var _format2 = _slicedToArray$1(format, 1);
                renderCtx.strokeStyle = _format2[0];
                renderCtx.stroke();
                renderCtx.closePath();
              } else {
                var _minusLen = checksCF.dataBar.minusLen;
                if (format.length > 1) {
                  var _my_gradient2 = renderCtx.createLinearGradient(x2 + w2 * _minusLen, y2, x2 + w2 * _minusLen + w2 * plusLen * valueLen, y2);
                  _my_gradient2.addColorStop(0, format[0]);
                  _my_gradient2.addColorStop(1, format[1]);
                  renderCtx.fillStyle = _my_gradient2;
                } else {
                  var _format3 = _slicedToArray$1(format, 1);
                  renderCtx.fillStyle = _format3[0];
                }
                renderCtx.fillRect(x2 + w2 * _minusLen, y2, w2 * plusLen * valueLen, h2);
                renderCtx.beginPath();
                renderCtx.moveTo(x2 + w2 * _minusLen, y2);
                renderCtx.lineTo(x2 + w2 * _minusLen, y2 + h2);
                renderCtx.lineTo(x2 + w2 * _minusLen + w2 * plusLen * valueLen, y2 + h2);
                renderCtx.lineTo(x2 + w2 * _minusLen + w2 * plusLen * valueLen, y2);
                renderCtx.lineTo(x2 + w2 * _minusLen, y2);
                renderCtx.lineWidth = 1;
                var _format4 = _slicedToArray$1(format, 1);
                renderCtx.strokeStyle = _format4[0];
                renderCtx.stroke();
                renderCtx.closePath();
              }
            }
          }
          var _pos_x = startX + offsetLeft;
          var _pos_y = startY + offsetTop + 1;
          renderCtx.save();
          renderCtx.beginPath();
          renderCtx.rect(_pos_x, _pos_y, cellWidth, cellHeight);
          renderCtx.clip();
          renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
          var textInfo = cell ? getCellTextInfo(cell, renderCtx, this.sheetCtx, {
            cellWidth,
            cellHeight,
            space_width,
            space_height,
            r: r2,
            c: c2
          }, this.sheetCtx) : void 0;
          if ((checksCF === null || checksCF === void 0 ? void 0 : checksCF.icons) && textInfo.type === "plain") {
            var l2 = checksCF.icons.left;
            var t2 = checksCF.icons.top;
            var _value = textInfo.values[0];
            var verticalAlignPos = _pos_y + _value.top - textInfo.textHeightAll;
            if (verticalAlign === 0) {
              verticalAlignPos = _pos_y + cellHeight / 2 - textInfo.textHeightAll / 2;
            } else if (verticalAlign === 1) {
              verticalAlignPos = _pos_y;
            } else if (verticalAlign === 2) {
              verticalAlignPos -= textInfo.desc;
            }
            verticalAlignPos /= this.sheetCtx.zoomRatio;
            renderCtx.drawImage(getCfIconsImg(), l2 * 42, t2 * 32, 32, 32, _pos_x / this.sheetCtx.zoomRatio, verticalAlignPos, textInfo.textHeightAll / this.sheetCtx.zoomRatio, textInfo.textHeightAll / this.sheetCtx.zoomRatio);
          }
          renderCtx.fillStyle = normalizedAttr(flowdata, r2, c2, "fc");
          if (checksCF === null || checksCF === void 0 ? void 0 : checksCF.textColor) {
            renderCtx.fillStyle = checksCF.textColor;
          }
          if (((_cell$ct$fa$indexOf = cell === null || cell === void 0 ? void 0 : (_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : (_cell$ct$fa = _cell$ct.fa) === null || _cell$ct$fa === void 0 ? void 0 : _cell$ct$fa.indexOf("[Red]")) !== null && _cell$ct$fa$indexOf !== void 0 ? _cell$ct$fa$indexOf : -1) > -1 && (cell === null || cell === void 0 ? void 0 : (_cell$ct2 = cell.ct) === null || _cell$ct2 === void 0 ? void 0 : _cell$ct2.t) === "n" && (cell === null || cell === void 0 ? void 0 : cell.v) < 0) {
            renderCtx.fillStyle = "#ff0000";
          }
          this.cellTextRender(textInfo, renderCtx, {
            pos_x: _pos_x,
            pos_y: _pos_y
          });
          renderCtx.restore();
        }
        if (cellOverflow_bd_r_render) {
          if (!this.sheetCtx.luckysheetcurrentisPivotTable && this.sheetCtx.showGridLines) {
            renderCtx.beginPath();
            renderCtx.moveTo(endX + offsetLeft - 2 + bodrder05, startY + offsetTop);
            renderCtx.lineTo(endX + offsetLeft - 2 + bodrder05, endY + offsetTop);
            renderCtx.lineWidth = 1;
            renderCtx.strokeStyle = defaultStyle.strokeStyle;
            renderCtx.stroke();
            renderCtx.closePath();
          }
        }
        if (!this.sheetCtx.luckysheetcurrentisPivotTable && this.sheetCtx.showGridLines) {
          renderCtx.beginPath();
          renderCtx.moveTo(startX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
          renderCtx.lineTo(endX + offsetLeft - 1, endY + offsetTop - 2 + bodrder05);
          renderCtx.lineWidth = 1;
          renderCtx.strokeStyle = defaultStyle.strokeStyle;
          renderCtx.stroke();
          renderCtx.closePath();
        }
        (_this$sheetCtx$hooks$9 = (_this$sheetCtx$hooks9 = this.sheetCtx.hooks).afterRenderCell) === null || _this$sheetCtx$hooks$9 === void 0 ? void 0 : _this$sheetCtx$hooks$9.call(_this$sheetCtx$hooks9, (_flowdata$r3 = flowdata[r2]) === null || _flowdata$r3 === void 0 ? void 0 : _flowdata$r3[c2], {
          row: r2,
          column: c2,
          startX: cellsize[0],
          startY: cellsize[1],
          endX: cellsize[2] + cellsize[0],
          endY: cellsize[3] + cellsize[1]
        }, renderCtx);
      }
    }, {
      key: "cellOverflowRender",
      value: function cellOverflowRender(r2, c2, stc, edc, renderCtx, scrollHeight, scrollWidth, offsetLeft, offsetTop, afCompute, cfCompute) {
        var startY;
        if (r2 === 0) {
          startY = -scrollHeight - 1;
        } else {
          startY = this.sheetCtx.visibledatarow[r2 - 1] - scrollHeight - 1;
        }
        var endY = this.sheetCtx.visibledatarow[r2] - scrollHeight;
        var startX;
        if (stc === 0) {
          startX = -scrollWidth;
        } else {
          startX = this.sheetCtx.visibledatacolumn[stc - 1] - scrollWidth;
        }
        var endX = this.sheetCtx.visibledatacolumn[edc] - scrollWidth;
        var flowdata = getFlowdata(this.sheetCtx);
        if (!flowdata) {
          return;
        }
        var cell = flowdata[r2][c2];
        var cellWidth = endX - startX - 2;
        var cellHeight = endY - startY - 2;
        var space_width = 2;
        var space_height = 2;
        var pos_x = startX + offsetLeft;
        var pos_y = startY + offsetTop + 1;
        var fontset = getFontSet(cell, this.sheetCtx.defaultFontSize, this.sheetCtx);
        renderCtx.font = fontset;
        renderCtx.save();
        renderCtx.beginPath();
        renderCtx.rect(pos_x, pos_y, cellWidth, cellHeight);
        renderCtx.clip();
        renderCtx.scale(this.sheetCtx.zoomRatio, this.sheetCtx.zoomRatio);
        var textInfo = cell ? getCellTextInfo(cell, renderCtx, this.sheetCtx, {
          cellWidth,
          cellHeight,
          space_width,
          space_height,
          r: r2,
          c: c2
        }, this.sheetCtx) : void 0;
        var checksCF = checkCF(r2, c2, cfCompute);
        renderCtx.fillStyle = normalizedAttr(flowdata, r2, c2, "fc");
        if (checksCF === null || checksCF === void 0 ? void 0 : checksCF.textColor) {
          renderCtx.fillStyle = checksCF.textColor;
        }
        this.cellTextRender(textInfo, renderCtx, {
          pos_x,
          pos_y
        });
        renderCtx.restore();
      }
    }, {
      key: "cellOverflow_trace",
      value: function cellOverflow_trace(r2, curC, traceC, traceDir, horizonAlign, textMetrics) {
        var flowdata = getFlowdata(this.sheetCtx);
        if (!flowdata) return {};
        var data = flowdata;
        if (traceDir === "forward" && traceC < 0) {
          return {
            success: false,
            r: r2,
            c: traceC
          };
        }
        if (traceDir === "backward" && traceC > data[r2].length - 1) {
          return {
            success: false,
            r: r2,
            c: traceC
          };
        }
        var cell = data[r2][traceC];
        if (cell && (!_$1.isEmpty(cell.v) || cell.mc)) {
          return {
            success: false,
            r: r2,
            c: traceC
          };
        }
        var start_curC = curC - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[curC - 1];
        var end_curC = this.sheetCtx.visibledatacolumn[curC];
        var w2 = textMetrics - (end_curC - start_curC);
        if (horizonAlign === "0") {
          start_curC -= w2 / 2;
          end_curC += w2 / 2;
        } else if (horizonAlign === "1") {
          end_curC += w2;
        } else if (horizonAlign === "2") {
          start_curC -= w2;
        }
        var start_traceC = traceC - 1 < 0 ? 0 : this.sheetCtx.visibledatacolumn[traceC - 1];
        var end_traceC = this.sheetCtx.visibledatacolumn[traceC];
        if (traceDir === "forward") {
          if (start_curC < start_traceC) {
            return this.cellOverflow_trace(r2, curC, traceC - 1, traceDir, horizonAlign, textMetrics);
          }
          if (start_curC < end_traceC) {
            return {
              success: true,
              r: r2,
              c: traceC
            };
          }
          return {
            success: false,
            r: r2,
            c: traceC
          };
        }
        if (traceDir === "backward") {
          if (end_curC > end_traceC) {
            return this.cellOverflow_trace(r2, curC, traceC + 1, traceDir, horizonAlign, textMetrics);
          }
          if (end_curC > start_traceC) {
            return {
              success: true,
              r: r2,
              c: traceC
            };
          }
          return {
            success: false,
            r: r2,
            c: traceC
          };
        }
        return null;
      }
    }, {
      key: "cellOverflow_colIn",
      value: function cellOverflow_colIn(map, r2, c2, col_st, col_ed) {
        var colIn = false;
        var colLast = false;
        var rowIndex;
        var colIndex;
        var stc;
        var edc;
        _$1.forEach(map, function(row, rkey) {
          _$1.forEach(row, function(mapItem, ckey) {
            rowIndex = Number(rkey);
            colIndex = Number(ckey);
            stc = mapItem.stc;
            edc = mapItem.edc;
            if (rowIndex === r2) {
              if (c2 >= stc && c2 <= edc) {
                colIn = true;
                if (c2 === edc || c2 === col_ed) {
                  colLast = true;
                  return false;
                }
              }
            }
            return true;
          });
          return !colLast;
        });
        return {
          colIn,
          colLast,
          rowIndex,
          colIndex,
          stc,
          edc
        };
      }
    }, {
      key: "cellTextRender",
      value: function cellTextRender(textInfo, ctx, option) {
        if (!textInfo) {
          return;
        }
        var values = textInfo.values;
        var pos_x = option.pos_x;
        var pos_y = option.pos_y;
        if (!values) {
          return;
        }
        if (textInfo.rotate !== 0 && textInfo.type !== "verticalWrap") {
          ctx.save();
          ctx.translate((pos_x + textInfo.textLeftAll) / this.sheetCtx.zoomRatio, (pos_y + textInfo.textTopAll) / this.sheetCtx.zoomRatio);
          ctx.rotate(-textInfo.rotate * Math.PI / 180);
          ctx.translate(-(textInfo.textLeftAll + pos_x) / this.sheetCtx.zoomRatio, -(pos_y + textInfo.textTopAll) / this.sheetCtx.zoomRatio);
        }
        for (var i2 = 0; i2 < values.length; i2 += 1) {
          var word = values[i2];
          if (word.inline === true && word.style) {
            ctx.font = word.style.fontset;
            ctx.fillStyle = word.style.fc;
          } else {
            ctx.font = word.style;
          }
          var txt = _$1.isPlainObject(word.content) ? word.content.m : word.content;
          ctx.fillText(txt, (pos_x + word.left) / this.sheetCtx.zoomRatio, (pos_y + word.top) / this.sheetCtx.zoomRatio);
          if (word.cancelLine) {
            var c2 = word.cancelLine;
            ctx.beginPath();
            ctx.moveTo(Math.floor((pos_x + c2.startX) / this.sheetCtx.zoomRatio) + 0.5, Math.floor((pos_y + c2.startY) / this.sheetCtx.zoomRatio) + 0.5);
            ctx.lineTo(Math.floor((pos_x + c2.endX) / this.sheetCtx.zoomRatio) + 0.5, Math.floor((pos_y + c2.endY) / this.sheetCtx.zoomRatio) + 0.5);
            ctx.lineWidth = Math.floor(c2.fs / 9);
            ctx.strokeStyle = ctx.fillStyle;
            ctx.stroke();
            ctx.closePath();
          }
          if (word.underLine) {
            var underLines = word.underLine;
            for (var a2 = 0; a2 < underLines.length; a2 += 1) {
              var item = underLines[a2];
              ctx.beginPath();
              ctx.moveTo(Math.floor((pos_x + item.startX) / this.sheetCtx.zoomRatio) + 0.5, Math.floor((pos_y + item.startY) / this.sheetCtx.zoomRatio));
              ctx.lineTo(Math.floor((pos_x + item.endX) / this.sheetCtx.zoomRatio) + 0.5, Math.floor((pos_y + item.endY) / this.sheetCtx.zoomRatio) + 0.5);
              ctx.lineWidth = Math.floor(item.fs / 9);
              ctx.strokeStyle = ctx.fillStyle;
              ctx.stroke();
              ctx.closePath();
            }
          }
        }
        if (textInfo.rotate !== 0 && textInfo.type !== "verticalWrap") {
          ctx.restore();
        }
      }
    }, {
      key: "drawFreezeLine",
      value: function drawFreezeLine(_ref2) {
        var horizontalTop = _ref2.horizontalTop, verticalLeft = _ref2.verticalLeft;
        var renderCtx = this.canvasElement.getContext("2d");
        if (!renderCtx) return;
        renderCtx.save();
        renderCtx.scale(this.sheetCtx.devicePixelRatio, this.sheetCtx.devicePixelRatio);
        renderCtx.strokeStyle = "#ccc";
        renderCtx.lineWidth = 2;
        if (horizontalTop) {
          renderCtx.beginPath();
          renderCtx.moveTo(0, horizontalTop);
          renderCtx.lineTo(this.canvasElement.width, horizontalTop);
          renderCtx.stroke();
          renderCtx.closePath();
        }
        if (verticalLeft) {
          renderCtx.beginPath();
          renderCtx.moveTo(verticalLeft, 0);
          renderCtx.lineTo(verticalLeft, this.canvasElement.height);
          renderCtx.stroke();
          renderCtx.closePath();
        }
        renderCtx.restore();
      }
    }]);
    return Canvas2;
  }();
  function handleScreenShot(ctx) {
    if (ctx.luckysheet_select_save == null) return void 0;
    if (ctx.luckysheet_select_save.length === 0) {
      return void 0;
    }
    if (ctx.luckysheet_select_save.length > 1) {
      return void 0;
    }
    if (ctx.config.merge != null) {
      var has_PartMC = false;
      for (var s2 = 0; s2 < ctx.luckysheet_select_save.length; s2 += 1) {
        var r1 = ctx.luckysheet_select_save[s2].row[0];
        var r2 = ctx.luckysheet_select_save[s2].row[1];
        var c1 = ctx.luckysheet_select_save[s2].column[0];
        var c2 = ctx.luckysheet_select_save[s2].column[1];
        has_PartMC = hasPartMC(ctx, ctx.config, r1, r2, c1, c2);
        if (has_PartMC) {
          break;
        }
      }
      if (has_PartMC) {
        return void 0;
      }
    }
    var st_r = ctx.luckysheet_select_save[0].row[0];
    var ed_r = ctx.luckysheet_select_save[0].row[1];
    var st_c = ctx.luckysheet_select_save[0].column[0];
    var ed_c = ctx.luckysheet_select_save[0].column[1];
    var scrollHeight;
    var rh_height;
    if (st_r - 1 < 0) {
      scrollHeight = 0;
      rh_height = ctx.visibledatarow[ed_r];
    } else {
      scrollHeight = ctx.visibledatarow[st_r - 1];
      rh_height = ctx.visibledatarow[ed_r] - ctx.visibledatarow[st_r - 1];
    }
    var scrollWidth;
    var ch_width;
    if (st_c - 1 < 0) {
      scrollWidth = 0;
      ch_width = ctx.visibledatacolumn[ed_c];
    } else {
      scrollWidth = ctx.visibledatacolumn[st_c - 1];
      ch_width = ctx.visibledatacolumn[ed_c] - ctx.visibledatacolumn[st_c - 1];
    }
    var newCanvasElement = document.createElement("canvas");
    newCanvasElement.width = Math.ceil(ch_width * devicePixelRatio);
    newCanvasElement.height = Math.ceil(rh_height * devicePixelRatio);
    newCanvasElement.style.width = "".concat(ch_width, "px");
    newCanvasElement.style.height = "".concat(rh_height, "px");
    var newCanvas = new Canvas(newCanvasElement, ctx);
    newCanvas.drawMain({
      scrollWidth,
      scrollHeight,
      drawWidth: ch_width,
      drawHeight: rh_height,
      offsetLeft: 1,
      offsetTop: 1,
      clear: true
    });
    var ctx_newCanvas = newCanvasElement.getContext("2d");
    if (ctx_newCanvas == null) return void 0;
    ctx_newCanvas.beginPath();
    ctx_newCanvas.moveTo(0, 0);
    ctx_newCanvas.lineTo(0, ctx.devicePixelRatio * rh_height);
    ctx_newCanvas.lineWidth = ctx.devicePixelRatio * 2;
    ctx_newCanvas.strokeStyle = defaultStyle.strokeStyle;
    ctx_newCanvas.stroke();
    ctx_newCanvas.closePath();
    ctx_newCanvas.beginPath();
    ctx_newCanvas.moveTo(0, 0);
    ctx_newCanvas.lineTo(ctx.devicePixelRatio * ch_width, 0);
    ctx_newCanvas.lineWidth = ctx.devicePixelRatio * 2;
    ctx_newCanvas.strokeStyle = defaultStyle.strokeStyle;
    ctx_newCanvas.stroke();
    ctx_newCanvas.closePath();
    var image = new Image();
    var url = newCanvasElement.toDataURL("image/png");
    image.src = url;
    if (ch_width > rh_height) {
      image.style.width = "100%";
    } else {
      image.style.height = "100%";
    }
    newCanvasElement.remove();
    return image.src;
  }
  function getSearchIndexArr(searchText, range, flowdata) {
    var _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      regCheck: false,
      wordCheck: false,
      caseCheck: false
    }, regCheck = _ref.regCheck, wordCheck = _ref.wordCheck, caseCheck = _ref.caseCheck;
    var arr = [];
    var obj = {};
    for (var s2 = 0; s2 < range.length; s2 += 1) {
      var r1 = range[s2].row[0];
      var r2 = range[s2].row[1];
      var c1 = range[s2].column[0];
      var c2 = range[s2].column[1];
      for (var r3 = r1; r3 <= r2; r3 += 1) {
        for (var c3 = c1; c3 <= c2; c3 += 1) {
          var cell = flowdata[r3][c3];
          if (cell != null) {
            var value = valueShowEs(r3, c3, flowdata);
            if (value === 0) {
              value = value.toString();
            }
            if (value != null && value !== "") {
              value = value.toString();
              if (wordCheck) {
                if (caseCheck) {
                  if (searchText === value) {
                    if (!("".concat(r3, "_").concat(c3) in obj)) {
                      _$1.set(obj, "".concat(r3, "_").concat(c3), 0);
                      arr.push({
                        r: r3,
                        c: c3
                      });
                    }
                  }
                } else {
                  var txt = searchText.toLowerCase();
                  if (txt === value.toLowerCase()) {
                    if (!("".concat(r3, "_").concat(c3) in obj)) {
                      _$1.set(obj, "".concat(r3, "_").concat(c3), 0);
                      arr.push({
                        r: r3,
                        c: c3
                      });
                    }
                  }
                }
              } else if (regCheck) {
                var reg = void 0;
                if (caseCheck) {
                  reg = new RegExp(getRegExpStr(searchText), "g");
                } else {
                  reg = new RegExp(getRegExpStr(searchText), "ig");
                }
                if (reg.test(value)) {
                  if (!("".concat(r3, "_").concat(c3) in obj)) {
                    _$1.set(obj, "".concat(r3, "_").concat(c3), 0);
                    arr.push({
                      r: r3,
                      c: c3
                    });
                  }
                }
              } else {
                if (caseCheck) {
                  if (~value.indexOf(searchText)) {
                    if (!("".concat(r3, "_").concat(c3) in obj)) {
                      _$1.set(obj, "".concat(r3, "_").concat(c3), 0);
                      arr.push({
                        r: r3,
                        c: c3
                      });
                    }
                  }
                } else {
                  if (~value.toLowerCase().indexOf(searchText.toLowerCase())) {
                    if (!("".concat(r3, "_").concat(c3) in obj)) {
                      _$1.set(obj, "".concat(r3, "_").concat(c3), 0);
                      arr.push({
                        r: r3,
                        c: c3
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return arr;
  }
  function searchNext(ctx, searchText, checkModes) {
    var _ctx$luckysheet_selec, _ctx$luckysheet_selec2;
    var _locale = locale(ctx), findAndReplace = _locale.findAndReplace;
    var flowdata = getFlowdata(ctx);
    if (searchText === "" || searchText == null || flowdata == null) {
      return findAndReplace.searchInputTip;
    }
    var range;
    if (_$1.size(ctx.luckysheet_select_save) === 0 || ((_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      range = [{
        row: [0, flowdata.length - 1],
        column: [0, flowdata[0].length - 1],
        row_focus: 0,
        column_focus: 0
      }];
    } else {
      range = _$1.assign([], ctx.luckysheet_select_save);
    }
    var searchIndexArr = getSearchIndexArr(searchText, range, flowdata, checkModes);
    if (searchIndexArr.length === 0) {
      return findAndReplace.noFindTip;
    }
    var count = 0;
    if (_$1.size(ctx.luckysheet_select_save) === 0 || ((_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      if (_$1.size(ctx.luckysheet_select_save) === 0) {
        count = 0;
      } else {
        for (var i2 = 0; i2 < searchIndexArr.length; i2 += 1) {
          if (searchIndexArr[i2].r === ctx.luckysheet_select_save[0].row[0] && searchIndexArr[i2].c === ctx.luckysheet_select_save[0].column[0]) {
            if (i2 === searchIndexArr.length - 1) {
              count = 0;
            } else {
              count = i2 + 1;
            }
            break;
          }
        }
      }
      ctx.luckysheet_select_save = normalizeSelection(ctx, [{
        row: [searchIndexArr[count].r, searchIndexArr[count].r],
        column: [searchIndexArr[count].c, searchIndexArr[count].c]
      }]);
    } else {
      var rf2 = range[range.length - 1].row_focus;
      var cf2 = range[range.length - 1].column_focus;
      for (var _i = 0; _i < searchIndexArr.length; _i += 1) {
        if (searchIndexArr[_i].r === rf2 && searchIndexArr[_i].c === cf2) {
          if (_i === searchIndexArr.length - 1) {
            count = 0;
          } else {
            count = _i + 1;
          }
          break;
        }
      }
      for (var s2 = 0; s2 < range.length; s2 += 1) {
        var r1 = range[s2].row[0];
        var r2 = range[s2].row[1];
        var c1 = range[s2].column[0];
        var c2 = range[s2].column[1];
        if (searchIndexArr[count].r >= r1 && searchIndexArr[count].r <= r2 && searchIndexArr[count].c >= c1 && searchIndexArr[count].c <= c2) {
          var obj = range[s2];
          obj.row_focus = searchIndexArr[count].r;
          obj.column_focus = searchIndexArr[count].c;
          range.splice(s2, 1);
          range.push(obj);
          break;
        }
      }
      ctx.luckysheet_select_save = range;
    }
    scrollToHighlightCell(ctx, searchIndexArr[count].r, searchIndexArr[count].c);
    return null;
  }
  function searchAll(ctx, searchText, checkModes) {
    var _ctx$luckysheet_selec3;
    var flowdata = getFlowdata(ctx);
    var searchResult = [];
    if (searchText === "" || searchText == null || flowdata == null) {
      return searchResult;
    }
    var range;
    if (_$1.size(ctx.luckysheet_select_save) === 0 || ((_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      range = [{
        row: [0, flowdata.length - 1],
        column: [0, flowdata[0].length - 1]
      }];
    } else {
      range = _$1.assign([], ctx.luckysheet_select_save);
    }
    var searchIndexArr = getSearchIndexArr(searchText, range, flowdata, checkModes);
    if (searchIndexArr.length === 0) {
      return searchResult;
    }
    for (var i2 = 0; i2 < searchIndexArr.length; i2 += 1) {
      var _ctx$luckysheetfile;
      var value_ShowEs = valueShowEs(searchIndexArr[i2].r, searchIndexArr[i2].c, flowdata).toString();
      searchResult.push({
        r: searchIndexArr[i2].r,
        c: searchIndexArr[i2].c,
        sheetName: (_ctx$luckysheetfile = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId) || 0]) === null || _ctx$luckysheetfile === void 0 ? void 0 : _ctx$luckysheetfile.name,
        sheetId: ctx.currentSheetId,
        cellPosition: "".concat(chatatABC(searchIndexArr[i2].c)).concat(searchIndexArr[i2].r + 1),
        value: value_ShowEs
      });
    }
    ctx.luckysheet_select_save = normalizeSelection(ctx, [{
      row: [searchIndexArr[0].r, searchIndexArr[0].r],
      column: [searchIndexArr[0].c, searchIndexArr[0].c]
    }]);
    return searchResult;
  }
  function onSearchDialogMoveStart(globalCache, e, container) {
    var box = document.getElementById("fortune-search-replace");
    if (!box) return;
    var _box$getBoundingClien = box.getBoundingClientRect(), top = _box$getBoundingClien.top, left = _box$getBoundingClien.left, width = _box$getBoundingClien.width, height = _box$getBoundingClien.height;
    var rect = container.getBoundingClientRect();
    left -= rect.left;
    top -= rect.top;
    var initialPosition = {
      left,
      top,
      width,
      height
    };
    _$1.set(globalCache, "searchDialog.moveProps", {
      cursorMoveStartPosition: {
        x: e.pageX,
        y: e.pageY
      },
      initialPosition
    });
  }
  function onSearchDialogMove(globalCache, e) {
    var searchDialog = globalCache === null || globalCache === void 0 ? void 0 : globalCache.searchDialog;
    var moveProps = searchDialog === null || searchDialog === void 0 ? void 0 : searchDialog.moveProps;
    if (moveProps == null) return;
    var dialog = document.getElementById("fortune-search-replace");
    var _moveProps$cursorMove = moveProps.cursorMoveStartPosition, startX = _moveProps$cursorMove.x, startY = _moveProps$cursorMove.y;
    var _moveProps$initialPos = moveProps.initialPosition, top = _moveProps$initialPos.top, left = _moveProps$initialPos.left;
    left += e.pageX - startX;
    top += e.pageY - startY;
    if (top < 0) top = 0;
    dialog.style.left = "".concat(left, "px");
    dialog.style.top = "".concat(top, "px");
  }
  function onSearchDialogMoveEnd(globalCache) {
    _$1.set(globalCache, "searchDialog.moveProps", void 0);
  }
  function replace(ctx, searchText, replaceText, checkModes) {
    var _ctx$luckysheet_selec4, _ctx$luckysheet_selec5;
    var _locale2 = locale(ctx), findAndReplace = _locale2.findAndReplace;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) {
      return findAndReplace.modeTip;
    }
    var flowdata = getFlowdata(ctx);
    if (searchText === "" || searchText == null || flowdata == null) {
      return findAndReplace.searchInputTip;
    }
    var range;
    if (_$1.size(ctx.luckysheet_select_save) === 0 || ((_ctx$luckysheet_selec4 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec4 === void 0 ? void 0 : _ctx$luckysheet_selec4.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      range = [{
        row: [0, flowdata.length - 1],
        column: [0, flowdata[0].length - 1]
      }];
    } else {
      range = _$1.assign([], ctx.luckysheet_select_save);
    }
    var searchIndexArr = getSearchIndexArr(searchText, range, flowdata, checkModes);
    if (searchIndexArr.length === 0) {
      return findAndReplace.noReplceTip;
    }
    var count = null;
    var last = (_ctx$luckysheet_selec5 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec5 === void 0 ? void 0 : _ctx$luckysheet_selec5[ctx.luckysheet_select_save.length - 1];
    var rf2 = last === null || last === void 0 ? void 0 : last.row_focus;
    var cf2 = last === null || last === void 0 ? void 0 : last.column_focus;
    for (var i2 = 0; i2 < searchIndexArr.length; i2 += 1) {
      if (searchIndexArr[i2].r === rf2 && searchIndexArr[i2].c === cf2) {
        count = i2;
        break;
      }
    }
    if (count == null) {
      if (searchIndexArr.length === 0) {
        return findAndReplace.noMatchTip;
      }
      count = 0;
    }
    var d2 = flowdata;
    var r2;
    var c2;
    if (checkModes.wordCheck) {
      r2 = searchIndexArr[count].r;
      c2 = searchIndexArr[count].c;
      var v2 = replaceText;
      setCellValue(ctx, r2, c2, d2, v2);
    } else {
      var reg;
      if (checkModes.caseCheck) {
        reg = new RegExp(getRegExpStr(searchText), "g");
      } else {
        reg = new RegExp(getRegExpStr(searchText), "ig");
      }
      r2 = searchIndexArr[count].r;
      c2 = searchIndexArr[count].c;
      var _v = valueShowEs(r2, c2, d2).toString().replace(reg, replaceText);
      setCellValue(ctx, r2, c2, d2, _v);
    }
    ctx.luckysheet_select_save = normalizeSelection(ctx, [{
      row: [r2, r2],
      column: [c2, c2]
    }]);
    scrollToHighlightCell(ctx, r2, c2);
    return null;
  }
  function replaceAll(ctx, searchText, replaceText, checkModes) {
    var _ctx$luckysheet_selec6;
    var _locale3 = locale(ctx), findAndReplace = _locale3.findAndReplace;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) {
      return findAndReplace.modeTip;
    }
    var flowdata = getFlowdata(ctx);
    if (searchText === "" || searchText == null || flowdata == null) {
      return findAndReplace.searchInputTip;
    }
    var range;
    if (_$1.size(ctx.luckysheet_select_save) === 0 || ((_ctx$luckysheet_selec6 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec6 === void 0 ? void 0 : _ctx$luckysheet_selec6.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      range = [{
        row: [0, flowdata.length - 1],
        column: [0, flowdata[0].length - 1]
      }];
    } else {
      range = _$1.assign([], ctx.luckysheet_select_save);
    }
    var searchIndexArr = getSearchIndexArr(searchText, range, flowdata, checkModes);
    if (searchIndexArr.length === 0) {
      return findAndReplace.noReplceTip;
    }
    var d2 = flowdata;
    var replaceCount = 0;
    if (checkModes.wordCheck) {
      for (var i2 = 0; i2 < searchIndexArr.length; i2 += 1) {
        var r2 = searchIndexArr[i2].r;
        var c2 = searchIndexArr[i2].c;
        var v2 = replaceText;
        setCellValue(ctx, r2, c2, d2, v2);
        range.push({
          row: [r2, r2],
          column: [c2, c2]
        });
        replaceCount += 1;
      }
    } else {
      var reg;
      if (checkModes.caseCheck) {
        reg = new RegExp(getRegExpStr(searchText), "g");
      } else {
        reg = new RegExp(getRegExpStr(searchText), "ig");
      }
      for (var _i2 = 0; _i2 < searchIndexArr.length; _i2 += 1) {
        var _r = searchIndexArr[_i2].r;
        var _c = searchIndexArr[_i2].c;
        var _v2 = valueShowEs(_r, _c, d2).toString().replace(reg, replaceText);
        setCellValue(ctx, _r, _c, d2, _v2);
        range.push({
          row: [_r, _r],
          column: [_c, _c]
        });
        replaceCount += 1;
      }
    }
    ctx.luckysheet_select_save = normalizeSelection(ctx, range);
    var succeedInfo = replaceHtml(findAndReplace.successTip, {
      xlength: replaceCount
    });
    return succeedInfo;
  }
  function labelFilterOptionState(ctx, optionstate, rowhidden, caljs, str, edr, cindex, stc, edc, saveData) {
    var param = {
      caljs,
      rowhidden,
      optionstate,
      str,
      edr,
      cindex,
      stc,
      edc
    };
    if (optionstate) {
      ctx.filter[cindex - stc] = param;
    } else {
      delete ctx.filter[cindex - stc];
    }
    {
      var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
      if (sheetIndex == null) return;
      var file = ctx.luckysheetfile[sheetIndex];
      if (file.filter == null) {
        file.filter = {};
      }
      if (optionstate) {
        file.filter[cindex - stc] = param;
      } else {
        delete file.filter[cindex - stc];
      }
    }
  }
  function orderbydatafiler(ctx, str, stc, edr, edc, curr, asc) {
    var d2 = getFlowdata(ctx);
    if (d2 == null) {
      return null;
    }
    str += 1;
    var hasMc = false;
    var data = [];
    for (var r2 = str; r2 <= edr; r2 += 1) {
      var data_row = [];
      for (var c2 = stc; c2 <= edc; c2 += 1) {
        var _d$r$c;
        if (d2[r2][c2] != null && ((_d$r$c = d2[r2][c2]) === null || _d$r$c === void 0 ? void 0 : _d$r$c.mc) != null) {
          hasMc = true;
          break;
        }
        data_row.push(d2[r2][c2]);
      }
      data.push(data_row);
    }
    if (hasMc) {
      var _locale = locale(ctx), filter = _locale.filter;
      return filter.mergeError;
    }
    sortDataRange(ctx, d2, data, curr - stc, asc, str, edr, stc, edc);
    return null;
  }
  function createFilterOptions(ctx, luckysheet_filter_save, sheetId, filterObj, saveData) {
    var _ctx$visibledatarow$r, _ctx$visibledatarow, _ctx$visibledatacolum, _ctx$visibledatacolum2;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (sheetId != null && sheetId !== ctx.currentSheetId) return;
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (sheetIndex == null) return;
    if (luckysheet_filter_save == null || _$1.size(luckysheet_filter_save) === 0) {
      delete ctx.filterOptions;
      return;
    }
    var r1 = luckysheet_filter_save.row[0];
    var r2 = luckysheet_filter_save.row[1];
    var c1 = luckysheet_filter_save.column[0];
    var c2 = luckysheet_filter_save.column[1];
    var row = (_ctx$visibledatarow$r = ctx.visibledatarow[r2]) !== null && _ctx$visibledatarow$r !== void 0 ? _ctx$visibledatarow$r : 0;
    var row_pre = r1 - 1 === -1 ? 0 : (_ctx$visibledatarow = ctx.visibledatarow[r1 - 1]) !== null && _ctx$visibledatarow !== void 0 ? _ctx$visibledatarow : 0;
    var col = (_ctx$visibledatacolum = ctx.visibledatacolumn[c2]) !== null && _ctx$visibledatacolum !== void 0 ? _ctx$visibledatacolum : 0;
    var col_pre = c1 - 1 === -1 ? 0 : (_ctx$visibledatacolum2 = ctx.visibledatacolumn[c1 - 1]) !== null && _ctx$visibledatacolum2 !== void 0 ? _ctx$visibledatacolum2 : 0;
    var options = {
      startRow: r1,
      endRow: r2,
      startCol: c1,
      endCol: c2,
      left: col_pre,
      top: row_pre,
      width: col - col_pre - 1,
      height: row - row_pre - 1,
      items: []
    };
    for (var c3 = c1; c3 <= c2; c3 += 1) {
      if (filterObj == null || (filterObj === null || filterObj === void 0 ? void 0 : filterObj[c3 - c1]) == null) ;
      var left = 0;
      if (ctx.visibledatacolumn[c3]) {
        left = ctx.visibledatacolumn[c3] - 20;
      }
      options.items.push({
        col: c3,
        left,
        top: row_pre
      });
    }
    if (saveData) {
      var file = ctx.luckysheetfile[sheetIndex];
      file.filter_select = luckysheet_filter_save;
    }
    ctx.filterOptions = options;
  }
  function clearFilter(ctx) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    var hiddenRows = _$1.reduce(ctx.filter, function(pre, curr) {
      return _$1.assign(pre, (curr === null || curr === void 0 ? void 0 : curr.rowhidden) || {});
    }, {});
    ctx.config.rowhidden = _$1.omit(ctx.config.rowhidden, _$1.keys(hiddenRows));
    ctx.luckysheet_filter_save = void 0;
    ctx.filterOptions = void 0;
    ctx.filterContextMenu = void 0;
    ctx.filter = {};
    if (sheetIndex != null) {
      ctx.luckysheetfile[sheetIndex].filter = void 0;
      ctx.luckysheetfile[sheetIndex].filter_select = void 0;
      ctx.luckysheetfile[sheetIndex].config = _$1.assign({}, ctx.config);
    }
  }
  function createFilter(ctx) {
    var _ctx$luckysheet_selec, _filterSave, _ctx$luckysheet_selec2;
    if (_$1.size(ctx.luckysheet_select_save) > 1) {
      return;
    }
    if (_$1.size(ctx.luckysheet_filter_save) > 0) {
      clearFilter(ctx);
      return;
    }
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (sheetIndex == null || ctx.luckysheetfile[sheetIndex].isPivotTable) {
      return;
    }
    var last = (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec[0];
    var flowdata = getFlowdata(ctx);
    var filterSave;
    if (last == null || flowdata == null) return;
    if (last.row[0] === last.row[1] && last.column[0] === last.column[1]) {
      var st_c;
      var ed_c;
      var curR = last.row[1];
      for (var c2 = 0; c2 < flowdata[curR].length; c2 += 1) {
        var cell = flowdata[curR][c2];
        if (cell != null && !isRealNull(cell.v)) {
          if (st_c == null) {
            st_c = c2;
          }
        } else if (st_c != null) {
          ed_c = c2 - 1;
          break;
        }
      }
      if (ed_c == null) {
        ed_c = flowdata[curR].length - 1;
      }
      filterSave = normalizeSelection(ctx, [{
        row: [curR, curR],
        column: [st_c || 0, ed_c]
      }]);
      ctx.luckysheet_select_save = filterSave;
      ctx.luckysheet_shiftpositon = _$1.assign({}, last);
    } else if (last.row[1] - last.row[0] < 2) {
      ctx.luckysheet_shiftpositon = _$1.assign({}, last);
    }
    ctx.luckysheet_filter_save = _$1.assign({}, ((_filterSave = filterSave) === null || _filterSave === void 0 ? void 0 : _filterSave[0]) || ((_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2[0]));
    createFilterOptions(ctx, ctx.luckysheet_filter_save, void 0, {}, true);
  }
  function getFilterHiddenRows(ctx, col, startCol) {
    var _ctx$filter;
    var otherHiddenRows = _$1.reduce(ctx.filter, function(pre, curr) {
      return _$1.assign(pre, (curr === null || curr === void 0 ? void 0 : curr.cindex) !== col && (curr === null || curr === void 0 ? void 0 : curr.rowhidden) || {});
    }, {});
    var hiddenRows = ((_ctx$filter = ctx.filter[col - startCol]) === null || _ctx$filter === void 0 ? void 0 : _ctx$filter.rowhidden) || {};
    return {
      otherHiddenRows,
      hiddenRows
    };
  }
  function getFilterColumnValues(ctx, col, startRow, endRow, startCol) {
    var _getFilterHiddenRows = getFilterHiddenRows(ctx, col, startCol), otherHiddenRows = _getFilterHiddenRows.otherHiddenRows, hiddenRows = _getFilterHiddenRows.hiddenRows;
    var visibleRows = [];
    var flattenValues = [];
    var dates = [];
    var datesUncheck = [];
    var dateRowMap = {};
    var valuesMap = /* @__PURE__ */ new Map();
    var valuesUncheck = [];
    var valueRowMap = {};
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return {
      dates,
      datesUncheck,
      dateRowMap,
      values: [],
      valuesUncheck,
      valueRowMap,
      visibleRows,
      flattenValues
    };
    var cell;
    var _locale2 = locale(ctx), filter = _locale2.filter;
    for (var r2 = startRow + 1; r2 <= endRow; r2 += 1) {
      if (r2 in otherHiddenRows) {
        continue;
      }
      visibleRows.push(r2);
      cell = flowdata[r2][col];
      if (cell != null && !isRealNull(cell.v) && cell.ct != null && cell.ct.t === "d") {
        (function() {
          var dateStr = update("YYYY-MM-DD", cell.v);
          var y2 = dateStr.split("-")[0];
          var m2 = dateStr.split("-")[1];
          var d2 = dateStr.split("-")[2];
          var yearValue = _$1.find(dates, function(v2) {
            return v2.value === y2;
          });
          if (yearValue == null) {
            yearValue = {
              key: y2,
              type: "year",
              value: y2,
              text: y2 + filter.filiterYearText,
              children: [],
              rows: [],
              dateValues: []
            };
            dates.push(yearValue);
            flattenValues.push(dateStr);
          }
          var monthValue = _$1.find(yearValue.children, function(v2) {
            return v2.value === m2;
          });
          if (monthValue == null) {
            monthValue = {
              key: "".concat(y2, "-").concat(m2),
              type: "month",
              value: m2,
              text: m2 + filter.filiterMonthText,
              children: [],
              rows: [],
              dateValues: []
            };
            yearValue.children.push(monthValue);
          }
          var dayValue = _$1.find(monthValue.children, function(v2) {
            return v2.value === d2;
          });
          if (dayValue == null) {
            dayValue = {
              key: dateStr,
              type: "day",
              value: d2,
              text: d2,
              children: [],
              rows: [],
              dateValues: []
            };
            monthValue.children.push(dayValue);
          }
          yearValue.rows.push(r2);
          yearValue.dateValues.push(dateStr);
          monthValue.rows.push(r2);
          monthValue.dateValues.push(dateStr);
          dayValue.rows.push(r2);
          dayValue.dateValues.push(dateStr);
          dateRowMap[dateStr] = (dateRowMap[dateStr] || []).concat(r2);
          if (r2 in hiddenRows) {
            datesUncheck = _$1.union(datesUncheck, [dateStr]);
          }
        })();
      } else {
        (function() {
          var v2 = void 0;
          var m2 = void 0;
          if (cell == null || isRealNull(cell.v)) {
            v2 = null;
            m2 = null;
          } else {
            v2 = cell.v;
            m2 = cell.m;
          }
          var data = valuesMap.get("".concat(v2));
          var text2 = m2 == null ? filter.valueBlank : "".concat(m2);
          var key = "".concat(v2, "#$$$#").concat(m2);
          if (data != null) {
            var maskValue = _$1.find(data, function(value) {
              return value.mask === m2;
            });
            if (maskValue == null) {
              maskValue = {
                key,
                value: v2,
                text: text2,
                mask: m2,
                rows: []
              };
              data.push(maskValue);
              flattenValues.push(text2);
            }
            maskValue.rows.push(r2);
          } else {
            valuesMap.set("".concat(v2), [{
              key,
              value: v2,
              text: text2,
              mask: m2,
              rows: [r2]
            }]);
            flattenValues.push(text2);
          }
          if (r2 in hiddenRows) {
            valuesUncheck = _$1.union(valuesUncheck, [key]);
          }
          valueRowMap[key] = (valueRowMap[key] || []).concat(r2);
        })();
      }
    }
    return {
      dates,
      datesUncheck,
      dateRowMap,
      values: _$1.flatten(Array.from(valuesMap.values())),
      valuesUncheck,
      valueRowMap,
      visibleRows,
      flattenValues
    };
  }
  function getFilterColumnColors(ctx, col, startRow, endRow) {
    var bgMap = /* @__PURE__ */ new Map();
    var fcMap = /* @__PURE__ */ new Map();
    var cf_compute = getComputeMap(ctx);
    var flowdata = getFlowdata(ctx);
    if (flowdata == null) return {
      bgColors: [],
      fcColors: []
    };
    for (var r2 = startRow + 1; r2 <= endRow; r2 += 1) {
      var _ctx$config;
      var cell = flowdata[r2][col];
      var bg2 = normalizedAttr(flowdata, r2, col, "bg");
      if (bg2 == null) {
        bg2 = "#ffffff";
      }
      var checksAF = [];
      if (checksAF.length > 1) {
        bg2 = checksAF[1];
      }
      var checksCF = checkCF(r2, col, cf_compute);
      if (checksCF != null && checksCF.cellColor != null) {
        bg2 = checksCF.cellColor;
      }
      if (bg2.indexOf("rgb") > -1) {
        bg2 = rgbToHex(bg2);
      }
      if (bg2.length === 4) {
        bg2 = bg2.substr(0, 1) + bg2.substr(1, 1).repeat(2) + bg2.substr(2, 1).repeat(2) + bg2.substr(3, 1).repeat(2);
      }
      var fc2 = normalizedAttr(flowdata, r2, col, "fc");
      if (checksAF.length > 0) {
        fc2 = checksAF[0];
      }
      if (checksCF != null && checksCF.textColor != null) {
        fc2 = checksCF.textColor;
      }
      if (fc2 != null) {
        if (fc2.indexOf("rgb") > -1) {
          fc2 = rgbToHex(fc2);
        }
        if (fc2.length === 4) {
          fc2 = fc2.substr(0, 1) + fc2.substr(1, 1).repeat(2) + fc2.substr(2, 1).repeat(2) + fc2.substr(3, 1).repeat(2);
        }
      }
      var isRowHidden = r2 in (((_ctx$config = ctx.config) === null || _ctx$config === void 0 ? void 0 : _ctx$config.rowhidden) || {});
      var bgData = bgMap.get(bg2);
      if (bgData != null) {
        bgData.rows.push(r2);
        if (isRowHidden) bgData.checked = false;
      } else {
        bgMap.set(bg2, {
          color: bg2,
          checked: !isRowHidden,
          rows: [r2]
        });
      }
      if (fc2 != null) {
        var fcData = fcMap.get(fc2);
        if (fcData != null && cell != null && !isRealNull(cell.v)) {
          fcData.rows.push(r2);
          if (isRowHidden) fcData.checked = false;
        } else if (cell != null && !isRealNull(cell.v)) {
          fcMap.set(fc2, {
            color: fc2,
            checked: !isRowHidden,
            rows: [r2]
          });
        }
      }
    }
    var bgColors = _$1.flatten(Array.from(bgMap.values()));
    var fcColors = _$1.flatten(Array.from(fcMap.values()));
    return {
      bgColors: bgColors.length < 2 ? [] : bgColors,
      fcColors: fcColors.length < 2 ? [] : fcColors
    };
  }
  function saveFilter(ctx, optionState, hiddenRows, caljs, st_r, ed_r, cindex, st_c, ed_c) {
    var _getFilterHiddenRows2 = getFilterHiddenRows(ctx, cindex, st_c), otherHiddenRows = _getFilterHiddenRows2.otherHiddenRows;
    var rowHiddenAll = _$1.assign(otherHiddenRows, hiddenRows);
    labelFilterOptionState(ctx, optionState, hiddenRows, caljs, st_r, ed_r, cindex, st_c, ed_c);
    var cfg = _$1.assign({}, ctx.config);
    cfg.rowhidden = rowHiddenAll;
    ctx.config = cfg;
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (sheetIndex == null) {
      return;
    }
    ctx.luckysheetfile[sheetIndex].config = cfg;
  }
  var dragCellThreshold = 8;
  function getCellLocationByMouse(ctx, e, scrollbarX, scrollbarY, container) {
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollbarX.scrollLeft;
    var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollbarY.scrollTop;
    return {
      row: rowLocation(y2, ctx.visibledatarow),
      column: colLocation(x2, ctx.visibledatacolumn)
    };
  }
  function onCellsMoveStart(ctx, globalCache, e, scrollbarX, scrollbarY, container) {
    var allowEdit = isAllowEdit(ctx);
    if (allowEdit === false) {
      return;
    }
    globalCache.dragCellStartPos = {
      x: e.pageX,
      y: e.pageY
    };
    ctx.luckysheet_cell_selected_move = true;
    ctx.luckysheet_scroll_status = true;
    var _getCellLocationByMou = getCellLocationByMouse(ctx, e, scrollbarX, scrollbarY, container), _getCellLocationByMou2 = _slicedToArray$1(_getCellLocationByMou.row, 3), row_pre = _getCellLocationByMou2[0], row = _getCellLocationByMou2[1], row_index = _getCellLocationByMou2[2], _getCellLocationByMou3 = _slicedToArray$1(_getCellLocationByMou.column, 3), col_pre = _getCellLocationByMou3[0], col = _getCellLocationByMou3[1], col_index = _getCellLocationByMou3[2];
    var range = _$1.last(ctx.luckysheet_select_save);
    if (range == null) return;
    if (row_index < range.row[0]) {
      var _range$row = _slicedToArray$1(range.row, 1);
      row_index = _range$row[0];
    } else if (row_index > range.row[1]) {
      var _range$row2 = _slicedToArray$1(range.row, 2);
      row_index = _range$row2[1];
    }
    if (col_index < range.column[0]) {
      var _range$column = _slicedToArray$1(range.column, 1);
      col_index = _range$column[0];
    } else if (col_index > range.column[1]) {
      var _range$column2 = _slicedToArray$1(range.column, 2);
      col_index = _range$column2[1];
    }
    var _rowLocationByIndex = rowLocationByIndex(row_index, ctx.visibledatarow);
    var _rowLocationByIndex2 = _slicedToArray$1(_rowLocationByIndex, 2);
    row_pre = _rowLocationByIndex2[0];
    row = _rowLocationByIndex2[1];
    var _colLocationByIndex = colLocationByIndex(col_index, ctx.visibledatacolumn);
    var _colLocationByIndex2 = _slicedToArray$1(_colLocationByIndex, 2);
    col_pre = _colLocationByIndex2[0];
    col = _colLocationByIndex2[1];
    ctx.luckysheet_cell_selected_move_index = [row_index, col_index];
    var ele = document.getElementById("fortune-cell-selected-move");
    if (ele == null) return;
    ele.style.left = "".concat(col_pre, "px");
    ele.style.top = "".concat(row_pre, "px");
    ele.style.width = "".concat(col - col_pre - 1, "px");
    ele.style.height = "".concat(row - row_pre - 1, "px");
    ele.style.display = "block";
    e.stopPropagation();
  }
  function onCellsMove(ctx, globalCache, e, scrollbarX, scrollbarY, container) {
    if (!ctx.luckysheet_cell_selected_move) return;
    if (globalCache.dragCellStartPos != null) {
      var deltaX = Math.abs(globalCache.dragCellStartPos.x - e.pageX);
      var deltaY = Math.abs(globalCache.dragCellStartPos.y - e.pageY);
      if (deltaX < dragCellThreshold && deltaY < dragCellThreshold) {
        return;
      }
      globalCache.dragCellStartPos = void 0;
    }
    var _mousePosition = mousePosition(e.pageX, e.pageY, ctx), _mousePosition2 = _slicedToArray$1(_mousePosition, 2), x2 = _mousePosition2[0], y2 = _mousePosition2[1];
    var rect = container.getBoundingClientRect();
    var winH = rect.height - 20 * ctx.zoomRatio;
    var winW = rect.width - 60 * ctx.zoomRatio;
    var _getCellLocationByMou4 = getCellLocationByMouse(ctx, e, scrollbarX, scrollbarY, container), rowL = _getCellLocationByMou4.row, column = _getCellLocationByMou4.column;
    var _rowL = _slicedToArray$1(rowL, 2), row_pre = _rowL[0], row = _rowL[1];
    var _column = _slicedToArray$1(column, 2), col_pre = _column[0], col = _column[1];
    var row_index = rowL[2];
    var col_index = column[2];
    var row_index_original = ctx.luckysheet_cell_selected_move_index[0];
    var col_index_original = ctx.luckysheet_cell_selected_move_index[1];
    if (ctx.luckysheet_select_save == null) return;
    var row_s = ctx.luckysheet_select_save[0].row[0] - row_index_original + row_index;
    var row_e = ctx.luckysheet_select_save[0].row[1] - row_index_original + row_index;
    var col_s = ctx.luckysheet_select_save[0].column[0] - col_index_original + col_index;
    var col_e = ctx.luckysheet_select_save[0].column[1] - col_index_original + col_index;
    if (row_s < 0 || y2 < 0) {
      row_s = 0;
      row_e = ctx.luckysheet_select_save[0].row[1] - ctx.luckysheet_select_save[0].row[0];
    }
    if (col_s < 0 || x2 < 0) {
      col_s = 0;
      col_e = ctx.luckysheet_select_save[0].column[1] - ctx.luckysheet_select_save[0].column[0];
    }
    if (row_e >= ctx.visibledatarow.length - 1 || y2 > winH) {
      row_s = ctx.visibledatarow.length - 1 - ctx.luckysheet_select_save[0].row[1] + ctx.luckysheet_select_save[0].row[0];
      row_e = ctx.visibledatarow.length - 1;
    }
    if (col_e >= ctx.visibledatacolumn.length - 1 || x2 > winW) {
      col_s = ctx.visibledatacolumn.length - 1 - ctx.luckysheet_select_save[0].column[1] + ctx.luckysheet_select_save[0].column[0];
      col_e = ctx.visibledatacolumn.length - 1;
    }
    col_pre = col_s - 1 === -1 ? 0 : ctx.visibledatacolumn[col_s - 1];
    col = ctx.visibledatacolumn[col_e];
    row_pre = row_s - 1 === -1 ? 0 : ctx.visibledatarow[row_s - 1];
    row = ctx.visibledatarow[row_e];
    var ele = document.getElementById("fortune-cell-selected-move");
    if (ele == null) return;
    ele.style.left = "".concat(col_pre, "px");
    ele.style.top = "".concat(row_pre, "px");
    ele.style.width = "".concat(col - col_pre - 2, "px");
    ele.style.height = "".concat(row - row_pre - 2, "px");
    ele.style.display = "block";
  }
  function onCellsMoveEnd(ctx, globalCache, e, scrollbarX, scrollbarY, container) {
    var _ctx$luckysheetfile$g2;
    if (!ctx.luckysheet_cell_selected_move) return;
    ctx.luckysheet_cell_selected_move = false;
    var ele = document.getElementById("fortune-cell-selected-move");
    if (ele != null) ele.style.display = "none";
    if (globalCache.dragCellStartPos != null) {
      globalCache.dragCellStartPos = void 0;
      return;
    }
    var _mousePosition3 = mousePosition(e.pageX, e.pageY, ctx), _mousePosition4 = _slicedToArray$1(_mousePosition3, 2), x2 = _mousePosition4[0], y2 = _mousePosition4[1];
    var rect = container.getBoundingClientRect();
    var winH = rect.height - 20 * ctx.zoomRatio;
    var winW = rect.width - 60 * ctx.zoomRatio;
    var _getCellLocationByMou5 = getCellLocationByMouse(ctx, e, scrollbarX, scrollbarY, container), _getCellLocationByMou6 = _slicedToArray$1(_getCellLocationByMou5.row, 3), row_index = _getCellLocationByMou6[2], _getCellLocationByMou7 = _slicedToArray$1(_getCellLocationByMou5.column, 3), col_index = _getCellLocationByMou7[2];
    var allowEdit = isAllowEdit(ctx, [{
      row: [row_index, row_index],
      column: [col_index, col_index]
    }]);
    if (!allowEdit) return;
    var row_index_original = ctx.luckysheet_cell_selected_move_index[0];
    var col_index_original = ctx.luckysheet_cell_selected_move_index[1];
    if (row_index === row_index_original && col_index === col_index_original) {
      return;
    }
    var d2 = getFlowdata(ctx);
    if (d2 == null || ctx.luckysheet_select_save == null) return;
    var last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
    var data = _$1.cloneDeep(getdatabyselection(ctx, last, ctx.currentSheetId));
    var cfg = ctx.config;
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    if (cfg.rowlen == null) {
      cfg.rowlen = {};
    }
    var _locale = locale(ctx), locale_drag = _locale.drag;
    if (hasPartMC(ctx, cfg, last.row[0], last.row[1], last.column[0], last.column[1])) {
      throw new Error(locale_drag.noMerge);
    }
    var row_s = last.row[0] - row_index_original + row_index;
    var row_e = last.row[1] - row_index_original + row_index;
    var col_s = last.column[0] - col_index_original + col_index;
    var col_e = last.column[1] - col_index_original + col_index;
    if (row_s < 0 || y2 < 0) {
      row_s = 0;
      row_e = last.row[1] - last.row[0];
    }
    if (col_s < 0 || x2 < 0) {
      col_s = 0;
      col_e = last.column[1] - last.column[0];
    }
    if (row_e >= ctx.visibledatarow.length - 1 || y2 > winH) {
      row_s = ctx.visibledatarow.length - 1 - last.row[1] + last.row[0];
      row_e = ctx.visibledatarow.length - 1;
    }
    if (col_e >= ctx.visibledatacolumn.length - 1 || x2 > winW) {
      col_s = ctx.visibledatacolumn.length - 1 - last.column[1] + last.column[0];
      col_e = ctx.visibledatacolumn.length - 1;
    }
    if (hasPartMC(ctx, cfg, row_s, row_e, col_s, col_e)) {
      throw new Error(locale_drag.noMerge);
    }
    var borderInfoCompute = getBorderInfoCompute(ctx, ctx.currentSheetId);
    var hyperLinkList = {};
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    for (var r2 = last.row[0]; r2 <= last.row[1]; r2 += 1) {
      for (var c2 = last.column[0]; c2 <= last.column[1]; c2 += 1) {
        var _ctx$luckysheetfile$i;
        var cellData = d2[r2][c2];
        if ((cellData === null || cellData === void 0 ? void 0 : cellData.mc) != null) {
          var mergeKey = "".concat(cellData.mc.r, "_").concat(c2);
          if (cfg.merge[mergeKey] != null) {
            delete cfg.merge[mergeKey];
          }
        }
        d2[r2][c2] = null;
        if ((_ctx$luckysheetfile$i = ctx.luckysheetfile[index2].hyperlink) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i["".concat(r2, "_").concat(c2)]) {
          var _ctx$luckysheetfile$i2, _ctx$luckysheetfile$g;
          hyperLinkList["".concat(r2, "_").concat(c2)] = (_ctx$luckysheetfile$i2 = ctx.luckysheetfile[index2].hyperlink) === null || _ctx$luckysheetfile$i2 === void 0 ? void 0 : _ctx$luckysheetfile$i2["".concat(r2, "_").concat(c2)];
          (_ctx$luckysheetfile$g = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].hyperlink) === null || _ctx$luckysheetfile$g === void 0 ? true : delete _ctx$luckysheetfile$g["".concat(r2, "_").concat(c2)];
        }
      }
    }
    if (cfg.borderInfo && cfg.borderInfo.length > 0) {
      var borderInfo = [];
      for (var i2 = 0; i2 < cfg.borderInfo.length; i2 += 1) {
        var bd_rangeType = cfg.borderInfo[i2].rangeType;
        if (bd_rangeType === "range" && cfg.borderInfo[i2].borderType !== "border-slash") {
          var bd_range = cfg.borderInfo[i2].range;
          var bd_emptyRange = [];
          for (var j2 = 0; j2 < bd_range.length; j2 += 1) {
            bd_emptyRange = bd_emptyRange.concat(cfSplitRange(bd_range[j2], {
              row: last.row,
              column: last.column
            }, {
              row: [row_s, row_e],
              column: [col_s, col_e]
            }));
          }
          cfg.borderInfo[i2].range = bd_emptyRange;
          borderInfo.push(cfg.borderInfo[i2]);
        } else if (bd_rangeType === "cell") {
          var bd_r = cfg.borderInfo[i2].value.row_index;
          var bd_c = cfg.borderInfo[i2].value.col_index;
          if (!(bd_r >= last.row[0] && bd_r <= last.row[1] && bd_c >= last.column[0] && bd_c <= last.column[1])) {
            borderInfo.push(cfg.borderInfo[i2]);
          }
        } else if (bd_rangeType === "range" && cfg.borderInfo[i2].borderType === "border-slash" && !(cfg.borderInfo[i2].range[0].row[0] >= last.row[0] && cfg.borderInfo[i2].range[0].row[0] <= last.row[1] && cfg.borderInfo[i2].range[0].column[0] >= last.column[0] && cfg.borderInfo[i2].range[0].column[0] <= last.column[1])) {
          borderInfo.push(cfg.borderInfo[i2]);
        }
      }
      cfg.borderInfo = borderInfo;
    }
    var offsetMC = {};
    for (var _r = 0; _r < data.length; _r += 1) {
      for (var _c = 0; _c < data[0].length; _c += 1) {
        var _value;
        if (borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])] && !borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].s) {
          var bd_obj = {
            rangeType: "cell",
            value: {
              row_index: _r + row_s,
              col_index: _c + col_s,
              l: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].l,
              r: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].r,
              t: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].t,
              b: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].b
            }
          };
          if (cfg.borderInfo == null) {
            cfg.borderInfo = [];
          }
          cfg.borderInfo.push(bd_obj);
        } else if (borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])]) {
          var _bd_obj = {
            rangeType: "range",
            borderType: "border-slash",
            color: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].s.color,
            style: borderInfoCompute["".concat(_r + last.row[0], "_").concat(_c + last.column[0])].s.style,
            range: normalizeSelection(ctx, [{
              row: [_r + row_s, _r + row_s],
              column: [_c + col_s, _c + col_s]
            }])
          };
          if (cfg.borderInfo == null) {
            cfg.borderInfo = [];
          }
          cfg.borderInfo.push(_bd_obj);
        }
        var value = null;
        if (data[_r] != null && data[_r][_c] != null) {
          value = data[_r][_c];
        }
        if (((_value = value) === null || _value === void 0 ? void 0 : _value.mc) != null) {
          var mc2 = _$1.assign({}, value.mc);
          if ("rs" in value.mc) {
            _$1.set(offsetMC, "".concat(mc2.r, "_").concat(mc2.c), [_r + row_s, _c + col_s]);
            value.mc.r = _r + row_s;
            value.mc.c = _c + col_s;
            _$1.set(cfg.merge, "".concat(_r + row_s, "_").concat(_c + col_s), value.mc);
          } else {
            _$1.set(value.mc, "r", offsetMC["".concat(mc2.r, "_").concat(mc2.c)][0]);
            _$1.set(value.mc, "c", offsetMC["".concat(mc2.r, "_").concat(mc2.c)][1]);
          }
        }
        d2[_r + row_s][_c + col_s] = value;
        if (hyperLinkList === null || hyperLinkList === void 0 ? void 0 : hyperLinkList["".concat(_r + last.row[0], "_").concat(_c + last.column[0])]) {
          ctx.luckysheetfile[index2].hyperlink["".concat(_r + row_s, "_").concat(_c + col_s)] = hyperLinkList === null || hyperLinkList === void 0 ? void 0 : hyperLinkList["".concat(_r + last.row[0], "_").concat(_c + last.column[0])];
        }
      }
    }
    var cdformat = (_ctx$luckysheetfile$g2 = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].luckysheet_conditionformat_save) !== null && _ctx$luckysheetfile$g2 !== void 0 ? _ctx$luckysheetfile$g2 : [];
    if (cdformat != null && cdformat.length > 0) {
      for (var _i = 0; _i < cdformat.length; _i += 1) {
        var cdformat_cellrange = cdformat[_i].cellrange;
        var emptyRange = [];
        for (var _j = 0; _j < cdformat_cellrange.length; _j += 1) {
          var _range = CFSplitRange(cdformat_cellrange[_j], {
            row: last.row,
            column: last.column
          }, {
            row: [row_s, row_e],
            column: [col_s, col_e]
          }, "allPart");
          emptyRange = emptyRange.concat(_range);
        }
        cdformat[_i].cellrange = emptyRange;
      }
    }
    var rf2;
    if (ctx.luckysheet_select_save[0].row_focus === ctx.luckysheet_select_save[0].row[0]) {
      rf2 = row_s;
    } else {
      rf2 = row_e;
    }
    var cf2;
    if (ctx.luckysheet_select_save[0].column_focus === ctx.luckysheet_select_save[0].column[0]) {
      cf2 = col_s;
    } else {
      cf2 = col_e;
    }
    var range = [];
    range.push({
      row: last.row,
      column: last.column
    });
    range.push({
      row: [row_s, row_e],
      column: [col_s, col_e]
    });
    last.row = [row_s, row_e];
    last.column = [col_s, col_e];
    last.row_focus = rf2;
    last.column_focus = cf2;
    ctx.luckysheet_select_save = normalizeSelection(ctx, [last]);
    var sheetIndex = getSheetIndex(ctx, ctx.currentSheetId);
    if (sheetIndex != null) {
      ctx.luckysheetfile[sheetIndex].config = _$1.assign({}, cfg);
    }
    jfrefreshgrid(ctx, d2, range);
  }
  function getNullData(rlen, clen) {
    var arr = [];
    for (var r2 = 0; r2 < rlen; r2 += 1) {
      var rowArr = [];
      for (var c2 = 0; c2 < clen; c2 += 1) {
        rowArr.push("");
      }
      arr.push(rowArr);
    }
    return arr;
  }
  function updateMoreCell(r2, c2, dataMatrix, ctx) {
    if (ctx.allowEdit === false) return;
    var flowdata = getFlowdata(ctx);
    dataMatrix.forEach(function(datas, i2) {
      datas.forEach(function(data, j2) {
        var v2 = dataMatrix[i2][j2];
        setCellValue(ctx, r2 + i2, c2 + j2, flowdata, v2);
      });
    });
  }
  function getRegStr(regStr, splitSymbols) {
    regStr = "";
    var mark = 0;
    for (var i2 = 0; i2 < splitSymbols.length; i2 += 1) {
      var split = splitSymbols[i2];
      var inputNode = split.childNodes[0];
      if (inputNode.checked) {
        var id2 = inputNode.id;
        if (id2 === "Tab") {
          regStr += "\\t";
          mark += 1;
        } else if (id2 === "semicolon") {
          if (mark > 0) {
            regStr += "|";
          }
          regStr += ";";
          mark = 1;
        } else if (id2 === "comma") {
          if (mark > 0) {
            regStr += "|";
          }
          regStr += ",";
          mark += 1;
        } else if (id2 === "space") {
          if (mark > 0) {
            regStr += "|";
          }
          regStr += "\\s";
          mark += 1;
        } else if (id2 === "splitsimple") {
          regStr = "[".concat(regStr, "]+");
        } else if (id2 === "other") {
          var txt = split.childNodes[2].value;
          if (txt !== "") {
            if (mark > 0) {
              regStr += "|";
            }
            regStr += txt;
          }
        }
      }
    }
    return regStr;
  }
  function getDataArr(regStr, ctx) {
    var arr = [];
    var r1 = ctx.luckysheet_select_save[0].row[0];
    var r2 = ctx.luckysheet_select_save[0].row[1];
    var c2 = ctx.luckysheet_select_save[0].column[0];
    var data = getFlowdata(ctx);
    if (!_$1.isNull(regStr) && regStr !== "") {
      var reg = new RegExp(regStr, "g");
      var dataArr = [];
      for (var r3 = r1; r3 <= r2; r3 += 1) {
        var rowArr = [];
        var cell = data[r3][c2];
        var value = void 0;
        if (!_$1.isNull(cell) && !_$1.isNull(cell.m)) {
          value = cell.m;
        } else {
          value = getCellValue(r3, c2, data);
        }
        if (_$1.isNull(value) || _$1.isUndefined(value)) {
          value = "";
        }
        rowArr = value.toString().split(reg);
        dataArr.push(rowArr);
      }
      var rlen = dataArr.length;
      var clen = 0;
      for (var i2 = 0; i2 < rlen; i2 += 1) {
        if (dataArr[i2].length > clen) {
          clen = dataArr[i2].length;
        }
      }
      arr = getNullData(rlen, clen);
      for (var _i = 0; _i < arr.length; _i += 1) {
        for (var j2 = 0; j2 < arr[0].length; j2 += 1) {
          if (dataArr[_i][j2] != null) {
            arr[_i][j2] = dataArr[_i][j2];
          }
        }
      }
    } else {
      for (var _r = r1; _r <= r2; _r += 1) {
        var _rowArr = [];
        var _cell = data[_r][c2];
        var _value = void 0;
        if (!_$1.isNull(_cell) && !_$1.isNull(_cell.m)) {
          _value = _cell.m;
        } else {
          _value = getCellValue(_r, c2, data);
        }
        if (_$1.isNull(_value)) {
          _value = "";
        }
        _rowArr.push(_value);
        arr.push(_rowArr);
      }
    }
    return arr;
  }
  function deleteCellInSave(cellSave, range) {
    for (var r2 = range.row[0]; r2 <= range.row[1]; r2 += 1) {
      for (var c2 = range.column[0]; c2 <= range.column[1]; c2 += 1) {
        delete cellSave["".concat(r2, "_").concat(c2)];
      }
    }
    return cellSave;
  }
  function getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx) {
    if (Object.keys(cellSave).length === 0) {
      return rangeArr;
    }
    var stack_str = null;
    var stack_edr = null;
    var stack_stc = null;
    var stack_edc = null;
    var flowData = getFlowdata(ctx, ctx.currentSheetId);
    for (var r2 = minR; r2 <= maxR; r2 += 1) {
      for (var c2 = minC; c2 <= maxC; c2 += 1) {
        if (_$1.isNil(flowData)) break;
        var cell = flowData[r2][c2];
        if ("".concat(r2, "_").concat(c2) in cellSave) {
          var _cell$mc, _cell$mc2, _cell$mc3;
          if (!!(cell === null || cell === void 0 ? void 0 : (_cell$mc = cell.mc) === null || _cell$mc === void 0 ? void 0 : _cell$mc.cs) && !!(cell === null || cell === void 0 ? void 0 : (_cell$mc2 = cell.mc) === null || _cell$mc2 === void 0 ? void 0 : _cell$mc2.rs) && !!(cell === null || cell === void 0 ? void 0 : (_cell$mc3 = cell.mc) === null || _cell$mc3 === void 0 ? void 0 : _cell$mc3.r)) {
            if (stack_stc === null) {
              var range = {
                row: [cell.mc.r, cell.mc.r + cell.mc.rs - 1],
                column: [cell.mc.c, cell.mc.c + cell.mc.cs - 1]
              };
              rangeArr.push(range);
              cellSave = deleteCellInSave(cellSave, range);
              return getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx);
            }
            if (stack_edc !== null && c2 < stack_edc) {
              var _range = {
                row: [stack_str, stack_edr],
                column: [stack_stc, stack_edc]
              };
              rangeArr.push(_range);
              cellSave = deleteCellInSave(cellSave, _range);
              return getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx);
            }
            break;
          } else if (stack_stc === null) {
            stack_stc = c2;
            stack_edc = c2;
            stack_str = r2;
            stack_edr = r2;
          } else if (stack_edc !== null && c2 > stack_edc) {
            stack_edc = c2;
          }
        } else if (stack_stc !== null) {
          if (cell !== null && cell.mc !== null) {
            break;
          } else if (c2 < stack_stc) ;
          else if (stack_edc !== null && c2 <= stack_edc) {
            var _range2 = {
              row: [stack_str, stack_edr],
              column: [stack_stc, stack_edc]
            };
            rangeArr.push(_range2);
            cellSave = deleteCellInSave(cellSave, _range2);
            return getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx);
          } else {
            stack_edr = r2;
          }
        }
      }
    }
    if (stack_stc !== null) {
      var _range3 = {
        row: [stack_str, stack_edr],
        column: [stack_stc, stack_edc]
      };
      rangeArr.push(_range3);
      cellSave = deleteCellInSave(cellSave, _range3);
      return getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx);
    }
    return rangeArr;
  }
  function getOptionValue(constants) {
    var tempConstans = _$1.cloneDeep(constants);
    var len = _$1.filter(tempConstans, function(o2) {
      return o2;
    }).length;
    var value;
    if (len === 0) {
      value = "";
    } else if (len === 5) {
      value = "all";
    } else {
      var arr = [];
      _$1.toPairs(constants).forEach(function(entry) {
        var _entry = _slicedToArray$1(entry, 2), k2 = _entry[0], v2 = _entry[1];
        if (v2) {
          if (k2 === "locationDate") {
            arr.push("d");
          } else if (k2 === "locationDigital") {
            arr.push("n");
          } else if (k2 === "locationString") {
            arr.push("s,g");
          } else if (k2 === "locationBool") {
            arr.push("b");
          } else if (k2 === "locationError") {
            arr.push("e");
          }
        }
      });
      value = arr.join(",");
    }
    return value;
  }
  function getSelectRange(ctx) {
    var _ctx$luckysheet_selec, _ctx$luckysheet_selec2;
    var range;
    if (((_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec.length) === 0 || ((_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2.length) === 1 && ctx.luckysheet_select_save[0].row[0] === ctx.luckysheet_select_save[0].row[1] && ctx.luckysheet_select_save[0].column[0] === ctx.luckysheet_select_save[0].column[1]) {
      var flowdata = getFlowdata(ctx, ctx.currentSheetId);
      if (_$1.isNil(flowdata)) return [];
      range = [{
        row: [0, flowdata.length - 1],
        column: [0, flowdata[0].length - 1]
      }];
    } else {
      range = _$1.assignIn([], ctx.luckysheet_select_save);
    }
    return range;
  }
  function applyLocation(range, type, value, ctx) {
    var rangeArr = [];
    if (type === "locationFormula" || type === "locationConstant" || type === "locationNull") {
      var minR = null;
      var maxR = null;
      var minC = null;
      var maxC = null;
      var cellSave = {};
      var flowData = getFlowdata(ctx, ctx.currentSheetId);
      if (_$1.isNil(flowData)) return [];
      for (var s2 = 0; s2 < range.length; s2 += 1) {
        var st_r = range[s2].row[0];
        var ed_r = range[s2].row[1];
        var st_c = range[s2].column[0];
        var ed_c = range[s2].column[1];
        if (minR === null || minR < st_r) {
          minR = st_r;
        }
        if (maxR === null || maxR > ed_r) {
          maxR = ed_r;
        }
        if (minC === null || minC < st_c) {
          minC = st_c;
        }
        if (maxC === null || maxC > ed_c) {
          maxC = ed_c;
        }
        for (var r2 = st_r; r2 <= ed_r; r2 += 1) {
          for (var c2 = st_c; c2 <= ed_c; c2 += 1) {
            var _cell, _cell2, _cell3, _cell3$ct;
            var cell = flowData[r2][c2];
            if ((_cell = cell) === null || _cell === void 0 ? void 0 : _cell.mc) {
              cell = flowData[cell.mc.r][cell.mc.c];
            }
            if (type === "locationFormula" && !!cell && cell.v !== null && !!cell.f && (value === "all" || !!cell.ct && !!value && !!cell.ct.t && value.indexOf(cell.ct.t) > -1)) {
              cellSave["".concat(r2, "_").concat(c2)] = 0;
            } else if (type === "locationConstant" && ((_cell2 = cell) === null || _cell2 === void 0 ? void 0 : _cell2.v) && (value === "all" || ((_cell3 = cell) === null || _cell3 === void 0 ? void 0 : (_cell3$ct = _cell3.ct) === null || _cell3$ct === void 0 ? void 0 : _cell3$ct.t) && value.indexOf(cell.ct.t) > -1)) {
              cellSave["".concat(r2, "_").concat(c2)] = 0;
            } else if (type === "locationNull" && (cell === null || cell.v === null)) {
              cellSave["".concat(r2, "_").concat(c2)] = 0;
            }
          }
        }
      }
      rangeArr = getRangeArr(minR, maxR, minC, maxC, cellSave, rangeArr, ctx);
    } else if (type === "locationCF") ;
    else if (type === "locationRowSpan") {
      for (var _s = 0; _s < range.length; _s += 1) {
        if (range[_s].row[0] === range[_s].row[1]) {
          continue;
        }
        var _st_r = range[_s].row[0];
        var _ed_r = range[_s].row[1];
        var _st_c = range[_s].column[0];
        var _ed_c = range[_s].column[1];
        for (var _r = _st_r; _r <= _ed_r; _r += 1) {
          if ((_r - _st_r) % 2 === 0) {
            rangeArr.push({
              row: [_r, _r],
              column: [_st_c, _ed_c]
            });
          }
        }
      }
    } else if (type === "locationColumnSpan") {
      for (var _s2 = 0; _s2 < range.length; _s2 += 1) {
        if (range[_s2].column[0] === range[_s2].column[1]) {
          continue;
        }
        var _st_r2 = range[_s2].row[0];
        var _ed_r2 = range[_s2].row[1];
        var _st_c2 = range[_s2].column[0];
        var _ed_c2 = range[_s2].column[1];
        for (var _c = _st_c2; _c <= _ed_c2; _c += 1) {
          if ((_c - _st_c2) % 2 === 0) {
            rangeArr.push({
              row: [_st_r2, _ed_r2],
              column: [_c, _c]
            });
          }
        }
      }
    }
    if (rangeArr.length === 0) {
      return rangeArr;
    }
    ctx.luckysheet_select_save = normalizeSelection(ctx, rangeArr);
    return rangeArr;
  }
  var ZOOM_STEP = 0.1;
  var MAX_ZOOM_RATIO = 4;
  var MIN_ZOOM_RATIO = 0.1;
  function handleKeydownForZoom(ev, currentZoom) {
    if (!ev.ctrlKey) {
      return currentZoom;
    }
    var handled = false;
    var zoom = currentZoom || 1;
    if (ev.key === "-" || ev.which === 189) {
      zoom -= ZOOM_STEP;
      handled = true;
    } else if (ev.key === "+" || ev.which === 187) {
      zoom += ZOOM_STEP;
      handled = true;
    } else if (ev.key === "0" || ev.which === 48) {
      zoom = 1;
      handled = true;
    }
    if (handled) {
      ev.preventDefault();
      if (zoom >= MAX_ZOOM_RATIO) {
        zoom = MAX_ZOOM_RATIO;
      } else if (zoom < MIN_ZOOM_RATIO) {
        zoom = MIN_ZOOM_RATIO;
      }
    }
    return parseFloat(zoom.toFixed(1));
  }
  function defaultContext(globalCache) {
    return {
      luckysheetfile: [],
      defaultcolumnNum: 60,
      defaultrowNum: 84,
      addDefaultRows: 50,
      fullscreenmode: true,
      devicePixelRatio: (globalThis || window).devicePixelRatio,
      contextMenu: {},
      sheetTabContextMenu: {},
      currentSheetId: "",
      calculateSheetId: "",
      config: {},
      warnDialog: void 0,
      rangeDialog: {
        show: false,
        rangeTxt: "",
        type: "",
        singleSelect: false
      },
      dataVerification: {
        selectStatus: false,
        selectRange: [],
        optionLabel_en: {
          number: "numeric",
          number_integer: "integer",
          number_decimal: "decimal",
          between: "between",
          notBetween: "not between",
          equal: "equal to",
          notEqualTo: "not equal to",
          moreThanThe: "greater",
          lessThan: "less than",
          greaterOrEqualTo: "greater or equal to",
          lessThanOrEqualTo: "less than or equal to",
          include: "include",
          exclude: "not include",
          earlierThan: "earlier than",
          noEarlierThan: "not earlier than",
          laterThan: "later than",
          noLaterThan: "not later than",
          identificationNumber: "identification number",
          phoneNumber: "phone number"
        },
        optionLabel_zh: {
          number: "数值",
          number_integer: "整数",
          number_decimal: "小数",
          between: "介于",
          notBetween: "不介于",
          equal: "等于",
          notEqualTo: "不等于",
          moreThanThe: "大于",
          lessThan: "小于",
          greaterOrEqualTo: "大于等于",
          lessThanOrEqualTo: "小于等于",
          include: "包括",
          exclude: "不包括",
          earlierThan: "早于",
          noEarlierThan: "不早于",
          laterThan: "晚于",
          noLaterThan: "不晚于",
          identificationNumber: "身份证号码",
          phoneNumber: "手机号"
        },
        optionLabel_zh_tw: {
          number: "數位",
          number_integer: "數位-整數",
          number_decimal: "數位-小數",
          between: "介於",
          notBetween: "不介於",
          equal: "等於",
          notEqualTo: "不等於",
          moreThanThe: "大於",
          lessThan: "小於",
          greaterOrEqualTo: "大於等於",
          lessThanOrEqualTo: "小於等於",
          include: "包括",
          exclude: "不包括",
          earlierThan: "早於",
          noEarlierThan: "不早於",
          laterThan: "晚於",
          noLaterThan: "不晚於",
          identificationNumber: "身份證號碼",
          phoneNumber: "手機號"
        },
        optionLabel_es: {
          number: "Número",
          number_integer: "Número entero",
          number_decimal: "Número decimal",
          between: "Entre",
          notBetween: "No entre",
          equal: "Iqual",
          notEqualTo: "No iqual a",
          moreThanThe: "Más que el",
          lessThan: "Menos que",
          greaterOrEqualTo: "Mayor o igual a",
          lessThanOrEqualTo: "Menor o igual a",
          include: "Incluir",
          exclude: "Excluir",
          earlierThan: "Antes de",
          noEarlierThan: "No antes de",
          laterThan: "Después de",
          noLaterThan: "No después de",
          identificationNumber: "Número de identificación",
          phoneNumber: "Número de teléfono"
        },
        dataRegulation: {
          type: "",
          type2: "",
          rangeTxt: "",
          value1: "",
          value2: "",
          validity: "",
          remote: false,
          prohibitInput: false,
          hintShow: false,
          hintValue: ""
        }
      },
      dataVerificationDropDownList: false,
      conditionRules: {
        rulesType: "",
        rulesValue: "",
        textColor: {
          check: true,
          color: "#000000"
        },
        cellColor: {
          check: true,
          color: "#000000"
        },
        betweenValue: {
          value1: "",
          value2: ""
        },
        dateValue: "",
        repeatValue: "0",
        projectValue: "10"
      },
      visibledatarow: [],
      visibledatacolumn: [],
      ch_width: 0,
      rh_height: 0,
      cellmainWidth: 0,
      cellmainHeight: 0,
      toolbarHeight: 41,
      infobarHeight: 57,
      calculatebarHeight: 29,
      rowHeaderWidth: 46,
      columnHeaderHeight: 20,
      cellMainSrollBarSize: 12,
      sheetBarHeight: 31,
      statisticBarHeight: 23,
      luckysheetTableContentHW: [0, 0],
      defaultcollen: 73,
      defaultrowlen: 19,
      scrollLeft: 0,
      scrollTop: 0,
      sheetScrollRecord: {},
      luckysheet_select_status: false,
      luckysheet_select_save: void 0,
      luckysheet_selection_range: [],
      formulaRangeHighlight: [],
      formulaRangeSelect: void 0,
      functionCandidates: [],
      functionHint: null,
      luckysheet_copy_save: void 0,
      luckysheet_paste_iscut: false,
      filterchage: true,
      filter: {},
      luckysheet_sheet_move_status: false,
      luckysheet_sheet_move_data: [],
      luckysheet_scroll_status: false,
      luckysheetcurrentisPivotTable: false,
      luckysheet_rows_selected_status: false,
      luckysheet_cols_selected_status: false,
      luckysheet_rows_change_size: false,
      luckysheet_rows_change_size_start: [],
      luckysheet_cols_change_size: false,
      luckysheet_cols_change_size_start: [],
      luckysheet_cols_freeze_drag: false,
      luckysheet_rows_freeze_drag: false,
      luckysheetCellUpdate: [],
      luckysheet_shiftkeydown: false,
      luckysheet_shiftpositon: void 0,
      iscopyself: true,
      activeImg: void 0,
      orderbyindex: 0,
      luckysheet_model_move_state: false,
      luckysheet_model_xy: [0, 0],
      luckysheet_model_move_obj: null,
      luckysheet_cell_selected_move: false,
      luckysheet_cell_selected_move_index: [],
      luckysheet_cell_selected_extend: false,
      luckysheet_cell_selected_extend_index: [],
      lang: null,
      chart_selection: {},
      zoomRatio: 1,
      showGridLines: true,
      allowEdit: true,
      fontList: [],
      defaultFontSize: 10,
      luckysheetPaintModelOn: false,
      luckysheetPaintSingle: false,
      defaultCell: {
        bl: 0,
        ct: {
          fa: "General",
          t: "n"
        },
        fc: "rgb(51, 51, 51)",
        ff: 0,
        fs: 11,
        ht: 1,
        it: 0,
        vt: 1,
        m: "",
        v: ""
      },
      groupValuesRefreshData: [],
      formulaCache: new FormulaCache(),
      hooks: {},
      getGlobalCache: function getGlobalCache() {
        return globalCache;
      }
    };
  }
  function getFlowdata(ctx, id2) {
    var _ctx$luckysheetfile, _ctx$luckysheetfile$i;
    if (!ctx) return null;
    var i2 = getSheetIndex(ctx, id2 || ctx.currentSheetId);
    if (_$1.isNil(i2)) {
      return null;
    }
    return (_ctx$luckysheetfile = ctx.luckysheetfile) === null || _ctx$luckysheetfile === void 0 ? void 0 : (_ctx$luckysheetfile$i = _ctx$luckysheetfile[i2]) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i.data;
  }
  function calcRowColSize(ctx, rowCount, colCount) {
    ctx.visibledatarow = [];
    ctx.rh_height = 0;
    for (var r2 = 0; r2 < rowCount; r2 += 1) {
      var _ctx$config$rowlen, _ctx$config2, _ctx$config2$rowhidde;
      var rowlen = ctx.defaultrowlen;
      if ((_ctx$config$rowlen = ctx.config.rowlen) === null || _ctx$config$rowlen === void 0 ? void 0 : _ctx$config$rowlen[r2]) {
        var _ctx$config, _ctx$config$rowlen2;
        rowlen = (_ctx$config = ctx.config) === null || _ctx$config === void 0 ? void 0 : (_ctx$config$rowlen2 = _ctx$config.rowlen) === null || _ctx$config$rowlen2 === void 0 ? void 0 : _ctx$config$rowlen2[r2];
      }
      if (((_ctx$config2 = ctx.config) === null || _ctx$config2 === void 0 ? void 0 : (_ctx$config2$rowhidde = _ctx$config2.rowhidden) === null || _ctx$config2$rowhidde === void 0 ? void 0 : _ctx$config2$rowhidde[r2]) != null) {
        ctx.visibledatarow.push(ctx.rh_height);
        continue;
      }
      ctx.rh_height += Math.round((rowlen + 1) * ctx.zoomRatio);
      ctx.visibledatarow.push(ctx.rh_height);
    }
    ctx.rh_height += 80;
    ctx.visibledatacolumn = [];
    ctx.ch_width = 0;
    var maxColumnlen = 120;
    var flowdata = getFlowdata(ctx);
    for (var c2 = 0; c2 < colCount; c2 += 1) {
      var _ctx$config3, _ctx$config3$columnle, _ctx$config5, _ctx$config5$colhidde;
      var firstcolumnlen = ctx.defaultcollen;
      if ((_ctx$config3 = ctx.config) === null || _ctx$config3 === void 0 ? void 0 : (_ctx$config3$columnle = _ctx$config3.columnlen) === null || _ctx$config3$columnle === void 0 ? void 0 : _ctx$config3$columnle[c2]) {
        firstcolumnlen = ctx.config.columnlen[c2];
      } else {
        var _flowdata$;
        if (flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$ = flowdata[0]) === null || _flowdata$ === void 0 ? void 0 : _flowdata$[c2]) {
          if (firstcolumnlen > 300) {
            firstcolumnlen = 300;
          } else if (firstcolumnlen < ctx.defaultcollen) {
            firstcolumnlen = ctx.defaultcollen;
          }
          if (firstcolumnlen !== ctx.defaultcollen) {
            var _ctx$config4;
            if (!((_ctx$config4 = ctx.config) === null || _ctx$config4 === void 0 ? void 0 : _ctx$config4.columnlen)) {
              ctx.config.columnlen = {};
            }
            ctx.config.columnlen[c2] = firstcolumnlen;
          }
        }
      }
      if (((_ctx$config5 = ctx.config) === null || _ctx$config5 === void 0 ? void 0 : (_ctx$config5$colhidde = _ctx$config5.colhidden) === null || _ctx$config5$colhidde === void 0 ? void 0 : _ctx$config5$colhidde[c2]) != null) {
        ctx.visibledatacolumn.push(ctx.ch_width);
        continue;
      }
      ctx.ch_width += Math.round((firstcolumnlen + 1) * ctx.zoomRatio);
      ctx.visibledatacolumn.push(ctx.ch_width);
    }
    ctx.ch_width += maxColumnlen;
  }
  function ensureSheetIndex(data, generateSheetId) {
    if ((data === null || data === void 0 ? void 0 : data.length) > 0) {
      var hasActive = false;
      var indexs = [];
      data.forEach(function(item) {
        if (item.id == null) {
          item.id = generateSheetId();
        }
        if (indexs.includes(item.id)) {
          item.id = generateSheetId();
        } else {
          indexs.push(item.id);
        }
        if (item.status == null) {
          item.status = 0;
        }
        if (item.status === 1) {
          if (hasActive) {
            item.status = 0;
          } else {
            hasActive = true;
          }
        }
      });
      if (!hasActive) {
        data[0].status = 1;
      }
    }
  }
  function initSheetIndex(ctx) {
    var shownSheets = ctx.luckysheetfile.filter(function(singleSheet) {
      return _$1.isUndefined(singleSheet.hide) || singleSheet.hide !== 1;
    });
    ctx.currentSheetId = _$1.sortBy(shownSheets, function(sheet) {
      return sheet.order;
    })[0].id;
    for (var i2 = 0; i2 < ctx.luckysheetfile.length; i2 += 1) {
      if (ctx.luckysheetfile[i2].status === 1 && ctx.luckysheetfile[i2].hide !== 1) {
        ctx.currentSheetId = ctx.luckysheetfile[i2].id;
        break;
      }
    }
  }
  function updateContextWithSheetData(ctx, data) {
    var rowCount = data.length;
    var colCount = rowCount === 0 ? 0 : data[0].length;
    calcRowColSize(ctx, rowCount, colCount);
    normalizeSelection(ctx, ctx.luckysheet_select_save);
  }
  function updateContextWithCanvas(ctx, canvas, placeholder) {
    ctx.luckysheetTableContentHW = [placeholder.clientWidth, placeholder.clientHeight];
    ctx.cellmainHeight = placeholder.clientHeight - ctx.columnHeaderHeight;
    ctx.cellmainWidth = canvas.clientWidth - ctx.rowHeaderWidth;
    canvas.style.width = "".concat(ctx.luckysheetTableContentHW[0], "px");
    canvas.style.height = "".concat(ctx.luckysheetTableContentHW[1], "px");
    canvas.width = Math.ceil(ctx.luckysheetTableContentHW[0] * ctx.devicePixelRatio);
    canvas.height = Math.ceil(ctx.luckysheetTableContentHW[1] * ctx.devicePixelRatio);
  }
  var addtionalMergeOps = function addtionalMergeOps2(ops, id2) {
    var merge_new = {};
    ops.some(function(op) {
      if (op.op === "replace" && op.path[0] === "config" && op.path[1] === "merge") {
        merge_new = op.value;
        return true;
      }
      return false;
    });
    var new_ops = [];
    Object.entries(merge_new).forEach(function(_ref) {
      var _ref2 = _slicedToArray$1(_ref, 2), v2 = _ref2[1];
      var r2 = v2.r, c2 = v2.c, rs = v2.rs, cs = v2.cs;
      var headerOp = {
        op: "replace",
        path: ["data", r2, c2, "mc"],
        id: id2,
        value: v2
      };
      for (var i2 = r2; i2 < r2 + rs; i2 += 1) {
        for (var j2 = c2; j2 < c2 + cs; j2 += 1) {
          new_ops.push({
            op: "replace",
            path: ["data", i2, j2, "mc"],
            id: id2,
            value: {
              r: r2,
              c: c2
            }
          });
        }
      }
      new_ops.push(headerOp);
    });
    return new_ops;
  };
  function additionalCellOps(ctx, insertRowColOp) {
    var id2 = insertRowColOp.id, index2 = insertRowColOp.index, direction = insertRowColOp.direction, count = insertRowColOp.count, type = insertRowColOp.type;
    var d2 = getFlowdata(ctx, id2);
    var startIndex = index2 + (direction === "rightbottom" ? 1 : 0);
    if (d2 == null) {
      return [];
    }
    var cellOps = [];
    if (type === "row") {
      for (var i2 = 0; i2 < d2[startIndex].length; i2 += 1) {
        var cell = d2[startIndex][i2];
        if (cell != null) {
          for (var j2 = 0; j2 < count; j2 += 1) {
            cellOps.push({
              op: "replace",
              id: id2,
              path: ["data", startIndex + j2, i2],
              value: cell
            });
          }
        }
      }
    } else {
      for (var _i = 0; _i < d2.length; _i += 1) {
        var _cell = d2[_i][startIndex];
        if (_cell != null) {
          for (var _j = 0; _j < count; _j += 1) {
            cellOps.push({
              op: "replace",
              id: id2,
              path: ["data", _i, startIndex + _j],
              value: _cell
            });
          }
        }
      }
    }
    return cellOps;
  }
  function filterPatch(patches) {
    return _$1.filter(patches, function(p2) {
      return p2.path[0] === "luckysheetfile" && p2.path[2] !== "luckysheet_select_save";
    });
  }
  function extractFormulaCellOps(ops) {
    var formulaOps = [];
    ops.forEach(function(op) {
      var _op$value;
      if (op.op === "remove") return;
      if (op.path.length === 2 && Array.isArray(op.value)) {
        for (var i2 = 0; i2 < op.value.length; i2 += 1) {
          var _op$value$i;
          if ((_op$value$i = op.value[i2]) === null || _op$value$i === void 0 ? void 0 : _op$value$i.f) {
            formulaOps.push({
              op: "replace",
              id: op.id,
              path: [].concat(_toConsumableArray$1(op.path), [i2]),
              value: op.value[i2]
            });
          }
        }
      } else if (op.path.length === 3 && ((_op$value = op.value) === null || _op$value === void 0 ? void 0 : _op$value.f)) {
        formulaOps.push(op);
      } else if (op.path.length === 4 && op.path[3] === "f") {
        formulaOps.push(op);
      }
    });
    return formulaOps;
  }
  function patchToOp(ctx, patches, options) {
    var undo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var ops = patches.map(function(p2) {
      var op = {
        op: p2.op,
        value: p2.value,
        path: p2.path
      };
      if (p2.path[0] === "luckysheetfile" && _$1.isNumber(p2.path[1])) {
        var id2 = ctx.luckysheetfile[p2.path[1]].id;
        op.id = id2;
        op.path = p2.path.slice(2);
        if (_$1.isEqual(op.path, ["calcChain", "length"])) {
          op.path = ["calcChain"];
          op.value = ctx.luckysheetfile[p2.path[1]].calcChain;
        }
      }
      return op;
    });
    _$1.every(ops, function(p2) {
      var _p$value;
      if (p2.op === "replace" && !_$1.isNil((_p$value = p2.value) === null || _p$value === void 0 ? void 0 : _p$value.hl) && p2.path.length === 3 && p2.path[0] === "data") {
        var index3 = getSheetIndex(ctx, p2.id);
        ops.push({
          id: p2.id,
          op: "replace",
          path: ["hyperlink", "".concat(p2.path[1], "_").concat(p2.path[2])],
          value: ctx.luckysheetfile[index3].hyperlink["".concat(p2.value.hl.r, "_").concat(p2.value.hl.c)]
        });
      }
    });
    if (options === null || options === void 0 ? void 0 : options.insertRowColOp) {
      var _$partition = _$1.partition(ops, function(p2) {
        return p2.path[0] !== "data";
      }), _$partition2 = _slicedToArray$1(_$partition, 2), nonDataOps = _$partition2[0], dataOps = _$partition2[1];
      var formulaOps = extractFormulaCellOps(dataOps);
      ops = nonDataOps;
      ops.push({
        op: "insertRowCol",
        id: options.insertRowColOp.id,
        path: [],
        value: options.insertRowColOp
      });
      ops = [].concat(_toConsumableArray$1(ops), _toConsumableArray$1(formulaOps));
      var mergeOps = addtionalMergeOps(ops, ctx.currentSheetId);
      ops = [].concat(_toConsumableArray$1(ops), _toConsumableArray$1(mergeOps));
      if (options === null || options === void 0 ? void 0 : options.restoreDeletedCells) {
        var restoreCellsOps = [];
        var flowdata = getFlowdata(ctx);
        if (flowdata) {
          var rowlen = flowdata.length;
          var collen = flowdata[0].length;
          for (var i2 = 0; i2 < rowlen; i2 += 1) {
            for (var j2 = 0; j2 < collen; j2 += 1) {
              var cell = flowdata[i2][j2];
              if (!cell) continue;
              if (options.insertRowColOp.type === "row" && i2 >= options.insertRowColOp.index && i2 < options.insertRowColOp.index + options.insertRowColOp.count || options.insertRowColOp.type === "column" && j2 >= options.insertRowColOp.index && j2 < options.insertRowColOp.index + options.insertRowColOp.count) {
                restoreCellsOps.push({
                  op: "replace",
                  path: ["data", i2, j2],
                  id: ctx.currentSheetId,
                  value: cell
                });
              }
            }
          }
        }
        ops = [].concat(_toConsumableArray$1(ops), restoreCellsOps);
      } else {
        var cellOps = additionalCellOps(ctx, options.insertRowColOp);
        ops = [].concat(_toConsumableArray$1(ops), _toConsumableArray$1(cellOps));
      }
    } else if (options === null || options === void 0 ? void 0 : options.deleteRowColOp) {
      var _$partition3 = _$1.partition(ops, function(p2) {
        return p2.path[0] !== "data";
      }), _$partition4 = _slicedToArray$1(_$partition3, 2), _nonDataOps = _$partition4[0], _dataOps = _$partition4[1];
      var _formulaOps = extractFormulaCellOps(_dataOps);
      ops = _nonDataOps;
      ops.push({
        op: "deleteRowCol",
        id: options.deleteRowColOp.id,
        path: [],
        value: options.deleteRowColOp
      });
      ops = [].concat(_toConsumableArray$1(ops), _toConsumableArray$1(_formulaOps));
      var _mergeOps = addtionalMergeOps(ops, ctx.currentSheetId);
      ops = [].concat(_toConsumableArray$1(ops), _toConsumableArray$1(_mergeOps));
    } else if (options === null || options === void 0 ? void 0 : options.addSheetOp) {
      var _$partition5 = _$1.partition(ops, function(op) {
        return op.path.length === 0 && op.op === "add";
      }), _$partition6 = _slicedToArray$1(_$partition5, 2), addSheetOps = _$partition6[0], otherOps = _$partition6[1];
      options.id = options.addSheet.id;
      if (undo) {
        var _options$addSheet, _options$addSheet$val, _options$addSheet2;
        var index2 = getSheetIndex(ctx, options.addSheet.id);
        var order = (_options$addSheet = options.addSheet) === null || _options$addSheet === void 0 ? void 0 : (_options$addSheet$val = _options$addSheet.value) === null || _options$addSheet$val === void 0 ? void 0 : _options$addSheet$val.order;
        ops = otherOps;
        ops.push({
          op: "deleteSheet",
          id: (_options$addSheet2 = options.addSheet) === null || _options$addSheet2 === void 0 ? void 0 : _options$addSheet2.id,
          path: [],
          value: options.addSheet
        });
        if (index2 !== ctx.luckysheetfile.length) {
          var sheetsRight = ctx.luckysheetfile.filter(function(sheet) {
            return (sheet === null || sheet === void 0 ? void 0 : sheet.order) >= order;
          });
          _$1.forEach(sheetsRight, function(sheet) {
            ops.push({
              id: sheet.id,
              op: "replace",
              path: ["order"],
              value: (sheet === null || sheet === void 0 ? void 0 : sheet.order) - 1
            });
          });
        }
      } else {
        var _options$addSheet3, _addSheetOps$;
        ops = otherOps;
        ops.push({
          op: "addSheet",
          id: (_options$addSheet3 = options.addSheet) === null || _options$addSheet3 === void 0 ? void 0 : _options$addSheet3.id,
          path: [],
          value: (_addSheetOps$ = addSheetOps[0]) === null || _addSheetOps$ === void 0 ? void 0 : _addSheetOps$.value
        });
      }
    } else if (options === null || options === void 0 ? void 0 : options.deleteSheetOp) {
      options.id = options.deleteSheetOp.id;
      if (undo) {
        var _options$deletedSheet, _options$deletedSheet2, _options$deletedSheet3, _options$deletedSheet4, _options$deletedSheet5;
        ops = [{
          op: "addSheet",
          id: options.deleteSheetOp.id,
          path: [],
          value: (_options$deletedSheet = options.deletedSheet) === null || _options$deletedSheet === void 0 ? void 0 : _options$deletedSheet.value
        }, {
          id: options.deleteSheetOp.id,
          op: "replace",
          path: ["name"],
          value: (_options$deletedSheet2 = options.deletedSheet) === null || _options$deletedSheet2 === void 0 ? void 0 : (_options$deletedSheet3 = _options$deletedSheet2.value) === null || _options$deletedSheet3 === void 0 ? void 0 : _options$deletedSheet3.name
        }];
        var _order = (_options$deletedSheet4 = options.deletedSheet) === null || _options$deletedSheet4 === void 0 ? void 0 : (_options$deletedSheet5 = _options$deletedSheet4.value) === null || _options$deletedSheet5 === void 0 ? void 0 : _options$deletedSheet5.order;
        var _sheetsRight = ctx.luckysheetfile.filter(function(sheet) {
          var _options$deleteSheetO;
          return (sheet === null || sheet === void 0 ? void 0 : sheet.order) >= _order && sheet.id !== ((_options$deleteSheetO = options.deleteSheetOp) === null || _options$deleteSheetO === void 0 ? void 0 : _options$deleteSheetO.id);
        });
        _$1.forEach(_sheetsRight, function(sheet) {
          ops.push({
            id: sheet.id,
            op: "replace",
            path: ["order"],
            value: sheet === null || sheet === void 0 ? void 0 : sheet.order
          });
        });
      } else {
        var _options$deletedSheet6, _options$deletedSheet7, _options$deletedSheet8;
        ops = [{
          op: "deleteSheet",
          id: options.deleteSheetOp.id,
          path: [],
          value: options.deletedSheet
        }];
        var _order2 = (_options$deletedSheet6 = options.deletedSheet) === null || _options$deletedSheet6 === void 0 ? void 0 : (_options$deletedSheet7 = _options$deletedSheet6.value) === null || _options$deletedSheet7 === void 0 ? void 0 : _options$deletedSheet7.order;
        if (((_options$deletedSheet8 = options.deletedSheet) === null || _options$deletedSheet8 === void 0 ? void 0 : _options$deletedSheet8.order) !== ctx.luckysheetfile.length) {
          var _sheetsRight2 = ctx.luckysheetfile.filter(function(sheet) {
            return (sheet === null || sheet === void 0 ? void 0 : sheet.order) >= _order2;
          });
          _$1.forEach(_sheetsRight2, function(sheet) {
            ops.push({
              id: sheet.id,
              op: "replace",
              path: ["order"],
              value: sheet === null || sheet === void 0 ? void 0 : sheet.order
            });
          });
        }
      }
    }
    return ops;
  }
  function opToPatch(ctx, ops) {
    var _$partition7 = _$1.partition(ops, function(op) {
      return op.op === "add" || op.op === "remove" || op.op === "replace";
    }), _$partition8 = _slicedToArray$1(_$partition7, 2), normalOps = _$partition8[0], specialOps = _$partition8[1];
    var additionalPatches = [];
    var patches = normalOps.map(function(op) {
      var patch = {
        op: op.op,
        value: op.value,
        path: op.path
      };
      if (op.id) {
        var i2 = getSheetIndex(ctx, op.id);
        if (i2 != null) {
          patch.path = ["luckysheetfile", i2].concat(_toConsumableArray$1(op.path));
        }
        if (op.path[0] === "images" && op.id === ctx.currentSheetId) {
          additionalPatches.push(_objectSpread2$1(_objectSpread2$1({}, patch), {}, {
            path: ["insertedImgs"]
          }));
        }
      }
      return patch;
    });
    return [patches.concat(additionalPatches), specialOps];
  }
  function inverseRowColOptions(options) {
    if (!options) return options;
    if (options.insertRowColOp) {
      var index2 = options.insertRowColOp.index;
      if (options.insertRowColOp.direction === "rightbottom") {
        index2 += 1;
      }
      return {
        deleteRowColOp: {
          type: options.insertRowColOp.type,
          id: options.insertRowColOp.id,
          start: index2,
          end: index2 + options.insertRowColOp.count - 1
        }
      };
    }
    if (options.deleteRowColOp) {
      return {
        insertRowColOp: {
          type: options.deleteRowColOp.type,
          id: options.deleteRowColOp.id,
          index: options.deleteRowColOp.start,
          count: options.deleteRowColOp.end - options.deleteRowColOp.start + 1,
          direction: "lefttop"
        }
      };
    }
    return options;
  }
  function generateRandomSheetName(file, isPivotTable, ctx) {
    var index2 = file.length;
    var locale_pivotTable = locale(ctx).pivotTable;
    var title = locale_pivotTable.title;
    for (var i2 = 0; i2 < file.length; i2 += 1) {
      if (file[i2].name.indexOf("Sheet") > -1 || file[i2].name.indexOf(title) > -1) {
        var suffix = parseFloat(file[i2].name.replace("Sheet", "").replace(title, ""));
        if (!Number.isNaN(suffix) && Math.ceil(suffix) > index2) {
          index2 = Math.ceil(suffix);
        }
      }
    }
    if (isPivotTable) {
      return title + (index2 + 1);
    }
    return "Sheet".concat(index2 + 1);
  }
  function rgbToHex(color) {
    var rgb;
    if (color.indexOf("rgba") > -1) {
      rgb = color.replace("rgba(", "").replace(")", "").split(",");
    } else {
      rgb = color.replace("rgb(", "").replace(")", "").split(",");
    }
    var r2 = Number(rgb[0]);
    var g2 = Number(rgb[1]);
    var b2 = Number(rgb[2]);
    return "#".concat(((1 << 24) + (r2 << 16) + (g2 << 8) + b2).toString(16).slice(1));
  }
  function indexToColumnChar(n2) {
    var orda = "a".charCodeAt(0);
    var ordz = "z".charCodeAt(0);
    var len = ordz - orda + 1;
    var s2 = "";
    while (n2 >= 0) {
      s2 = String.fromCharCode(n2 % len + orda) + s2;
      n2 = Math.floor(n2 / len) - 1;
    }
    return s2.toUpperCase();
  }
  function columnCharToIndex(a2) {
    if (a2 == null || a2.length === 0) {
      return NaN;
    }
    var str = a2.toLowerCase().split("");
    var al2 = str.length;
    var getCharNumber = function getCharNumber2(charx) {
      return charx.charCodeAt(0) - 96;
    };
    var numout = 0;
    var charnum = 0;
    for (var i2 = 0; i2 < al2; i2 += 1) {
      charnum = getCharNumber(str[i2]);
      numout += charnum * Math.pow(26, al2 - i2 - 1);
    }
    if (numout === 0) {
      return NaN;
    }
    return numout - 1;
  }
  function escapeScriptTag(str) {
    if (typeof str !== "string") return str;
    return str.replace(/<script>/g, "&lt;script&gt;").replace(/<\/script>/, "&lt;/script&gt;");
  }
  function escapeHTMLTag(str) {
    if (typeof str !== "string") return str;
    if (str.substr(0, 5) === "<span" || _$1.startsWith(str, "=")) {
      return str;
    }
    return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function getSheetIndex(ctx, id2) {
    for (var i2 = 0; i2 < ctx.luckysheetfile.length; i2 += 1) {
      var _ctx$luckysheetfile$i;
      if (((_ctx$luckysheetfile$i = ctx.luckysheetfile[i2]) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i.id) === id2) {
        return i2;
      }
    }
    return null;
  }
  function getSheetIdByName(ctx, name) {
    for (var i2 = 0; i2 < ctx.luckysheetfile.length; i2 += 1) {
      if (ctx.luckysheetfile[i2].name === name) {
        return ctx.luckysheetfile[i2].id;
      }
    }
    return null;
  }
  function getSheetByIndex(ctx, id2) {
    if (_$1.isNil(id2)) {
      id2 = ctx.currentSheetId;
    }
    var i2 = getSheetIndex(ctx, id2);
    if (_$1.isNil(i2)) {
      return null;
    }
    return ctx.luckysheetfile[i2];
  }
  function getNowDateTime(format) {
    var now = /* @__PURE__ */ new Date();
    var year = now.getFullYear();
    var month = now.getMonth();
    var date = now.getDate();
    var hour = now.getHours();
    var minu = now.getMinutes();
    var sec = now.getSeconds();
    month += 1;
    if (month < 10) month = "0".concat(month);
    if (date < 10) date = "0".concat(date);
    if (hour < 10) hour = "0".concat(hour);
    if (minu < 10) minu = "0".concat(minu);
    if (sec < 10) sec = "0".concat(sec);
    var time = "";
    {
      time = "".concat(year, "-").concat(month, "-").concat(date, " ").concat(hour, ":").concat(minu, ":").concat(sec);
    }
    return time;
  }
  function replaceHtml(temp, dataarry) {
    return temp.replace(/\$\{([\w]+)\}/g, function(s1, s2) {
      var s3 = dataarry[s2];
      if (typeof s3 !== "undefined") {
        return s3;
      }
      return s1;
    });
  }
  function getRegExpStr(str) {
    return str.replace("~*", "\\*").replace("~?", "\\?").replace(".", "\\.").replace("*", ".*").replace("?", ".");
  }
  function chatatABC(n2) {
    var orda = "a".charCodeAt(0);
    var ordz = "z".charCodeAt(0);
    var len = ordz - orda + 1;
    var s2 = "";
    while (n2 >= 0) {
      s2 = String.fromCharCode(n2 % len + orda) + s2;
      n2 = Math.floor(n2 / len) - 1;
    }
    return s2.toUpperCase();
  }
  function isAllowEdit(ctx, range) {
    var cfg = ctx.config;
    var judgeRange = _$1.isUndefined(range) ? ctx.luckysheet_select_save : range;
    return _$1.every(judgeRange, function(selection) {
      for (var r2 = selection.row[0]; r2 <= selection.row[1]; r2 += 1) {
        var _cfg$rowReadOnly;
        if ((_cfg$rowReadOnly = cfg.rowReadOnly) === null || _cfg$rowReadOnly === void 0 ? void 0 : _cfg$rowReadOnly[r2]) {
          return false;
        }
      }
      for (var c2 = selection.column[0]; c2 <= selection.column[1]; c2 += 1) {
        var _cfg$colReadOnly;
        if ((_cfg$colReadOnly = cfg.colReadOnly) === null || _cfg$colReadOnly === void 0 ? void 0 : _cfg$colReadOnly[c2]) {
          return false;
        }
      }
      return true;
    }) && (_$1.isUndefined(ctx.allowEdit) ? true : ctx.allowEdit);
  }
  var INVALID_PARAMS = new Error("invalid params");
  var SHEET_NOT_FOUND = new Error("sheet not found");
  var dataToCelldata = function dataToCelldata2(data) {
    var celldata = [];
    if (data == null) {
      return celldata;
    }
    for (var r2 = 0; r2 < data.length; r2 += 1) {
      for (var c2 = 0; c2 < data[r2].length; c2 += 1) {
        var v2 = data[r2][c2];
        if (v2 != null) {
          celldata.push({
            r: r2,
            c: c2,
            v: v2
          });
        }
      }
    }
    return celldata;
  };
  var celldataToData = function celldataToData2(celldata, rowCount, colCount) {
    var _lastRow$r, _lastCol$c;
    var lastRow = _$1.maxBy(celldata, "r");
    var lastCol = _$1.maxBy(celldata, "c");
    var lastRowNum = ((_lastRow$r = lastRow === null || lastRow === void 0 ? void 0 : lastRow.r) !== null && _lastRow$r !== void 0 ? _lastRow$r : 0) + 1;
    var lastColNum = ((_lastCol$c = lastCol === null || lastCol === void 0 ? void 0 : lastCol.c) !== null && _lastCol$c !== void 0 ? _lastCol$c : 0) + 1;
    if (rowCount != null && colCount != null && rowCount > 0 && colCount > 0) {
      lastRowNum = Math.max(lastRowNum, rowCount);
      lastColNum = Math.max(lastColNum, colCount);
    }
    if (lastRowNum && lastColNum) {
      var expandedData = _$1.times(lastRowNum, function() {
        return _$1.times(lastColNum, function() {
          return null;
        });
      });
      celldata === null || celldata === void 0 ? void 0 : celldata.forEach(function(d2) {
        expandedData[d2.r][d2.c] = d2.v;
      });
      return expandedData;
    }
    return null;
  };
  function getSheet(ctx) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _options$index = options.index, index2 = _options$index === void 0 ? getSheetIndex(ctx, options.id || ctx.currentSheetId) : _options$index;
    if (index2 == null) {
      throw SHEET_NOT_FOUND;
    }
    var sheet = ctx.luckysheetfile[index2];
    if (sheet == null) {
      throw SHEET_NOT_FOUND;
    }
    return sheet;
  }
  function getSheetWithLatestCelldata(ctx) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var sheet = getSheet(ctx, options);
    return _objectSpread2$1(_objectSpread2$1({}, sheet), {}, {
      celldata: dataToCelldata(sheet.data)
    });
  }
  function getCellValue$1(ctx, row, column) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!_$1.isNumber(row) || !_$1.isNumber(column)) {
      throw new Error("row or column cannot be null or undefined");
    }
    var sheet = getSheet(ctx, options);
    var _options$type = options.type, type = _options$type === void 0 ? "v" : _options$type;
    var targetSheetData = sheet.data;
    if (!targetSheetData) {
      throw SHEET_NOT_FOUND;
    }
    var cellData = targetSheetData[row][column];
    var ret;
    if (cellData && _$1.isPlainObject(cellData)) {
      var _cellData$ct;
      ret = cellData[type];
      if (type === "f" && ret != null) {
        ret = functionHTMLGenerate(ret);
      } else if (type === "f") {
        ret = cellData.v;
      } else if (cellData && cellData.ct && cellData.ct.fa === "yyyy-MM-dd") {
        ret = cellData.m;
      } else if (((_cellData$ct = cellData.ct) === null || _cellData$ct === void 0 ? void 0 : _cellData$ct.t) === "inlineStr") {
        ret = cellData.ct.s[0].v;
      }
    }
    if (ret === void 0) {
      ret = null;
    }
    return ret;
  }
  function setCellValue$1(ctx, row, column, value, cellInput) {
    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    if (!_$1.isNumber(row) || !_$1.isNumber(column)) {
      throw new Error("row or column cannot be null or undefined");
    }
    var sheet = getSheet(ctx, options);
    var data = sheet.data;
    var formatList = {
      bg: 1,
      ff: 1,
      fc: 1,
      bl: 1,
      it: 1,
      fs: 1,
      cl: 1,
      un: 1,
      vt: 1,
      ht: 1,
      mc: 1,
      tr: 1,
      tb: 1,
      rt: 1,
      qp: 1
    };
    if (value == null || value.toString().length === 0) {
      delFunctionGroup(ctx, row, column);
      setCellValue(ctx, row, column, data, value);
    } else if (value instanceof Object) {
      var _data$row;
      var curv = {};
      if ((data === null || data === void 0 ? void 0 : (_data$row = data[row]) === null || _data$row === void 0 ? void 0 : _data$row[column]) == null) {
        data[row][column] = {};
      }
      var cell = data[row][column];
      if (value.f != null && value.v == null) {
        curv.f = value.f;
        if (value.ct != null) {
          curv.ct = value.ct;
        }
        updateCell(ctx, row, column, cellInput, curv);
      } else {
        if (value.ct != null) {
          curv.ct = value.ct;
        }
        if (value.f != null) {
          curv.f = value.f;
        }
        if (value.v != null) {
          curv.v = value.v;
        } else {
          curv.v = cell.v;
        }
        if (value.m != null) {
          curv.m = value.m;
        }
        delFunctionGroup(ctx, row, column);
        setCellValue(ctx, row, column, data, curv);
      }
      _$1.forEach(value, function(v2, attr) {
        if (attr in formatList) {
          updateFormatCell(ctx, data, attr, v2, row, row, column, column);
        } else {
          cell[attr] = v2;
        }
      });
      data[row][column] = cell;
    } else {
      if (value.toString().substr(0, 1) === "=" || value.toString().substr(0, 5) === "<span") {
        updateCell(ctx, row, column, cellInput, value);
      } else {
        delFunctionGroup(ctx, row, column);
        setCellValue(ctx, row, column, data, value);
      }
    }
  }
  function clearCell(ctx, row, column) {
    var _sheet$data, _sheet$data$row;
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!_$1.isNumber(row) || !_$1.isNumber(column)) {
      throw new Error("row or column cannot be null or undefined");
    }
    var sheet = getSheet(ctx, options);
    var cell = (_sheet$data = sheet.data) === null || _sheet$data === void 0 ? void 0 : (_sheet$data$row = _sheet$data[row]) === null || _sheet$data$row === void 0 ? void 0 : _sheet$data$row[column];
    if (cell && _$1.isPlainObject(cell)) {
      delete cell.m;
      delete cell.v;
      if (cell.f != null) {
        delete cell.f;
        delFunctionGroup(ctx, row, column, sheet.id);
        delete cell.spl;
      }
    }
  }
  function setCellFormat(ctx, row, column, attr, value) {
    var _targetSheetData$row;
    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    if (!_$1.isNumber(row) || !_$1.isNumber(column)) {
      throw new Error("row or column cannot be null or undefined");
    }
    if (!attr) {
      throw new Error("attr cannot be null or undefined");
    }
    var sheet = getSheet(ctx, options);
    var targetSheetData = sheet.data;
    var cellData = (targetSheetData === null || targetSheetData === void 0 ? void 0 : (_targetSheetData$row = targetSheetData[row]) === null || _targetSheetData$row === void 0 ? void 0 : _targetSheetData$row[column]) || {};
    var cfg = sheet.config || {};
    if (attr === "ct" && (!value || value.fa == null || value.t == null)) {
      throw new Error("'fa' and 't' should be present in value when attr is 'ct'");
    } else if (attr === "ct" && !_$1.isNil(cellData.v)) {
      cellData.m = SSF.format(value.fa, cellData.v);
    }
    if (attr === "bd") {
      if (cfg.borderInfo == null) {
        cfg.borderInfo = [];
      }
      var borderInfo = _objectSpread2$1({
        rangeType: "range",
        borderType: "border-all",
        color: "#000",
        style: "1",
        range: [{
          column: [column, column],
          row: [row, row]
        }]
      }, value);
      cfg.borderInfo.push(borderInfo);
    } else {
      cellData[attr] = value;
    }
    targetSheetData[row][column] = cellData;
    sheet.config = cfg;
    ctx.config = cfg;
  }
  function autoFillCell(ctx, copyRange, applyRange, direction) {
    dropCellCache.copyRange = copyRange;
    dropCellCache.applyRange = applyRange;
    dropCellCache.direction = direction;
    var typeItemHide = getTypeItemHide(ctx);
    if (!typeItemHide[0] && !typeItemHide[1] && !typeItemHide[2] && !typeItemHide[3] && !typeItemHide[4] && !typeItemHide[5] && !typeItemHide[6]) {
      dropCellCache.applyType = "0";
    } else {
      dropCellCache.applyType = "1";
    }
    updateDropCell(ctx);
  }
  function freeze(ctx, type, range) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var sheet = getSheet(ctx, options);
    var typeMap = {
      row: "rangeRow",
      column: "rangeColumn",
      both: "rangeBoth"
    };
    var innerType = typeMap[type];
    sheet.frozen = {
      type: innerType,
      range: {
        column_focus: range.column,
        row_focus: range.row
      }
    };
  }
  function insertRowOrColumn(ctx, type, index2, count, direction) {
    var options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    if (!["row", "column"].includes(type) || !_$1.isNumber(index2) || !_$1.isNumber(count) || !["lefttop", "rightbottom"].includes(direction)) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    try {
      insertRowCol(ctx, {
        type,
        index: index2,
        count,
        direction,
        id: sheet.id
      });
    } catch (e) {
      console.error(e);
    }
  }
  function deleteRowOrColumn(ctx, type, start, end) {
    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    if (!["row", "column"].includes(type) || !_$1.isNumber(start) || !_$1.isNumber(end)) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    deleteRowCol(ctx, {
      type,
      start,
      end,
      id: sheet.id
    });
  }
  function setRowHeight(ctx, rowInfo) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var custom = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (!_$1.isPlainObject(rowInfo)) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    var cfg = sheet.config || {};
    if (cfg.rowlen == null) {
      cfg.rowlen = {};
    }
    _$1.forEach(rowInfo, function(len, r2) {
      if (Number(r2) >= 0) {
        if (Number(len) >= 0) {
          cfg.rowlen[Number(r2)] = Number(len);
          if (custom && _$1.isUndefined(cfg.customHeight)) {
            cfg.customHeight = _defineProperty$1({}, r2, 1);
          } else if (custom) {
            cfg.customHeight[r2] = 1;
          }
        }
      }
    });
    sheet.config = cfg;
    if (ctx.currentSheetId === sheet.id) {
      ctx.config = cfg;
    }
  }
  function setColumnWidth(ctx, columnInfo) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var custom = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (!_$1.isPlainObject(columnInfo)) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    var cfg = sheet.config || {};
    if (cfg.columnlen == null) {
      cfg.columnlen = {};
    }
    _$1.forEach(columnInfo, function(len, c2) {
      if (Number(c2) >= 0) {
        if (Number(len) >= 0) {
          cfg.columnlen[Number(c2)] = Number(len);
          if (custom && _$1.isUndefined(cfg.customWidth)) {
            cfg.customWidth = _defineProperty$1({}, c2, 1);
          } else if (custom) {
            cfg.customWidth[c2] = 1;
          }
        }
      }
    });
    sheet.config = cfg;
    if (ctx.currentSheetId === sheet.id) {
      ctx.config = cfg;
    }
  }
  function getRowHeight(ctx, rows) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!_$1.isArray(rows) || rows.length === 0) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    var cfg = sheet.config || {};
    var rowlen = cfg.rowlen || {};
    var rowlenObj = {};
    rows.forEach(function(item) {
      if (Number(item) >= 0) {
        var size2 = rowlen[Number(item)] || ctx.defaultrowlen;
        rowlenObj[Number(item)] = size2;
      }
    });
    return rowlenObj;
  }
  function getColumnWidth(ctx, columns) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!_$1.isArray(columns) || columns.length === 0) {
      throw INVALID_PARAMS;
    }
    var sheet = getSheet(ctx, options);
    var cfg = sheet.config || {};
    var columnlen = cfg.columnlen || {};
    var columnlenObj = {};
    columns.forEach(function(item) {
      if (Number(item) >= 0) {
        var size2 = columnlen[Number(item)] || ctx.defaultcollen;
        columnlenObj[Number(item)] = size2;
      }
    });
    return columnlenObj;
  }
  function getSelection(ctx) {
    var _ctx$luckysheet_selec;
    return (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec.map(function(selection) {
      return {
        row: selection.row,
        column: selection.column
      };
    });
  }
  function getFlattenRange(ctx, range) {
    var _range;
    range = range || getSelection(ctx);
    var result = [];
    (_range = range) === null || _range === void 0 ? void 0 : _range.forEach(function(ele) {
      var rs = ele.row;
      var cs = ele.column;
      for (var r2 = rs[0]; r2 <= rs[1]; r2 += 1) {
        for (var c2 = cs[0]; c2 <= cs[1]; c2 += 1) {
          result.push({
            r: r2,
            c: c2
          });
        }
      }
    });
    return result;
  }
  function getCellsByFlattenRange(ctx, range) {
    range = range || getFlattenRange(ctx);
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return [];
    return range.map(function(item) {
      var _flowdata$item$r;
      return (_flowdata$item$r = flowdata[item.r]) === null || _flowdata$item$r === void 0 ? void 0 : _flowdata$item$r[item.c];
    });
  }
  function getSelectionCoordinates(ctx) {
    var result = [];
    var rangeArr = _$1.cloneDeep(ctx.luckysheet_select_save);
    var sheetId = ctx.currentSheetId;
    rangeArr === null || rangeArr === void 0 ? void 0 : rangeArr.forEach(function(ele) {
      var rangeText = getRangetxt(ctx, sheetId, {
        column: ele.column,
        row: ele.row
      });
      result.push(rangeText);
    });
    return result;
  }
  function getCellsByRange(ctx, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var sheet = getSheet(ctx, options);
    if (!range || _typeof(range) === "object") {
      return getdatabyselection(ctx, range, sheet.id);
    }
    throw INVALID_PARAMS;
  }
  function getHtmlByRange(ctx, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var sheet = getSheet(ctx, options);
    return rangeValueToHtml(ctx, sheet.id, range);
  }
  function setSelection(ctx, range, options) {
    var sheet = getSheet(ctx, options);
    sheet.luckysheet_select_save = normalizeSelection(ctx, range);
    if (ctx.currentSheetId === sheet.id) {
      ctx.luckysheet_select_save = sheet.luckysheet_select_save;
    }
  }
  function setCellValuesByRange(ctx, data, range, cellInput) {
    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    if (data == null) {
      throw INVALID_PARAMS;
    }
    if (range instanceof Array) {
      throw new Error("setCellValuesByRange does not support multiple ranges");
    }
    if (!_$1.isPlainObject(range)) {
      throw INVALID_PARAMS;
    }
    var rowCount = range.row[1] - range.row[0] + 1;
    var columnCount = range.column[1] - range.column[0] + 1;
    if (data.length !== rowCount || data[0].length !== columnCount) {
      throw new Error("data size does not match range");
    }
    for (var i2 = 0; i2 < rowCount; i2 += 1) {
      for (var j2 = 0; j2 < columnCount; j2 += 1) {
        var row = range.row[0] + i2;
        var column = range.column[0] + j2;
        setCellValue$1(ctx, row, column, data[i2][j2], cellInput, options);
      }
    }
  }
  function setCellFormatByRange(ctx, attr, value, range) {
    var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
    if (_$1.isPlainObject(range)) {
      range = [range];
    }
    if (!_$1.isArray(range)) {
      throw INVALID_PARAMS;
    }
    range.forEach(function(singleRange) {
      for (var r2 = singleRange.row[0]; r2 <= singleRange.row[1]; r2 += 1) {
        for (var c2 = singleRange.column[0]; c2 <= singleRange.column[1]; c2 += 1) {
          setCellFormat(ctx, r2, c2, attr, value, options);
        }
      }
    });
  }
  function mergeCells$1(ctx, ranges, type) {
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var sheet = getSheet(ctx, options);
    mergeCells(ctx, sheet.id, ranges, type);
  }
  function cancelMerge(ctx, ranges) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    mergeCells$1(ctx, ranges, "merge-cancel", options);
  }
  function addSheet$1(ctx, settings, newSheetID) {
    var isPivotTable = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var sheetname = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
    var sheetData = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : void 0;
    addSheet(ctx, settings, newSheetID, isPivotTable, sheetname, sheetData);
  }
  function deleteSheet$1(ctx) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var sheet = getSheet(ctx, options);
    deleteSheet(ctx, sheet.id);
  }
  function updateSheet$1(ctx, data) {
    updateSheet(ctx, data);
  }
  function activateSheet(ctx) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var sheet = getSheet(ctx, options);
    ctx.currentSheetId = sheet.id;
  }
  function setSheetName(ctx, name) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var sheet = getSheet(ctx, options);
    sheet.name = name;
  }
  function setSheetOrder(ctx, orderList) {
    var _ctx$luckysheetfile;
    (_ctx$luckysheetfile = ctx.luckysheetfile) === null || _ctx$luckysheetfile === void 0 ? void 0 : _ctx$luckysheetfile.forEach(function(sheet) {
      if (sheet.id in orderList) {
        sheet.order = orderList[sheet.id];
      }
    });
    _$1.sortBy(ctx.luckysheetfile, ["order"]).forEach(function(sheet, i2) {
      sheet.order = i2;
    });
  }
  function scroll(ctx, scrollbarX, scrollbarY, options) {
    if (options.scrollLeft != null) {
      if (!_$1.isNumber(options.scrollLeft)) {
        throw INVALID_PARAMS;
      }
      if (scrollbarX) {
        scrollbarX.scrollLeft = options.scrollLeft;
      }
    } else if (options.targetColumn != null) {
      if (!_$1.isNumber(options.targetColumn)) {
        throw INVALID_PARAMS;
      }
      var col_pre = options.targetColumn <= 0 ? 0 : ctx.visibledatacolumn[options.targetColumn - 1];
      if (scrollbarX) {
        scrollbarX.scrollLeft = col_pre;
      }
    }
    if (options.scrollTop != null) {
      if (!_$1.isNumber(options.scrollTop)) {
        throw INVALID_PARAMS;
      }
      if (scrollbarY) {
        scrollbarY.scrollTop = options.scrollTop;
      }
    } else if (options.targetRow != null) {
      if (!_$1.isNumber(options.targetRow)) {
        throw INVALID_PARAMS;
      }
      var row_pre = options.targetRow <= 0 ? 0 : ctx.visibledatarow[options.targetRow - 1];
      if (scrollbarY) {
        scrollbarY.scrollTop = row_pre;
      }
    }
  }
  var index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getSheetWithLatestCelldata,
    dataToCelldata,
    celldataToData,
    getCellValue: getCellValue$1,
    setCellValue: setCellValue$1,
    clearCell,
    setCellFormat,
    autoFillCell,
    freeze,
    insertRowOrColumn,
    deleteRowOrColumn,
    setRowHeight,
    setColumnWidth,
    getRowHeight,
    getColumnWidth,
    getSelection,
    getFlattenRange,
    getCellsByFlattenRange,
    getSelectionCoordinates,
    getCellsByRange,
    getHtmlByRange,
    setSelection,
    setCellValuesByRange,
    setCellFormatByRange,
    mergeCells: mergeCells$1,
    cancelMerge,
    getAllSheets,
    getSheet,
    initSheetData,
    hideSheet,
    showSheet,
    copySheet,
    calculateSheetFromula,
    addSheet: addSheet$1,
    deleteSheet: deleteSheet$1,
    updateSheet: updateSheet$1,
    activateSheet,
    setSheetName,
    setSheetOrder,
    scroll
  });
  var defaultSettings = {
    column: 60,
    row: 84,
    addRows: 50,
    showToolbar: true,
    showFormulaBar: true,
    showSheetTabs: true,
    data: [],
    config: {},
    devicePixelRatio: 0,
    allowEdit: true,
    lang: null,
    forceCalculation: false,
    rowHeaderWidth: 46,
    columnHeaderHeight: 20,
    defaultColWidth: 73,
    defaultRowHeight: 19,
    defaultFontSize: 10,
    toolbarItems: ["undo", "redo", "format-painter", "clear-format", "|", "currency-format", "percentage-format", "number-decrease", "number-increase", "format", "|", "font", "|", "font-size", "|", "bold", "italic", "strike-through", "underline", "|", "font-color", "background", "border", "merge-cell", "|", "horizontal-align", "vertical-align", "text-wrap", "text-rotation", "|", "freeze", "conditionFormat", "filter", "link", "image", "comment", "quick-formula", "dataVerification", "splitColumn", "locationCondition", "screenshot", "search"],
    cellContextMenu: ["copy", "paste", "|", "insert-row", "insert-column", "delete-row", "delete-column", "delete-cell", "hide-row", "hide-column", "set-row-height", "set-column-width", "|", "clear", "sort", "orderAZ", "orderZA", "filter", "chart", "image", "link", "data", "cell-format"],
    headerContextMenu: ["copy", "paste", "|", "insert-row", "insert-column", "delete-row", "delete-column", "delete-cell", "hide-row", "hide-column", "set-row-height", "set-column-width", "|", "clear", "sort", "orderAZ", "orderZA"],
    sheetTabContextMenu: ["delete", "copy", "rename", "color", "hide", "|", "move"],
    filterContextMenu: ["sort-by-asc", "sort-by-desc", "|", "filter-by-color", "|", "filter-by-value"],
    generateSheetId: function generateSheetId() {
      return v4();
    },
    hooks: {},
    customToolbarItems: []
  };
  function handleCopy(ctx) {
    if (ctx.luckysheetPaintModelOn) {
      cancelPaintModel(ctx);
    }
    var selection = ctx.luckysheet_select_save;
    if (!selection || _$1.isEmpty(selection)) {
      return;
    }
    if (ctx.config.merge != null) {
      var has_PartMC = false;
      for (var s2 = 0; s2 < selection.length; s2 += 1) {
        var r1 = selection[s2].row[0];
        var r2 = selection[s2].row[1];
        var c1 = selection[s2].column[0];
        var c2 = selection[s2].column[1];
        has_PartMC = hasPartMC(ctx, ctx.config, r1, r2, c1, c2);
        if (has_PartMC) {
          break;
        }
      }
      if (has_PartMC) {
        return;
      }
    }
    var cdformat = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].luckysheet_conditionformat_save;
    if (!_$1.isNil(ctx.luckysheet_select_save) && ctx.luckysheet_select_save.length > 1 && !_$1.isNil(cdformat) && cdformat.length > 0) {
      var hasCF = false;
      var cf_compute = getComputeMap(ctx);
      for (var _s = 0; _s < ctx.luckysheet_select_save.length; _s += 1) {
        if (hasCF) {
          break;
        }
        var _r = ctx.luckysheet_select_save[_s].row[0];
        var _r2 = ctx.luckysheet_select_save[_s].row[1];
        var _c = ctx.luckysheet_select_save[_s].column[0];
        var _c2 = ctx.luckysheet_select_save[_s].column[1];
        for (var r3 = _r; r3 <= _r2; r3 += 1) {
          if (hasCF) {
            break;
          }
          for (var c3 = _c; c3 <= _c2; c3 += 1) {
            if (!_$1.isNil(checkCF(r3, c3, cf_compute))) {
              hasCF = true;
              break;
            }
          }
        }
      }
      if (hasCF) {
        return;
      }
    }
    if (selection.length > 1) {
      var isSameRow = true;
      var str_r = selection[0].row[0];
      var end_r = selection[0].row[1];
      var isSameCol = true;
      var str_c = selection[0].column[0];
      var end_c = selection[0].column[1];
      for (var _s2 = 1; _s2 < selection.length; _s2 += 1) {
        if (selection[_s2].row[0] !== str_r || selection[_s2].row[1] !== end_r) {
          isSameRow = false;
        }
        if (selection[_s2].column[0] !== str_c || selection[_s2].column[1] !== end_c) {
          isSameCol = false;
        }
      }
      if (!isSameRow && !isSameCol || selectIsOverlap(ctx)) {
        return;
      }
    }
    copy(ctx);
    ctx.luckysheet_paste_iscut = false;
  }
  function handleGlobalEnter(ctx, cellInput, e, canvas) {
    if ((e.altKey || e.metaKey) && ctx.luckysheetCellUpdate.length > 0) {
      var _ctx$luckysheet_selec;
      var last = (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec[ctx.luckysheet_select_save.length - 1];
      if (last && !_$1.isNil(last.row_focus) && !_$1.isNil(last.column_focus)) ;
      e.preventDefault();
    } else if (ctx.luckysheetCellUpdate.length > 0) {
      var lastCellUpdate = _$1.clone(ctx.luckysheetCellUpdate);
      updateCell(ctx, ctx.luckysheetCellUpdate[0], ctx.luckysheetCellUpdate[1], cellInput, void 0, canvas);
      ctx.luckysheet_select_save = [{
        row: [lastCellUpdate[0], lastCellUpdate[0]],
        column: [lastCellUpdate[1], lastCellUpdate[1]],
        row_focus: lastCellUpdate[0],
        column_focus: lastCellUpdate[1]
      }];
      moveHighlightCell(ctx, "down", 1);
      e.preventDefault();
    } else {
      var _ctx$luckysheet_selec2, _ctx$luckysheet_selec3;
      if (((_ctx$luckysheet_selec2 = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3.length) !== null && _ctx$luckysheet_selec2 !== void 0 ? _ctx$luckysheet_selec2 : 0) > 0) {
        var _last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
        var row_index = _last.row_focus;
        var col_index = _last.column_focus;
        ctx.luckysheetCellUpdate = [row_index, col_index];
        e.preventDefault();
      }
    }
  }
  function handleBatchSelectionWithArrowKey(ctx, e) {
    if (ctx.luckysheetCellUpdate.length > 0) {
      return;
    }
    switch (e.key) {
    }
  }
  function handleWithCtrlOrMetaKey(ctx, cache, e, cellInput, fxInput, handleUndo, handleRedo) {
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    if (e.shiftKey) {
      var _ctx$luckysheet_selec4;
      ctx.luckysheet_shiftpositon = _$1.cloneDeep((_ctx$luckysheet_selec4 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec4 === void 0 ? void 0 : _ctx$luckysheet_selec4[ctx.luckysheet_select_save.length - 1]);
      ctx.luckysheet_shiftkeydown = true;
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
        handleBatchSelectionWithArrowKey(ctx, e);
      } else if (_$1.includes([";", '"', ":", "'"], e.key)) {
        var _ctx$luckysheet_selec5;
        var last = (_ctx$luckysheet_selec5 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec5 === void 0 ? void 0 : _ctx$luckysheet_selec5[ctx.luckysheet_select_save.length - 1];
        if (!last) return;
        var row_index = last.row_focus;
        var col_index = last.column_focus;
        updateCell(ctx, row_index, col_index, cellInput);
        ctx.luckysheetCellUpdate = [row_index, col_index];
        cache.ignoreWriteCell = true;
        var value = getNowDateTime();
        cellInput.innerText = value;
        handleFormulaInput(ctx, fxInput, cellInput, e.keyCode);
      } else if (e.code === "KeyZ") {
        handleRedo();
        e.stopPropagation();
        return;
      }
    } else if (e.code === "KeyB") {
      handleBold(ctx, cellInput);
    } else if (e.code === "KeyC") {
      handleCopy(ctx);
      e.stopPropagation();
      return;
    } else if (e.code === "KeyF") {
      ctx.showSearch = true;
    } else if (e.code === "KeyH") {
      ctx.showReplace = true;
    } else if (e.code === "KeyV") {
      var _ctx$luckysheet_selec6, _ctx$luckysheet_selec7;
      if (((_ctx$luckysheet_selec6 = (_ctx$luckysheet_selec7 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec7 === void 0 ? void 0 : _ctx$luckysheet_selec7.length) !== null && _ctx$luckysheet_selec6 !== void 0 ? _ctx$luckysheet_selec6 : 0) > 1) {
        return;
      }
      selectionCache.isPasteAction = true;
      e.stopPropagation();
      return;
    } else if (e.code === "KeyX") {
      if (ctx.luckysheetPaintModelOn) {
        cancelPaintModel(ctx);
      }
      var selection = ctx.luckysheet_select_save;
      if (!selection || _$1.isEmpty(selection)) {
        return;
      }
      if (ctx.config.merge != null) {
        var has_PartMC = false;
        for (var s2 = 0; s2 < selection.length; s2 += 1) {
          var r1 = selection[s2].row[0];
          var r2 = selection[s2].row[1];
          var c1 = selection[s2].column[0];
          var c2 = selection[s2].column[1];
          has_PartMC = hasPartMC(ctx, ctx.config, r1, r2, c1, c2);
          if (has_PartMC) {
            break;
          }
        }
        if (has_PartMC) {
          return;
        }
      }
      if (selection.length > 1) {
        return;
      }
      copy(ctx);
      ctx.luckysheet_paste_iscut = true;
      e.stopPropagation();
      return;
    } else if (e.code === "KeyZ") {
      handleUndo();
      e.stopPropagation();
      return;
    } else if (e.code === "KeyA") {
      selectAll(ctx);
    }
    e.preventDefault();
  }
  function handleShiftWithArrowKey(ctx, e) {
    var _ctx$luckysheet_selec8;
    if (ctx.luckysheetCellUpdate.length > 0) {
      return;
    }
    ctx.luckysheet_shiftpositon = _$1.cloneDeep((_ctx$luckysheet_selec8 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec8 === void 0 ? void 0 : _ctx$luckysheet_selec8[ctx.luckysheet_select_save.length - 1]);
    ctx.luckysheet_shiftkeydown = true;
    switch (e.key) {
      case "ArrowUp":
        moveHighlightRange(ctx, "down", -1);
        break;
      case "ArrowDown":
        moveHighlightRange(ctx, "down", 1);
        break;
      case "ArrowLeft":
        moveHighlightRange(ctx, "right", -1);
        break;
      case "ArrowRight":
        moveHighlightRange(ctx, "right", 1);
        break;
    }
    e.preventDefault();
  }
  function handleArrowKey(ctx, e) {
    if (ctx.luckysheetCellUpdate.length > 0 || ctx.luckysheet_cell_selected_move || ctx.luckysheet_cell_selected_extend) {
      return;
    }
    var moveCount = hideCRCount(ctx, e.key);
    switch (e.key) {
      case "ArrowUp":
        moveHighlightCell(ctx, "down", -moveCount);
        break;
      case "ArrowDown":
        moveHighlightCell(ctx, "down", moveCount);
        break;
      case "ArrowLeft":
        moveHighlightCell(ctx, "right", -moveCount);
        break;
      case "ArrowRight":
        moveHighlightCell(ctx, "right", moveCount);
        break;
    }
  }
  function handleGlobalKeyDown(ctx, cellInput, fxInput, e, cache, handleUndo, handleRedo, canvas) {
    ctx.luckysheet_select_status = false;
    var kcode = e.keyCode;
    var kstr = e.key;
    if (!_$1.isEmpty(ctx.contextMenu) || ctx.filterContextMenu) {
      return;
    }
    if (kstr === "Escape" && !!ctx.luckysheet_selection_range) {
      ctx.luckysheet_selection_range = [];
    }
    var allowEdit = isAllowEdit(ctx);
    if (ctx.luckysheetCellUpdate.length > 0 && kstr !== "Enter" && kstr !== "Tab" && kstr !== "ArrowUp" && kstr !== "ArrowDown" && kstr !== "ArrowLeft" && kstr !== "ArrowRight") {
      return;
    }
    if (kstr === "Enter") {
      if (!allowEdit) return;
      handleGlobalEnter(ctx, cellInput, e, canvas);
    } else if (kstr === "Tab") {
      if (ctx.luckysheetCellUpdate.length > 0) {
        return;
      }
      moveHighlightCell(ctx, "right", 1);
      e.preventDefault();
    } else if (kstr === "F2") {
      var _ctx$luckysheet_selec9;
      if (!allowEdit) return;
      if (ctx.luckysheetCellUpdate.length > 0) {
        return;
      }
      var last = (_ctx$luckysheet_selec9 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec9 === void 0 ? void 0 : _ctx$luckysheet_selec9[ctx.luckysheet_select_save.length - 1];
      if (!last) return;
      var row_index = last.row_focus;
      var col_index = last.column_focus;
      ctx.luckysheetCellUpdate = [row_index, col_index];
      e.preventDefault();
    } else if (kstr === "F4" && ctx.luckysheetCellUpdate.length > 0) {
      e.preventDefault();
    } else if (kstr === "Escape" && ctx.luckysheetCellUpdate.length > 0) {
      cancelNormalSelected(ctx);
      moveHighlightCell(ctx, "down", 0);
      e.preventDefault();
    } else {
      if (e.ctrlKey || e.metaKey) {
        handleWithCtrlOrMetaKey(ctx, cache, e, cellInput, fxInput, handleUndo, handleRedo);
        return;
      }
      if (e.shiftKey && (kstr === "ArrowUp" || kstr === "ArrowDown" || kstr === "ArrowLeft" || kstr === "ArrowRight")) {
        handleShiftWithArrowKey(ctx, e);
      } else if (kstr === "Escape") {
        ctx.contextMenu = {};
      } else if (kstr === "Delete" || kstr === "Backspace") {
        if (!allowEdit) return;
        if (ctx.activeImg != null) {
          removeActiveImage(ctx);
        } else {
          deleteSelectedCellText(ctx);
        }
        jfrefreshgrid(ctx, null, void 0);
        e.preventDefault();
      } else if (kstr === "ArrowUp" || kstr === "ArrowDown" || kstr === "ArrowLeft" || kstr === "ArrowRight") {
        handleArrowKey(ctx, e);
      } else if (!(kcode >= 112 && kcode <= 123 || kcode <= 46 || kcode === 144 || kcode === 108 || e.ctrlKey || e.altKey || e.shiftKey && (kcode === 37 || kcode === 38 || kcode === 39 || kcode === 40)) || kcode === 8 || kcode === 32 || kcode === 46 || kcode === 0 || e.ctrlKey && kcode === 86) {
        if (!allowEdit) return;
        if (String.fromCharCode(kcode) != null && !_$1.isEmpty(ctx.luckysheet_select_save) && kstr !== "CapsLock" && kstr !== "Win" && kcode !== 18) {
          var _last2 = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
          var _row_index = _last2.row_focus;
          var _col_index = _last2.column_focus;
          ctx.luckysheetCellUpdate = [_row_index, _col_index];
          cache.overwriteCell = true;
          handleFormulaInput(ctx, fxInput, cellInput, kcode);
        }
      }
    }
    if (cellInput !== document.activeElement) {
      cellInput === null || cellInput === void 0 ? void 0 : cellInput.focus();
    }
    e.stopPropagation();
  }
  var mouseWheelUniqueTimeout;
  function handleGlobalWheel(ctx, e, cache, scrollbarX, scrollbarY) {
    var _cache$searchDialog;
    if (((_cache$searchDialog = cache.searchDialog) === null || _cache$searchDialog === void 0 ? void 0 : _cache$searchDialog.mouseEnter) && ctx.showSearch && ctx.showReplace) return;
    if (ctx.filterContextMenu != null) return;
    var scrollLeft = scrollbarX.scrollLeft;
    var scrollTop = scrollbarY.scrollTop;
    var visibledatacolumn_c = ctx.visibledatacolumn;
    var visibledatarow_c = ctx.visibledatarow;
    clearTimeout(mouseWheelUniqueTimeout);
    if (cache.visibleColumnsUnique != null) {
      visibledatacolumn_c = cache.visibleColumnsUnique;
    } else {
      visibledatacolumn_c = _$1.uniq(visibledatacolumn_c);
      cache.visibleColumnsUnique = visibledatacolumn_c;
    }
    if (cache.visibleRowsUnique != null) {
      visibledatarow_c = cache.visibleRowsUnique;
    } else {
      visibledatarow_c = _$1.uniq(visibledatarow_c);
      cache.visibleRowsUnique = visibledatarow_c;
    }
    var row_st = _$1.sortedIndex(visibledatarow_c, scrollTop) + 1;
    var rowscroll = 0;
    var scrollNum = 1;
    if (e.deltaY !== 0) {
      var row_ed;
      var step = Math.round(scrollNum / ctx.zoomRatio);
      step = step < 1 ? 1 : step;
      if (e.deltaY > 0) {
        row_ed = row_st + step;
        if (row_ed >= visibledatarow_c.length) {
          row_ed = visibledatarow_c.length - 1;
        }
      } else {
        row_ed = row_st - step;
        if (row_ed < 0) {
          row_ed = 0;
        }
      }
      rowscroll = row_ed === 0 ? 0 : visibledatarow_c[row_ed - 1];
      scrollbarY.scrollTop = rowscroll;
    } else if (e.deltaX !== 0) {
      if (e.deltaX > 0) {
        scrollLeft += 20 * ctx.zoomRatio;
      } else {
        scrollLeft -= 20 * ctx.zoomRatio;
      }
      scrollbarX.scrollLeft = scrollLeft;
    }
    mouseWheelUniqueTimeout = setTimeout(function() {
      delete cache.visibleColumnsUnique;
      delete cache.visibleRowsUnique;
    }, 500);
    e.preventDefault();
  }
  function fixPositionOnFrozenCells(freeze2, x2, y2, mouseX, mouseY) {
    var _freeze$vertical, _freeze$horizontal;
    if (!freeze2) return [x2, y2];
    var freezenverticaldata = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$vertical = freeze2.vertical) === null || _freeze$vertical === void 0 ? void 0 : _freeze$vertical.freezenverticaldata;
    var freezenhorizontaldata = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$horizontal = freeze2.horizontal) === null || _freeze$horizontal === void 0 ? void 0 : _freeze$horizontal.freezenhorizontaldata;
    if (freezenverticaldata != null && mouseX < freezenverticaldata[0] - freezenverticaldata[2]) {
      x2 = mouseX + freezenverticaldata[2];
    }
    if (freezenhorizontaldata != null && mouseY < freezenhorizontaldata[0] - freezenhorizontaldata[2]) {
      y2 = mouseY + freezenhorizontaldata[2];
    }
    return [x2, y2];
  }
  function handleCellAreaMouseDown(ctx, globalCache, e, cellInput, container, fxInput, canvas) {
    var _globalCache$freezen, _ctx$hooks$beforeCell, _ctx$hooks, _flowdata$row_index;
    ctx.contextMenu = {};
    ctx.filterContextMenu = void 0;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    var rect = container.getBoundingClientRect();
    var mouseX = e.pageX - rect.left - window.scrollX;
    var mouseY = e.pageY - rect.top - window.scrollY;
    var x2 = mouseX + ctx.scrollLeft;
    var y2 = mouseY + ctx.scrollTop;
    if (x2 >= rect.width + ctx.scrollLeft || y2 >= rect.height + ctx.scrollTop) {
      return;
    }
    var freeze2 = (_globalCache$freezen = globalCache.freezen) === null || _globalCache$freezen === void 0 ? void 0 : _globalCache$freezen[ctx.currentSheetId];
    var _fixPositionOnFrozenC = fixPositionOnFrozenCells(freeze2, x2, y2, mouseX, mouseY);
    var _fixPositionOnFrozenC2 = _slicedToArray$1(_fixPositionOnFrozenC, 2);
    x2 = _fixPositionOnFrozenC2[0];
    y2 = _fixPositionOnFrozenC2[1];
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row = row_location[1];
    var row_pre = row_location[0];
    var row_index = row_location[2];
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col = col_location[1];
    var col_pre = col_location[0];
    var col_index = col_location[2];
    var row_index_ed = row_index;
    var col_index_ed = col_index;
    var margeset = mergeBorder(ctx, flowdata, row_index, col_index);
    if (margeset) {
      var _margeset$row = _slicedToArray$1(margeset.row, 4);
      row_pre = _margeset$row[0];
      row = _margeset$row[1];
      row_index = _margeset$row[2];
      row_index_ed = _margeset$row[3];
      var _margeset$column = _slicedToArray$1(margeset.column, 4);
      col_pre = _margeset$column[0];
      col = _margeset$column[1];
      col_index = _margeset$column[2];
      col_index_ed = _margeset$column[3];
    }
    showLinkCard(ctx, row_index, col_index, false, true);
    if (((_ctx$hooks$beforeCell = (_ctx$hooks = ctx.hooks).beforeCellMouseDown) === null || _ctx$hooks$beforeCell === void 0 ? void 0 : _ctx$hooks$beforeCell.call(_ctx$hooks, (_flowdata$row_index = flowdata[row_index]) === null || _flowdata$row_index === void 0 ? void 0 : _flowdata$row_index[col_index], {
      row: row_index,
      column: col_index,
      startRow: row_pre,
      startColumn: col_pre,
      endRow: row,
      endColumn: col
    })) === false) {
      return;
    }
    cellFocus(ctx, row_index, col_index);
    if (col_pre < ctx.scrollLeft) {
      ctx.scrollLeft = col_pre;
    }
    if (row_pre < ctx.scrollTop) {
      ctx.scrollTop = row_pre;
    }
    if (e.button === 2) {
      var isInSelection = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        return obj_s.row != null && row_index >= obj_s.row[0] && row_index <= obj_s.row[1] && col_index >= obj_s.column[0] && col_index <= obj_s.column[1];
      });
      if (isInSelection) return;
    }
    ctx.luckysheet_scroll_status = true;
    if (ctx.luckysheetCellUpdate.length > 0) {
      if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
        var _$last;
        var rowseleted = [row_index, row_index_ed];
        var columnseleted = [col_index, col_index_ed];
        var left = col_pre;
        var width = col - col_pre - 1;
        var top = row_pre;
        var height = row - row_pre - 1;
        if (e.shiftKey) {
          var last = ctx.formulaCache.func_selectedrange;
          top = 0;
          height = 0;
          rowseleted = [];
          if (last == null || last.top == null || last.height == null || last.row_focus == null || last.left == null || last.width == null) return;
          if (last.top > row_pre) {
            top = row_pre;
            height = last.top + last.height - row_pre;
            if (last.row[1] > last.row_focus) {
              last.row[1] = last.row_focus;
            }
            rowseleted = [row_index, last.row[1]];
          } else if (last.top === row_pre) {
            top = row_pre;
            height = last.top + last.height - row_pre;
            rowseleted = [row_index, last.row[0]];
          } else {
            top = last.top;
            height = row - last.top - 1;
            if (last.row[0] < last.row_focus) {
              last.row[0] = last.row_focus;
            }
            rowseleted = [last.row[0], row_index];
          }
          left = 0;
          width = 0;
          columnseleted = [];
          if (last.left > col_pre) {
            left = col_pre;
            width = last.left + last.width - col_pre;
            if (last.column == null || last.column_focus == null) return;
            if (last.column[1] > last.column_focus) {
              last.column[1] = last.column_focus;
            }
            columnseleted = [col_index, last.column[1]];
          } else if (last.left === col_pre) {
            left = col_pre;
            width = last.left + last.width - col_pre;
            columnseleted = [col_index, last.column[0]];
          } else {
            left = last.left;
            width = col - last.left - 1;
            if (last.column == null || last.column_focus == null) return;
            if (last.column[0] < last.column_focus) {
              last.column[0] = last.column_focus;
            }
            columnseleted = [last.column[0], col_index];
          }
          var changeparam = mergeMoveMain(ctx, columnseleted, rowseleted, last, top, height, left, width);
          if (changeparam != null) {
            var _changeparam = _slicedToArray$1(changeparam, 6);
            columnseleted = _changeparam[0];
            rowseleted = _changeparam[1];
            top = _changeparam[2];
            height = _changeparam[3];
            left = _changeparam[4];
            width = _changeparam[5];
          }
          last.row = rowseleted;
          last.column = columnseleted;
          last.left_move = left;
          last.width_move = width;
          last.top_move = top;
          last.height_move = height;
          ctx.formulaCache.func_selectedrange = last;
        } else if (e.ctrlKey && ((_$last = _$1.last(cellInput.querySelectorAll("span"))) === null || _$last === void 0 ? void 0 : _$last.innerText) !== ",") {
          var vText = cellInput.innerText;
          if (vText[vText.length - 1] === ")") {
            vText = vText.substring(0, vText.length - 1);
          }
          if (vText.length > 0) {
            var lastWord = vText.substring(vText.length - 1, 1);
            if (lastWord !== "," && lastWord !== "=" && lastWord !== "(") {
              vText += ",";
            }
          }
          if (vText.length > 0 && vText.substring(0, 1) === "=") {
            vText = functionHTMLGenerate(vText);
            if (window.getSelection) {
              var _currSelection$anchor, _currSelection$anchor2, _currSelection$anchor3, _currSelection$anchor4;
              var currSelection = window.getSelection();
              if (currSelection == null) return;
              ctx.formulaCache.functionRangeIndex = [_$1.indexOf((_currSelection$anchor = currSelection.anchorNode) === null || _currSelection$anchor === void 0 ? void 0 : (_currSelection$anchor2 = _currSelection$anchor.parentNode) === null || _currSelection$anchor2 === void 0 ? void 0 : (_currSelection$anchor3 = _currSelection$anchor2.parentNode) === null || _currSelection$anchor3 === void 0 ? void 0 : _currSelection$anchor3.childNodes, (_currSelection$anchor4 = currSelection.anchorNode) === null || _currSelection$anchor4 === void 0 ? void 0 : _currSelection$anchor4.parentNode), currSelection.anchorOffset];
            } else {
              var textRange = document.selection.createRange();
              ctx.formulaCache.functionRangeIndex = textRange;
            }
            cellInput.innerHTML = vText;
            cancelFunctionrangeSelected(ctx);
            createRangeHightlight(ctx, vText);
          }
          ctx.formulaCache.rangestart = false;
          ctx.formulaCache.rangedrag_column_start = false;
          ctx.formulaCache.rangedrag_row_start = false;
          if (fxInput) fxInput.innerHTML = vText;
          rangeHightlightselected(ctx, cellInput);
          israngeseleciton(ctx);
          ctx.formulaCache.func_selectedrange = {
            left,
            width,
            top,
            height,
            left_move: left,
            width_move: width,
            top_move: top,
            height_move: height,
            row: rowseleted,
            column: columnseleted,
            row_focus: row_index,
            column_focus: col_index
          };
        } else {
          ctx.formulaCache.func_selectedrange = {
            left,
            width,
            top,
            height,
            left_move: left,
            width_move: width,
            top_move: top,
            height_move: height,
            row: rowseleted,
            column: columnseleted,
            row_focus: row_index,
            column_focus: col_index
          };
        }
        rangeSetValue(ctx, cellInput, {
          row: rowseleted,
          column: columnseleted
        }, fxInput);
        ctx.formulaCache.rangestart = true;
        ctx.formulaCache.rangedrag_column_start = false;
        ctx.formulaCache.rangedrag_row_start = false;
        ctx.formulaCache.selectingRangeIndex = ctx.formulaCache.rangechangeindex;
        if (ctx.formulaCache.rangechangeindex > ctx.formulaRangeHighlight.length) {
          createRangeHightlight(ctx, cellInput.innerHTML, ctx.formulaCache.rangechangeindex);
        }
        createFormulaRangeSelect(ctx, {
          rangeIndex: ctx.formulaCache.rangechangeindex || 0,
          left,
          top,
          width,
          height
        });
        e.preventDefault();
        return;
      }
      updateCell(ctx, ctx.luckysheetCellUpdate[0], ctx.luckysheetCellUpdate[1], cellInput, void 0, canvas);
      ctx.luckysheet_select_status = true;
    }
    if (checkProtectionSelectLockedOrUnLockedCells(ctx, row_index, col_index, ctx.currentSheetId)) {
      ctx.luckysheet_select_status = true;
    }
    if (ctx.luckysheet_select_status) {
      if (e.shiftKey) {
        var _ctx$luckysheet_selec;
        var _last = (_ctx$luckysheet_selec = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec === void 0 ? void 0 : _ctx$luckysheet_selec[ctx.luckysheet_select_save.length - 1];
        if (_last && _last.top != null && _last.left != null && _last.height != null && _last.width != null && _last.row_focus != null && _last.column_focus != null) {
          var _top2 = 0;
          var _height2 = 0;
          var _rowseleted2 = [];
          if (_last.top > row_pre) {
            _top2 = row_pre;
            _height2 = _last.top + _last.height - row_pre;
            if (_last.row[1] > _last.row_focus) {
              _last.row[1] = _last.row_focus;
            }
            _rowseleted2 = [row_index, _last.row[1]];
          } else if (_last.top === row_pre) {
            _top2 = row_pre;
            _height2 = _last.top + _last.height - row_pre;
            _rowseleted2 = [row_index, _last.row[0]];
          } else {
            _top2 = _last.top;
            _height2 = row - _last.top - 1;
            if (_last.row[0] < _last.row_focus) {
              _last.row[0] = _last.row_focus;
            }
            _rowseleted2 = [_last.row[0], row_index];
          }
          var _left2 = 0;
          var _width2 = 0;
          var _columnseleted2 = [];
          if (_last.left > col_pre) {
            _left2 = col_pre;
            _width2 = _last.left + _last.width - col_pre;
            if (_last.column[1] > _last.column_focus) {
              _last.column[1] = _last.column_focus;
            }
            _columnseleted2 = [col_index, _last.column[1]];
          } else if (_last.left === col_pre) {
            _left2 = col_pre;
            _width2 = _last.left + _last.width - col_pre;
            _columnseleted2 = [col_index, _last.column[0]];
          } else {
            _left2 = _last.left;
            _width2 = col - _last.left - 1;
            if (_last.column[0] < _last.column_focus) {
              _last.column[0] = _last.column_focus;
            }
            _columnseleted2 = [_last.column[0], col_index];
          }
          var _changeparam2 = mergeMoveMain(ctx, _columnseleted2, _rowseleted2, _last, _top2, _height2, _left2, _width2);
          if (_changeparam2 != null) {
            var _changeparam3 = _slicedToArray$1(_changeparam2, 6);
            _columnseleted2 = _changeparam3[0];
            _rowseleted2 = _changeparam3[1];
            _top2 = _changeparam3[2];
            _height2 = _changeparam3[3];
            _left2 = _changeparam3[4];
            _width2 = _changeparam3[5];
          }
          _last.row = _rowseleted2;
          _last.column = _columnseleted2;
          _last.left_move = _left2;
          _last.width_move = _width2;
          _last.top_move = _top2;
          _last.height_move = _height2;
          ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1] = _last;
        }
      } else if (e.ctrlKey || e.metaKey) {
        var _ctx$luckysheet_selec2;
        (_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2.push({
          left: col_pre,
          width: col - col_pre - 1,
          top: row_pre,
          height: row - row_pre - 1,
          left_move: col_pre,
          width_move: col - col_pre - 1,
          top_move: row_pre,
          height_move: row - row_pre - 1,
          row: [row_index, row_index_ed],
          column: [col_index, col_index_ed],
          row_focus: row_index,
          column_focus: col_index
        });
      } else {
        ctx.luckysheet_select_save = [{
          left: col_pre,
          width: col - col_pre - 1,
          top: row_pre,
          height: row - row_pre - 1,
          left_move: col_pre,
          width_move: col - col_pre - 1,
          top_move: row_pre,
          height_move: row - row_pre - 1,
          row: [row_index, row_index_ed],
          column: [col_index, col_index_ed],
          row_focus: row_index,
          column_focus: col_index
        }];
      }
    }
    ctx.luckysheet_select_save = normalizeSelection(ctx, ctx.luckysheet_select_save);
    if (ctx.hooks.afterCellMouseDown) {
      setTimeout(function() {
        var _ctx$hooks$afterCellM, _ctx$hooks2, _flowdata$row_index2;
        (_ctx$hooks$afterCellM = (_ctx$hooks2 = ctx.hooks).afterCellMouseDown) === null || _ctx$hooks$afterCellM === void 0 ? void 0 : _ctx$hooks$afterCellM.call(_ctx$hooks2, (_flowdata$row_index2 = flowdata[row_index]) === null || _flowdata$row_index2 === void 0 ? void 0 : _flowdata$row_index2[col_index], {
          row: row_index,
          column: col_index,
          startRow: row_pre,
          startColumn: col_pre,
          endRow: row,
          endColumn: col
        });
      });
    }
  }
  function handleCellAreaDoubleClick(ctx, globalCache, settings, e, container) {
    var _globalCache$freezen2;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    if (ctx.luckysheetCellUpdate.length > 0 && ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
      return;
    }
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var rect = container.getBoundingClientRect();
    var mouseX = e.pageX - rect.left;
    var mouseY = e.pageY - rect.top;
    var x2 = mouseX + ctx.scrollLeft;
    var y2 = mouseY + ctx.scrollTop;
    var freeze2 = (_globalCache$freezen2 = globalCache.freezen) === null || _globalCache$freezen2 === void 0 ? void 0 : _globalCache$freezen2[ctx.currentSheetId];
    var _fixPositionOnFrozenC3 = fixPositionOnFrozenCells(freeze2, x2, y2, mouseX, mouseY);
    var _fixPositionOnFrozenC4 = _slicedToArray$1(_fixPositionOnFrozenC3, 2);
    x2 = _fixPositionOnFrozenC4[0];
    y2 = _fixPositionOnFrozenC4[1];
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row_index = row_location[2];
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col_index = col_location[2];
    var index2 = getSheetIndex(ctx, ctx.currentSheetId);
    var dataVerification = ctx.luckysheetfile[index2].dataVerification;
    if (dataVerification) {
      var item = dataVerification["".concat(row_index, "_").concat(col_index)];
      if (item && item.type === "checkbox") return;
    }
    var margeset = mergeBorder(ctx, flowdata, row_index, col_index);
    if (margeset) {
      var _margeset$row2 = _slicedToArray$1(margeset.row, 3);
      row_index = _margeset$row2[2];
      var _margeset$column2 = _slicedToArray$1(margeset.column, 3);
      col_index = _margeset$column2[2];
    }
    var _ctx$luckysheet_selec3 = ctx.luckysheet_select_save[0], column_focus = _ctx$luckysheet_selec3.column_focus, row_focus = _ctx$luckysheet_selec3.row_focus;
    if (!_$1.isNil(column_focus) && !_$1.isNil(row_focus) && (column_focus !== col_index || row_focus !== row_index)) {
      row_index = row_focus;
      col_index = column_focus;
    }
    luckysheetUpdateCell(ctx, row_index, col_index);
  }
  function handleContextMenu(ctx, settings, e, workbookContainer, container, area) {
    e.preventDefault();
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var flowdata = getFlowdata(ctx);
    if (!flowdata) return;
    var workbookRect = workbookContainer.getBoundingClientRect();
    var cellContextMenu = settings.cellContextMenu;
    if (_$1.isEmpty(cellContextMenu)) {
      return;
    }
    var x2 = e.pageX - workbookRect.left + workbookRect.x;
    var y2 = e.pageY - workbookRect.top + workbookRect.y;
    ctx.contextMenu = {
      x: x2,
      y: y2,
      pageX: e.pageX,
      pageY: e.pageY
    };
    e.preventDefault();
    if (area === "cell") {
      var _flowdata$row_index$c2;
      _$1.set(ctx.contextMenu, "headerMenu", false);
      var rect = container.getBoundingClientRect();
      var mouseX = e.pageX - rect.left - window.scrollX;
      var mouseY = e.pageY - rect.top - window.scrollY;
      var selected_x = mouseX + ctx.scrollLeft;
      var selected_y = mouseY + ctx.scrollTop;
      var _fixPositionOnFrozenC5 = fixPositionOnFrozenCells(void 0, selected_x, selected_y, mouseX, mouseY);
      var _fixPositionOnFrozenC6 = _slicedToArray$1(_fixPositionOnFrozenC5, 2);
      selected_x = _fixPositionOnFrozenC6[0];
      selected_y = _fixPositionOnFrozenC6[1];
      var row_location = rowLocation(selected_y, ctx.visibledatarow);
      var row = row_location[1];
      var row_pre = row_location[0];
      var row_index = row_location[2];
      var col_location = colLocation(selected_x, ctx.visibledatacolumn);
      var col = col_location[1];
      var col_pre = col_location[0];
      var col_index = col_location[2];
      var isInSelection = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        return obj_s.row != null && row_index >= obj_s.row[0] && row_index <= obj_s.row[1] && col_index >= obj_s.column[0] && col_index <= obj_s.column[1];
      });
      if (!isInSelection && (e.metaKey || e.ctrlKey)) {
        var _flowdata$row_index$c, _ctx$luckysheet_selec5;
        if ((_flowdata$row_index$c = flowdata[row_index][col_index]) === null || _flowdata$row_index$c === void 0 ? void 0 : _flowdata$row_index$c.mc) {
          var changeparam = mergeMoveMain(ctx, [col_index, col_index], [row_index, row_index], {
            row_focus: row_index,
            column_focus: col_index
          }, row_pre, row, col_pre, col);
          if (changeparam != null) {
            var _ctx$luckysheet_selec4;
            var _changeparam4 = _slicedToArray$1(changeparam, 6), columnseleted = _changeparam4[0], rowseleted = _changeparam4[1], top = _changeparam4[2], height = _changeparam4[3], left = _changeparam4[4], width = _changeparam4[5];
            (_ctx$luckysheet_selec4 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec4 === void 0 ? void 0 : _ctx$luckysheet_selec4.push({
              left,
              width: width - 1,
              top,
              height: height - 1,
              left_move: left,
              width_move: width,
              top_move: top,
              height_move: height,
              row: rowseleted,
              column: columnseleted,
              row_focus: rowseleted[0],
              column_focus: columnseleted[0]
            });
            return;
          }
        }
        (_ctx$luckysheet_selec5 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec5 === void 0 ? void 0 : _ctx$luckysheet_selec5.push({
          left: col_pre,
          width: col - col_pre - 1,
          top: row_pre,
          height: row - row_pre - 1,
          left_move: col_pre,
          width_move: col - col_pre - 1,
          top_move: row_pre,
          height_move: row - row_pre - 1,
          row: [row_index, row_index],
          column: [col_index, col_index],
          row_focus: row_index,
          column_focus: col_index
        });
        return;
      }
      if (isInSelection) return;
      var row_index_ed = row_index;
      var col_index_ed = col_index;
      if ((_flowdata$row_index$c2 = flowdata[row_index][col_index]) === null || _flowdata$row_index$c2 === void 0 ? void 0 : _flowdata$row_index$c2.mc) {
        var _changeparam5 = mergeMoveMain(ctx, [col_index, col_index], [row_index, row_index], {
          row_focus: row_index,
          column_focus: col_index
        }, row_pre, row, col_pre, col);
        if (_changeparam5 != null) {
          var _changeparam6 = _slicedToArray$1(_changeparam5, 6), _columnseleted3 = _changeparam6[0], _rowseleted3 = _changeparam6[1], _top3 = _changeparam6[2], _height3 = _changeparam6[3], _left3 = _changeparam6[4], _width3 = _changeparam6[5];
          ctx.luckysheet_select_save = [{
            left: _left3,
            width: _width3 - 1,
            top: _top3,
            height: _height3 - 1,
            left_move: _left3,
            width_move: _width3,
            top_move: _top3,
            height_move: _height3,
            row: _rowseleted3,
            column: _columnseleted3,
            row_focus: _rowseleted3[0],
            column_focus: _columnseleted3[0]
          }];
          return;
        }
      }
      ctx.luckysheet_select_save = [{
        left: col_pre,
        width: col - col_pre - 1,
        top: row_pre,
        height: row - row_pre - 1,
        left_move: col_pre,
        width_move: col - col_pre - 1,
        top_move: row_pre,
        height_move: row - row_pre - 1,
        row: [row_index, row_index_ed],
        column: [col_index, col_index_ed],
        row_focus: row_index,
        column_focus: col_index
      }];
    } else if (area === "rowHeader") {
      _$1.set(ctx.contextMenu, "headerMenu", true);
      var _rect = container.getBoundingClientRect();
      var _selected_y = e.pageY - _rect.top + ctx.scrollTop;
      var _row_location = rowLocation(_selected_y, ctx.visibledatarow);
      var _row = _row_location[1];
      var _row_pre = _row_location[0];
      var _row_index = _row_location[2];
      var _isInSelection = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        return obj_s.row != null && _row_index >= obj_s.row[0] && _row_index <= obj_s.row[1] && !obj_s.column_select;
      });
      if (_isInSelection) return;
      var _col_index = ctx.visibledatacolumn.length - 1;
      var _col = ctx.visibledatacolumn[_col_index];
      var _col_pre = 0;
      var _top4 = _row_pre;
      var _height4 = _row - _row_pre - 1;
      var _rowseleted4 = [_row_index, _row_index];
      ctx.luckysheet_select_save = [];
      ctx.luckysheet_select_save.push({
        left: colLocationByIndex(0, ctx.visibledatacolumn)[0],
        width: colLocationByIndex(0, ctx.visibledatacolumn)[1] - colLocationByIndex(0, ctx.visibledatacolumn)[0] - 1,
        top: _top4,
        height: _height4,
        left_move: _col_pre,
        width_move: _col - _col_pre - 1,
        top_move: _top4,
        height_move: _height4,
        row: _rowseleted4,
        column: [0, _col_index],
        row_focus: _row_index,
        column_focus: 0,
        row_select: true
      });
    } else if (area === "columnHeader") {
      _$1.set(ctx.contextMenu, "headerMenu", true);
      var _rect2 = container.getBoundingClientRect();
      var _selected_x = e.pageX - _rect2.left + ctx.scrollLeft;
      var _row_index2 = ctx.visibledatarow.length - 1;
      var _row2 = ctx.visibledatarow[_row_index2];
      var _row_pre2 = 0;
      var _col_location = colLocation(_selected_x, ctx.visibledatacolumn);
      var _col2 = _col_location[1];
      var _col_pre2 = _col_location[0];
      var _col_index2 = _col_location[2];
      var _isInSelection2 = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        return obj_s.row != null && _col_index2 >= obj_s.column[0] && _col_index2 <= obj_s.column[1] && !obj_s.row_select;
      });
      if (_isInSelection2) return;
      var _left4 = _col_pre2;
      var _width4 = _col2 - _col_pre2 - 1;
      var _columnseleted4 = [_col_index2, _col_index2];
      ctx.luckysheet_select_save = [];
      ctx.luckysheet_select_save.push({
        left: _left4,
        width: _width4,
        top: rowLocationByIndex(0, ctx.visibledatarow)[0],
        height: rowLocationByIndex(0, ctx.visibledatarow)[1] - rowLocationByIndex(0, ctx.visibledatarow)[0] - 1,
        left_move: _left4,
        width_move: _width4,
        top_move: _row_pre2,
        height_move: _row2 - _row_pre2 - 1,
        row: [0, _row_index2],
        column: _columnseleted4,
        row_focus: 0,
        column_focus: _col_index2,
        column_select: true
      });
    }
  }
  function mouseRender(ctx, globalCache, e, cellInput, scrollX, scrollY, container, fxInput) {
    var _ctx$rangeDialog;
    var rect = container.getBoundingClientRect();
    if (ctx.luckysheet_scroll_status && !ctx.luckysheet_cols_change_size && !ctx.luckysheet_rows_change_size) {
      var left = ctx.scrollLeft;
      var top = ctx.scrollTop;
      var x2 = e.pageX - rect.left - window.scrollX;
      var y2 = e.pageY - rect.top - window.scrollY;
      var winH = rect.height - 20 * ctx.zoomRatio;
      var winW = rect.width - 60 * ctx.zoomRatio;
      if (y2 < 0 || y2 > winH) {
        var stop;
        if (y2 < 0) {
          stop = top + y2 / 2;
        } else {
          stop = top + (y2 - winH) / 2;
        }
        scrollY.scrollTop = stop;
      }
      if (x2 < 0 || x2 > winW) {
        var sleft;
        if (x2 < 0) {
          sleft = left + x2 / 2;
        } else {
          sleft = left + (x2 - winW) / 2;
        }
        scrollX.scrollLeft = sleft;
      }
    }
    if ((_ctx$rangeDialog = ctx.rangeDialog) === null || _ctx$rangeDialog === void 0 ? void 0 : _ctx$rangeDialog.singleSelect) {
      return;
    }
    if (ctx.luckysheet_select_status) {
      var _ctx$luckysheet_selec6, _globalCache$freezen3;
      var _x = e.pageX - rect.left - window.scrollX - ctx.rowHeaderWidth + ctx.scrollLeft;
      var _y = e.pageY - rect.top - window.scrollY - ctx.columnHeaderHeight + ctx.scrollTop;
      var row_location = rowLocation(_y, ctx.visibledatarow);
      var row = row_location[1];
      var row_pre = row_location[0];
      var row_index = row_location[2];
      var col_location = colLocation(_x, ctx.visibledatacolumn);
      var col = col_location[1];
      var col_pre = col_location[0];
      var col_index = col_location[2];
      if (!checkProtectionSelectLockedOrUnLockedCells(ctx, row_index, col_index, ctx.currentSheetId)) {
        ctx.luckysheet_select_status = false;
        return;
      }
      var last = _$1.cloneDeep((_ctx$luckysheet_selec6 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec6 === void 0 ? void 0 : _ctx$luckysheet_selec6[ctx.luckysheet_select_save.length - 1]);
      if (!last || _$1.isNil(last.left) || _$1.isNil(last.top) || _$1.isNil(last.height) || _$1.isNil(last.width) || _$1.isNil(last.row_focus) || _$1.isNil(last.column_focus)) {
        return;
      }
      var _top5 = 0;
      var height = 0;
      var rowseleted = [];
      if (last.top > row_pre) {
        _top5 = row_pre;
        height = last.top + last.height - row_pre;
        if (last.row[1] > last.row_focus) {
          last.row[1] = last.row_focus;
        }
        rowseleted = [row_index, last.row[1]];
      } else if (last.top === row_pre) {
        _top5 = row_pre;
        height = last.top + last.height - row_pre;
        rowseleted = [row_index, last.row[0]];
      } else {
        _top5 = last.top;
        height = row - last.top - 1;
        if (last.row[0] < last.row_focus) {
          last.row[0] = last.row_focus;
        }
        rowseleted = [last.row[0], row_index];
      }
      var _left5 = 0;
      var width = 0;
      var columnseleted = [];
      if (last.left > col_pre) {
        _left5 = col_pre;
        width = last.left + last.width - col_pre;
        if (last.column[1] > last.column_focus) {
          last.column[1] = last.column_focus;
        }
        columnseleted = [col_index, last.column[1]];
      } else if (last.left === col_pre) {
        _left5 = col_pre;
        width = last.left + last.width - col_pre;
        columnseleted = [col_index, last.column[0]];
      } else {
        _left5 = last.left;
        width = col - last.left - 1;
        if (last.column[0] < last.column_focus) {
          last.column[0] = last.column_focus;
        }
        columnseleted = [last.column[0], col_index];
      }
      var changeparam = mergeMoveMain(ctx, columnseleted, rowseleted, last, _top5, height, _left5, width);
      if (changeparam != null) {
        var _changeparam7 = _slicedToArray$1(changeparam, 6);
        columnseleted = _changeparam7[0];
        rowseleted = _changeparam7[1];
        _top5 = _changeparam7[2];
        height = _changeparam7[3];
        _left5 = _changeparam7[4];
        width = _changeparam7[5];
      }
      last.row = rowseleted;
      last.column = columnseleted;
      last.left_move = _left5;
      last.width_move = width;
      last.top_move = _top5;
      last.height_move = height;
      var isMaxColumn = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1].column;
      var colMax = ctx.visibledatacolumn.length - 1;
      if (isMaxColumn[0] === 0 && isMaxColumn[1] === colMax) {
        last.column[1] = colMax;
        last.width_move = ctx.visibledatacolumn[colMax] - 1;
      }
      var isMaxRow = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1].row;
      var rowMax = ctx.visibledatarow.length - 1;
      if (isMaxRow[0] === 0 && isMaxRow[1] === rowMax) {
        last.row[1] = rowMax;
        last.height_move = ctx.visibledatarow[rowMax] - 1;
      }
      ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1] = last;
      scrollToFrozenRowCol(ctx, (_globalCache$freezen3 = globalCache.freezen) === null || _globalCache$freezen3 === void 0 ? void 0 : _globalCache$freezen3[ctx.currentSheetId]);
    } else if (ctx.formulaCache.rangestart) {
      rangeDrag(ctx, e, cellInput, scrollX.scrollLeft, scrollY.scrollTop, container, fxInput);
    } else if (ctx.formulaCache.rangedrag_row_start) {
      rangeDragRow(ctx, e, cellInput, scrollX.scrollLeft, scrollY.scrollTop, container, fxInput);
    } else if (ctx.formulaCache.rangedrag_column_start) {
      rangeDragColumn(ctx, e, cellInput, scrollX.scrollLeft, scrollY.scrollTop, container, fxInput);
    } else if (ctx.luckysheet_rows_selected_status) ;
    else if (ctx.luckysheet_cols_selected_status) ;
    else if (ctx.luckysheet_cell_selected_move) ;
    else if (ctx.luckysheet_cell_selected_extend) {
      onDropCellSelect(ctx, e, scrollX, scrollY, container);
    } else if (ctx.luckysheet_cols_change_size) {
      var _x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollX.scrollLeft;
      if (_x2 + 3 - ctx.luckysheet_cols_change_size_start[0] > 30 && _x2 < rect.width + ctx.scrollLeft - 100) {
        var changeSizeLine = container.querySelector(".fortune-change-size-line");
        if (changeSizeLine) {
          changeSizeLine.style.left = "".concat(_x2, "px");
        }
        var changeSizeCol = container.querySelector(".fortune-cols-change-size");
        if (changeSizeCol) {
          changeSizeCol.style.left = "".concat(_x2 - 2, "px");
        }
      }
    } else if (ctx.luckysheet_rows_change_size) {
      var _y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollY.scrollTop;
      if (_y2 + 3 - ctx.luckysheet_rows_change_size_start[0] > 19 && _y2 < rect.height + ctx.scrollTop - 20) {
        var _changeSizeLine = container.querySelector(".fortune-change-size-line");
        if (_changeSizeLine) {
          _changeSizeLine.style.top = "".concat(_y2, "px");
        }
        var changeSizeRow = container.querySelector(".fortune-rows-change-size");
        if (changeSizeRow) {
          changeSizeRow.style.top = "".concat(_y2, "px");
        }
      }
    } else if (ctx.luckysheet_cols_freeze_drag) {
      var _x3 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollX.scrollLeft;
      var _col_location2 = colLocation(_x3, ctx.visibledatacolumn);
      var _col_pre3 = _col_location2[0];
      if (_x3 < rect.width + ctx.scrollLeft - 100) {
        var freezeLine = container.querySelector(".fortune-freeze-drag-line");
        if (freezeLine) {
          freezeLine.style.left = "".concat(_col_pre3 - 3, "px");
        }
        var freezeHandle = container.querySelector(".fortune-cols-freeze-handle");
        if (freezeHandle) {
          freezeHandle.style.left = "".concat(_x3, "px");
        }
        var _changeSizeLine2 = container.querySelector(".fortune-change-size-line");
        if (_changeSizeLine2) {
          _changeSizeLine2.style.left = "".concat(_x3, "px");
        }
      }
    } else if (ctx.luckysheet_rows_freeze_drag) {
      var _y3 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollY.scrollTop;
      var _row_location2 = rowLocation(_y3, ctx.visibledatarow);
      var _row_pre3 = _row_location2[0];
      if (_y3 < rect.height + ctx.scrollTop - 20) {
        var _freezeLine = container.querySelector(".fortune-freeze-drag-line");
        if (_freezeLine) {
          _freezeLine.style.top = "".concat(_row_pre3 - 3, "px");
        }
        var _freezeHandle = container.querySelector(".fortune-rows-freeze-handle");
        if (_freezeHandle) {
          _freezeHandle.style.top = "".concat(_y3, "px");
        }
        var _changeSizeLine3 = container.querySelector(".fortune-change-size-line");
        if (_changeSizeLine3) {
          _changeSizeLine3.style.top = "".concat(_y3, "px");
        }
      }
    }
  }
  function handleOverlayMouseMove(ctx, globalCache, e, cellInput, scrollX, scrollY, container, fxInput) {
    if (onCommentBoxResize(ctx, globalCache, e)) return;
    if (onCommentBoxMove(ctx, globalCache, e)) return;
    if (onImageMove(ctx, globalCache, e)) return;
    if (onImageResize(ctx, globalCache, e)) return;
    onCellsMove(ctx, globalCache, e, scrollX, scrollY, container);
    overShowComment(ctx, e, scrollX, scrollY, container);
    onSearchDialogMove(globalCache, e);
    onRangeSelectionModalMove(globalCache, e);
    if (!!ctx.luckysheet_scroll_status || !!ctx.luckysheet_select_status || !!ctx.luckysheet_rows_selected_status || !!ctx.luckysheet_cols_selected_status || !!ctx.luckysheet_cell_selected_move || !!ctx.luckysheet_cell_selected_extend || !!ctx.luckysheet_cols_change_size || !!ctx.luckysheet_rows_change_size) {
      mouseRender(ctx, globalCache, e, cellInput, scrollX, scrollY, container, fxInput);
    }
  }
  function handleOverlayMouseUp(ctx, globalCache, settings, e, scrollbarX, scrollbarY, container, cellInput, fxInput) {
    var rect = container.getBoundingClientRect();
    onImageMoveEnd(ctx, globalCache);
    onImageResizeEnd(ctx, globalCache);
    onCommentBoxMoveEnd(ctx, globalCache);
    onCommentBoxResizeEnd(ctx, globalCache);
    onFormulaRangeDragEnd(ctx);
    onSearchDialogMoveEnd(globalCache);
    onRangeSelectionModalMoveEnd(globalCache);
    onCellsMoveEnd(ctx, globalCache, e, scrollbarX, scrollbarY, container);
    if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start) {
      var _document$activeEleme;
      if (((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.id) === "luckysheet-functionbox-cell") {
        handleFormulaInput(ctx, cellInput, fxInput, 0, void 0, false);
      } else {
        handleFormulaInput(ctx, fxInput, cellInput, 0, void 0, false);
      }
    }
    if (ctx.luckysheet_select_status) {
      if (ctx.luckysheetPaintModelOn) {
        pasteHandlerOfPaintModel(ctx, ctx.luckysheet_copy_save);
        if (ctx.luckysheetPaintSingle) {
          cancelPaintModel(ctx);
        }
      }
    }
    ctx.luckysheet_select_status = false;
    ctx.luckysheet_scroll_status = false;
    ctx.luckysheet_rows_selected_status = false;
    ctx.luckysheet_cols_selected_status = false;
    ctx.luckysheet_model_move_state = false;
    if (ctx.luckysheet_rows_change_size) {
      var _ctx$luckysheet_selec7, _ctx$luckysheet_selec8;
      ctx.luckysheet_rows_change_size = false;
      var scrollTop = ctx.scrollTop;
      var y2 = e.pageY - rect.top - ctx.columnHeaderHeight + scrollTop;
      var winH = rect.height;
      var size2 = y2 + 3 - ctx.luckysheet_rows_change_size_start[0];
      if (y2 + 3 - ctx.luckysheet_rows_change_size_start[0] < 19) {
        size2 = 19;
      }
      if (y2 >= winH - 20 + scrollTop) {
        size2 = winH - 20 - ctx.luckysheet_rows_change_size_start[0] + scrollTop;
      }
      var cfg = ctx.config;
      if (cfg.rowlen == null) {
        cfg.rowlen = {};
      }
      if (cfg.customHeight == null) {
        cfg.customHeight = {};
      }
      cfg.customHeight[ctx.luckysheet_rows_change_size_start[1]] = 1;
      var changeRowIndex = ctx.luckysheet_rows_change_size_start[1];
      var changeRowSelected = false;
      if (((_ctx$luckysheet_selec7 = (_ctx$luckysheet_selec8 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec8 === void 0 ? void 0 : _ctx$luckysheet_selec8.length) !== null && _ctx$luckysheet_selec7 !== void 0 ? _ctx$luckysheet_selec7 : 0) > 0) {
        var _ctx$luckysheet_selec9, _ctx$luckysheet_selec10;
        (_ctx$luckysheet_selec9 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec9 === void 0 ? void 0 : (_ctx$luckysheet_selec10 = _ctx$luckysheet_selec9.filter(function(select) {
          return select.row_select;
        })) === null || _ctx$luckysheet_selec10 === void 0 ? void 0 : _ctx$luckysheet_selec10.some(function(select) {
          if (changeRowIndex >= select.row[0] && changeRowIndex <= select.row[1]) {
            changeRowSelected = true;
          }
          return changeRowSelected;
        });
      }
      if (changeRowSelected) {
        var _ctx$luckysheet_selec11, _ctx$luckysheet_selec12;
        cfg.rowlen || (cfg.rowlen = {});
        (_ctx$luckysheet_selec11 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec11 === void 0 ? void 0 : (_ctx$luckysheet_selec12 = _ctx$luckysheet_selec11.filter(function(select) {
          return select.row_select;
        })) === null || _ctx$luckysheet_selec12 === void 0 ? void 0 : _ctx$luckysheet_selec12.forEach(function(select) {
          for (var r2 = select.row[0]; r2 <= select.row[1]; r2 += 1) {
            cfg.rowlen[r2] = Math.ceil(size2 / ctx.zoomRatio);
          }
        });
      } else {
        cfg.rowlen[ctx.luckysheet_rows_change_size_start[1]] = Math.ceil(size2 / ctx.zoomRatio);
      }
      ctx.config = cfg;
      var idx = getSheetIndex(ctx, ctx.currentSheetId);
      if (idx == null) return;
      ctx.luckysheetfile[idx].config = ctx.config;
    }
    if (ctx.luckysheet_cols_change_size) {
      var _ctx$luckysheet_selec13, _ctx$luckysheet_selec14;
      ctx.luckysheet_cols_change_size = false;
      var scrollLeft = ctx.scrollLeft;
      var x2 = e.pageX - rect.left - ctx.rowHeaderWidth + scrollLeft;
      var winW = rect.width;
      var _size = x2 + 3 - ctx.luckysheet_cols_change_size_start[0];
      var firstcolumnlen = ctx.defaultcollen;
      if (ctx.config.columnlen != null && ctx.config.columnlen[ctx.luckysheet_cols_change_size_start[1]] != null) {
        firstcolumnlen = ctx.config.columnlen[ctx.luckysheet_cols_change_size_start[1]];
      }
      if (Math.abs(_size - firstcolumnlen) < 3) {
        return;
      }
      if (x2 + 3 - ctx.luckysheet_cols_change_size_start[0] < 30) {
        _size = 30;
      }
      if (x2 >= winW - 100 + scrollLeft) {
        _size = winW - 100 - ctx.luckysheet_cols_change_size_start[0] + scrollLeft;
      }
      var _cfg = ctx.config;
      if (_cfg.columnlen == null) {
        _cfg.columnlen = {};
      }
      if (_cfg.customWidth == null) {
        _cfg.customWidth = {};
      }
      _cfg.customWidth[ctx.luckysheet_cols_change_size_start[1]] = 1;
      var changeColumnIndex = ctx.luckysheet_cols_change_size_start[1];
      var changeColumnSelected = false;
      if (((_ctx$luckysheet_selec13 = (_ctx$luckysheet_selec14 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec14 === void 0 ? void 0 : _ctx$luckysheet_selec14.length) !== null && _ctx$luckysheet_selec13 !== void 0 ? _ctx$luckysheet_selec13 : 0) > 0) {
        var _ctx$luckysheet_selec15, _ctx$luckysheet_selec16;
        (_ctx$luckysheet_selec15 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec15 === void 0 ? void 0 : (_ctx$luckysheet_selec16 = _ctx$luckysheet_selec15.filter(function(select) {
          return select.column_select;
        })) === null || _ctx$luckysheet_selec16 === void 0 ? void 0 : _ctx$luckysheet_selec16.some(function(select) {
          if (changeColumnIndex >= select.column[0] && changeColumnIndex <= select.column[1]) {
            changeColumnSelected = true;
          }
          return changeColumnSelected;
        });
      }
      if (changeColumnSelected) {
        var _ctx$luckysheet_selec17, _ctx$luckysheet_selec18;
        _cfg.columnlen || (_cfg.columnlen = {});
        (_ctx$luckysheet_selec17 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec17 === void 0 ? void 0 : (_ctx$luckysheet_selec18 = _ctx$luckysheet_selec17.filter(function(select) {
          return select.column_select;
        })) === null || _ctx$luckysheet_selec18 === void 0 ? void 0 : _ctx$luckysheet_selec18.forEach(function(select) {
          for (var r2 = select.column[0]; r2 <= select.column[1]; r2 += 1) {
            _cfg.columnlen[r2] = Math.ceil(_size / ctx.zoomRatio);
          }
        });
      } else {
        _cfg.columnlen[ctx.luckysheet_cols_change_size_start[1]] = Math.ceil(_size / ctx.zoomRatio);
      }
      ctx.config = _cfg;
      var _idx = getSheetIndex(ctx, ctx.currentSheetId);
      if (_idx == null) return;
      ctx.luckysheetfile[_idx].config = ctx.config;
    }
    if (ctx.luckysheet_cols_freeze_drag) {
      ctx.luckysheet_cols_freeze_drag = false;
      var _scrollLeft = ctx.scrollLeft;
      var _x4 = e.pageX - rect.left - ctx.rowHeaderWidth + _scrollLeft;
      var col_location = colLocation(_x4, ctx.visibledatacolumn);
      var col_index = col_location[2] - 1;
      var _idx2 = getSheetIndex(ctx, ctx.currentSheetId);
      if (_idx2 == null) return;
      if (col_index < 0) {
        var frozen = ctx.luckysheetfile[_idx2].frozen;
        if (frozen) {
          if (frozen.type === "rangeBoth" || frozen.type === "both") {
            frozen.type = "rangeRow";
          } else if (frozen.type === "column" || frozen.type === "rangeColumn") {
            delete ctx.luckysheetfile[_idx2].frozen;
          }
        }
      } else if (!ctx.luckysheetfile[_idx2].frozen) {
        ctx.luckysheetfile[_idx2].frozen = {
          type: "rangeColumn",
          range: {
            column_focus: col_index,
            row_focus: 0
          }
        };
      } else {
        var _frozen = ctx.luckysheetfile[_idx2].frozen;
        if (!_frozen.range) {
          _frozen.range = {
            column_focus: col_index,
            row_focus: 0
          };
        } else {
          _frozen.range.column_focus = col_index;
        }
        if ((_frozen === null || _frozen === void 0 ? void 0 : _frozen.type) === "rangeRow" || (_frozen === null || _frozen === void 0 ? void 0 : _frozen.type) === "row") {
          _frozen.type = "rangeBoth";
        }
      }
    }
    if (ctx.luckysheet_rows_freeze_drag) {
      ctx.luckysheet_rows_freeze_drag = false;
      var _scrollTop = ctx.scrollTop;
      var _y4 = e.pageY - rect.top - ctx.columnHeaderHeight + _scrollTop;
      var row_location = rowLocation(_y4, ctx.visibledatarow);
      var row_index = row_location[2] - 1;
      var _idx3 = getSheetIndex(ctx, ctx.currentSheetId);
      if (_idx3 == null) return;
      if (row_index < 0) {
        var _frozen2 = ctx.luckysheetfile[_idx3].frozen;
        if (_frozen2) {
          if (_frozen2.type === "rangeBoth" || _frozen2.type === "both") {
            _frozen2.type = "rangeColumn";
          } else if (_frozen2.type === "row" || _frozen2.type === "rangeRow") {
            delete ctx.luckysheetfile[_idx3].frozen;
          }
        }
      } else if (!ctx.luckysheetfile[_idx3].frozen) {
        ctx.luckysheetfile[_idx3].frozen = {
          type: "rangeRow",
          range: {
            column_focus: 0,
            row_focus: row_index
          }
        };
      } else {
        var _frozen3 = ctx.luckysheetfile[_idx3].frozen;
        if (!_frozen3.range) {
          _frozen3.range = {
            column_focus: 0,
            row_focus: row_index
          };
        } else {
          _frozen3.range.row_focus = row_index;
        }
        if ((_frozen3 === null || _frozen3 === void 0 ? void 0 : _frozen3.type) === "rangeColumn" || (_frozen3 === null || _frozen3 === void 0 ? void 0 : _frozen3.type) === "column") {
          _frozen3.type = "rangeBoth";
        }
      }
    }
    if (ctx.luckysheet_cell_selected_extend) {
      onDropCellSelectEnd(ctx, e, container);
    }
  }
  function handleRowHeaderMouseDown(ctx, globalCache, e, container, cellInput, fxInput) {
    if (!checkProtectionAllSelected(ctx, ctx.currentSheetId)) {
      return;
    }
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    var rect = container.getBoundingClientRect();
    var y2 = e.pageY - rect.top + ctx.scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row = row_location[1];
    var row_pre = row_location[0];
    var row_index = row_location[2];
    var col_index = ctx.visibledatacolumn.length - 1;
    var col = ctx.visibledatacolumn[col_index];
    var col_pre = 0;
    if (e.button === 2) {
      var flowdata = getFlowdata(ctx);
      var isInSelection = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        var _flowdata$0$length, _flowdata$;
        return obj_s.row != null && row_index >= obj_s.row[0] && row_index <= obj_s.row[1] && obj_s.column[0] === 0 && obj_s.column[1] === ((_flowdata$0$length = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$ = flowdata[0]) === null || _flowdata$ === void 0 ? void 0 : _flowdata$.length) !== null && _flowdata$0$length !== void 0 ? _flowdata$0$length : 0) - 1;
      });
      if (isInSelection) return;
    }
    var top = row_pre;
    var height = row - row_pre - 1;
    var rowseleted = [row_index, row_index];
    ctx.luckysheet_scroll_status = true;
    if (!_$1.isEmpty(ctx.luckysheetCellUpdate)) {
      if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
        var _$last2;
        var changeparam = mergeMoveMain(ctx, [0, col_index], rowseleted, {
          row_focus: row_index,
          column_focus: 0
        }, top, height, col_pre, col);
        if (changeparam != null) {
          var _ref = [changeparam[1], changeparam[2], changeparam[3]];
          rowseleted = _ref[0];
          top = _ref[1];
          height = _ref[2];
        }
        if (e.shiftKey) {
          var last = ctx.formulaCache.func_selectedrange;
          top = 0;
          height = 0;
          rowseleted = [];
          if (last == null || last.top == null || last.height == null || last.row == null || last.row_focus == null) return;
          if (last.top > row_pre) {
            top = row_pre;
            height = last.top + last.height - row_pre;
            if (last.row[1] > last.row_focus) {
              last.row[1] = last.row_focus;
            }
            rowseleted = [row_index, last.row[1]];
          } else if (last.top === row_pre) {
            top = row_pre;
            height = last.top + last.height - row_pre;
            rowseleted = [row_index, last.row[0]];
          } else {
            top = last.top;
            height = row - last.top - 1;
            if (last.row[0] < last.row_focus) {
              last.row[0] = last.row_focus;
            }
            rowseleted = [last.row[0], row_index];
          }
          changeparam = mergeMoveMain(ctx, [0, col_index], rowseleted, {
            row_focus: row_index,
            column_focus: 0
          }, top, height, col_pre, col);
          if (changeparam != null) {
            var _ref2 = [changeparam[1], changeparam[2], changeparam[3]];
            rowseleted = _ref2[0];
            top = _ref2[1];
            height = _ref2[2];
          }
          last.row = rowseleted;
          last.top_move = top;
          last.height_move = height;
          ctx.formulaCache.func_selectedrange = last;
        } else if (e.ctrlKey && ((_$last2 = _$1.last(cellInput.querySelectorAll("span"))) === null || _$last2 === void 0 ? void 0 : _$last2.innerText) !== ",") {
          var vText = "".concat(cellInput.innerText, ",");
          if (vText.length > 0 && vText.substring(0, 1) === "=") {
            vText = functionHTMLGenerate(vText);
            if (window.getSelection) {
              var _currSelection$anchor5, _currSelection$anchor6, _currSelection$anchor7, _currSelection$anchor8;
              var currSelection = window.getSelection();
              if (currSelection == null) return;
              ctx.formulaCache.functionRangeIndex = [_$1.indexOf((_currSelection$anchor5 = currSelection.anchorNode) === null || _currSelection$anchor5 === void 0 ? void 0 : (_currSelection$anchor6 = _currSelection$anchor5.parentNode) === null || _currSelection$anchor6 === void 0 ? void 0 : (_currSelection$anchor7 = _currSelection$anchor6.parentNode) === null || _currSelection$anchor7 === void 0 ? void 0 : _currSelection$anchor7.childNodes, (_currSelection$anchor8 = currSelection.anchorNode) === null || _currSelection$anchor8 === void 0 ? void 0 : _currSelection$anchor8.parentNode), currSelection.anchorOffset];
            } else {
              var textRange = document.selection.createRange();
              ctx.formulaCache.functionRangeIndex = textRange;
            }
            cellInput.innerHTML = vText;
            cancelFunctionrangeSelected(ctx);
            createRangeHightlight(ctx, vText);
          }
          ctx.formulaCache.rangestart = false;
          ctx.formulaCache.rangedrag_column_start = false;
          ctx.formulaCache.rangedrag_row_start = false;
          if (fxInput) fxInput.innerHTML = vText;
          rangeHightlightselected(ctx, cellInput);
          israngeseleciton(ctx);
          ctx.formulaCache.func_selectedrange = {
            left: colLocationByIndex(0, ctx.visibledatacolumn)[0],
            width: colLocationByIndex(0, ctx.visibledatacolumn)[1] - colLocationByIndex(0, ctx.visibledatacolumn)[0] - 1,
            top,
            height,
            left_move: col_pre,
            width_move: col - col_pre - 1,
            top_move: top,
            height_move: height,
            row: rowseleted,
            column: [0, col_index],
            row_focus: row_index,
            column_focus: 0
          };
        } else {
          ctx.formulaCache.func_selectedrange = {
            left: colLocationByIndex(0, ctx.visibledatacolumn)[0],
            width: colLocationByIndex(0, ctx.visibledatacolumn)[1] - colLocationByIndex(0, ctx.visibledatacolumn)[0] - 1,
            top,
            height,
            left_move: col_pre,
            width_move: col - col_pre - 1,
            top_move: top,
            height_move: height,
            row: rowseleted,
            column: [0, col_index],
            row_focus: row_index,
            column_focus: 0
          };
        }
        if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
          rangeSetValue(ctx, cellInput, {
            row: rowseleted,
            column: [null, null]
          }, fxInput);
        }
        ctx.formulaCache.rangedrag_row_start = true;
        ctx.formulaCache.rangestart = false;
        ctx.formulaCache.rangedrag_column_start = false;
        ctx.formulaCache.selectingRangeIndex = ctx.formulaCache.rangechangeindex;
        if (ctx.formulaCache.rangechangeindex > ctx.formulaRangeHighlight.length) {
          createRangeHightlight(ctx, cellInput.innerHTML, ctx.formulaCache.rangechangeindex);
        }
        createFormulaRangeSelect(ctx, {
          rangeIndex: ctx.formulaCache.rangechangeindex || 0,
          left: col_pre,
          top,
          width: col - col_pre - 1,
          height
        });
        e.preventDefault();
        return;
      }
      updateCell(ctx, ctx.luckysheetCellUpdate[0], ctx.luckysheetCellUpdate[1], cellInput);
      ctx.luckysheet_rows_selected_status = true;
    } else {
      ctx.luckysheet_rows_selected_status = true;
    }
    if (ctx.luckysheet_rows_selected_status) {
      if (e.shiftKey) {
        var _ctx$luckysheet_selec19;
        var _last2 = _$1.cloneDeep((_ctx$luckysheet_selec19 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec19 === void 0 ? void 0 : _ctx$luckysheet_selec19[ctx.luckysheet_select_save.length - 1]);
        if (!_last2 || _$1.isNil(_last2.top) || _$1.isNil(_last2.height) || _$1.isNil(_last2.row_focus)) {
          return;
        }
        var _top = 0;
        var _height = 0;
        var _rowseleted = [];
        if (_last2.top > row_pre) {
          _top = row_pre;
          _height = _last2.top + _last2.height - row_pre;
          if (_last2.row[1] > _last2.row_focus) {
            _last2.row[1] = _last2.row_focus;
          }
          _rowseleted = [row_index, _last2.row[1]];
        } else if (_last2.top === row_pre) {
          _top = row_pre;
          _height = _last2.top + _last2.height - row_pre;
          _rowseleted = [row_index, _last2.row[0]];
        } else {
          _top = _last2.top;
          _height = row - _last2.top - 1;
          if (_last2.row[0] < _last2.row_focus) {
            _last2.row[0] = _last2.row_focus;
          }
          _rowseleted = [_last2.row[0], row_index];
        }
        _last2.row = _rowseleted;
        _last2.top_move = _top;
        _last2.height_move = _height;
        ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1] = _last2;
      } else if (e.ctrlKey || e.metaKey) {
        var _ctx$luckysheet_selec20;
        (_ctx$luckysheet_selec20 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec20 === void 0 ? void 0 : _ctx$luckysheet_selec20.push({
          left: colLocationByIndex(0, ctx.visibledatacolumn)[0],
          width: colLocationByIndex(0, ctx.visibledatacolumn)[1] - colLocationByIndex(0, ctx.visibledatacolumn)[0] - 1,
          top,
          height,
          left_move: col_pre,
          width_move: col - col_pre - 1,
          top_move: top,
          height_move: height,
          row: rowseleted,
          column: [0, col_index],
          row_focus: row_index,
          column_focus: 0,
          row_select: true
        });
      } else {
        ctx.luckysheet_select_save = [];
        ctx.luckysheet_select_save.push({
          left: colLocationByIndex(0, ctx.visibledatacolumn)[0],
          width: colLocationByIndex(0, ctx.visibledatacolumn)[1] - colLocationByIndex(0, ctx.visibledatacolumn)[0] - 1,
          top,
          height,
          left_move: col_pre,
          width_move: col - col_pre - 1,
          top_move: top,
          height_move: height,
          row: rowseleted,
          column: [0, col_index],
          row_focus: row_index,
          column_focus: 0,
          row_select: true
        });
        ctx.luckysheet_select_status = true;
        ctx.luckysheet_scroll_status = true;
      }
    }
  }
  function handleColumnHeaderMouseDown(ctx, globalCache, e, container, cellInput, fxInput) {
    if (!checkProtectionAllSelected(ctx, ctx.currentSheetId)) {
      return;
    }
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    var rect = container.getBoundingClientRect();
    var x2 = e.pageX - rect.left + ctx.scrollLeft;
    var row_index = ctx.visibledatarow.length - 1;
    var row = ctx.visibledatarow[row_index];
    var row_pre = 0;
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col = col_location[1];
    var col_pre = col_location[0];
    var col_index = col_location[2];
    ctx.orderbyindex = col_index;
    if (e.button === 2) {
      var flowdata = getFlowdata(ctx);
      var isInSelection = _$1.some(ctx.luckysheet_select_save, function(obj_s) {
        var _flowdata$length;
        return obj_s.column != null && col_index >= obj_s.column[0] && col_index <= obj_s.column[1] && obj_s.row[0] === 0 && obj_s.row[1] === ((_flowdata$length = flowdata === null || flowdata === void 0 ? void 0 : flowdata.length) !== null && _flowdata$length !== void 0 ? _flowdata$length : 0) - 1;
      });
      if (isInSelection) return;
    }
    var left = col_pre;
    var width = col - col_pre - 1;
    var columnseleted = [col_index, col_index];
    ctx.luckysheet_scroll_status = true;
    if (!_$1.isEmpty(ctx.luckysheetCellUpdate)) {
      if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
        var _$last3;
        var changeparam = mergeMoveMain(ctx, columnseleted, [0, row_index], {
          row_focus: 0,
          column_focus: col_index
        }, row_pre, row, left, width);
        if (changeparam != null) {
          var _ref3 = [changeparam[0], changeparam[4], changeparam[5]];
          columnseleted = _ref3[0];
          left = _ref3[1];
          width = _ref3[2];
        }
        if (e.shiftKey) {
          var last = ctx.formulaCache.func_selectedrange;
          left = 0;
          width = 0;
          columnseleted = [];
          if (last == null || last.width == null || last.height == null || last.left == null || last.column_focus == null) return;
          if (last.left > col_pre) {
            left = col_pre;
            width = last.left + last.width - col_pre;
            if (last.column[1] > last.column_focus) {
              last.column[1] = last.column_focus;
            }
            columnseleted = [col_index, last.column[1]];
          } else if (last.left === col_pre) {
            left = col_pre;
            width = last.left + last.width - col_pre;
            columnseleted = [col_index, last.column[0]];
          } else {
            left = last.left;
            width = col - last.left - 1;
            if (last.column[0] < last.column_focus) {
              last.column[0] = last.column_focus;
            }
            columnseleted = [last.column[0], col_index];
          }
          changeparam = mergeMoveMain(ctx, columnseleted, [0, row_index], {
            row_focus: 0,
            column_focus: col_index
          }, row_pre, row, left, width);
          if (changeparam != null) {
            var _ref4 = [changeparam[0], changeparam[4], changeparam[5]];
            columnseleted = _ref4[0];
            left = _ref4[1];
            width = _ref4[2];
          }
          last.column = columnseleted;
          last.left_move = left;
          last.width_move = width;
          ctx.formulaCache.func_selectedrange = last;
        } else if (e.ctrlKey && ((_$last3 = _$1.last(cellInput.querySelectorAll("span"))) === null || _$last3 === void 0 ? void 0 : _$last3.innerText) !== ",") {
          var vText = "".concat(cellInput.innerText, ",");
          if (vText.length > 0 && vText.substring(0, 1) === "=") {
            vText = functionHTMLGenerate(vText);
            if (window.getSelection) {
              var _currSelection$anchor9, _currSelection$anchor10, _currSelection$anchor11, _currSelection$anchor12;
              var currSelection = window.getSelection();
              if (currSelection == null) return;
              ctx.formulaCache.functionRangeIndex = [_$1.indexOf((_currSelection$anchor9 = currSelection.anchorNode) === null || _currSelection$anchor9 === void 0 ? void 0 : (_currSelection$anchor10 = _currSelection$anchor9.parentNode) === null || _currSelection$anchor10 === void 0 ? void 0 : (_currSelection$anchor11 = _currSelection$anchor10.parentNode) === null || _currSelection$anchor11 === void 0 ? void 0 : _currSelection$anchor11.childNodes, (_currSelection$anchor12 = currSelection.anchorNode) === null || _currSelection$anchor12 === void 0 ? void 0 : _currSelection$anchor12.parentNode), currSelection.anchorOffset];
            } else {
              var textRange = document.selection.createRange();
              ctx.formulaCache.functionRangeIndex = textRange;
            }
            cellInput.innerHTML = vText;
            cancelFunctionrangeSelected(ctx);
            createRangeHightlight(ctx, vText);
          }
          ctx.formulaCache.rangestart = false;
          ctx.formulaCache.rangedrag_column_start = false;
          ctx.formulaCache.rangedrag_row_start = false;
          if (fxInput) {
            fxInput.innerHTML = vText;
          }
          rangeHightlightselected(ctx, cellInput);
          israngeseleciton(ctx);
          ctx.formulaCache.func_selectedrange = {
            left,
            width,
            top: rowLocationByIndex(0, ctx.visibledatarow)[0],
            height: rowLocationByIndex(0, ctx.visibledatarow)[1] - rowLocationByIndex(0, ctx.visibledatarow)[0] - 1,
            left_move: left,
            width_move: width,
            top_move: row_pre,
            height_move: row - row_pre - 1,
            row: [0, row_index],
            column: columnseleted,
            row_focus: 0,
            column_focus: col_index
          };
        } else {
          ctx.formulaCache.func_selectedrange = {
            left,
            width,
            top: rowLocationByIndex(0, ctx.visibledatarow)[0],
            height: rowLocationByIndex(0, ctx.visibledatarow)[1] - rowLocationByIndex(0, ctx.visibledatarow)[0] - 1,
            left_move: left,
            width_move: width,
            top_move: row_pre,
            height_move: row - row_pre - 1,
            row: [0, row_index],
            column: columnseleted,
            row_focus: 0,
            column_focus: col_index
          };
        }
        if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) {
          rangeSetValue(ctx, cellInput, {
            row: [null, null],
            column: columnseleted
          }, fxInput);
        }
        ctx.formulaCache.rangedrag_column_start = true;
        ctx.formulaCache.rangestart = false;
        ctx.formulaCache.rangedrag_row_start = false;
        ctx.formulaCache.selectingRangeIndex = ctx.formulaCache.rangechangeindex;
        if (ctx.formulaCache.rangechangeindex > ctx.formulaRangeHighlight.length) {
          createRangeHightlight(ctx, cellInput.innerHTML, ctx.formulaCache.rangechangeindex);
        }
        createFormulaRangeSelect(ctx, {
          rangeIndex: ctx.formulaCache.rangechangeindex || 0,
          left,
          top: row_pre,
          width,
          height: row - row_pre - 1
        });
        e.preventDefault();
        return;
      }
      updateCell(ctx, ctx.luckysheetCellUpdate[0], ctx.luckysheetCellUpdate[1], cellInput);
      ctx.luckysheet_cols_selected_status = true;
    } else {
      ctx.luckysheet_cols_selected_status = true;
    }
    if (ctx.luckysheet_cols_selected_status) {
      if (e.shiftKey) {
        var _ctx$luckysheet_selec21;
        var _last3 = _$1.cloneDeep((_ctx$luckysheet_selec21 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec21 === void 0 ? void 0 : _ctx$luckysheet_selec21[ctx.luckysheet_select_save.length - 1]);
        var _left = 0;
        var _width = 0;
        var _columnseleted = [];
        if (!_last3 || _$1.isNil(_last3.left) || _$1.isNil(_last3.width) || _$1.isNil(_last3.column_focus)) {
          return;
        }
        if (_last3.left > col_pre) {
          _left = col_pre;
          _width = _last3.left + _last3.width - col_pre;
          if (_last3.column[1] > _last3.column_focus) {
            _last3.column[1] = _last3.column_focus;
          }
          _columnseleted = [col_index, _last3.column[1]];
        } else if (_last3.left === col_pre) {
          _left = col_pre;
          _width = _last3.left + _last3.width - col_pre;
          _columnseleted = [col_index, _last3.column[0]];
        } else {
          _left = _last3.left;
          _width = col - _last3.left - 1;
          if (_last3.column[0] < _last3.column_focus) {
            _last3.column[0] = _last3.column_focus;
          }
          _columnseleted = [_last3.column[0], col_index];
        }
        _last3.column = _columnseleted;
        _last3.left_move = _left;
        _last3.width_move = _width;
        ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1] = _last3;
      } else if (e.ctrlKey || e.metaKey) {
        var _ctx$luckysheet_selec22;
        (_ctx$luckysheet_selec22 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec22 === void 0 ? void 0 : _ctx$luckysheet_selec22.push({
          left,
          width,
          top: rowLocationByIndex(0, ctx.visibledatarow)[0],
          height: rowLocationByIndex(0, ctx.visibledatarow)[1] - rowLocationByIndex(0, ctx.visibledatarow)[0] - 1,
          left_move: left,
          width_move: width,
          top_move: row_pre,
          height_move: row - row_pre - 1,
          row: [0, row_index],
          column: columnseleted,
          row_focus: 0,
          column_focus: col_index,
          column_select: true
        });
      } else {
        ctx.luckysheet_select_save = [];
        ctx.luckysheet_select_save.push({
          left,
          width,
          top: rowLocationByIndex(0, ctx.visibledatarow)[0],
          height: rowLocationByIndex(0, ctx.visibledatarow)[1] - rowLocationByIndex(0, ctx.visibledatarow)[0] - 1,
          left_move: left,
          width_move: width,
          top_move: row_pre,
          height_move: row - row_pre - 1,
          row: [0, row_index],
          column: columnseleted,
          row_focus: 0,
          column_focus: col_index,
          column_select: true
        });
        ctx.luckysheet_select_status = true;
        ctx.luckysheet_scroll_status = true;
      }
    }
  }
  function handleColSizeHandleMouseDown(ctx, globalCache, e, headerContainer, workbookContainer, cellArea) {
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    ctx.luckysheetCellUpdate = [];
    var scrollLeft = ctx.scrollLeft;
    var scrollTop = ctx.scrollTop;
    var x2 = e.pageX - headerContainer.getBoundingClientRect().left + scrollLeft;
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col = col_location[1];
    var col_pre = col_location[0];
    var col_index = col_location[2];
    ctx.luckysheet_cols_change_size = true;
    ctx.luckysheet_scroll_status = true;
    var changeSizeLine = workbookContainer.querySelector(".fortune-change-size-line");
    if (changeSizeLine) {
      var ele = changeSizeLine;
      ele.style.height = "".concat(cellArea.getBoundingClientRect().height + scrollTop, "px");
      ele.style.borderWidth = "0 1px 0 0";
      ele.style.top = "0";
      ele.style.left = "".concat(col - 3, "px");
      ele.style.width = "1px";
    }
    ctx.luckysheet_cols_change_size_start = [col_pre, col_index];
    e.stopPropagation();
  }
  function handleRowSizeHandleMouseDown(ctx, globalCache, e, headerContainer, workbookContainer, cellArea) {
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    if (ctx.formulaCache.rangestart || ctx.formulaCache.rangedrag_column_start || ctx.formulaCache.rangedrag_row_start || israngeseleciton(ctx)) return;
    ctx.luckysheetCellUpdate = [];
    var scrollLeft = ctx.scrollLeft;
    var scrollTop = ctx.scrollTop;
    var y2 = e.pageY - headerContainer.getBoundingClientRect().top + scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row = row_location[1];
    var row_pre = row_location[0];
    var row_index = row_location[2];
    ctx.luckysheet_rows_change_size = true;
    ctx.luckysheet_scroll_status = true;
    var changeSizeLine = workbookContainer.querySelector(".fortune-change-size-line");
    if (changeSizeLine) {
      var ele = changeSizeLine;
      ele.style.width = "".concat(cellArea.getBoundingClientRect().width + scrollLeft, "px");
      ele.style.borderWidth = "0 0 1px 0";
      ele.style.top = "".concat(row - 3, "px");
      ele.style.left = "0";
      ele.style.height = "1px";
    }
    ctx.luckysheet_rows_change_size_start = [row_pre, row_index];
    e.stopPropagation();
  }
  function handleColFreezeHandleMouseDown(ctx, globalCache, e, headerContainer, workbookContainer, cellArea) {
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    ctx.luckysheetCellUpdate = [];
    var scrollLeft = ctx.scrollLeft;
    var scrollTop = ctx.scrollTop;
    var x2 = e.pageX - headerContainer.getBoundingClientRect().left + scrollLeft;
    var col_location = colLocation(x2, ctx.visibledatacolumn);
    var col = col_location[1];
    ctx.luckysheet_cols_freeze_drag = true;
    ctx.luckysheet_scroll_status = true;
    var freezeDragLine = workbookContainer.querySelector(".fortune-freeze-drag-line");
    if (freezeDragLine) {
      var ele = freezeDragLine;
      ele.style.height = "".concat(cellArea.getBoundingClientRect().height + scrollTop, "px");
      ele.style.borderWidth = "0 3px 0 0";
      ele.style.top = "0";
      ele.style.left = "".concat(col - 3, "px");
      ele.style.width = "1px";
    }
    var changeSizeLine = workbookContainer.querySelector(".fortune-change-size-line");
    if (changeSizeLine) {
      var _ele = changeSizeLine;
      _ele.style.height = "".concat(cellArea.getBoundingClientRect().height + scrollTop, "px");
      _ele.style.borderWidth = "0 1px 0 0";
      _ele.style.top = "0";
      _ele.style.left = "".concat(col - 3, "px");
      _ele.style.width = "1px";
    }
    e.stopPropagation();
  }
  function handleRowFreezeHandleMouseDown(ctx, globalCache, e, headerContainer, workbookContainer, cellArea) {
    removeEditingComment(ctx, globalCache);
    cancelActiveImgItem(ctx, globalCache);
    ctx.luckysheetCellUpdate = [];
    var scrollLeft = ctx.scrollLeft;
    var scrollTop = ctx.scrollTop;
    var y2 = e.pageY - headerContainer.getBoundingClientRect().top + scrollTop;
    var row_location = rowLocation(y2, ctx.visibledatarow);
    var row = row_location[1];
    ctx.luckysheet_rows_freeze_drag = true;
    ctx.luckysheet_scroll_status = true;
    var freezeDragLine = workbookContainer.querySelector(".fortune-freeze-drag-line");
    if (freezeDragLine) {
      var ele = freezeDragLine;
      ele.style.width = "".concat(cellArea.getBoundingClientRect().width + scrollLeft, "px");
      ele.style.borderWidth = "0 0 3px 0";
      ele.style.top = "".concat(row - 3, "px");
      ele.style.left = "0";
      ele.style.height = "1px";
    }
    var changeSizeLine = workbookContainer.querySelector(".fortune-change-size-line");
    if (changeSizeLine) {
      var _ele2 = changeSizeLine;
      _ele2.style.width = "".concat(cellArea.getBoundingClientRect().width + scrollLeft, "px");
      _ele2.style.borderWidth = "0 0 1px 0";
      _ele2.style.top = "".concat(row - 3, "px");
      _ele2.style.left = "0";
      _ele2.style.height = "1px";
    }
    e.stopPropagation();
  }
  function postPasteCut(ctx, source, target, RowlChange) {
    var execF_rc = {};
    ctx.formulaCache.execFunctionExist = [];
    for (var r2 = source.range.row[0]; r2 <= source.range.row[1]; r2 += 1) {
      for (var c2 = source.range.column[0]; c2 <= source.range.column[1]; c2 += 1) {
        if ("".concat(r2, "_").concat(c2, "_").concat(source.sheetId) in execF_rc) {
          continue;
        }
        execF_rc["".concat(r2, "_").concat(c2, "_").concat(source.sheetId)] = 0;
        ctx.formulaCache.execFunctionExist.push({
          r: r2,
          c: c2,
          i: source.sheetId
        });
      }
    }
    for (var _r = target.range.row[0]; _r <= target.range.row[1]; _r += 1) {
      for (var _c = target.range.column[0]; _c <= target.range.column[1]; _c += 1) {
        if ("".concat(_r, "_").concat(_c, "_").concat(target.sheetId) in execF_rc) {
          continue;
        }
        execF_rc["".concat(_r, "_").concat(_c, "_").concat(target.sheetId)] = 0;
        ctx.formulaCache.execFunctionExist.push({
          r: _r,
          c: _c,
          i: target.sheetId
        });
      }
    }
    var rowHeight;
    if (ctx.currentSheetId === source.sheetId) {
      ctx.config = source.curConfig;
      rowHeight = source.curData.length;
      ctx.luckysheetfile[getSheetIndex(ctx, target.sheetId)].config = target.curConfig;
    } else if (ctx.currentSheetId === target.sheetId) {
      ctx.config = target.curConfig;
      rowHeight = target.curData.length;
      ctx.luckysheetfile[getSheetIndex(ctx, source.sheetId)].config = source.curConfig;
    }
    if (RowlChange) {
      ctx.visibledatarow = [];
      ctx.rh_height = 0;
      for (var i2 = 0; i2 < rowHeight; i2 += 1) {
        var rowlen = ctx.defaultrowlen;
        if (ctx.config.rowlen != null && ctx.config.rowlen[i2] != null) {
          rowlen = ctx.config.rowlen[i2];
        }
        if (ctx.config.rowhidden != null && ctx.config.rowhidden[i2] != null) {
          rowlen = ctx.config.rowhidden[i2];
          ctx.visibledatarow.push(ctx.rh_height);
          continue;
        } else {
          ctx.rh_height += rowlen + 1;
        }
        ctx.visibledatarow.push(ctx.rh_height);
      }
      ctx.rh_height += 80;
      if (ctx.currentSheetId === source.sheetId) ;
      else if (ctx.currentSheetId === target.sheetId) ;
    }
    if (ctx.currentSheetId === source.sheetId) {
      ctx.luckysheetfile[getSheetIndex(ctx, target.sheetId)].data = target.curData;
    } else if (ctx.currentSheetId === target.sheetId) {
      ctx.luckysheetfile[getSheetIndex(ctx, source.sheetId)].data = source.curData;
    }
    if (ctx.currentSheetId === target.sheetId) {
      ctx.luckysheet_select_save = [{
        row: target.range.row,
        column: target.range.column
      }];
    } else {
      ctx.luckysheet_select_save = [{
        row: source.range.row,
        column: source.range.column
      }];
    }
    if (ctx.luckysheet_select_save.length > 0) ;
    ctx.luckysheetfile[getSheetIndex(ctx, source.sheetId)].luckysheet_conditionformat_save = source.curCdformat;
    ctx.luckysheetfile[getSheetIndex(ctx, target.sheetId)].luckysheet_conditionformat_save = target.curCdformat;
    ctx.luckysheetfile[getSheetIndex(ctx, source.sheetId)].dataVerification = source.curDataVerification;
    ctx.luckysheetfile[getSheetIndex(ctx, target.sheetId)].dataVerification = target.curDataVerification;
    ctx.formulaCache.execFunctionExist.reverse();
    execFunctionGroup(ctx, null, null, null, null, target.curData);
    ctx.formulaCache.execFunctionGlobalData = null;
    storeSheetParamALL(ctx);
  }
  function pasteHandler(ctx, data, borderInfo) {
    var _ctx$luckysheet_selec, _ctx$luckysheet_selec2;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (((_ctx$luckysheet_selec = (_ctx$luckysheet_selec2 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec2 === void 0 ? void 0 : _ctx$luckysheet_selec2.length) !== null && _ctx$luckysheet_selec !== void 0 ? _ctx$luckysheet_selec : 0) !== 1) {
      return;
    }
    if (_typeof(data) === "object") {
      if (data.length === 0) {
        return;
      }
      var cfg = ctx.config || {};
      if (cfg.merge == null) {
        cfg.merge = {};
      }
      if (JSON.stringify(borderInfo).length > 2 && cfg.borderInfo == null) {
        cfg.borderInfo = [];
      }
      var copyh = data.length;
      var copyc = data[0].length;
      var minh = ctx.luckysheet_select_save[0].row[0];
      var maxh = minh + copyh - 1;
      var minc = ctx.luckysheet_select_save[0].column[0];
      var maxc = minc + copyc - 1;
      var has_PartMC = false;
      if (cfg.merge != null) {
        has_PartMC = hasPartMC(ctx, cfg, minh, maxh, minc, maxc);
      }
      if (has_PartMC) {
        return;
      }
      var d2 = getFlowdata(ctx);
      if (!d2) return;
      var rowMaxLength = d2.length;
      var cellMaxLength = d2[0].length;
      var addr = maxh - rowMaxLength + 1;
      var addc = maxc - cellMaxLength + 1;
      if (addr > 0 || addc > 0) {
        expandRowsAndColumns(d2, addr, addc);
      }
      if (!d2) return;
      if (cfg.rowlen == null) {
        cfg.rowlen = {};
      }
      var RowlChange = false;
      var offsetMC = {};
      for (var h2 = minh; h2 <= maxh; h2 += 1) {
        var x2 = d2[h2];
        var currentRowLen = ctx.defaultrowlen;
        if (cfg.rowlen[h2] != null) {
          currentRowLen = cfg.rowlen[h2];
        }
        for (var c2 = minc; c2 <= maxc; c2 += 1) {
          var _x$c, _x$c2;
          if (x2 === null || x2 === void 0 ? void 0 : (_x$c = x2[c2]) === null || _x$c === void 0 ? void 0 : _x$c.mc) {
            if ("rs" in x2[c2].mc) {
              delete cfg.merge["".concat(x2[c2].mc.r, "_").concat(x2[c2].mc.c)];
            }
            delete x2[c2].mc;
          }
          var value = null;
          if (data[h2 - minh] != null && data[h2 - minh][c2 - minc] != null) {
            value = data[h2 - minh][c2 - minc];
          }
          x2[c2] = value;
          if (value != null && (x2 === null || x2 === void 0 ? void 0 : (_x$c2 = x2[c2]) === null || _x$c2 === void 0 ? void 0 : _x$c2.mc)) {
            if (x2[c2].mc.rs != null) {
              x2[c2].mc.r = h2;
              x2[c2].mc.c = c2;
              cfg.merge["".concat(x2[c2].mc.r, "_").concat(x2[c2].mc.c)] = x2[c2].mc;
              offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)] = [x2[c2].mc.r, x2[c2].mc.c];
            } else {
              x2[c2] = {
                mc: {
                  r: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][0],
                  c: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][1]
                }
              };
            }
          }
          if (borderInfo["".concat(h2 - minh, "_").concat(c2 - minc)]) {
            var _cfg$borderInfo;
            var bd_obj = {
              rangeType: "cell",
              value: {
                row_index: h2,
                col_index: c2,
                l: borderInfo["".concat(h2 - minh, "_").concat(c2 - minc)].l,
                r: borderInfo["".concat(h2 - minh, "_").concat(c2 - minc)].r,
                t: borderInfo["".concat(h2 - minh, "_").concat(c2 - minc)].t,
                b: borderInfo["".concat(h2 - minh, "_").concat(c2 - minc)].b
              }
            };
            (_cfg$borderInfo = cfg.borderInfo) === null || _cfg$borderInfo === void 0 ? void 0 : _cfg$borderInfo.push(bd_obj);
          }
        }
        d2[h2] = x2;
        if (currentRowLen !== ctx.defaultrowlen) {
          cfg.rowlen[h2] = currentRowLen;
        }
      }
      ctx.luckysheet_select_save = [{
        row: [minh, maxh],
        column: [minc, maxc]
      }];
      if (addr > 0 || addc > 0 || RowlChange) {
        ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].config = cfg;
      } else {
        ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].config = cfg;
      }
    } else {
      var _ctx$luckysheet_selec3;
      data = data.replace(/\r/g, "");
      var dataChe = [];
      var che = data.split("\n");
      var colchelen = che[0].split("	").length;
      for (var i2 = 0; i2 < che.length; i2 += 1) {
        if (che[i2].split("	").length < colchelen) {
          continue;
        }
        dataChe.push(che[i2].split("	"));
      }
      var _d = getFlowdata(ctx);
      if (!_d) return;
      var last = (_ctx$luckysheet_selec3 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec3 === void 0 ? void 0 : _ctx$luckysheet_selec3[ctx.luckysheet_select_save.length - 1];
      if (!last) return;
      var curR = last.row == null ? 0 : last.row[0];
      var curC = last.column == null ? 0 : last.column[0];
      var rlen = dataChe.length;
      var clen = dataChe[0].length;
      var _has_PartMC = false;
      if (ctx.config.merge != null) {
        _has_PartMC = hasPartMC(ctx, ctx.config, curR, curR + rlen - 1, curC, curC + clen - 1);
      }
      if (_has_PartMC) {
        return;
      }
      var _addr = curR + rlen - _d.length;
      var _addc = curC + clen - _d[0].length;
      if (_addr > 0 || _addc > 0) {
        expandRowsAndColumns(_d, _addr, _addc);
      }
      if (!_d) return;
      for (var r2 = 0; r2 < rlen; r2 += 1) {
        var _x = _d[r2 + curR];
        for (var _c2 = 0; _c2 < clen; _c2 += 1) {
          var originCell = _x[_c2 + curC];
          var _value = dataChe[r2][_c2];
          if (isRealNum(_value)) {
            if (originCell && originCell.ct && originCell.ct.fa === "@") {
              _value = String(_value);
            } else {
              _value = parseFloat(_value);
            }
          }
          if (originCell) {
            originCell.v = _value;
            if (originCell.ct != null && originCell.ct.fa != null) {
              originCell.m = update(originCell.ct.fa, _value);
            } else {
              originCell.m = _value;
            }
            if (originCell.f != null && originCell.f.length > 0) {
              originCell.f = "";
              delFunctionGroup(ctx, r2 + curR, _c2 + curC, ctx.currentSheetId);
            }
          } else {
            var cell = {};
            var mask = genarate(_value);
            var _mask = _slicedToArray$1(mask, 3);
            cell.m = _mask[0];
            cell.ct = _mask[1];
            cell.v = _mask[2];
            _x[_c2 + curC] = cell;
          }
        }
        _d[r2 + curR] = _x;
      }
      last.row = [curR, curR + rlen - 1];
      last.column = [curC, curC + clen - 1];
    }
  }
  function setCellHyperlink(ctx, id2, r2, c2, link) {
    var index2 = getSheetIndex(ctx, id2);
    if (!ctx.luckysheetfile[index2].hyperlink) {
      ctx.luckysheetfile[index2].hyperlink = {};
    }
    ctx.luckysheetfile[index2].hyperlink["".concat(r2, "_").concat(c2)] = link;
  }
  function pasteHandlerOfCutPaste(ctx, copyRange) {
    var _ctx$luckysheet_selec4, _ctx$luckysheet_selec5, _ctx$luckysheet_copy_;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (!copyRange) return;
    var cfg = ctx.config || {};
    if (cfg.merge == null) {
      cfg.merge = {};
    }
    var copyHasMC = copyRange.HasMC;
    var copyRowlChange = copyRange.RowlChange;
    var copySheetId = copyRange.dataSheetId;
    var c_r1 = copyRange.copyRange[0].row[0];
    var c_r2 = copyRange.copyRange[0].row[1];
    var c_c1 = copyRange.copyRange[0].column[0];
    var c_c2 = copyRange.copyRange[0].column[1];
    var copyData = _$1.cloneDeep(getdatabyselection(ctx, {
      row: [c_r1, c_r2],
      column: [c_c1, c_c2]
    }, copySheetId));
    var copyh = copyData.length;
    var copyc = copyData[0].length;
    var last = (_ctx$luckysheet_selec4 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec4 === void 0 ? void 0 : _ctx$luckysheet_selec4[ctx.luckysheet_select_save.length - 1];
    if (!last || last.row_focus == null || last.column_focus == null) return;
    var minh = last.row_focus;
    var maxh = minh + copyh - 1;
    var minc = last.column_focus;
    var maxc = minc + copyc - 1;
    var has_PartMC = false;
    if (cfg.merge != null) {
      has_PartMC = hasPartMC(ctx, cfg, minh, maxh, minc, maxc);
    }
    if (has_PartMC) {
      return;
    }
    var d2 = getFlowdata(ctx);
    if (!d2) return;
    var rowMaxLength = d2.length;
    var cellMaxLength = d2[0].length;
    var addr = copyh + minh - rowMaxLength;
    var addc = copyc + minc - cellMaxLength;
    if (addr > 0 || addc > 0) {
      expandRowsAndColumns(d2, addr, addc);
    }
    var borderInfoCompute = getBorderInfoCompute(ctx, copySheetId);
    var c_dataVerification = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetId)].dataVerification) || {};
    var dataVerification = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification) || {};
    if (((_ctx$luckysheet_selec5 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec5 === void 0 ? void 0 : _ctx$luckysheet_selec5.length) === 1 && ((_ctx$luckysheet_copy_ = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_ === void 0 ? void 0 : _ctx$luckysheet_copy_.copyRange.length) === 1) {
      var _ctx$luckysheet_copy_2;
      _$1.forEach((_ctx$luckysheet_copy_2 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_2 === void 0 ? void 0 : _ctx$luckysheet_copy_2.copyRange, function(range3) {
        for (var r2 = 0; r2 <= range3.row[1] - range3.row[0]; r2 += 1) {
          for (var c3 = 0; c3 <= range3.column[1] - range3.column[0]; c3 += 1) {
            var _ctx$luckysheet_copy_3, _ctx$luckysheetfile$i;
            var index2 = getSheetIndex(ctx, (_ctx$luckysheet_copy_3 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_3 === void 0 ? void 0 : _ctx$luckysheet_copy_3.dataSheetId);
            if (((_ctx$luckysheetfile$i = ctx.luckysheetfile[index2].data[r2 + range3.row[0]][c3 + range3.column[0]]) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i.hl) && ctx.luckysheetfile[index2].hyperlink["".concat(r2, "_").concat(c3)]) {
              var _ctx$luckysheet_copy_4;
              setCellHyperlink(ctx, (_ctx$luckysheet_copy_4 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_4 === void 0 ? void 0 : _ctx$luckysheet_copy_4.dataSheetId, r2 + ctx.luckysheet_select_save[0].row[0], c3 + ctx.luckysheet_select_save[0].column[0], ctx.luckysheetfile[index2].hyperlink["".concat(r2, "_").concat(c3)]);
            }
          }
        }
      });
    }
    if (ctx.currentSheetId === copySheetId) {
      for (var i2 = c_r1; i2 <= c_r2; i2 += 1) {
        for (var j2 = c_c1; j2 <= c_c2; j2 += 1) {
          var _ctx$luckysheetfile$g;
          var cell = d2[i2][j2];
          if (cell && _$1.isPlainObject(cell) && "mc" in cell) {
            var _cell$mc;
            if (((_cell$mc = cell.mc) === null || _cell$mc === void 0 ? void 0 : _cell$mc.rs) != null) {
              delete cfg.merge["".concat(cell.mc.r, "_").concat(cell.mc.c)];
            }
            delete cell.mc;
          }
          d2[i2][j2] = null;
          delete dataVerification["".concat(i2, "_").concat(j2)];
          (_ctx$luckysheetfile$g = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].hyperlink) === null || _ctx$luckysheetfile$g === void 0 ? true : delete _ctx$luckysheetfile$g["".concat(i2, "_").concat(j2)];
        }
      }
      if (cfg.borderInfo && cfg.borderInfo.length > 0) {
        var source_borderInfo = [];
        for (var _i = 0; _i < cfg.borderInfo.length; _i += 1) {
          var bd_rangeType = cfg.borderInfo[_i].rangeType;
          if (bd_rangeType === "range") {
            var bd_range = cfg.borderInfo[_i].range;
            var bd_emptyRange = [];
            for (var _j = 0; _j < bd_range.length; _j += 1) {
              bd_emptyRange = bd_emptyRange.concat(CFSplitRange(bd_range[_j], {
                row: [c_r1, c_r2],
                column: [c_c1, c_c2]
              }, {
                row: [minh, maxh],
                column: [minc, maxc]
              }, "restPart"));
            }
            cfg.borderInfo[_i].range = bd_emptyRange;
            source_borderInfo.push(cfg.borderInfo[_i]);
          } else if (bd_rangeType === "cell") {
            var bd_r = cfg.borderInfo[_i].value.row_index;
            var bd_c = cfg.borderInfo[_i].value.col_index;
            if (!(bd_r >= c_r1 && bd_r <= c_r2 && bd_c >= c_c1 && bd_c <= c_c2)) {
              source_borderInfo.push(cfg.borderInfo[_i]);
            }
          }
        }
        cfg.borderInfo = source_borderInfo;
      }
    }
    var offsetMC = {};
    for (var h2 = minh; h2 <= maxh; h2 += 1) {
      var x2 = d2[h2];
      for (var c2 = minc; c2 <= maxc; c2 += 1) {
        var _x$c3, _x$c5;
        if (borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)] && !borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].s) {
          var bd_obj = {
            rangeType: "cell",
            value: {
              row_index: h2,
              col_index: c2,
              l: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].l,
              r: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].r,
              t: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].t,
              b: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].b
            }
          };
          if (cfg.borderInfo == null) {
            cfg.borderInfo = [];
          }
          cfg.borderInfo.push(bd_obj);
        } else if (borderInfoCompute["".concat(h2, "_").concat(c2)]) {
          var _bd_obj = {
            rangeType: "cell",
            value: {
              row_index: h2,
              col_index: c2,
              l: null,
              r: null,
              t: null,
              b: null
            }
          };
          if (cfg.borderInfo == null) {
            cfg.borderInfo = [];
          }
          cfg.borderInfo.push(_bd_obj);
        } else if (borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)]) {
          var _bd_obj2 = {
            rangeType: "range",
            borderType: "border-slash",
            color: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].s.color,
            style: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].s.style,
            range: normalizeSelection(ctx, [{
              row: [h2, h2],
              column: [c2, c2]
            }])
          };
          if (cfg.borderInfo == null) {
            cfg.borderInfo = [];
          }
          cfg.borderInfo.push(_bd_obj2);
        }
        if (c_dataVerification["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)]) {
          dataVerification["".concat(h2, "_").concat(c2)] = c_dataVerification["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)];
        }
        if ((_x$c3 = x2[c2]) === null || _x$c3 === void 0 ? void 0 : _x$c3.mc) {
          var _x$c4, _x$c4$mc;
          if (((_x$c4 = x2[c2]) === null || _x$c4 === void 0 ? void 0 : (_x$c4$mc = _x$c4.mc) === null || _x$c4$mc === void 0 ? void 0 : _x$c4$mc.rs) != null) {
            delete cfg.merge["".concat(x2[c2].mc.r, "_").concat(x2[c2].mc.c)];
          }
          delete x2[c2].mc;
        }
        var value = null;
        if (copyData[h2 - minh] != null && copyData[h2 - minh][c2 - minc] != null) {
          value = copyData[h2 - minh][c2 - minc];
        }
        x2[c2] = _$1.cloneDeep(value);
        if (value != null && copyHasMC && ((_x$c5 = x2[c2]) === null || _x$c5 === void 0 ? void 0 : _x$c5.mc)) {
          if (x2[c2].mc.rs != null) {
            x2[c2].mc.r = h2;
            x2[c2].mc.c = c2;
            cfg.merge["".concat(x2[c2].mc.r, "_").concat(x2[c2].mc.c)] = x2[c2].mc;
            offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)] = [x2[c2].mc.r, x2[c2].mc.c];
          } else {
            x2[c2] = {
              mc: {
                r: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][0],
                c: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][1]
              }
            };
          }
        }
      }
      d2[h2] = x2;
    }
    last.row = [minh, maxh];
    last.column = [minc, maxc];
    var source;
    var target;
    if (ctx.currentSheetId !== copySheetId) {
      var sourceData = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetId)].data);
      var sourceConfig = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetId)].config);
      var sourceCurData = _$1.cloneDeep(sourceData);
      var sourceCurConfig = _$1.cloneDeep(sourceConfig) || {};
      if (sourceCurConfig.merge == null) {
        sourceCurConfig.merge = {};
      }
      for (var source_r = c_r1; source_r <= c_r2; source_r += 1) {
        for (var source_c = c_c1; source_c <= c_c2; source_c += 1) {
          var _cell = sourceCurData[source_r][source_c];
          if (_cell === null || _cell === void 0 ? void 0 : _cell.mc) {
            if ("rs" in _cell.mc) {
              delete sourceCurConfig.merge["".concat(_cell.mc.r, "_").concat(_cell.mc.c)];
            }
            delete _cell.mc;
          }
          sourceCurData[source_r][source_c] = null;
        }
      }
      if (sourceCurConfig.borderInfo && sourceCurConfig.borderInfo.length > 0) {
        var _source_borderInfo = [];
        for (var _i2 = 0; _i2 < sourceCurConfig.borderInfo.length; _i2 += 1) {
          var _bd_rangeType = sourceCurConfig.borderInfo[_i2].rangeType;
          if (_bd_rangeType === "range") {
            var _bd_range = sourceCurConfig.borderInfo[_i2].range;
            var _bd_emptyRange = [];
            for (var _j2 = 0; _j2 < _bd_range.length; _j2 += 1) {
              _bd_emptyRange = _bd_emptyRange.concat(CFSplitRange(_bd_range[_j2], {
                row: [c_r1, c_r2],
                column: [c_c1, c_c2]
              }, {
                row: [minh, maxh],
                column: [minc, maxc]
              }, "restPart"));
            }
            sourceCurConfig.borderInfo[_i2].range = _bd_emptyRange;
            _source_borderInfo.push(sourceCurConfig.borderInfo[_i2]);
          } else if (_bd_rangeType === "cell") {
            var _bd_r = sourceCurConfig.borderInfo[_i2].value.row_index;
            var _bd_c = sourceCurConfig.borderInfo[_i2].value.col_index;
            if (!(_bd_r >= c_r1 && _bd_r <= c_r2 && _bd_c >= c_c1 && _bd_c <= c_c2)) {
              _source_borderInfo.push(sourceCurConfig.borderInfo[_i2]);
            }
          }
        }
        sourceCurConfig.borderInfo = _source_borderInfo;
      }
      var source_cdformat = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetId)].luckysheet_conditionformat_save);
      var source_curCdformat = _$1.cloneDeep(source_cdformat);
      var ruleArr = [];
      if (source_curCdformat != null && source_curCdformat.length > 0) {
        for (var _i3 = 0; _i3 < source_curCdformat.length; _i3 += 1) {
          var source_curCdformat_cellrange = source_curCdformat[_i3].cellrange;
          var emptyRange = [];
          var emptyRange2 = [];
          for (var _j3 = 0; _j3 < source_curCdformat_cellrange.length; _j3 += 1) {
            var range = CFSplitRange(source_curCdformat_cellrange[_j3], {
              row: [c_r1, c_r2],
              column: [c_c1, c_c2]
            }, {
              row: [minh, maxh],
              column: [minc, maxc]
            }, "restPart");
            emptyRange = emptyRange.concat(range);
            var range2 = CFSplitRange(source_curCdformat_cellrange[_j3], {
              row: [c_r1, c_r2],
              column: [c_c1, c_c2]
            }, {
              row: [minh, maxh],
              column: [minc, maxc]
            }, "operatePart");
            if (range2.length > 0) {
              emptyRange2 = emptyRange2.concat(range2);
            }
          }
          source_curCdformat[_i3].cellrange = emptyRange;
          if (emptyRange2.length > 0) {
            var _source_curCdformat$_;
            var ruleObj = (_source_curCdformat$_ = source_curCdformat[_i3]) !== null && _source_curCdformat$_ !== void 0 ? _source_curCdformat$_ : {};
            ruleObj.cellrange = emptyRange2;
            ruleArr.push(ruleObj);
          }
        }
      }
      var target_cdformat = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].luckysheet_conditionformat_save);
      var target_curCdformat = _$1.cloneDeep(target_cdformat);
      if (ruleArr.length > 0) {
        var _target_curCdformat;
        target_curCdformat = (_target_curCdformat = target_curCdformat) === null || _target_curCdformat === void 0 ? void 0 : _target_curCdformat.concat(ruleArr);
      }
      for (var _i4 = c_r1; _i4 <= c_r2; _i4 += 1) {
        for (var _j4 = c_c1; _j4 <= c_c2; _j4 += 1) {
          delete c_dataVerification["".concat(_i4, "_").concat(_j4)];
        }
      }
      source = {
        sheetId: copySheetId,
        data: sourceData,
        curData: sourceCurData,
        config: sourceConfig,
        curConfig: sourceCurConfig,
        cdformat: source_cdformat,
        curCdformat: source_curCdformat,
        dataVerification: _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetId)].dataVerification),
        curDataVerification: c_dataVerification,
        range: {
          row: [c_r1, c_r2],
          column: [c_c1, c_c2]
        }
      };
      target = {
        sheetId: ctx.currentSheetId,
        data: getFlowdata(ctx),
        curData: d2,
        config: _$1.cloneDeep(ctx.config),
        curConfig: cfg,
        cdformat: target_cdformat,
        curCdformat: target_curCdformat,
        dataVerification: _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification),
        curDataVerification: dataVerification,
        range: {
          row: [minh, maxh],
          column: [minc, maxc]
        }
      };
    } else {
      var cdformat = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].luckysheet_conditionformat_save);
      var curCdformat = _$1.cloneDeep(cdformat);
      if (curCdformat != null && curCdformat.length > 0) {
        for (var _i5 = 0; _i5 < curCdformat.length; _i5 += 1) {
          var cellrange = curCdformat[_i5].cellrange;
          var _emptyRange = [];
          for (var _j5 = 0; _j5 < cellrange.length; _j5 += 1) {
            var _range = CFSplitRange(cellrange[_j5], {
              row: [c_r1, c_r2],
              column: [c_c1, c_c2]
            }, {
              row: [minh, maxh],
              column: [minc, maxc]
            }, "allPart");
            _emptyRange = _emptyRange.concat(_range);
          }
          curCdformat[_i5].cellrange = _emptyRange;
        }
      }
      source = {
        sheetId: ctx.currentSheetId,
        data: getFlowdata(ctx),
        curData: d2,
        config: _$1.cloneDeep(ctx.config),
        curConfig: cfg,
        cdformat,
        curCdformat,
        dataVerification: _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification),
        curDataVerification: dataVerification,
        range: {
          row: [c_r1, c_r2],
          column: [c_c1, c_c2]
        }
      };
      target = {
        sheetId: ctx.currentSheetId,
        data: getFlowdata(ctx),
        curData: d2,
        config: _$1.cloneDeep(ctx.config),
        curConfig: cfg,
        cdformat,
        curCdformat,
        dataVerification: _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification),
        curDataVerification: dataVerification,
        range: {
          row: [minh, maxh],
          column: [minc, maxc]
        }
      };
    }
    if (addr > 0 || addc > 0) {
      postPasteCut(ctx, source, target, true);
    } else {
      postPasteCut(ctx, source, target, copyRowlChange);
    }
  }
  function pasteHandlerOfCopyPaste(ctx, copyRange) {
    var _ctx$luckysheet_selec6, _ctx$luckysheet_selec7, _ctx$luckysheet_copy_5;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (!copyRange) return;
    var cfg = ctx.config;
    if (_$1.isNil(cfg.merge)) {
      cfg.merge = {};
    }
    var copyHasMC = copyRange.HasMC;
    var copyRowlChange = copyRange.RowlChange;
    var copySheetIndex = copyRange.dataSheetId;
    var c_r1 = copyRange.copyRange[0].row[0];
    var c_r2 = copyRange.copyRange[0].row[1];
    var c_c1 = copyRange.copyRange[0].column[0];
    var c_c2 = copyRange.copyRange[0].column[1];
    var arr = [];
    var isSameRow = false;
    var _loop = function _loop2(i3) {
      var arrData = getdatabyselection(ctx, {
        row: copyRange.copyRange[i3].row,
        column: copyRange.copyRange[i3].column
      }, copySheetIndex);
      if (copyRange.copyRange.length > 1) {
        if (c_r1 === copyRange.copyRange[1].row[0] && c_r2 === copyRange.copyRange[1].row[1]) {
          arrData = arrData[0].map(function(col, a2) {
            return arrData.map(function(row) {
              return row[a2];
            });
          });
          arr = arr.concat(arrData);
          isSameRow = true;
        } else if (c_c1 === copyRange.copyRange[1].column[0] && c_c2 === copyRange.copyRange[1].column[1]) {
          arr = arr.concat(arrData);
        }
      } else {
        arr = arrData;
      }
    };
    for (var i2 = 0; i2 < copyRange.copyRange.length; i2 += 1) {
      _loop(i2);
    }
    if (isSameRow) {
      arr = arr[0].map(function(col, b2) {
        return arr.map(function(row) {
          return row[b2];
        });
      });
    }
    var copyData = _$1.cloneDeep(arr);
    if (copyRange.copyRange.length > 1) {
      for (var _i6 = 0; _i6 < copyData.length; _i6 += 1) {
        for (var j2 = 0; j2 < copyData[_i6].length; j2 += 1) {
          if (copyData[_i6][j2] != null && copyData[_i6][j2].f != null) {
            delete copyData[_i6][j2].f;
            delete copyData[_i6][j2].spl;
          }
        }
      }
    }
    var copyh = copyData.length;
    var copyc = copyData[0].length;
    var last = (_ctx$luckysheet_selec6 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec6 === void 0 ? void 0 : _ctx$luckysheet_selec6[ctx.luckysheet_select_save.length - 1];
    if (!last) return;
    var minh = last.row[0];
    var maxh = last.row[1];
    var minc = last.column[0];
    var maxc = last.column[1];
    var mh2 = (maxh - minh + 1) % copyh;
    var mc2 = (maxc - minc + 1) % copyc;
    if (mh2 !== 0 || mc2 !== 0) {
      maxh = minh + copyh - 1;
      maxc = minc + copyc - 1;
    }
    var has_PartMC = false;
    if (!_$1.isNil(cfg.merge)) {
      has_PartMC = hasPartMC(ctx, cfg, minh, maxh, minc, maxc);
    }
    if (has_PartMC) {
      return;
    }
    var timesH = (maxh - minh + 1) / copyh;
    var timesC = (maxc - minc + 1) / copyc;
    var d2 = getFlowdata(ctx);
    if (!d2) return;
    var rowMaxLength = d2.length;
    var cellMaxLength = d2[0].length;
    var addr = copyh + minh - rowMaxLength;
    var addc = copyc + minc - cellMaxLength;
    if (addr > 0 || addc > 0) {
      expandRowsAndColumns(d2, addr, addc);
    }
    var borderInfoCompute = getBorderInfoCompute(ctx, copySheetIndex);
    var c_dataVerification = _$1.cloneDeep(ctx.luckysheetfile[getSheetIndex(ctx, copySheetIndex)].dataVerification) || {};
    var dataVerification = null;
    var mth = 0;
    var mtc = 0;
    var maxcellCahe = 0;
    var maxrowCache = 0;
    for (var th2 = 1; th2 <= timesH; th2 += 1) {
      for (var tc2 = 1; tc2 <= timesC; tc2 += 1) {
        mth = minh + (th2 - 1) * copyh;
        mtc = minc + (tc2 - 1) * copyc;
        maxrowCache = minh + th2 * copyh;
        maxcellCahe = minc + tc2 * copyc;
        var offsetRow = mth - c_r1;
        var offsetCol = mtc - c_c1;
        var offsetMC = {};
        for (var h2 = mth; h2 < maxrowCache; h2 += 1) {
          var x2 = d2[h2];
          for (var c2 = mtc; c2 < maxcellCahe; c2 += 1) {
            var _x$c6, _copyData, _x$c7;
            if (borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)] && !borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)].s) {
              var bd_obj = {
                rangeType: "cell",
                value: {
                  row_index: h2,
                  col_index: c2,
                  l: borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)].l,
                  r: borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)].r,
                  t: borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)].t,
                  b: borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)].b
                }
              };
              if (_$1.isNil(cfg.borderInfo)) {
                cfg.borderInfo = [];
              }
              cfg.borderInfo.push(bd_obj);
            } else if (borderInfoCompute["".concat(h2, "_").concat(c2)]) {
              var _bd_obj3 = {
                rangeType: "cell",
                value: {
                  row_index: h2,
                  col_index: c2,
                  l: null,
                  r: null,
                  t: null,
                  b: null
                }
              };
              if (_$1.isNil(cfg.borderInfo)) {
                cfg.borderInfo = [];
              }
              cfg.borderInfo.push(_bd_obj3);
            } else if (borderInfoCompute["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)]) {
              var _bd_obj4 = {
                rangeType: "range",
                borderType: "border-slash",
                color: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].s.color,
                style: borderInfoCompute["".concat(c_r1 + h2 - minh, "_").concat(c_c1 + c2 - minc)].s.style,
                range: normalizeSelection(ctx, [{
                  row: [h2, h2],
                  column: [c2, c2]
                }])
              };
              if (cfg.borderInfo == null) {
                cfg.borderInfo = [];
              }
              cfg.borderInfo.push(_bd_obj4);
            }
            if (c_dataVerification["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)]) {
              if (_$1.isNil(dataVerification)) {
                var _ctx$luckysheetfile$g2;
                dataVerification = _$1.cloneDeep(((_ctx$luckysheetfile$g2 = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)]) === null || _ctx$luckysheetfile$g2 === void 0 ? void 0 : _ctx$luckysheetfile$g2.dataVerification) || {});
              }
              dataVerification["".concat(h2, "_").concat(c2)] = c_dataVerification["".concat(c_r1 + h2 - mth, "_").concat(c_c1 + c2 - mtc)];
            }
            if (((_x$c6 = x2[c2]) === null || _x$c6 === void 0 ? void 0 : _x$c6.mc) != null) {
              if ("rs" in x2[c2].mc) {
                delete cfg.merge["".concat(x2[c2].mc.r, "_").concat(x2[c2].mc.c)];
              }
              delete x2[c2].mc;
            }
            var value = null;
            if ((_copyData = copyData[h2 - mth]) === null || _copyData === void 0 ? void 0 : _copyData[c2 - mtc]) {
              value = _$1.cloneDeep(copyData[h2 - mth][c2 - mtc]);
            }
            if (!_$1.isNil(value) && !_$1.isNil(value.f)) {
              var func2 = value.f;
              if (offsetRow > 0) {
                func2 = "=".concat(functionCopy(ctx, func2, "down", offsetRow));
              }
              if (offsetRow < 0) {
                func2 = "=".concat(functionCopy(ctx, func2, "up", Math.abs(offsetRow)));
              }
              if (offsetCol > 0) {
                func2 = "=".concat(functionCopy(ctx, func2, "right", offsetCol));
              }
              if (offsetCol < 0) {
                func2 = "=".concat(functionCopy(ctx, func2, "left", Math.abs(offsetCol)));
              }
              var funcV = execfunction(ctx, func2, h2, c2, void 0, true);
              if (!_$1.isNil(value.spl)) ;
              else {
                var _funcV = _slicedToArray$1(funcV, 3);
                value.v = _funcV[1];
                value.f = _funcV[2];
                if (!_$1.isNil(value.ct) && !_$1.isNil(value.ct.fa)) {
                  value.m = update(value.ct.fa, funcV[1]);
                }
              }
            }
            x2[c2] = _$1.cloneDeep(value);
            if (value != null && copyHasMC && (x2 === null || x2 === void 0 ? void 0 : (_x$c7 = x2[c2]) === null || _x$c7 === void 0 ? void 0 : _x$c7.mc)) {
              var _x$c8, _x$c8$mc;
              if ((x2 === null || x2 === void 0 ? void 0 : (_x$c8 = x2[c2]) === null || _x$c8 === void 0 ? void 0 : (_x$c8$mc = _x$c8.mc) === null || _x$c8$mc === void 0 ? void 0 : _x$c8$mc.rs) != null) {
                x2[c2].mc.r = h2;
                x2[c2].mc.c = c2;
                cfg.merge["".concat(h2, "_").concat(c2)] = x2[c2].mc;
                offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)] = [x2[c2].mc.r, x2[c2].mc.c];
              } else {
                x2[c2] = {
                  mc: {
                    r: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][0],
                    c: offsetMC["".concat(value.mc.r, "_").concat(value.mc.c)][1]
                  }
                };
              }
            }
          }
          d2[h2] = x2;
        }
      }
    }
    var cdformat = null;
    if (copyRange.copyRange.length === 1) {
      var c_file = ctx.luckysheetfile[getSheetIndex(ctx, copySheetIndex)];
      var a_file = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)];
      var ruleArr_cf = _$1.cloneDeep(c_file.luckysheet_conditionformat_save);
      if (!_$1.isNil(ruleArr_cf) && ruleArr_cf.length > 0) {
        var _$cloneDeep;
        cdformat = (_$cloneDeep = _$1.cloneDeep(a_file.luckysheet_conditionformat_save)) !== null && _$cloneDeep !== void 0 ? _$cloneDeep : [];
        for (var _i7 = 0; _i7 < ruleArr_cf.length; _i7 += 1) {
          var cf_range = ruleArr_cf[_i7].cellrange;
          var emptyRange = [];
          for (var _th = 1; _th <= timesH; _th += 1) {
            for (var _tc = 1; _tc <= timesC; _tc += 1) {
              mth = minh + (_th - 1) * copyh;
              mtc = minc + (_tc - 1) * copyc;
              maxrowCache = minh + _th * copyh;
              maxcellCahe = minc + _tc * copyc;
              for (var _j6 = 0; _j6 < cf_range.length; _j6 += 1) {
                var range = CFSplitRange(cf_range[_j6], {
                  row: [c_r1, c_r2],
                  column: [c_c1, c_c2]
                }, {
                  row: [mth, maxrowCache - 1],
                  column: [mtc, maxcellCahe - 1]
                }, "operatePart");
                if (range.length > 0) {
                  emptyRange = emptyRange.concat(range);
                }
              }
            }
          }
          if (emptyRange.length > 0) {
            ruleArr_cf[_i7].cellrange = emptyRange;
            cdformat.push(ruleArr_cf[_i7]);
          }
        }
      }
    }
    last.row = [minh, maxh];
    last.column = [minc, maxc];
    var file = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)];
    file.config = cfg;
    file.luckysheet_conditionformat_save = cdformat;
    file.dataVerification = dataVerification;
    if (((_ctx$luckysheet_selec7 = ctx.luckysheet_select_save) === null || _ctx$luckysheet_selec7 === void 0 ? void 0 : _ctx$luckysheet_selec7.length) === 1 && ((_ctx$luckysheet_copy_5 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_5 === void 0 ? void 0 : _ctx$luckysheet_copy_5.copyRange.length) === 1) {
      var _ctx$luckysheet_copy_6;
      _$1.forEach((_ctx$luckysheet_copy_6 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_6 === void 0 ? void 0 : _ctx$luckysheet_copy_6.copyRange, function(range2) {
        for (var r2 = 0; r2 <= range2.row[1] - range2.row[0]; r2 += 1) {
          for (var _c3 = 0; _c3 <= range2.column[1] - range2.column[0]; _c3 += 1) {
            var _ctx$luckysheet_copy_7, _ctx$luckysheetfile$i2;
            var index2 = getSheetIndex(ctx, (_ctx$luckysheet_copy_7 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_7 === void 0 ? void 0 : _ctx$luckysheet_copy_7.dataSheetId);
            if (((_ctx$luckysheetfile$i2 = ctx.luckysheetfile[index2].data[r2 + range2.row[0]][_c3 + range2.column[0]]) === null || _ctx$luckysheetfile$i2 === void 0 ? void 0 : _ctx$luckysheetfile$i2.hl) && ctx.luckysheetfile[index2].hyperlink["".concat(r2, "_").concat(_c3)]) {
              var _ctx$luckysheet_copy_8;
              setCellHyperlink(ctx, (_ctx$luckysheet_copy_8 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_8 === void 0 ? void 0 : _ctx$luckysheet_copy_8.dataSheetId, r2 + ctx.luckysheet_select_save[0].row[0], _c3 + ctx.luckysheet_select_save[0].column[0], ctx.luckysheetfile[index2].hyperlink["".concat(r2, "_").concat(_c3)]);
            }
          }
        }
      });
    }
    if (copyRowlChange || addr > 0 || addc > 0) {
      jfrefreshgrid(ctx, d2, ctx.luckysheet_select_save);
    } else {
      jfrefreshgrid(ctx, d2, ctx.luckysheet_select_save);
    }
  }
  function handlePaste(ctx, e) {
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    if (selectionCache.isPasteAction) {
      var _ctx$luckysheet_copy_9, _ctx$hooks$beforePast, _ctx$hooks, _ctx$luckysheet_copy_10;
      ctx.luckysheetCellUpdate = [];
      selectionCache.isPasteAction = false;
      var clipboardData = e.clipboardData;
      if (!clipboardData) {
        clipboardData = window.clipboardData;
      }
      if (!clipboardData) return;
      var txtdata = clipboardData.getData("text/html") || clipboardData.getData("text/plain");
      var isEqual = true;
      if (txtdata.indexOf("fortune-copy-action-table") > -1 && ((_ctx$luckysheet_copy_9 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_9 === void 0 ? void 0 : _ctx$luckysheet_copy_9.copyRange) != null && ctx.luckysheet_copy_save.copyRange.length > 0) {
        var cpDataArr = [];
        var reg = /<tr.*?>(.*?)<\/tr>/g;
        var reg2 = /<td.*?>(.*?)<\/td>/g;
        var regArr = txtdata.match(reg) || [];
        for (var i2 = 0; i2 < regArr.length; i2 += 1) {
          var cpRowArr = [];
          var reg2Arr = regArr[i2].match(reg2);
          if (!_$1.isNil(reg2Arr)) {
            for (var j2 = 0; j2 < reg2Arr.length; j2 += 1) {
              var cpValue = reg2Arr[j2].replace(/<td.*?>/g, "").replace(/<\/td>/g, "");
              cpRowArr.push(cpValue);
            }
          }
          cpDataArr.push(cpRowArr);
        }
        var copy_r1 = ctx.luckysheet_copy_save.copyRange[0].row[0];
        var copy_r2 = ctx.luckysheet_copy_save.copyRange[0].row[1];
        var copy_c1 = ctx.luckysheet_copy_save.copyRange[0].column[0];
        var copy_c2 = ctx.luckysheet_copy_save.copyRange[0].column[1];
        var copy_index = ctx.luckysheet_copy_save.dataSheetId;
        var d2;
        if (copy_index === ctx.currentSheetId) {
          d2 = getFlowdata(ctx);
        } else {
          var index2 = getSheetIndex(ctx, copy_index);
          if (_$1.isNil(index2)) return;
          d2 = ctx.luckysheetfile[index2].data;
        }
        if (!d2) return;
        for (var r2 = copy_r1; r2 <= copy_r2; r2 += 1) {
          if (r2 - copy_r1 > cpDataArr.length - 1) {
            break;
          }
          for (var c2 = copy_c1; c2 <= copy_c2; c2 += 1) {
            var _d$r3, _d$r3$c, _d$r3$c$ct;
            var cell = d2[r2][c2];
            var isInlineStr = false;
            if (!_$1.isNil(cell) && !_$1.isNil(cell.mc) && _$1.isNil(cell.mc.rs)) {
              continue;
            }
            var v2 = void 0;
            if (!_$1.isNil(cell)) {
              var _cell$ct$fa$indexOf, _cell$ct, _cell$ct$fa;
              if (((_cell$ct$fa$indexOf = (_cell$ct = cell.ct) === null || _cell$ct === void 0 ? void 0 : (_cell$ct$fa = _cell$ct.fa) === null || _cell$ct$fa === void 0 ? void 0 : _cell$ct$fa.indexOf("w")) !== null && _cell$ct$fa$indexOf !== void 0 ? _cell$ct$fa$indexOf : -1) > -1) {
                var _d$r, _d$r$c;
                v2 = (_d$r = d2[r2]) === null || _d$r === void 0 ? void 0 : (_d$r$c = _d$r[c2]) === null || _d$r$c === void 0 ? void 0 : _d$r$c.v;
              } else {
                var _d$r2, _d$r2$c;
                v2 = (_d$r2 = d2[r2]) === null || _d$r2 === void 0 ? void 0 : (_d$r2$c = _d$r2[c2]) === null || _d$r2$c === void 0 ? void 0 : _d$r2$c.m;
              }
            } else {
              v2 = "";
            }
            if (_$1.isNil(v2) && ((_d$r3 = d2[r2]) === null || _d$r3 === void 0 ? void 0 : (_d$r3$c = _d$r3[c2]) === null || _d$r3$c === void 0 ? void 0 : (_d$r3$c$ct = _d$r3$c.ct) === null || _d$r3$c$ct === void 0 ? void 0 : _d$r3$c$ct.t) === "inlineStr") {
              v2 = d2[r2][c2].ct.s.map(function(val) {
                return val.v;
              }).join("");
              isInlineStr = true;
            }
            if (_$1.isNil(v2)) {
              v2 = "";
            }
            if (isInlineStr) ;
            else {
              if (_$1.trim(cpDataArr[r2 - copy_r1][c2 - copy_c1]) !== _$1.trim(v2)) {
                isEqual = false;
                break;
              }
            }
          }
        }
      }
      var locale_fontjson = locale(ctx).fontjson;
      if (((_ctx$hooks$beforePast = (_ctx$hooks = ctx.hooks).beforePaste) === null || _ctx$hooks$beforePast === void 0 ? void 0 : _ctx$hooks$beforePast.call(_ctx$hooks, ctx.luckysheet_select_save, txtdata)) === false) {
        return;
      }
      if (txtdata.indexOf("fortune-copy-action-table") > -1 && ((_ctx$luckysheet_copy_10 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_10 === void 0 ? void 0 : _ctx$luckysheet_copy_10.copyRange) != null && ctx.luckysheet_copy_save.copyRange.length > 0 && isEqual) {
        if (ctx.luckysheet_paste_iscut) {
          ctx.luckysheet_paste_iscut = false;
          pasteHandlerOfCutPaste(ctx, ctx.luckysheet_copy_save);
          ctx.luckysheet_selection_range = [];
        } else {
          pasteHandlerOfCopyPaste(ctx, ctx.luckysheet_copy_save);
        }
      } else if (txtdata.indexOf("fortune-copy-action-image") > -1) ;
      else {
        if (txtdata.indexOf("table") > -1) {
          var _ele$querySelectorAll;
          var ele = document.createElement("div");
          ele.innerHTML = txtdata;
          var trList = ele.querySelectorAll("table tr");
          if (trList.length === 0) {
            ele.remove();
            return;
          }
          var data = new Array(trList.length);
          var colLen = 0;
          _$1.forEach(trList[0].querySelectorAll("td"), function(td2) {
            var colspan = td2.colSpan;
            if (Number.isNaN(colspan)) {
              colspan = 1;
            }
            colLen += colspan;
          });
          for (var _i8 = 0; _i8 < data.length; _i8 += 1) {
            data[_i8] = new Array(colLen);
          }
          var _r2 = 0;
          var borderInfo = {};
          var styleInner = ((_ele$querySelectorAll = ele.querySelectorAll("style")[0]) === null || _ele$querySelectorAll === void 0 ? void 0 : _ele$querySelectorAll.innerHTML) || "";
          var patternReg = /{([^}]*)}/g;
          var patternStyle = styleInner.match(patternReg);
          var nameReg = /^[^\t].*/gm;
          var patternName = _$1.initial(styleInner.match(nameReg));
          var allStyleList = patternName.length === (patternStyle === null || patternStyle === void 0 ? void 0 : patternStyle.length) && _typeof(patternName) === _typeof(patternStyle) ? _$1.fromPairs(_$1.zip(patternName, patternStyle)) : {};
          _$1.forEach(trList, function(tr) {
            var c3 = 0;
            var targetR = ctx.luckysheet_select_save[0].row[0] + _r2;
            var index3 = getSheetIndex(ctx, ctx.currentSheetId);
            if (!_$1.isNil(index3)) {
              if (_$1.isNil(ctx.luckysheetfile[index3].config)) {
                ctx.luckysheetfile[index3].config = {};
              }
              if (_$1.isNil(ctx.luckysheetfile[index3].config.rowlen)) {
                ctx.luckysheetfile[index3].config.rowlen = {};
              }
              var targetRowHeight = !_$1.isNil(tr.getAttribute("height")) ? parseInt(tr.getAttribute("height"), 10) : null;
              if (_$1.has(ctx.luckysheetfile[index3].config.rowlen, targetR) && ctx.luckysheetfile[index3].config.rowlen[targetR] !== targetRowHeight || !_$1.has(ctx.luckysheetfile[index3].config.rowlen, targetR) && ctx.luckysheetfile[index3].defaultRowHeight !== targetRowHeight) {
                var rowHeightList = ctx.luckysheetfile[index3].config.rowlen;
                rowHeightList[targetR] = targetRowHeight;
                setRowHeight(ctx, rowHeightList);
              }
            }
            _$1.forEach(tr.querySelectorAll("td"), function(td2) {
              var className = td2.className;
              var cell2 = {};
              var txt = td2.innerText || td2.innerHTML;
              if (_$1.trim(txt).length === 0) {
                cell2.v = void 0;
                cell2.m = "";
              } else {
                var mask = genarate(txt);
                var _mask2 = _slicedToArray$1(mask, 3);
                cell2.m = _mask2[0];
                cell2.ct = _mask2[1];
                cell2.v = _mask2[2];
              }
              var styleString = typeof allStyleList[".".concat(className)] === "string" ? allStyleList[".".concat(className)].substring(1, allStyleList[".".concat(className)].length - 1).split("\n	") : [];
              var styles = {};
              _$1.forEach(styleString, function(s2) {
                var styleList = s2.split(":");
                styles[styleList[0]] = styleList === null || styleList === void 0 ? void 0 : styleList[1].replace(";", "");
              });
              if (!_$1.isNil(styles.border)) td2.style.border = styles.border;
              var bg2 = td2.style.backgroundColor || styles.background;
              if (bg2 === "rgba(0, 0, 0, 0)" || _$1.isEmpty(bg2)) {
                bg2 = void 0;
              }
              cell2.bg = bg2;
              var fontWight = td2.style.fontWeight;
              cell2.bl = (fontWight.toString() === "400" || fontWight === "normal" || _$1.isEmpty(fontWight)) && !_$1.includes(styles["font-style"], "bold") && (!styles["font-weight"] || styles["font-weight"] === "400") ? 0 : 1;
              cell2.it = (td2.style.fontStyle === "normal" || _$1.isEmpty(td2.style.fontStyle)) && !_$1.includes(styles["font-style"], "italic") ? 0 : 1;
              cell2.un = !_$1.includes(styles["text-decoration"], "underline") ? void 0 : 1;
              cell2.cl = !_$1.includes(td2.innerHTML, "<s>") ? void 0 : 1;
              var ff2 = td2.style.fontFamily || styles["font-family"] || "";
              var ffs = ff2.split(",");
              for (var _i9 = 0; _i9 < ffs.length; _i9 += 1) {
                var fa2 = _$1.trim(ffs[_i9].toLowerCase());
                fa2 = locale_fontjson[fa2];
                if (_$1.isNil(fa2)) {
                  cell2.ff = 0;
                } else {
                  cell2.ff = fa2;
                  break;
                }
              }
              var fs = Math.round(styles["font-size"] ? parseInt(styles["font-size"].replace("pt", ""), 10) : parseInt(td2.style.fontSize || "13", 10) * 72 / 96);
              cell2.fs = fs;
              cell2.fc = td2.style.color || styles.color;
              var ht = td2.style.textAlign || styles["text-align"] || "left";
              if (ht === "center") {
                cell2.ht = 0;
              } else if (ht === "right") {
                cell2.ht = 2;
              } else {
                cell2.ht = 1;
              }
              var regex = /vertical-align:\s*(.*?);/;
              var vt = td2.style.verticalAlign || styles["vertical-align"] || !_$1.isNil(allStyleList.td) && allStyleList.td.match(regex).length > 0 && allStyleList.td.match(regex)[1] || "top";
              if (vt === "middle") {
                cell2.vt = 0;
              } else if (vt === "top" || vt === "text-top") {
                cell2.vt = 1;
              } else {
                cell2.vt = 2;
              }
              if ("mso-rotate" in styles) {
                var rt = styles["mso-rotate"];
                cell2.rt = parseFloat(rt);
              }
              while (c3 < colLen && !_$1.isNil(data[_r2][c3])) {
                c3 += 1;
              }
              if (c3 === colLen) {
                return true;
              }
              if (_$1.isNil(data[_r2][c3])) {
                data[_r2][c3] = cell2;
                var rowspan = parseInt(td2.getAttribute("rowspan"), 10);
                var colspan = parseInt(td2.getAttribute("colspan"), 10);
                if (Number.isNaN(rowspan)) {
                  rowspan = 1;
                }
                if (Number.isNaN(colspan)) {
                  colspan = 1;
                }
                var r_ab = ctx.luckysheet_select_save[0].row[0] + _r2;
                var c_ab = ctx.luckysheet_select_save[0].column[0] + c3;
                for (var rp = 0; rp < rowspan; rp += 1) {
                  for (var cp = 0; cp < colspan; cp += 1) {
                    if (rp === 0) {
                      var bt = td2.style.borderTop;
                      if (!_$1.isEmpty(bt) && bt.substring(0, 3).toLowerCase() !== "0px") {
                        var width = td2.style.borderTopWidth;
                        var type = td2.style.borderTopStyle;
                        var color = td2.style.borderTopColor;
                        var borderconfig = getQKBorder(width, type, color);
                        if (!borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)]) {
                          borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)] = {};
                        }
                        borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)].t = {
                          style: borderconfig[0],
                          color: borderconfig[1]
                        };
                      }
                    }
                    if (rp === rowspan - 1) {
                      var bb2 = td2.style.borderBottom;
                      if (!_$1.isEmpty(bb2) && bb2.substring(0, 3).toLowerCase() !== "0px") {
                        var _width = td2.style.borderBottomWidth;
                        var _type = td2.style.borderBottomStyle;
                        var _color = td2.style.borderBottomColor;
                        var _borderconfig = getQKBorder(_width, _type, _color);
                        if (!borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)]) {
                          borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)] = {};
                        }
                        borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)].b = {
                          style: _borderconfig[0],
                          color: _borderconfig[1]
                        };
                      }
                    }
                    if (cp === 0) {
                      var bl2 = td2.style.borderLeft;
                      if (!_$1.isEmpty(bl2) && bl2.substring(0, 3).toLowerCase() !== "0px") {
                        var _width2 = td2.style.borderLeftWidth;
                        var _type2 = td2.style.borderLeftStyle;
                        var _color2 = td2.style.borderLeftColor;
                        var _borderconfig2 = getQKBorder(_width2, _type2, _color2);
                        if (!borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)]) {
                          borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)] = {};
                        }
                        borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)].l = {
                          style: _borderconfig2[0],
                          color: _borderconfig2[1]
                        };
                      }
                    }
                    if (cp === colspan - 1) {
                      var br = td2.style.borderLeft;
                      if (!_$1.isEmpty(br) && br.substring(0, 3).toLowerCase() !== "0px") {
                        var _width3 = td2.style.borderRightWidth;
                        var _type3 = td2.style.borderRightStyle;
                        var _color3 = td2.style.borderRightColor;
                        var _borderconfig3 = getQKBorder(_width3, _type3, _color3);
                        if (!borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)]) {
                          borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)] = {};
                        }
                        borderInfo["".concat(_r2 + rp, "_").concat(c3 + cp)].r = {
                          style: _borderconfig3[0],
                          color: _borderconfig3[1]
                        };
                      }
                    }
                    if (rp === 0 && cp === 0) {
                      continue;
                    }
                    data[_r2 + rp][c3 + cp] = {
                      mc: {
                        r: r_ab,
                        c: c_ab
                      }
                    };
                  }
                }
                if (rowspan > 1 || colspan > 1) {
                  var first = {
                    rs: rowspan,
                    cs: colspan,
                    r: r_ab,
                    c: c_ab
                  };
                  data[_r2][c3].mc = first;
                }
              }
              c3 += 1;
              if (c3 === colLen) {
                return true;
              }
              return true;
            });
            _r2 += 1;
          });
          ctx.luckysheet_selection_range = [];
          pasteHandler(ctx, data, borderInfo);
          ele.remove();
        } else if (clipboardData.files.length === 1 && clipboardData.files[0].type.indexOf("image") > -1) ;
        else {
          txtdata = clipboardData.getData("text/plain");
          pasteHandler(ctx, txtdata);
        }
      }
    } else if (ctx.luckysheetCellUpdate.length > 0) {
      var _clipboardData2;
      e.preventDefault();
      var _clipboardData = e.clipboardData;
      if (!_clipboardData) {
        _clipboardData = window.clipboardData;
      }
      var text2 = (_clipboardData2 = _clipboardData) === null || _clipboardData2 === void 0 ? void 0 : _clipboardData2.getData("text/plain");
      if (text2) {
        document.execCommand("insertText", false, text2);
      }
    }
  }
  function handlePasteByClick(ctx, triggerType) {
    var _ctx$luckysheet_copy_11;
    var allowEdit = isAllowEdit(ctx);
    if (!allowEdit) return;
    var textarea = document.querySelector("#fortune-copy-content");
    var data = textarea === null || textarea === void 0 ? void 0 : textarea.innerHTML;
    if (!data) return;
    if (data.indexOf("fortune-copy-action-table") > -1 && ((_ctx$luckysheet_copy_11 = ctx.luckysheet_copy_save) === null || _ctx$luckysheet_copy_11 === void 0 ? void 0 : _ctx$luckysheet_copy_11.copyRange) != null && ctx.luckysheet_copy_save.copyRange.length > 0) {
      if (ctx.luckysheet_paste_iscut) {
        ctx.luckysheet_paste_iscut = false;
        pasteHandlerOfCutPaste(ctx, ctx.luckysheet_copy_save);
      } else {
        pasteHandlerOfCopyPaste(ctx, ctx.luckysheet_copy_save);
      }
    } else if (data.indexOf("fortune-copy-action-image") > -1) ;
    else ;
  }
  function n(n2) {
    for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++) t2[e2 - 1] = arguments[e2];
    throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
      return "'" + n3 + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
  }
  function r(n2) {
    return !!n2 && !!n2[Q];
  }
  function t(n2) {
    var r2;
    return !!n2 && (function(n3) {
      if (!n3 || "object" != typeof n3) return false;
      var r3 = Object.getPrototypeOf(n3);
      if (null === r3) return true;
      var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
      return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
    }(n2) || Array.isArray(n2) || !!n2[L] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L]) || s(n2) || v(n2));
  }
  function i(n2, r2, t2) {
    void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
      t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
    }) : n2.forEach(function(t3, e2) {
      return r2(e2, t3, n2);
    });
  }
  function o(n2) {
    var r2 = n2[Q];
    return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
  }
  function u(n2, r2) {
    return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
  }
  function a(n2, r2) {
    return 2 === o(n2) ? n2.get(r2) : n2[r2];
  }
  function f(n2, r2, t2) {
    var e2 = o(n2);
    2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
  }
  function c(n2, r2) {
    return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
  }
  function s(n2) {
    return X && n2 instanceof Map;
  }
  function v(n2) {
    return q && n2 instanceof Set;
  }
  function p(n2) {
    return n2.o || n2.t;
  }
  function l(n2) {
    if (Array.isArray(n2)) return Array.prototype.slice.call(n2);
    var r2 = rn(n2);
    delete r2[Q];
    for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
      var i2 = t2[e2], o2 = r2[i2];
      false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
    }
    return Object.create(Object.getPrototypeOf(n2), r2);
  }
  function d(n2, e2) {
    return void 0 === e2 && (e2 = false), y(n2) || r(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, r2) {
      return d(r2, true);
    }, true)), n2;
  }
  function h() {
    n(2);
  }
  function y(n2) {
    return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
  }
  function b(r2) {
    var t2 = tn[r2];
    return t2 || n(18, r2), t2;
  }
  function m(n2, r2) {
    tn[n2] || (tn[n2] = r2);
  }
  function _() {
    return U;
  }
  function j(n2, r2) {
    r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
  }
  function g(n2) {
    O(n2), n2.p.forEach(S), n2.p = null;
  }
  function O(n2) {
    n2 === U && (U = n2.l);
  }
  function w(n2) {
    return U = { p: [], l: U, h: n2, m: true, _: 0 };
  }
  function S(n2) {
    var r2 = n2[Q];
    0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
  }
  function P(r2, e2) {
    e2._ = e2.p.length;
    var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
    return e2.h.O || b("ES5").S(e2, r2, o2), o2 ? (i2[Q].P && (g(e2), n(4)), t(r2) && (r2 = M(e2, r2), e2.l || x(e2, r2)), e2.u && b("Patches").M(i2[Q].t, r2, e2.u, e2.s)) : r2 = M(e2, i2, []), g(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H ? r2 : void 0;
  }
  function M(n2, r2, t2) {
    if (y(r2)) return r2;
    var e2 = r2[Q];
    if (!e2) return i(r2, function(i2, o3) {
      return A(n2, e2, r2, i2, o3, t2);
    }, true), r2;
    if (e2.A !== n2) return r2;
    if (!e2.P) return x(n2, e2.t, true), e2.t;
    if (!e2.I) {
      e2.I = true, e2.A._--;
      var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o, u2 = o2, a2 = false;
      3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
        return A(n2, e2, o2, r3, i2, t2, a2);
      }), x(n2, o2, false), t2 && n2.u && b("Patches").N(e2, t2, n2.u, n2.s);
    }
    return e2.o;
  }
  function A(e2, i2, o2, a2, c2, s2, v2) {
    if (r(c2)) {
      var p2 = M(e2, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
      if (f(o2, a2, p2), !r(p2)) return;
      e2.m = false;
    } else v2 && o2.add(c2);
    if (t(c2) && !y(c2)) {
      if (!e2.h.D && e2._ < 1) return;
      M(e2, c2), i2 && i2.A.l || x(e2, c2);
    }
  }
  function x(n2, r2, t2) {
    void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d(r2, t2);
  }
  function z(n2, r2) {
    var t2 = n2[Q];
    return (t2 ? p(t2) : n2)[r2];
  }
  function I(n2, r2) {
    if (r2 in n2) for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e2 = Object.getOwnPropertyDescriptor(t2, r2);
      if (e2) return e2;
      t2 = Object.getPrototypeOf(t2);
    }
  }
  function k(n2) {
    n2.P || (n2.P = true, n2.l && k(n2.l));
  }
  function E(n2) {
    n2.o || (n2.o = l(n2.t));
  }
  function N(n2, r2, t2) {
    var e2 = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
      var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
      t3 && (i2 = [e3], o2 = on);
      var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
      return e3.k = f2, e3.j = a2, f2;
    }(r2, t2) : b("ES5").J(r2, t2);
    return (t2 ? t2.A : _()).p.push(e2), e2;
  }
  function R(e2) {
    return r(e2) || n(22, e2), function n2(r2) {
      if (!t(r2)) return r2;
      var e3, u2 = r2[Q], c2 = o(r2);
      if (u2) {
        if (!u2.P && (u2.i < 4 || !b("ES5").K(u2))) return u2.t;
        u2.I = true, e3 = D(r2, c2), u2.I = false;
      } else e3 = D(r2, c2);
      return i(e3, function(r3, t2) {
        u2 && a(u2.t, r3) === t2 || f(e3, r3, n2(t2));
      }), 3 === c2 ? new Set(e3) : e3;
    }(e2);
  }
  function D(n2, r2) {
    switch (r2) {
      case 2:
        return new Map(n2);
      case 3:
        return Array.from(n2);
    }
    return l(n2);
  }
  function T() {
    function e2(n2) {
      if (!t(n2)) return n2;
      if (Array.isArray(n2)) return n2.map(e2);
      if (s(n2)) return new Map(Array.from(n2.entries()).map(function(n3) {
        return [n3[0], e2(n3[1])];
      }));
      if (v(n2)) return new Set(Array.from(n2).map(e2));
      var r2 = Object.create(Object.getPrototypeOf(n2));
      for (var i2 in n2) r2[i2] = e2(n2[i2]);
      return u(n2, L) && (r2[L] = n2[L]), r2;
    }
    function f2(n2) {
      return r(n2) ? e2(n2) : n2;
    }
    var c2 = "add";
    m("Patches", { $: function(r2, t2) {
      return t2.forEach(function(t3) {
        for (var i2 = t3.path, u2 = t3.op, f3 = r2, s2 = 0; s2 < i2.length - 1; s2++) {
          var v2 = o(f3), p2 = i2[s2];
          "string" != typeof p2 && "number" != typeof p2 && (p2 = "" + p2), 0 !== v2 && 1 !== v2 || "__proto__" !== p2 && "constructor" !== p2 || n(24), "function" == typeof f3 && "prototype" === p2 && n(24), "object" != typeof (f3 = a(f3, p2)) && n(15, i2.join("/"));
        }
        var l2 = o(f3), d2 = e2(t3.value), h2 = i2[i2.length - 1];
        switch (u2) {
          case "replace":
            switch (l2) {
              case 2:
                return f3.set(h2, d2);
              case 3:
                n(16);
              default:
                return f3[h2] = d2;
            }
          case c2:
            switch (l2) {
              case 1:
                return "-" === h2 ? f3.push(d2) : f3.splice(h2, 0, d2);
              case 2:
                return f3.set(h2, d2);
              case 3:
                return f3.add(d2);
              default:
                return f3[h2] = d2;
            }
          case "remove":
            switch (l2) {
              case 1:
                return f3.splice(h2, 1);
              case 2:
                return f3.delete(h2);
              case 3:
                return f3.delete(t3.value);
              default:
                return delete f3[h2];
            }
          default:
            n(17, u2);
        }
      }), r2;
    }, N: function(n2, r2, t2, e3) {
      switch (n2.i) {
        case 0:
        case 4:
        case 2:
          return function(n3, r3, t3, e4) {
            var o2 = n3.t, s2 = n3.o;
            i(n3.R, function(n4, i2) {
              var v2 = a(o2, n4), p2 = a(s2, n4), l2 = i2 ? u(o2, n4) ? "replace" : c2 : "remove";
              if (v2 !== p2 || "replace" !== l2) {
                var d2 = r3.concat(n4);
                t3.push("remove" === l2 ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), e4.push(l2 === c2 ? { op: "remove", path: d2 } : "remove" === l2 ? { op: c2, path: d2, value: f2(v2) } : { op: "replace", path: d2, value: f2(v2) });
              }
            });
          }(n2, r2, t2, e3);
        case 5:
        case 1:
          return function(n3, r3, t3, e4) {
            var i2 = n3.t, o2 = n3.R, u2 = n3.o;
            if (u2.length < i2.length) {
              var a2 = [u2, i2];
              i2 = a2[0], u2 = a2[1];
              var s2 = [e4, t3];
              t3 = s2[0], e4 = s2[1];
            }
            for (var v2 = 0; v2 < i2.length; v2++) if (o2[v2] && u2[v2] !== i2[v2]) {
              var p2 = r3.concat([v2]);
              t3.push({ op: "replace", path: p2, value: f2(u2[v2]) }), e4.push({ op: "replace", path: p2, value: f2(i2[v2]) });
            }
            for (var l2 = i2.length; l2 < u2.length; l2++) {
              var d2 = r3.concat([l2]);
              t3.push({ op: c2, path: d2, value: f2(u2[l2]) });
            }
            i2.length < u2.length && e4.push({ op: "replace", path: r3.concat(["length"]), value: i2.length });
          }(n2, r2, t2, e3);
        case 3:
          return function(n3, r3, t3, e4) {
            var i2 = n3.t, o2 = n3.o, u2 = 0;
            i2.forEach(function(n4) {
              if (!o2.has(n4)) {
                var i3 = r3.concat([u2]);
                t3.push({ op: "remove", path: i3, value: n4 }), e4.unshift({ op: c2, path: i3, value: n4 });
              }
              u2++;
            }), u2 = 0, o2.forEach(function(n4) {
              if (!i2.has(n4)) {
                var o3 = r3.concat([u2]);
                t3.push({ op: c2, path: o3, value: n4 }), e4.unshift({ op: "remove", path: o3, value: n4 });
              }
              u2++;
            });
          }(n2, r2, t2, e3);
      }
    }, M: function(n2, r2, t2, e3) {
      t2.push({ op: "replace", path: [], value: r2 === H ? void 0 : r2 }), e3.push({ op: "replace", path: [], value: n2 });
    } });
  }
  var G, U, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X = "undefined" != typeof Map, q = "undefined" != typeof Set, B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
    return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
  } : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
    var r2 = {};
    return nn(n2).forEach(function(t2) {
      r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
    }), r2;
  }, tn = {}, en = { get: function(n2, r2) {
    if (r2 === Q) return n2;
    var e2 = p(n2);
    if (!u(e2, r2)) return function(n3, r3, t2) {
      var e3, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, r2);
    var i2 = e2[r2];
    return n2.I || !t(i2) ? i2 : i2 === z(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
  }, has: function(n2, r2) {
    return r2 in p(n2);
  }, ownKeys: function(n2) {
    return Reflect.ownKeys(p(n2));
  }, set: function(n2, r2, t2) {
    var e2 = I(p(n2), r2);
    if (null == e2 ? void 0 : e2.set) return e2.set.call(n2.k, t2), true;
    if (!n2.P) {
      var i2 = z(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
      if (o2 && o2.t === t2) return n2.o[r2] = t2, n2.R[r2] = false, true;
      if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2))) return true;
      E(n2), k(n2);
    }
    return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
  }, deleteProperty: function(n2, r2) {
    return void 0 !== z(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
  }, getOwnPropertyDescriptor: function(n2, r2) {
    var t2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
    return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
  }, defineProperty: function() {
    n(11);
  }, getPrototypeOf: function(n2) {
    return Object.getPrototypeOf(n2.t);
  }, setPrototypeOf: function() {
    n(12);
  } }, on = {};
  i(en, function(n2, r2) {
    on[n2] = function() {
      return arguments[0] = arguments[0][0], r2.apply(this, arguments);
    };
  }), on.deleteProperty = function(r2, t2) {
    return on.set.call(this, r2, t2, void 0);
  }, on.set = function(r2, t2, e2) {
    return en.set.call(this, r2[0], t2, e2, r2[0]);
  };
  var un = function() {
    function e2(r2) {
      var e3 = this;
      this.O = B, this.D = true, this.produce = function(r3, i3, o2) {
        if ("function" == typeof r3 && "function" != typeof i3) {
          var u2 = i3;
          i3 = r3;
          var a2 = e3;
          return function(n2) {
            var r4 = this;
            void 0 === n2 && (n2 = u2);
            for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++) e4[o3 - 1] = arguments[o3];
            return a2.produce(n2, function(n3) {
              var t3;
              return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
            });
          };
        }
        var f2;
        if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
          var c2 = w(e3), s2 = N(e3, r3, void 0), v2 = true;
          try {
            f2 = i3(s2), v2 = false;
          } finally {
            v2 ? g(c2) : O(c2);
          }
          return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
            return j(c2, o2), P(n2, c2);
          }, function(n2) {
            throw g(c2), n2;
          }) : (j(c2, o2), P(f2, c2));
        }
        if (!r3 || "object" != typeof r3) {
          if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e3.D && d(f2, true), o2) {
            var p2 = [], l2 = [];
            b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
          }
          return f2;
        }
        n(21, r3);
      }, this.produceWithPatches = function(n2, r3) {
        if ("function" == typeof n2) return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++) i4[o3 - 1] = arguments[o3];
          return e3.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
        var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
          t2 = n3, i3 = r4;
        });
        return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
          return [n3, t2, i3];
        }) : [o2, t2, i3];
      }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
    }
    var i2 = e2.prototype;
    return i2.createDraft = function(e3) {
      t(e3) || n(8), r(e3) && (e3 = R(e3));
      var i3 = w(this), o2 = N(this, e3, void 0);
      return o2[Q].C = true, O(i3), o2;
    }, i2.finishDraft = function(r2, t2) {
      var e3 = r2 && r2[Q];
      var i3 = e3.A;
      return j(i3, t2), P(void 0, i3);
    }, i2.setAutoFreeze = function(n2) {
      this.D = n2;
    }, i2.setUseProxies = function(r2) {
      r2 && !B && n(20), this.O = r2;
    }, i2.applyPatches = function(n2, t2) {
      var e3;
      for (e3 = t2.length - 1; e3 >= 0; e3--) {
        var i3 = t2[e3];
        if (0 === i3.path.length && "replace" === i3.op) {
          n2 = i3.value;
          break;
        }
      }
      e3 > -1 && (t2 = t2.slice(e3 + 1));
      var o2 = b("Patches").$;
      return r(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
        return o2(n3, t2);
      });
    }, e2;
  }(), an = new un(), fn = an.produce, cn = an.produceWithPatches.bind(an);
  an.setAutoFreeze.bind(an);
  an.setUseProxies.bind(an);
  var pn = an.applyPatches.bind(an);
  an.createDraft.bind(an);
  an.finishDraft.bind(an);
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _slicedToArray(arr, i2) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _iterableToArrayLimit(arr, i2) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i2 && _arr.length === i2) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _unsupportedIterableToArray(o2, minLen) {
    if (!o2) return;
    if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
    if (n2 === "Map" || n2 === "Set") return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var WorkbookContext = /* @__PURE__ */ React.createContext({
    context: defaultContext({
      undoList: [],
      redoList: []
    }),
    setContext: function setContext() {
    },
    settings: defaultSettings,
    handleUndo: function handleUndo() {
    },
    handleRedo: function handleRedo() {
    },
    refs: {
      globalCache: {
        undoList: [],
        redoList: []
      },
      cellInput: /* @__PURE__ */ React.createRef(),
      fxInput: /* @__PURE__ */ React.createRef(),
      canvas: /* @__PURE__ */ React.createRef(),
      scrollbarX: /* @__PURE__ */ React.createRef(),
      scrollbarY: /* @__PURE__ */ React.createRef(),
      cellArea: /* @__PURE__ */ React.createRef(),
      workbookContainer: /* @__PURE__ */ React.createRef()
    }
  });
  var SVGIcon = function SVGIcon2(_ref) {
    var _ref$width = _ref.width, width = _ref$width === void 0 ? 24 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 24 : _ref$height, name = _ref.name, style = _ref.style;
    return /* @__PURE__ */ React.createElement("svg", {
      width,
      height,
      style
    }, /* @__PURE__ */ React.createElement("use", {
      xlinkHref: "#".concat(name)
    }));
  };
  var ColumnHeader = function ColumnHeader2() {
    var _refs$globalCache$fre;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings, refs = _useContext.refs;
    var containerRef = reactExports.useRef(null);
    var colChangeSizeRef = reactExports.useRef(null);
    var _useState = reactExports.useState({
      col: -1,
      col_pre: -1,
      col_index: -1
    }), _useState2 = _slicedToArray(_useState, 2), hoverLocation = _useState2[0], setHoverLocation = _useState2[1];
    var _useState3 = reactExports.useState([]), _useState4 = _slicedToArray(_useState3, 2), selectedLocation = _useState4[0], setSelectedLocation = _useState4[1];
    var allowEditRef = reactExports.useRef(true);
    var sheetIndex = getSheetIndex(context, context.currentSheetId);
    var sheet = sheetIndex == null ? null : context.luckysheetfile[sheetIndex];
    var freezeHandleLeft = reactExports.useMemo(function() {
      var _sheet$frozen, _sheet$frozen2, _sheet$frozen3, _sheet$frozen4;
      if ((sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen = sheet.frozen) === null || _sheet$frozen === void 0 ? void 0 : _sheet$frozen.type) === "column" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen2 = sheet.frozen) === null || _sheet$frozen2 === void 0 ? void 0 : _sheet$frozen2.type) === "rangeColumn" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen3 = sheet.frozen) === null || _sheet$frozen3 === void 0 ? void 0 : _sheet$frozen3.type) === "rangeBoth" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen4 = sheet.frozen) === null || _sheet$frozen4 === void 0 ? void 0 : _sheet$frozen4.type) === "both") {
        var _sheet$frozen5, _sheet$frozen5$range;
        return colLocationByIndex((sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen5 = sheet.frozen) === null || _sheet$frozen5 === void 0 ? void 0 : (_sheet$frozen5$range = _sheet$frozen5.range) === null || _sheet$frozen5$range === void 0 ? void 0 : _sheet$frozen5$range.column_focus) || 0, context.visibledatacolumn)[1] - 2 + context.scrollLeft;
      }
      return context.scrollLeft;
    }, [context.visibledatacolumn, sheet === null || sheet === void 0 ? void 0 : sheet.frozen, context.scrollLeft]);
    var onMouseMove = reactExports.useCallback(function(e) {
      if (context.luckysheet_cols_change_size) {
        return;
      }
      var x2 = e.pageX - containerRef.current.getBoundingClientRect().left + containerRef.current.scrollLeft;
      var col_location = colLocation(x2, context.visibledatacolumn);
      var _col_location = _slicedToArray(col_location, 3), col_pre = _col_location[0], col = _col_location[1], col_index = _col_location[2];
      if (col_index !== hoverLocation.col_index) {
        setHoverLocation({
          col_pre,
          col,
          col_index
        });
      }
      var flowdata = getFlowdata(context);
      if (!_$1.isNil(flowdata)) allowEditRef.current = isAllowEdit(context) && isAllowEdit(context, [{
        row: [0, flowdata.length - 1],
        column: col_location
      }]);
    }, [context, hoverLocation.col_index]);
    var onMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleColumnHeaderMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.cellInput.current, refs.fxInput.current);
      });
    }, [refs.globalCache, refs.cellInput, refs.fxInput, setContext]);
    var onMouseLeave = reactExports.useCallback(function() {
      if (context.luckysheet_cols_change_size) {
        return;
      }
      setHoverLocation({
        col: -1,
        col_pre: -1,
        col_index: -1
      });
    }, [context.luckysheet_cols_change_size]);
    var onColSizeHandleMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleColSizeHandleMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.workbookContainer.current, refs.cellArea.current);
      });
      e.stopPropagation();
    }, [refs.cellArea, refs.globalCache, refs.workbookContainer, setContext]);
    var onColFreezeHandleMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleColFreezeHandleMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.workbookContainer.current, refs.cellArea.current);
      });
      e.stopPropagation();
    }, [refs.cellArea, refs.globalCache, refs.workbookContainer, setContext]);
    var onContextMenu = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleContextMenu(draftCtx, settings, nativeEvent, refs.workbookContainer.current, refs.cellArea.current, "columnHeader");
      });
    }, [refs.workbookContainer, setContext, settings, refs.cellArea]);
    reactExports.useEffect(function() {
      var s2 = context.luckysheet_select_save;
      if (_$1.isNil(s2)) return;
      var columnTitleMap = {};
      for (var i2 = 0; i2 < s2.length; i2 += 1) {
        var c1 = s2[i2].column[0];
        var c2 = s2[i2].column[1];
        columnTitleMap = selectTitlesMap(columnTitleMap, c1, c2);
      }
      var columnTitleRange = selectTitlesRange(columnTitleMap);
      var selects = [];
      for (var j2 = 0; j2 < columnTitleRange.length; j2 += 1) {
        var _c = columnTitleRange[j2][0];
        var _c2 = columnTitleRange[j2][columnTitleRange[j2].length - 1];
        var col = colLocationByIndex(_c2, context.visibledatacolumn)[1];
        var col_pre = colLocationByIndex(_c, context.visibledatacolumn)[0];
        if (_$1.isNumber(col) && _$1.isNumber(col_pre)) {
          selects.push({
            col,
            col_pre,
            c1: _c,
            c2: _c2
          });
        }
      }
      setSelectedLocation(selects);
    }, [context.luckysheet_select_save, context.visibledatacolumn]);
    reactExports.useEffect(function() {
      containerRef.current.scrollLeft = context.scrollLeft;
    }, [context.scrollLeft]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "fortune-col-header",
      style: {
        height: context.columnHeaderHeight - 1.5
      },
      onMouseMove,
      onMouseDown,
      onMouseLeave,
      onContextMenu
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-cols-freeze-handle",
      onMouseDown: onColFreezeHandleMouseDown,
      style: {
        left: freezeHandleLeft
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-cols-change-size",
      ref: colChangeSizeRef,
      id: "fortune-cols-change-size",
      onMouseDown: onColSizeHandleMouseDown,
      style: {
        left: hoverLocation.col - 5,
        opacity: context.luckysheet_cols_change_size ? 1 : 0
      }
    }), !context.luckysheet_cols_change_size && hoverLocation.col_index >= 0 ? /* @__PURE__ */ React.createElement("div", {
      className: "fortune-col-header-hover",
      style: _$1.assign({
        left: hoverLocation.col_pre,
        width: hoverLocation.col - hoverLocation.col_pre - 1,
        display: "block"
      }, fixColumnStyleOverflowInFreeze(context, hoverLocation.col_index, hoverLocation.col_index, (_refs$globalCache$fre = refs.globalCache.freezen) === null || _refs$globalCache$fre === void 0 ? void 0 : _refs$globalCache$fre[context.currentSheetId]))
    }, allowEditRef.current && /* @__PURE__ */ React.createElement("span", {
      className: "header-arrow",
      onClick: function onClick(e) {
        setContext(function(ctx) {
          ctx.contextMenu = {
            x: e.pageX,
            y: 90,
            headerMenu: true
          };
        });
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "headDownArrow",
      width: 12
    }))) : null, selectedLocation.map(function(_ref, i2) {
      var _refs$globalCache$fre2;
      var col = _ref.col, col_pre = _ref.col_pre, c1 = _ref.c1, c2 = _ref.c2;
      return /* @__PURE__ */ React.createElement("div", {
        className: "fortune-col-header-selected",
        key: i2,
        style: _$1.assign({
          left: col_pre,
          width: col - col_pre - 1,
          display: "block",
          backgroundColor: "rgba(76, 76, 76, 0.1)"
        }, fixColumnStyleOverflowInFreeze(context, c1, c2, (_refs$globalCache$fre2 = refs.globalCache.freezen) === null || _refs$globalCache$fre2 === void 0 ? void 0 : _refs$globalCache$fre2[context.currentSheetId]))
      });
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cols-h-cells luckysheetsheetchange",
      id: "luckysheet-cols-h-cells_0",
      style: {
        width: context.ch_width,
        height: 1
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cols-h-cells-c"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-grdblkpush"
    }))));
  };
  var RowHeader = function RowHeader2() {
    var _refs$globalCache$fre;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings, refs = _useContext.refs;
    var rowChangeSizeRef = reactExports.useRef(null);
    var containerRef = reactExports.useRef(null);
    var _useState = reactExports.useState({
      row: -1,
      row_pre: -1,
      row_index: -1
    }), _useState2 = _slicedToArray(_useState, 2), hoverLocation = _useState2[0], setHoverLocation = _useState2[1];
    var _useState3 = reactExports.useState([]), _useState4 = _slicedToArray(_useState3, 2), selectedLocation = _useState4[0], setSelectedLocation = _useState4[1];
    var sheetIndex = getSheetIndex(context, context.currentSheetId);
    var sheet = sheetIndex == null ? null : context.luckysheetfile[sheetIndex];
    var freezeHandleTop = reactExports.useMemo(function() {
      var _sheet$frozen, _sheet$frozen2, _sheet$frozen3, _sheet$frozen4;
      if ((sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen = sheet.frozen) === null || _sheet$frozen === void 0 ? void 0 : _sheet$frozen.type) === "row" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen2 = sheet.frozen) === null || _sheet$frozen2 === void 0 ? void 0 : _sheet$frozen2.type) === "rangeRow" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen3 = sheet.frozen) === null || _sheet$frozen3 === void 0 ? void 0 : _sheet$frozen3.type) === "rangeBoth" || (sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen4 = sheet.frozen) === null || _sheet$frozen4 === void 0 ? void 0 : _sheet$frozen4.type) === "both") {
        var _sheet$frozen5, _sheet$frozen5$range;
        return rowLocationByIndex((sheet === null || sheet === void 0 ? void 0 : (_sheet$frozen5 = sheet.frozen) === null || _sheet$frozen5 === void 0 ? void 0 : (_sheet$frozen5$range = _sheet$frozen5.range) === null || _sheet$frozen5$range === void 0 ? void 0 : _sheet$frozen5$range.row_focus) || 0, context.visibledatarow)[1] + context.scrollTop;
      }
      return context.scrollTop;
    }, [context.visibledatarow, sheet === null || sheet === void 0 ? void 0 : sheet.frozen, context.scrollTop]);
    var onMouseMove = reactExports.useCallback(function(e) {
      if (context.luckysheet_rows_change_size) {
        return;
      }
      var y2 = e.pageY - containerRef.current.getBoundingClientRect().top + containerRef.current.scrollTop;
      var row_location = rowLocation(y2, context.visibledatarow);
      var _row_location = _slicedToArray(row_location, 3), row_pre = _row_location[0], row = _row_location[1], row_index = _row_location[2];
      if (row_pre !== hoverLocation.row_pre || row !== hoverLocation.row) {
        setHoverLocation({
          row_pre,
          row,
          row_index
        });
      }
    }, [context.luckysheet_rows_change_size, context.visibledatarow, hoverLocation.row, hoverLocation.row_pre]);
    var onMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleRowHeaderMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.cellInput.current, refs.fxInput.current);
      });
    }, [refs.globalCache, refs.cellInput, refs.fxInput, setContext]);
    var onMouseLeave = reactExports.useCallback(function() {
      if (context.luckysheet_rows_change_size) {
        return;
      }
      setHoverLocation({
        row: -1,
        row_pre: -1,
        row_index: -1
      });
    }, [context.luckysheet_rows_change_size]);
    var onRowSizeHandleMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleRowSizeHandleMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.workbookContainer.current, refs.cellArea.current);
      });
      e.stopPropagation();
    }, [refs.cellArea, refs.globalCache, refs.workbookContainer, setContext]);
    var onRowFreezeHandleMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleRowFreezeHandleMouseDown(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.workbookContainer.current, refs.cellArea.current);
      });
      e.stopPropagation();
    }, [refs.cellArea, refs.globalCache, refs.workbookContainer, setContext]);
    var onContextMenu = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleContextMenu(draftCtx, settings, nativeEvent, refs.workbookContainer.current, refs.cellArea.current, "rowHeader");
      });
    }, [refs.workbookContainer, setContext, settings, refs.cellArea]);
    reactExports.useEffect(function() {
      var s2 = context.luckysheet_select_save || [];
      var rowTitleMap = {};
      for (var i2 = 0; i2 < s2.length; i2 += 1) {
        var r1 = s2[i2].row[0];
        var r2 = s2[i2].row[1];
        rowTitleMap = selectTitlesMap(rowTitleMap, r1, r2);
      }
      var rowTitleRange = selectTitlesRange(rowTitleMap);
      var selects = [];
      for (var _i = 0; _i < rowTitleRange.length; _i += 1) {
        var _r = rowTitleRange[_i][0];
        var _r2 = rowTitleRange[_i][rowTitleRange[_i].length - 1];
        var row = rowLocationByIndex(_r2, context.visibledatarow)[1];
        var row_pre = rowLocationByIndex(_r, context.visibledatarow)[0];
        if (_$1.isNumber(row_pre) && _$1.isNumber(row)) {
          selects.push({
            row,
            row_pre,
            r1: _r,
            r2: _r2
          });
        }
      }
      setSelectedLocation(selects);
    }, [context.luckysheet_select_save, context.visibledatarow]);
    reactExports.useEffect(function() {
      containerRef.current.scrollTop = context.scrollTop;
    }, [context.scrollTop]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "fortune-row-header",
      style: {
        width: context.rowHeaderWidth - 1.5,
        height: context.cellmainHeight
      },
      onMouseMove,
      onMouseDown,
      onMouseLeave,
      onContextMenu
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-rows-freeze-handle",
      onMouseDown: onRowFreezeHandleMouseDown,
      style: {
        top: freezeHandleTop
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-rows-change-size",
      ref: rowChangeSizeRef,
      onMouseDown: onRowSizeHandleMouseDown,
      style: {
        top: hoverLocation.row - 3,
        opacity: context.luckysheet_rows_change_size ? 1 : 0
      }
    }), !context.luckysheet_rows_change_size && hoverLocation.row_index >= 0 ? /* @__PURE__ */ React.createElement("div", {
      className: "fortune-row-header-hover",
      style: _$1.assign({
        top: hoverLocation.row_pre,
        height: hoverLocation.row - hoverLocation.row_pre - 1,
        display: "block"
      }, fixRowStyleOverflowInFreeze(context, hoverLocation.row_index, hoverLocation.row_index, (_refs$globalCache$fre = refs.globalCache.freezen) === null || _refs$globalCache$fre === void 0 ? void 0 : _refs$globalCache$fre[context.currentSheetId]))
    }) : null, selectedLocation.map(function(_ref, i2) {
      var _refs$globalCache$fre2;
      var row = _ref.row, row_pre = _ref.row_pre, r1 = _ref.r1, r2 = _ref.r2;
      return /* @__PURE__ */ React.createElement("div", {
        className: "fortune-row-header-selected",
        key: i2,
        style: _$1.assign({
          top: row_pre,
          height: row - row_pre - 1,
          display: "block",
          backgroundColor: "rgba(76, 76, 76, 0.1)"
        }, fixRowStyleOverflowInFreeze(context, r1, r2, (_refs$globalCache$fre2 = refs.globalCache.freezen) === null || _refs$globalCache$fre2 === void 0 ? void 0 : _refs$globalCache$fre2[context.currentSheetId]))
      });
    }), /* @__PURE__ */ React.createElement("div", {
      style: {
        height: context.rh_height,
        width: 1
      },
      id: "luckysheetrowHeader_0",
      className: "luckysheetsheetchange"
    }));
  };
  var ContentEditable = function ContentEditable2(_ref) {
    var props = _extends({}, _ref);
    var lastHtml = reactExports.useRef("");
    var root = reactExports.useRef(null);
    var autoFocus = props.autoFocus, initialContent = props.initialContent, onChange = props.onChange;
    reactExports.useEffect(function() {
      if (autoFocus) {
        var _root$current;
        (_root$current = root.current) === null || _root$current === void 0 ? void 0 : _root$current.focus();
      }
    }, [autoFocus]);
    reactExports.useEffect(function() {
      if (initialContent && root.current != null) {
        root.current.innerHTML = initialContent;
      }
    }, [initialContent]);
    var fnEmitChange = reactExports.useCallback(function(__, isBlur) {
      var html;
      if (root.current != null) {
        html = root.current.innerHTML;
      }
      if (onChange && html !== lastHtml.current) {
        onChange(html || "", isBlur);
      }
      lastHtml.current = html || "";
    }, [root, onChange]);
    var innerRef = props.innerRef, _onBlur = props.onBlur;
    var allowEdit = props.allowEdit;
    if (_$1.isNil(allowEdit)) allowEdit = true;
    return /* @__PURE__ */ React.createElement("div", _objectSpread2(_objectSpread2({
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onDoubleClick: function onDoubleClick(e) {
        return e.stopPropagation();
      },
      onClick: function onClick(e) {
        return e.stopPropagation();
      }
    }, _$1.omit(props, "innerRef", "onChange", "html", "onBlur", "autoFocus", "allowEdit", "initialContent")), {}, {
      ref: function ref(e) {
        root.current = e;
        innerRef === null || innerRef === void 0 ? void 0 : innerRef(e);
      },
      tabIndex: 0,
      onInput: fnEmitChange,
      onBlur: function onBlur(e) {
        fnEmitChange(null, true);
        _onBlur === null || _onBlur === void 0 ? void 0 : _onBlur(e);
      },
      contentEditable: allowEdit
    }));
  };
  var FormulaSearch = function FormulaSearch2(props) {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context;
    if (_$1.isEmpty(context.functionCandidates)) return null;
    return /* @__PURE__ */ React.createElement("div", _objectSpread2(_objectSpread2({}, props), {}, {
      id: "luckysheet-formula-search-c",
      className: "luckysheet-formula-search-c"
    }), context.functionCandidates.map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: v2.n,
        "data-func": v2.n,
        className: "luckysheet-formula-search-item"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-formula-search-func"
      }, v2.n), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-formula-search-detail"
      }, v2.d));
    }));
  };
  var FormulaHint = function FormulaHint2(props) {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context;
    var _locale = locale(context), formulaMore = _locale.formulaMore;
    if (!context.functionHint) return null;
    var fn2 = context.formulaCache.functionlistMap[context.functionHint];
    if (!fn2) return null;
    return /* @__PURE__ */ React.createElement("div", _objectSpread2(_objectSpread2({}, props), {}, {
      id: "luckysheet-formula-help-c",
      className: "luckysheet-formula-help-c"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-close",
      title: "关闭"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-times",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-collapse",
      title: "收起"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-angle-up",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-title"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-title-formula"
    }, /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-help-function-name"
    }, fn2.n), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-paren"
    }, "("), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-parameter-holder"
    }, fn2.p.map(function(param, i2) {
      var name = param.name;
      if (param.repeat === "y") {
        name += ", ...";
      }
      if (param.require === "o") {
        name = "[".concat(name, "]");
      }
      return /* @__PURE__ */ React.createElement("span", {
        className: "luckysheet-arguments-help-parameter",
        dir: "auto",
        key: name
      }, name, i2 !== fn2.p.length - 1 && ", ");
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-paren"
    }, ")"))), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-content"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-content-example"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-arguments-help-section-title"
    }, formulaMore.helpExample), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-arguments-help-formula"
    }, /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-help-function-name"
    }, fn2.n), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-paren"
    }, "("), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-parameter-holder"
    }, fn2.p.map(function(param, i2) {
      return /* @__PURE__ */ React.createElement("span", {
        key: param.name,
        className: "luckysheet-arguments-help-parameter",
        dir: "auto"
      }, param.example, i2 !== fn2.p.length - 1 && ", ");
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-paren"
    }, ")"))), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-content-detail"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-arguments-help-section"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-arguments-help-section-title luckysheet-arguments-help-parameter-name"
    }, formulaMore.helpAbstract), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-arguments-help-parameter-content"
    }, fn2.d))), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-content-param"
    }, fn2.p.map(function(param) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-arguments-help-section",
        key: param.name
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-arguments-help-section-title"
      }, param.name, param.repeat === "y" && /* @__PURE__ */ React.createElement("span", {
        className: "luckysheet-arguments-help-argument-info"
      }, "...-", formulaMore.allowRepeatText), param.require === "o" && /* @__PURE__ */ React.createElement("span", {
        className: "luckysheet-arguments-help-argument-info"
      }, "-[", formulaMore.allowOptionText, "]")), /* @__PURE__ */ React.createElement("span", {
        className: "luckysheet-arguments-help-parameter-content"
      }, param.detail));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-formula-help-foot"
    }));
  };
  function usePrevious(value) {
    var ref = reactExports.useRef();
    reactExports.useEffect(function() {
      ref.current = value;
    }, [value]);
    return ref.current;
  }
  var InputBox = function InputBox2() {
    var _context$luckysheet_s, _context$rangeDialog;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var inputRef = reactExports.useRef(null);
    var lastKeyDownEventRef = reactExports.useRef();
    var prevCellUpdate = usePrevious(context.luckysheetCellUpdate);
    var prevSheetId = usePrevious(context.currentSheetId);
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), isHidenRC = _useState2[0], setIsHidenRC = _useState2[1];
    var firstSelection = (_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s[0];
    var row_index = firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.row_focus;
    var col_index = firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.column_focus;
    var preText = reactExports.useRef("");
    var inputBoxStyle = reactExports.useMemo(function() {
      if (firstSelection && context.luckysheetCellUpdate.length > 0) {
        var flowdata = getFlowdata(context);
        if (!flowdata) return {};
        return getStyleByCell(context, flowdata, firstSelection.row_focus, firstSelection.column_focus);
      }
      return {};
    }, [context.luckysheetfile, context.currentSheetId, context.luckysheetCellUpdate, firstSelection]);
    reactExports.useLayoutEffect(function() {
      if (!context.allowEdit) {
        setContext(function(ctx) {
          var flowdata2 = getFlowdata(ctx);
          if (!_$1.isNil(flowdata2) && ctx.forceFormulaRef) {
            var value2 = getCellValue(row_index, col_index, flowdata2, "f");
            createRangeHightlight(ctx, value2);
          }
        });
      }
      if (firstSelection && context.luckysheetCellUpdate.length > 0) {
        var _flowdata$row_index;
        if (refs.globalCache.doNotUpdateCell) {
          delete refs.globalCache.doNotUpdateCell;
          return;
        }
        if (_$1.isEqual(prevCellUpdate, context.luckysheetCellUpdate) && prevSheetId === context.currentSheetId) {
          return;
        }
        var flowdata = getFlowdata(context);
        var cell = flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$row_index = flowdata[row_index]) === null || _flowdata$row_index === void 0 ? void 0 : _flowdata$row_index[col_index];
        var value = "";
        if (cell && !refs.globalCache.overwriteCell) {
          if (isInlineStringCell(cell)) {
            value = getInlineStringHTML(row_index, col_index, flowdata);
          } else if (cell.f) {
            value = getCellValue(row_index, col_index, flowdata, "f");
            setContext(function(ctx) {
              createRangeHightlight(ctx, value);
            });
          } else {
            value = valueShowEs(row_index, col_index, flowdata);
            if (Number(cell.qp) === 1) {
              value = value ? "".concat(value) : value;
            }
          }
        }
        refs.globalCache.overwriteCell = false;
        if (!refs.globalCache.ignoreWriteCell) inputRef.current.innerHTML = escapeHTMLTag(escapeScriptTag(value));
        refs.globalCache.ignoreWriteCell = false;
        if (!refs.globalCache.doNotFocus) {
          setTimeout(function() {
            moveToEnd(inputRef.current);
          });
        }
        delete refs.globalCache.doNotFocus;
      }
    }, [context.luckysheetCellUpdate, context.luckysheetfile, context.currentSheetId, firstSelection]);
    reactExports.useEffect(function() {
      if (_$1.isEmpty(context.luckysheetCellUpdate)) {
        if (inputRef.current) {
          inputRef.current.innerHTML = "";
        }
      }
    }, [context.luckysheetCellUpdate]);
    reactExports.useEffect(function() {
      setIsHidenRC(isShowHidenCR(context));
    }, [context.luckysheet_select_save]);
    var onKeyDown = reactExports.useCallback(function(e) {
      lastKeyDownEventRef.current = new KeyboardEvent(e.type, e.nativeEvent);
      preText.current = inputRef.current.innerText;
      if (e.key === "Escape" && context.luckysheetCellUpdate.length > 0) {
        setContext(function(draftCtx) {
          cancelNormalSelected(draftCtx);
          moveHighlightCell(draftCtx, "down", 0);
        });
        e.preventDefault();
      } else if (e.key === "Enter" && context.luckysheetCellUpdate.length > 0) {
        if (e.altKey || e.metaKey) {
          document.execCommand("insertHTML", false, "\n ");
          document.execCommand("delete", false);
          e.stopPropagation();
        }
      } else if (e.key === "Tab" && context.luckysheetCellUpdate.length > 0) {
        setContext(function(draftCtx) {
          updateCell(draftCtx, draftCtx.luckysheetCellUpdate[0], draftCtx.luckysheetCellUpdate[1], refs.cellInput.current);
          moveHighlightCell(draftCtx, "right", 1);
        });
        e.preventDefault();
        e.stopPropagation();
      } else if (e.key === "F4" && context.luckysheetCellUpdate.length > 0) {
        e.preventDefault();
      }
    }, [context.luckysheetCellUpdate.length, refs.cellInput, setContext]);
    var onChange = reactExports.useCallback(function(__, isBlur) {
      var e = lastKeyDownEventRef.current;
      if (!e) return;
      var kcode = e.keyCode;
      if (!kcode) return;
      if (!(kcode >= 112 && kcode <= 123 || kcode <= 46 || kcode === 144 || kcode === 108 || e.ctrlKey || e.altKey || e.shiftKey && (kcode === 37 || kcode === 38 || kcode === 39 || kcode === 40)) || kcode === 8 || kcode === 32 || kcode === 46 || e.ctrlKey && kcode === 86) {
        setContext(function(draftCtx) {
          if ((draftCtx.formulaCache.rangestart || draftCtx.formulaCache.rangedrag_column_start || draftCtx.formulaCache.rangedrag_row_start || israngeseleciton(draftCtx)) && isBlur) return;
          handleFormulaInput(draftCtx, refs.fxInput.current, refs.cellInput.current, kcode, preText.current);
        });
      }
    }, [refs.cellInput, refs.fxInput, setContext]);
    var onPaste = reactExports.useCallback(function(e) {
      if (_$1.isEmpty(context.luckysheetCellUpdate)) {
        e.preventDefault();
      }
    }, [context.luckysheetCellUpdate]);
    var cfg = context.config || {};
    var rowReadOnly = cfg.rowReadOnly || {};
    var colReadOnly = cfg.colReadOnly || {};
    var edit = !((colReadOnly[col_index] || rowReadOnly[row_index]) && context.allowEdit === true);
    return /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-input-box",
      style: firstSelection && !((_context$rangeDialog = context.rangeDialog) === null || _context$rangeDialog === void 0 ? void 0 : _context$rangeDialog.show) ? {
        left: firstSelection.left,
        top: firstSelection.top,
        zIndex: _$1.isEmpty(context.luckysheetCellUpdate) ? -1 : 19,
        display: "block"
      } : {
        left: -1e4,
        top: -1e4,
        display: "block"
      },
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp(e) {
        return e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-input-box-inner",
      style: firstSelection ? _objectSpread2({
        minWidth: firstSelection.width,
        minHeight: firstSelection.height
      }, inputBoxStyle) : {}
    }, /* @__PURE__ */ React.createElement(ContentEditable, {
      innerRef: function innerRef(e) {
        inputRef.current = e;
        refs.cellInput.current = e;
      },
      className: "luckysheet-cell-input",
      id: "luckysheet-rich-text-editor",
      style: {
        transform: "scale(".concat(context.zoomRatio, ")"),
        transformOrigin: "left top",
        width: "".concat(100 / context.zoomRatio, "%"),
        height: "".concat(100 / context.zoomRatio, "%")
      },
      "aria-autocomplete": "list",
      onChange,
      onKeyDown,
      onPaste,
      allowEdit: edit ? !isHidenRC : edit
    })), document.activeElement === inputRef.current && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormulaSearch, {
      style: {
        top: ((firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.height_move) || 0) + 4
      }
    }), /* @__PURE__ */ React.createElement(FormulaHint, {
      style: {
        top: ((firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.height_move) || 0) + 4
      }
    })));
  };
  var ScrollBar = function ScrollBar2(_ref) {
    var axis = _ref.axis;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, refs = _useContext.refs, setContext = _useContext.setContext;
    reactExports.useEffect(function() {
      if (axis === "x") {
        refs.scrollbarX.current.scrollLeft = context.scrollLeft;
      } else {
        refs.scrollbarY.current.scrollTop = context.scrollTop;
      }
    }, [axis === "x" ? context.scrollLeft : context.scrollTop]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: axis === "x" ? refs.scrollbarX : refs.scrollbarY,
      style: axis === "x" ? {
        left: context.rowHeaderWidth,
        width: "calc(100% - ".concat(context.rowHeaderWidth, "px)")
      } : {
        height: "100%"
      },
      className: "luckysheet-scrollbars luckysheet-scrollbar-ltr luckysheet-scrollbar-".concat(axis),
      onScroll: function onScroll() {
        if (axis === "x") {
          setContext(function(draftCtx) {
            draftCtx.scrollLeft = refs.scrollbarX.current.scrollLeft;
          });
        } else {
          setContext(function(draftCtx) {
            draftCtx.scrollTop = refs.scrollbarY.current.scrollTop;
          });
        }
      }
    }, /* @__PURE__ */ React.createElement("div", {
      style: axis === "x" ? {
        width: context.ch_width,
        height: 10
      } : {
        width: 10,
        height: context.rh_height
      }
    }));
  };
  var Dialog = function Dialog2(_ref) {
    var type = _ref.type, onOk = _ref.onOk, onCancel = _ref.onCancel, children = _ref.children, containerStyle = _ref.containerStyle, contentStyle = _ref.contentStyle;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context;
    var _locale = locale(context), button = _locale.button;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-dialog",
      style: containerStyle
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-modal-dialog-header"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-modal-dialog-icon-close",
      onClick: onCancel
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "close",
      style: {
        padding: 7,
        cursor: "pointer"
      }
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-dialog-box-content",
      style: contentStyle
    }, children), type != null && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-dialog-box-button-container"
    }, type === "ok" ? /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-default",
      onClick: onOk
    }, button.confirm) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-primary",
      onClick: onOk
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-default",
      onClick: onCancel
    }, button.cancel))));
  };
  var MessageBox = function MessageBox2(_ref) {
    var _ref$type = _ref.type, type = _ref$type === void 0 ? "yesno" : _ref$type, onOk = _ref.onOk, onCancel = _ref.onCancel, children = _ref.children;
    return /* @__PURE__ */ React.createElement(Dialog, {
      type,
      onOk,
      onCancel,
      contentStyle: {
        width: 300,
        paddingTop: 20,
        paddingBottom: 30,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }, children);
  };
  var ModalContext = /* @__PURE__ */ React.createContext({
    component: null,
    showModal: function showModal() {
    },
    hideModal: function hideModal() {
    }
  });
  var ModalProvider = function ModalProvider2(_ref) {
    var children = _ref.children;
    var _useState = reactExports.useState(null), _useState2 = _slicedToArray(_useState, 2), component = _useState2[0], setComponent = _useState2[1];
    var showModal = reactExports.useCallback(function(c2) {
      setComponent(c2);
    }, []);
    var hideModal = reactExports.useCallback(function() {
      setComponent(null);
    }, []);
    var providerValue = reactExports.useMemo(function() {
      return {
        component: null,
        showModal,
        hideModal
      };
    }, [hideModal, showModal]);
    return /* @__PURE__ */ React.createElement(ModalContext.Provider, {
      value: providerValue
    }, children, component && /* @__PURE__ */ React.createElement("div", {
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onMouseMove: function onMouseMove(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp(e) {
        return e.stopPropagation();
      },
      onContextMenu: function onContextMenu(e) {
        return e.stopPropagation();
      },
      className: "fortune-popover-backdrop fortune-modal-container"
    }, component));
  };
  function useAlert() {
    var _useContext = reactExports.useContext(ModalContext), showModal = _useContext.showModal, hideModal = _useContext.hideModal;
    var showAlert = reactExports.useCallback(function(message) {
      var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ok";
      var onOk = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : hideModal;
      var onCancel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : hideModal;
      showModal(/* @__PURE__ */ React.createElement(MessageBox, {
        type,
        onOk,
        onCancel
      }, message));
    }, [hideModal, showModal]);
    return {
      showAlert,
      hideAlert: hideModal
    };
  }
  var SearchReplace = function SearchReplace2(_ref) {
    var getContainer = _ref.getContainer;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var _locale = locale(context), findAndReplace = _locale.findAndReplace, button = _locale.button;
    var _useState = reactExports.useState(""), _useState2 = _slicedToArray(_useState, 2), searchText = _useState2[0], setSearchText = _useState2[1];
    var _useState3 = reactExports.useState(""), _useState4 = _slicedToArray(_useState3, 2), replaceText = _useState4[0], setReplaceText = _useState4[1];
    var _useState5 = reactExports.useState(context.showReplace), _useState6 = _slicedToArray(_useState5, 2), showReplace = _useState6[0], setShowReplace = _useState6[1];
    var _useState7 = reactExports.useState([]), _useState8 = _slicedToArray(_useState7, 2), searchResult = _useState8[0], setSearchResult = _useState8[1];
    var _useState9 = reactExports.useState(), _useState10 = _slicedToArray(_useState9, 2), selectedCell = _useState10[0], setSelectedCell = _useState10[1];
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert;
    var _useState11 = reactExports.useState({
      regCheck: false,
      wordCheck: false,
      caseCheck: false
    }), _useState12 = _slicedToArray(_useState11, 2), checkMode = _useState12[0], checkModeReplace = _useState12[1];
    var closeDialog = reactExports.useCallback(function() {
      _$1.set(refs.globalCache, "searchDialog.mouseEnter", false);
      setContext(function(draftCtx) {
        draftCtx.showSearch = false;
        draftCtx.showReplace = false;
      });
    }, [refs.globalCache, setContext]);
    var setCheckMode = reactExports.useCallback(function(mode, value) {
      return checkModeReplace(fn(function(draft) {
        _$1.set(draft, mode, value);
      }));
    }, []);
    var getInitialPosition = reactExports.useCallback(function(container) {
      var rect = container.getBoundingClientRect();
      return {
        left: (rect.width - 500) / 2,
        top: (rect.height - 200) / 3
      };
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-search-replace",
      className: "fortune-search-replace fortune-dialog",
      style: getInitialPosition(getContainer()),
      onMouseEnter: function onMouseEnter() {
        _$1.set(refs.globalCache, "searchDialog.mouseEnter", true);
      },
      onMouseLeave: function onMouseLeave() {
        _$1.set(refs.globalCache, "searchDialog.mouseEnter", false);
      },
      onMouseDown: function onMouseDown(e) {
        var nativeEvent = e.nativeEvent;
        onSearchDialogMoveStart(refs.globalCache, nativeEvent, getContainer());
        e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "container",
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "icon-close fortune-modal-dialog-icon-close",
      onClick: closeDialog
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "close",
      style: {
        padding: 7,
        cursor: "pointer"
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "tabBox"
    }, /* @__PURE__ */ React.createElement("span", {
      id: "searchTab",
      className: showReplace ? "" : "on",
      onClick: function onClick() {
        return setShowReplace(false);
      }
    }, findAndReplace.find), /* @__PURE__ */ React.createElement("span", {
      id: "replaceTab",
      className: showReplace ? "on" : "",
      onClick: function onClick() {
        return setShowReplace(true);
      }
    }, findAndReplace.replace)), /* @__PURE__ */ React.createElement("div", {
      className: "ctBox"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "row"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "inputBox"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "textboxs",
      id: "searchInput"
    }, findAndReplace.findTextbox, "：", /* @__PURE__ */ React.createElement("input", {
      className: "formulaInputFocus",
      autoFocus: true,
      spellCheck: "false",
      onKeyDown: function onKeyDown(e) {
        return e.stopPropagation();
      },
      value: searchText,
      onChange: function onChange(e) {
        return setSearchText(e.target.value);
      }
    })), showReplace && /* @__PURE__ */ React.createElement("div", {
      className: "textboxs",
      id: "replaceInput"
    }, findAndReplace.replaceTextbox, "：", /* @__PURE__ */ React.createElement("input", {
      className: "formulaInputFocus",
      spellCheck: "false",
      onKeyDown: function onKeyDown(e) {
        return e.stopPropagation();
      },
      value: replaceText,
      onChange: function onChange(e) {
        return setReplaceText(e.target.value);
      }
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "checkboxs"
    }, /* @__PURE__ */ React.createElement("div", {
      id: "regCheck"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "checkbox",
      onChange: function onChange(e) {
        return setCheckMode("regCheck", e.target.checked);
      }
    }), /* @__PURE__ */ React.createElement("span", null, findAndReplace.regexTextbox)), /* @__PURE__ */ React.createElement("div", {
      id: "wordCheck"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "checkbox",
      onChange: function onChange(e) {
        return setCheckMode("wordCheck", e.target.checked);
      }
    }), /* @__PURE__ */ React.createElement("span", null, findAndReplace.wholeTextbox)), /* @__PURE__ */ React.createElement("div", {
      id: "caseCheck"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "checkbox",
      onChange: function onChange(e) {
        return setCheckMode("caseCheck", e.target.checked);
      }
    }), /* @__PURE__ */ React.createElement("span", null, findAndReplace.distinguishTextbox)))), /* @__PURE__ */ React.createElement("div", {
      className: "btnBox"
    }, showReplace && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      id: "replaceAllBtn",
      className: "fortune-message-box-button button-default",
      onClick: function onClick() {
        setContext(function(draftCtx) {
          setSelectedCell(void 0);
          var alertMsg = replaceAll(draftCtx, searchText, replaceText, checkMode);
          showAlert(alertMsg);
        });
      }
    }, findAndReplace.allReplaceBtn), /* @__PURE__ */ React.createElement("div", {
      id: "replaceBtn",
      className: "fortune-message-box-button button-default",
      onClick: function onClick() {
        return setContext(function(draftCtx) {
          setSelectedCell(void 0);
          var alertMsg = replace(draftCtx, searchText, replaceText, checkMode);
          if (alertMsg != null) {
            showAlert(alertMsg);
          }
        });
      }
    }, findAndReplace.replaceBtn)), /* @__PURE__ */ React.createElement("div", {
      id: "searchAllBtn",
      className: "fortune-message-box-button button-default",
      onClick: function onClick() {
        return setContext(function(draftCtx) {
          setSelectedCell(void 0);
          if (!searchText) return;
          var res = searchAll(draftCtx, searchText, checkMode);
          setSearchResult(res);
          if (_$1.isEmpty(res)) showAlert(findAndReplace.noFindTip);
        });
      }
    }, findAndReplace.allFindBtn), /* @__PURE__ */ React.createElement("div", {
      id: "searchNextBtn",
      className: "fortune-message-box-button button-default",
      onClick: function onClick() {
        return setContext(function(draftCtx) {
          setSearchResult([]);
          var alertMsg = searchNext(draftCtx, searchText, checkMode);
          if (alertMsg != null) showAlert(alertMsg);
        });
      }
    }, findAndReplace.findBtn))), /* @__PURE__ */ React.createElement("div", {
      className: "close-button fortune-message-box-button button-default",
      onClick: closeDialog
    }, button.close), searchResult.length > 0 && /* @__PURE__ */ React.createElement("div", {
      id: "searchAllbox"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "boxTitle"
    }, /* @__PURE__ */ React.createElement("span", null, findAndReplace.searchTargetSheet), /* @__PURE__ */ React.createElement("span", null, findAndReplace.searchTargetCell), /* @__PURE__ */ React.createElement("span", null, findAndReplace.searchTargetValue)), /* @__PURE__ */ React.createElement("div", {
      className: "boxMain"
    }, searchResult.map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "boxItem ".concat(_$1.isEqual(selectedCell, {
          r: v2.r,
          c: v2.c
        }) ? "on" : ""),
        key: v2.cellPosition,
        onClick: function onClick() {
          setContext(function(draftCtx) {
            draftCtx.luckysheet_select_save = normalizeSelection(draftCtx, [{
              row: [v2.r, v2.r],
              column: [v2.c, v2.c]
            }]);
            scrollToHighlightCell(draftCtx, v2.r, v2.c);
          });
          setSelectedCell({
            r: v2.r,
            c: v2.c
          });
        }
      }, /* @__PURE__ */ React.createElement("span", null, v2.sheetName), /* @__PURE__ */ React.createElement("span", null, v2.cellPosition), /* @__PURE__ */ React.createElement("span", null, v2.value));
    })))));
  };
  var LinkEditCard = function LinkEditCard2(_ref) {
    var r2 = _ref.r, c2 = _ref.c, rc2 = _ref.rc, originText = _ref.originText, originType = _ref.originType, originAddress = _ref.originAddress, isEditing = _ref.isEditing, position = _ref.position, selectingCellRange = _ref.selectingCellRange;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var _useState = reactExports.useState(originText), _useState2 = _slicedToArray(_useState, 2), linkText = _useState2[0], setLinkText = _useState2[1];
    var _useState3 = reactExports.useState(originAddress), _useState4 = _slicedToArray(_useState3, 2), linkAddress = _useState4[0], setLinkAddress = _useState4[1];
    var _useState5 = reactExports.useState(originType), _useState6 = _slicedToArray(_useState5, 2), linkType = _useState6[0], setLinkType = _useState6[1];
    var _locale = locale(context), insertLink = _locale.insertLink, linkTypeList = _locale.linkTypeList, button = _locale.button;
    var lastCell = reactExports.useRef(normalizeSelection(context, [{
      row: [r2, r2],
      column: [c2, c2]
    }]));
    var skipCellRangeSet = reactExports.useRef(true);
    var isLinkAddressValid = isLinkValid(context, linkType, linkAddress);
    var tooltip = /* @__PURE__ */ React.createElement("div", {
      className: "validation-input-tip"
    }, isLinkAddressValid.tooltip);
    var hideLinkCard = reactExports.useCallback(function() {
      _$1.set(refs.globalCache, "linkCard.mouseEnter", false);
      setContext(function(draftCtx) {
        draftCtx.linkCard = void 0;
      });
    }, [refs.globalCache, setContext]);
    var setRangeModalVisible = reactExports.useCallback(function(visible) {
      return setContext(function(draftCtx) {
        draftCtx.luckysheet_select_save = lastCell.current;
        if (draftCtx.linkCard != null) draftCtx.linkCard.selectingCellRange = visible;
      });
    }, [setContext]);
    var containerEvent = reactExports.useMemo(function() {
      return {
        onMouseEnter: function onMouseEnter() {
          return _$1.set(refs.globalCache, "linkCard.mouseEnter", true);
        },
        onMouseLeave: function onMouseLeave() {
          return _$1.set(refs.globalCache, "linkCard.mouseEnter", false);
        },
        onMouseDown: function onMouseDown(e) {
          return e.stopPropagation();
        },
        onMouseMove: function onMouseMove(e) {
          return e.stopPropagation();
        },
        onMouseUp: function onMouseUp(e) {
          return e.stopPropagation();
        },
        onKeyDown: function onKeyDown(e) {
          return e.stopPropagation();
        },
        onDoubleClick: function onDoubleClick(e) {
          return e.stopPropagation();
        }
      };
    }, [refs.globalCache]);
    var renderBottomButton = reactExports.useCallback(function(onOk, onCancel) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "button-group"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "button-basic button-default",
        onClick: onCancel
      }, button.cancel), /* @__PURE__ */ React.createElement("div", {
        className: "button-basic button-primary",
        onClick: onOk
      }, button.confirm));
    }, [button]);
    var renderToolbarButton = reactExports.useCallback(function(iconId, onClick) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "fortune-toolbar-button",
        onClick
      }, /* @__PURE__ */ React.createElement(SVGIcon, {
        name: iconId,
        style: {
          width: 18,
          height: 18
        }
      }));
    }, []);
    reactExports.useLayoutEffect(function() {
      setLinkAddress(originAddress);
      setLinkText(originText);
      setLinkType(originType);
    }, [rc2, originAddress, originText, originType]);
    reactExports.useLayoutEffect(function() {
      if (selectingCellRange) {
        skipCellRangeSet.current = true;
      }
    }, [selectingCellRange]);
    reactExports.useLayoutEffect(function() {
      if (skipCellRangeSet.current) {
        skipCellRangeSet.current = false;
        return;
      }
      if (selectingCellRange) {
        var len = _$1.size(context.luckysheet_select_save);
        if (len > 0) {
          setLinkAddress(getRangetxt(context, context.currentSheetId, context.luckysheet_select_save[len - 1], ""));
        }
      }
    }, [context, selectingCellRange]);
    if (!isEditing) {
      return /* @__PURE__ */ React.createElement("div", _objectSpread2(_objectSpread2({}, containerEvent), {}, {
        onKeyDown: function onKeyDown(e) {
          e.stopPropagation();
        },
        className: "fortune-link-modify-modal link-toolbar",
        style: {
          left: position.cellLeft + 20,
          top: position.cellBottom + 4
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "link-content",
        onClick: function onClick() {
          setContext(function(draftCtx) {
            return goToLink(draftCtx, r2, c2, linkType, linkAddress, refs.scrollbarX.current, refs.scrollbarY.current);
          });
        }
      }, linkType === "webpage" ? insertLink.openLink : replaceHtml(insertLink.goTo, {
        linkAddress
      })), context.allowEdit === true && /* @__PURE__ */ React.createElement("div", {
        className: "divider"
      }), context.allowEdit === true && linkType === "webpage" && renderToolbarButton("copy", function() {
        navigator.clipboard.writeText(originAddress);
        hideLinkCard();
      }), context.allowEdit === true && renderToolbarButton("pencil", function() {
        return setContext(function(draftCtx) {
          if (draftCtx.linkCard != null && draftCtx.allowEdit) {
            draftCtx.linkCard.isEditing = true;
          }
        });
      }), context.allowEdit === true && /* @__PURE__ */ React.createElement("div", {
        className: "divider"
      }), context.allowEdit === true && renderToolbarButton("unlink", function() {
        return setContext(function(draftCtx) {
          _$1.set(refs.globalCache, "linkCard.mouseEnter", false);
          removeHyperlink(draftCtx, r2, c2);
        });
      }));
    }
    return selectingCellRange ? /* @__PURE__ */ React.createElement("div", _objectSpread2(_objectSpread2({
      className: "fortune-link-modify-modal range-selection-modal",
      style: {
        left: position.cellLeft,
        top: position.cellBottom + 5
      }
    }, _$1.omit(containerEvent, ["onMouseDown", "onMouseMove", "onMouseUp"])), {}, {
      onMouseDown: function onMouseDown(e) {
        var nativeEvent = e.nativeEvent;
        onRangeSelectionModalMoveStart(context, refs.globalCache, nativeEvent);
        e.stopPropagation();
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "modal-icon-close",
      onClick: function onClick() {
        return setRangeModalVisible(false);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "close"
    })), /* @__PURE__ */ React.createElement("div", {
      className: "modal-title"
    }, insertLink.selectCellRange), /* @__PURE__ */ React.createElement("input", _objectSpread2(_objectSpread2({}, containerEvent), {}, {
      className: "range-selection-input ".concat(!linkAddress || isLinkAddressValid.isValid ? "" : "error-input"),
      placeholder: insertLink.cellRangePlaceholder,
      onChange: function onChange(e) {
        return setLinkAddress(e.target.value);
      },
      value: linkAddress
    })), tooltip, /* @__PURE__ */ React.createElement("div", {
      className: "modal-footer"
    }, renderBottomButton(function() {
      if (isLinkAddressValid.isValid) setRangeModalVisible(false);
    }, function() {
      setLinkAddress(originAddress);
      setRangeModalVisible(false);
    }))) : /* @__PURE__ */ React.createElement("div", _objectSpread2({
      className: "fortune-link-modify-modal",
      style: {
        left: position.cellLeft + 20,
        top: position.cellBottom + 4
      }
    }, containerEvent), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-line"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-title"
    }, insertLink.linkText), /* @__PURE__ */ React.createElement("input", {
      className: "fortune-link-modify-input",
      spellCheck: "false",
      autoFocus: true,
      value: linkText,
      onChange: function onChange(e) {
        return setLinkText(e.target.value);
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-line"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-title"
    }, insertLink.linkType), /* @__PURE__ */ React.createElement("select", {
      className: "fortune-link-modify-select",
      value: linkType,
      onChange: function onChange(e) {
        if (e.target.value === "sheet") {
          if (!linkText) {
            setLinkText(context.luckysheetfile[0].name);
          }
          setLinkAddress(context.luckysheetfile[0].name);
        } else {
          setLinkAddress("");
        }
        if (e.target.value === "cellrange") setRangeModalVisible(true);
        setLinkType(e.target.value);
      }
    }, linkTypeList.map(function(type) {
      return /* @__PURE__ */ React.createElement("option", {
        key: type.value,
        value: type.value
      }, type.text);
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-line"
    }, linkType === "webpage" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-title"
    }, insertLink.linkAddress), /* @__PURE__ */ React.createElement("input", {
      className: "fortune-link-modify-input ".concat(!linkAddress || isLinkAddressValid.isValid ? "" : "error-input"),
      spellCheck: "false",
      value: linkAddress,
      onChange: function onChange(e) {
        return setLinkAddress(e.target.value);
      }
    }), tooltip), linkType === "cellrange" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-title"
    }, insertLink.linkCell), /* @__PURE__ */ React.createElement("input", {
      className: "fortune-link-modify-input ".concat(!linkAddress || isLinkAddressValid.isValid ? "" : "error-input"),
      spellCheck: "false",
      value: linkAddress,
      onChange: function onChange(e) {
        return setLinkAddress(e.target.value);
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-cell-selector",
      onClick: function onClick() {
        return setRangeModalVisible(true);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "border-all"
    })), tooltip), linkType === "sheet" && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-link-modify-title"
    }, insertLink.linkSheet), /* @__PURE__ */ React.createElement("select", {
      className: "fortune-link-modify-select",
      onChange: function onChange(e) {
        if (!linkText) setLinkText(e.target.value);
        setLinkAddress(e.target.value);
      },
      value: linkAddress
    }, context.luckysheetfile.map(function(sheet) {
      return /* @__PURE__ */ React.createElement("option", {
        key: sheet.id,
        value: sheet.name
      }, sheet.name);
    })), tooltip)), /* @__PURE__ */ React.createElement("div", {
      className: "modal-footer"
    }, renderBottomButton(function() {
      if (!isLinkAddressValid.isValid) return;
      _$1.set(refs.globalCache, "linkCard.mouseEnter", false);
      setContext(function(draftCtx) {
        return saveHyperlink(draftCtx, r2, c2, linkText, linkType, linkAddress);
      });
    }, hideLinkCard)));
  };
  var FilterOptions = function FilterOptions2(_ref) {
    var getContainer = _ref.getContainer;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var filterOptions = context.filterOptions, currentSheetId = context.currentSheetId, filter = context.filter, visibledatarow = context.visibledatarow, visibledatacolumn = context.visibledatacolumn;
    var sheetIndex = getSheetIndex(context, context.currentSheetId);
    var filter_select = context.luckysheetfile[sheetIndex].filter_select;
    reactExports.useEffect(function() {
      setContext(function(draftCtx) {
        var sheetIdx = getSheetIndex(draftCtx, draftCtx.currentSheetId);
        if (sheetIdx == null) return;
        draftCtx.luckysheet_filter_save = draftCtx.luckysheetfile[sheetIdx].filter_select;
        draftCtx.filter = draftCtx.luckysheetfile[sheetIdx].filter || {};
        createFilterOptions(draftCtx, draftCtx.luckysheet_filter_save, void 0);
      });
    }, [visibledatarow, visibledatacolumn, setContext, currentSheetId, filter_select]);
    var showFilterContextMenu = reactExports.useCallback(function(v2, i2) {
      if (filterOptions == null) return;
      setContext(function(draftCtx) {
        var _draftCtx$filterConte, _draftCtx$filter$i;
        var container = getContainer();
        var workbookRect = refs.workbookContainer.current.getBoundingClientRect();
        if (((_draftCtx$filterConte = draftCtx.filterContextMenu) === null || _draftCtx$filterConte === void 0 ? void 0 : _draftCtx$filterConte.col) === filterOptions.startCol + i2) return;
        draftCtx.filterContextMenu = {
          x: v2.left + draftCtx.rowHeaderWidth - refs.scrollbarX.current.scrollLeft + workbookRect.x,
          y: v2.top + 20 + container.getBoundingClientRect().y + draftCtx.columnHeaderHeight - refs.scrollbarY.current.scrollTop + workbookRect.y,
          col: filterOptions.startCol + i2,
          startRow: filterOptions.startRow,
          endRow: filterOptions.endRow,
          startCol: filterOptions.startCol,
          endCol: filterOptions.endCol,
          hiddenRows: _$1.keys((_draftCtx$filter$i = draftCtx.filter[i2]) === null || _draftCtx$filter$i === void 0 ? void 0 : _draftCtx$filter$i.rowhidden).map(function(r2) {
            return parseInt(r2, 10);
          }),
          listBoxMaxHeight: 400
        };
      });
    }, [filterOptions, getContainer, refs.scrollbarX, refs.scrollbarY, refs.workbookContainer, setContext]);
    return filterOptions == null ? /* @__PURE__ */ React.createElement("div", null) : /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-filter-selected-sheet",
      className: "luckysheet-cell-selected luckysheet-filter-selected",
      style: {
        left: filterOptions.left,
        width: filterOptions.width,
        top: filterOptions.top,
        height: filterOptions.height,
        display: "block"
      }
    }), filterOptions.items.map(function(v2, i2) {
      var filterParam = filter[i2];
      return /* @__PURE__ */ React.createElement("div", {
        onMouseDown: function onMouseDown(e) {
          return e.stopPropagation();
        },
        onClick: function onClick(e) {
          e.stopPropagation();
          showFilterContextMenu(v2, i2);
        },
        onDoubleClick: function onDoubleClick(e) {
          return e.stopPropagation();
        },
        key: i2,
        style: {
          left: v2.left,
          top: v2.top
        },
        className: "luckysheet-filter-options ".concat(filterParam == null ? "" : "luckysheet-filter-options-active")
      }, filterParam == null ? /* @__PURE__ */ React.createElement("div", {
        className: "caret down"
      }) : /* @__PURE__ */ React.createElement(SVGIcon, {
        name: "filter-fill-white",
        style: {
          width: 15,
          height: 15
        }
      }));
    }));
  };
  var ImgBoxs = function ImgBoxs2() {
    var _context$insertedImgs;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var activeImg = reactExports.useMemo(function() {
      return _$1.find(context.insertedImgs, {
        id: context.activeImg
      });
    }, [context.activeImg, context.insertedImgs]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-image-showBoxs"
    }, activeImg && /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-modal-dialog-activeImage",
      className: "luckysheet-modal-dialog",
      style: {
        padding: 0,
        position: "absolute",
        zIndex: 300,
        width: activeImg.width * context.zoomRatio,
        height: activeImg.height * context.zoomRatio,
        left: activeImg.left * context.zoomRatio,
        top: activeImg.top * context.zoomRatio
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-border",
      style: {
        position: "absolute"
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-content",
      style: {
        width: activeImg.width * context.zoomRatio,
        height: activeImg.height * context.zoomRatio,
        backgroundImage: "url(".concat(activeImg.src, ")"),
        backgroundSize: "".concat(activeImg.width * context.zoomRatio, "px ").concat(activeImg.height * context.zoomRatio, "px"),
        backgroundRepeat: "no-repeat"
      },
      onMouseDown: function onMouseDown(e) {
        var nativeEvent = e.nativeEvent;
        onImageMoveStart(context, refs.globalCache, nativeEvent);
        e.stopPropagation();
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-resize"
    }, ["lt", "mt", "lm", "rm", "rt", "lb", "mb", "rb"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: v2,
        className: "luckysheet-modal-dialog-resize-item luckysheet-modal-dialog-resize-item-".concat(v2),
        "data-type": v2,
        onMouseDown: function onMouseDown(e) {
          var nativeEvent = e.nativeEvent;
          onImageResizeStart(refs.globalCache, nativeEvent, v2);
          e.stopPropagation();
        }
      });
    })), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-controll"
    }, /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-crop",
      role: "button",
      tabIndex: 0,
      "aria-label": "裁剪",
      title: "裁剪"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-pencil",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-restore",
      role: "button",
      tabIndex: 0,
      "aria-label": "恢复原图",
      title: "恢复原图"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-window-maximize",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-del",
      role: "button",
      tabIndex: 0,
      "aria-label": "删除",
      title: "删除"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-trash",
      "aria-hidden": "true"
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "img-list"
    }, (_context$insertedImgs = context.insertedImgs) === null || _context$insertedImgs === void 0 ? void 0 : _context$insertedImgs.map(function(v2) {
      var id2 = v2.id, left = v2.left, top = v2.top, width = v2.width, height = v2.height, src = v2.src;
      if (v2.id === context.activeImg) return null;
      return /* @__PURE__ */ React.createElement("div", {
        id: id2,
        key: id2,
        className: "luckysheet-modal-dialog luckysheet-modal-dialog-image",
        style: {
          width: width * context.zoomRatio,
          height: height * context.zoomRatio,
          padding: 0,
          position: "absolute",
          left: left * context.zoomRatio,
          top: top * context.zoomRatio,
          zIndex: 200
        },
        onMouseDown: function onMouseDown(e) {
          return e.stopPropagation();
        },
        onClick: function onClick(e) {
          setContext(function(ctx) {
            ctx.activeImg = id2;
          });
          e.stopPropagation();
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-modal-dialog-content",
        style: {
          width: "100%",
          height: "100%",
          overflow: "hidden",
          position: "relative"
        }
      }, /* @__PURE__ */ React.createElement("img", {
        src,
        alt: "",
        style: {
          width: width * context.zoomRatio,
          height: height * context.zoomRatio
        }
      })), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-modal-dialog-border"
      }));
    })), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-modal-dialog-cropping",
      className: "luckysheet-modal-dialog",
      style: {
        display: "none",
        padding: 0,
        position: "absolute",
        zIndex: 300
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "cropping-mask"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "cropping-content"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-border",
      style: {
        position: "absolute"
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-resize"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "resize-item lt",
      "data-type": "lt"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item mt",
      "data-type": "mt"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item lm",
      "data-type": "lm"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item rm",
      "data-type": "rm"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item rt",
      "data-type": "rt"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item lb",
      "data-type": "lb"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item mb",
      "data-type": "mb"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "resize-item rb",
      "data-type": "rb"
    })), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-modal-dialog-controll"
    }, /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-crop",
      role: "button",
      tabIndex: 0,
      "aria-label": "裁剪",
      title: "裁剪"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-pencil",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-restore",
      role: "button",
      tabIndex: 0,
      "aria-label": "恢复原图",
      title: "恢复原图"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-window-maximize",
      "aria-hidden": "true"
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-modal-controll-btn luckysheet-modal-controll-del",
      role: "button",
      tabIndex: 0,
      "aria-label": "删除",
      title: "删除"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "fa fa-trash",
      "aria-hidden": "true"
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "cell-date-picker"
    }));
  };
  var NotationBoxes = function NotationBoxes2() {
    var _context$commentBoxes;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var flowdata = getFlowdata(context);
    reactExports.useEffect(function() {
      if (flowdata) {
        var psShownCells = [];
        for (var i2 = 0; i2 < flowdata.length; i2 += 1) {
          for (var j2 = 0; j2 < flowdata[i2].length; j2 += 1) {
            var _cell$ps;
            var cell = flowdata[i2][j2];
            if (!cell) continue;
            if ((_cell$ps = cell.ps) === null || _cell$ps === void 0 ? void 0 : _cell$ps.isShow) {
              psShownCells.push({
                r: i2,
                c: j2
              });
            }
          }
        }
        setContext(function(ctx) {
          return showComments(ctx, psShownCells);
        });
      }
    }, [flowdata, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-postil-showBoxs"
    }, _$1.concat((_context$commentBoxes = context.commentBoxes) === null || _context$commentBoxes === void 0 ? void 0 : _context$commentBoxes.filter(function(v2) {
      var _context$editingComme;
      return (v2 === null || v2 === void 0 ? void 0 : v2.rc) !== ((_context$editingComme = context.editingCommentBox) === null || _context$editingComme === void 0 ? void 0 : _context$editingComme.rc);
    }), [context.editingCommentBox, context.hoveredCommentBox]).map(function(commentBox) {
      var _context$editingComme2;
      if (!commentBox) return null;
      var r2 = commentBox.r, c2 = commentBox.c, rc2 = commentBox.rc, left = commentBox.left, top = commentBox.top, width = commentBox.width, height = commentBox.height, value = commentBox.value, autoFocus = commentBox.autoFocus, size2 = commentBox.size;
      var isEditing = ((_context$editingComme2 = context.editingCommentBox) === null || _context$editingComme2 === void 0 ? void 0 : _context$editingComme2.rc) === rc2;
      var commentId = "comment-box-".concat(rc2);
      return /* @__PURE__ */ React.createElement("div", {
        key: rc2
      }, /* @__PURE__ */ React.createElement("canvas", {
        id: "arrowCanvas-".concat(rc2),
        className: "arrowCanvas",
        width: size2.width,
        height: size2.height,
        style: {
          position: "absolute",
          left: size2.left,
          top: size2.top,
          zIndex: 100,
          pointerEvents: "none"
        }
      }), /* @__PURE__ */ React.createElement("div", {
        id: commentId,
        className: "luckysheet-postil-show-main",
        style: {
          width,
          height,
          color: "#000",
          padding: 5,
          border: "1px solid #000",
          backgroundColor: "rgb(255,255,225)",
          position: "absolute",
          left,
          top,
          boxSizing: "border-box",
          zIndex: isEditing ? 200 : 100
        },
        onMouseDown: function onMouseDown(e) {
          var nativeEvent = e.nativeEvent;
          setContext(function(draftContext) {
            if (flowdata) {
              setEditingComment(draftContext, flowdata, r2, c2);
            }
          });
          onCommentBoxMoveStart(context, refs.globalCache, nativeEvent, {
            r: r2,
            c: c2,
            rc: rc2
          }, commentId);
          e.stopPropagation();
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-postil-dialog-move"
      }, ["t", "r", "b", "l"].map(function(v2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: v2,
          className: "luckysheet-postil-dialog-move-item luckysheet-postil-dialog-move-item-".concat(v2),
          "data-type": v2
        });
      })), isEditing && /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-postil-dialog-resize"
      }, ["lt", "mt", "lm", "rm", "rt", "lb", "mb", "rb"].map(function(v2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: v2,
          className: "luckysheet-postil-dialog-resize-item luckysheet-postil-dialog-resize-item-".concat(v2),
          "data-type": v2,
          onMouseDown: function onMouseDown(e) {
            var nativeEvent = e.nativeEvent;
            onCommentBoxResizeStart(context, refs.globalCache, nativeEvent, {
              r: r2,
              c: c2,
              rc: rc2
            }, commentId, v2);
            e.stopPropagation();
          }
        });
      })), /* @__PURE__ */ React.createElement("div", {
        style: {
          width: "100%",
          height: "100%",
          overflow: "hidden"
        }
      }, /* @__PURE__ */ React.createElement(ContentEditable, {
        id: "comment-editor-".concat(rc2),
        autoFocus,
        style: {
          width: "100%",
          height: "100%",
          lineHeight: "20px",
          boxSizing: "border-box",
          textAlign: "center",
          wordBreak: "break-all",
          outline: "none"
        },
        allowEdit: context.allowEdit,
        spellCheck: false,
        "data-r": r2,
        "data-c": c2,
        onKeyDown: function onKeyDown(e) {
          return e.stopPropagation();
        },
        onFocus: function onFocus(e) {
          if (context.allowEdit === false) return;
          refs.globalCache.editingCommentBoxEle = e.target;
        },
        onMouseDown: function onMouseDown(e) {
          setContext(function(draftContext) {
            if (flowdata) {
              setEditingComment(draftContext, flowdata, r2, c2);
            }
          });
          e.stopPropagation();
        },
        onDoubleClick: function onDoubleClick(e) {
          e.stopPropagation();
        },
        initialContent: value
      }))));
    }));
  };
  function useDialog() {
    var _useContext = reactExports.useContext(ModalContext), showModal = _useContext.showModal, hideModal = _useContext.hideModal;
    var showDialog = reactExports.useCallback(function(content, type) {
      var onOk = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : hideModal;
      var onCancel = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : hideModal;
      showModal(/* @__PURE__ */ React.createElement(Dialog, {
        type,
        onOk,
        onCancel
      }, content));
    }, [hideModal, showModal]);
    return {
      showDialog,
      hideDialog: hideModal
    };
  }
  var DataVerification = function DataVerification2() {
    var _context$dataVerifica, _context$dataVerifica2, _context$dataVerifica3, _context$dataVerifica4, _context$dataVerifica5, _context$dataVerifica6, _context$dataVerifica7, _context$dataVerifica8, _context$dataVerifica9, _context$dataVerifica10, _context$dataVerifica11, _context$dataVerifica12, _context$dataVerifica13, _context$dataVerifica14, _context$dataVerifica15, _context$dataVerifica16, _context$dataVerifica17, _context$dataVerifica18, _context$dataVerifica19, _context$dataVerifica20, _context$dataVerifica21, _context$dataVerifica22, _context$dataVerifica23, _context$dataVerifica24, _context$dataVerifica25;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog, hideDialog = _useDialog.hideDialog;
    var _locale = locale(context), dataVerification = _locale.dataVerification, toolbar = _locale.toolbar, button = _locale.button, generalDialog = _locale.generalDialog;
    var _useState = reactExports.useState(["between", "notBetween", "equal", "notEqualTo", "moreThanThe", "lessThan", "greaterOrEqualTo", "lessThanOrEqualTo"]), _useState2 = _slicedToArray(_useState, 1), numberCondition = _useState2[0];
    var _useState3 = reactExports.useState(["between", "notBetween", "equal", "notEqualTo", "earlierThan", "noEarlierThan", "laterThan", "noLaterThan"]), _useState4 = _slicedToArray(_useState3, 1), dateCondition = _useState4[0];
    var dataSelectRange = reactExports.useCallback(function(type, value) {
      hideDialog();
      setContext(function(ctx) {
        ctx.rangeDialog.show = true;
        ctx.rangeDialog.type = type;
        ctx.rangeDialog.rangeTxt = value;
      });
    }, [hideDialog, setContext]);
    var btn = reactExports.useCallback(function(type) {
      if (type === "confirm") {
        setContext(function(ctx) {
          var isPass = confirmMessage(ctx, generalDialog, dataVerification);
          if (isPass) {
            var _ctx$dataVerification, _ctx$dataVerification2, _ctx$luckysheetfile$g;
            var range = getRangeByTxt(ctx, (_ctx$dataVerification = ctx.dataVerification) === null || _ctx$dataVerification === void 0 ? void 0 : (_ctx$dataVerification2 = _ctx$dataVerification.dataRegulation) === null || _ctx$dataVerification2 === void 0 ? void 0 : _ctx$dataVerification2.rangeTxt);
            if (range.length === 0) {
              return;
            }
            var regulation = ctx.dataVerification.dataRegulation;
            var verifacationT = regulation === null || regulation === void 0 ? void 0 : regulation.type;
            var value1 = regulation.value1;
            var item = _objectSpread2(_objectSpread2({}, regulation), {}, {
              checked: false
            });
            if (verifacationT === "dropdown") {
              var list = getDropdownList(ctx, value1);
              item.value1 = list.join(",");
            }
            var currentDataVerification = (_ctx$luckysheetfile$g = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification) !== null && _ctx$luckysheetfile$g !== void 0 ? _ctx$luckysheetfile$g : {};
            var str = range[range.length - 1].row[0];
            var edr = range[range.length - 1].row[1];
            var stc = range[range.length - 1].column[0];
            var edc = range[range.length - 1].column[1];
            var d2 = getFlowdata(ctx);
            if (!d2) return;
            for (var r2 = str; r2 <= edr; r2 += 1) {
              for (var c2 = stc; c2 <= edc; c2 += 1) {
                var key = "".concat(r2, "_").concat(c2);
                currentDataVerification[key] = item;
                if (regulation.type === "checkbox") {
                  setCellValue(ctx, r2, c2, d2, item.value2);
                }
              }
            }
            ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification = currentDataVerification;
          }
        });
      } else if (type === "delete") {
        setContext(function(ctx) {
          var _ctx$dataVerification3, _ctx$dataVerification4, _ctx$luckysheetfile$g2;
          var range = getRangeByTxt(ctx, (_ctx$dataVerification3 = ctx.dataVerification) === null || _ctx$dataVerification3 === void 0 ? void 0 : (_ctx$dataVerification4 = _ctx$dataVerification3.dataRegulation) === null || _ctx$dataVerification4 === void 0 ? void 0 : _ctx$dataVerification4.rangeTxt);
          if (range.length === 0) {
            showDialog(generalDialog.noSeletionError, "ok");
            return;
          }
          var currentDataVerification = (_ctx$luckysheetfile$g2 = ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].dataVerification) !== null && _ctx$luckysheetfile$g2 !== void 0 ? _ctx$luckysheetfile$g2 : {};
          var str = range[range.length - 1].row[0];
          var edr = range[range.length - 1].row[1];
          var stc = range[range.length - 1].column[0];
          var edc = range[range.length - 1].column[1];
          for (var r2 = str; r2 <= edr; r2 += 1) {
            for (var c2 = stc; c2 <= edc; c2 += 1) {
              delete currentDataVerification["".concat(r2, "_").concat(c2)];
            }
          }
        });
      }
      hideDialog();
    }, [dataVerification, generalDialog, hideDialog, setContext, showDialog]);
    reactExports.useEffect(function() {
      setContext(function(ctx) {
        var rangeT = "";
        if (ctx.luckysheet_select_save) {
          var range = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
          rangeT = getRangetxt(context, context.currentSheetId, range, context.currentSheetId);
        }
        var index2 = getSheetIndex(ctx, ctx.currentSheetId);
        var ctxDataVerification = ctx.luckysheetfile[index2].dataVerification;
        if (ctxDataVerification) {
          var _defaultItem$value, _ctx$rangeDialog, _ctx$rangeDialog2;
          if (!ctx.luckysheet_select_save) return;
          var last = ctx.luckysheet_select_save[ctx.luckysheet_select_save.length - 1];
          var rowIndex = last.row_focus;
          var colIndex = last.column_focus;
          if (rowIndex == null || colIndex == null) return;
          var item = ctxDataVerification["".concat(rowIndex, "_").concat(colIndex)];
          var defaultItem = item !== null && item !== void 0 ? item : {};
          var rangValue = (_defaultItem$value = defaultItem.value1) !== null && _defaultItem$value !== void 0 ? _defaultItem$value : "";
          if (((_ctx$rangeDialog = ctx.rangeDialog) === null || _ctx$rangeDialog === void 0 ? void 0 : _ctx$rangeDialog.type) === "dropDown" && ctx.dataVerification && ctx.dataVerification.dataRegulation && ctx.dataVerification.dataRegulation.rangeTxt) {
            rangeT = ctx.dataVerification.dataRegulation.rangeTxt;
            rangValue = ctx.rangeDialog.rangeTxt;
          } else if (((_ctx$rangeDialog2 = ctx.rangeDialog) === null || _ctx$rangeDialog2 === void 0 ? void 0 : _ctx$rangeDialog2.type) === "rangeTxt" && ctx.dataVerification && ctx.dataVerification.dataRegulation && ctx.dataVerification.dataRegulation.value1) {
            rangValue = ctx.dataVerification.dataRegulation.value1;
            rangeT = ctx.rangeDialog.rangeTxt;
          }
          ctx.rangeDialog.type = "";
          if (item) {
            ctx.dataVerification.dataRegulation = _objectSpread2(_objectSpread2({}, item), {}, {
              value1: rangValue,
              rangeTxt: rangeT
            });
          } else {
            ctx.dataVerification.dataRegulation = {
              type: "dropdown",
              type2: "",
              rangeTxt: rangeT,
              value1: rangValue,
              value2: "",
              validity: "",
              remote: false,
              prohibitInput: false,
              hintShow: false,
              hintValue: ""
            };
          }
        } else {
          ctx.dataVerification.dataRegulation = {
            type: "dropdown",
            type2: "",
            rangeTxt: rangeT,
            value1: "",
            value2: "",
            validity: "",
            remote: false,
            prohibitInput: false,
            hintShow: false,
            hintValue: ""
          };
        }
      });
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-data-verification"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "title"
    }, toolbar.dataVerification), /* @__PURE__ */ React.createElement("div", {
      className: "box"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "box-item",
      style: {
        borderTop: "1px solid #E1E4E8"
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "box-item-title"
    }, dataVerification.cellRange), /* @__PURE__ */ React.createElement("div", {
      className: "data-verification-range"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "formulaInputFocus",
      spellCheck: "false",
      value: (_context$dataVerifica = context.dataVerification.dataRegulation) === null || _context$dataVerifica === void 0 ? void 0 : _context$dataVerifica.rangeTxt,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.rangeTxt = value;
        });
      }
    }), /* @__PURE__ */ React.createElement("i", {
      className: "icon",
      "aria-hidden": "true",
      onClick: function onClick() {
        hideDialog();
        dataSelectRange("rangeTxt", context.dataVerification.dataRegulation.value1);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "tab",
      width: 18
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "box-item"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "box-item-title"
    }, dataVerification.verificationCondition), /* @__PURE__ */ React.createElement("select", {
      className: "data-verification-type-select",
      value: context.dataVerification.dataRegulation.type,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type = value;
          if (value === "dropdown" || value === "checkbox") {
            ctx.dataVerification.dataRegulation.type2 = "";
          } else if (value === "number" || value === "number_integer" || value === "number_decimal" || value === "text_length" || value === "date") {
            ctx.dataVerification.dataRegulation.type2 = "between";
          } else if (value === "text_content") {
            ctx.dataVerification.dataRegulation.type2 = "include";
          } else if (value === "validity") {
            ctx.dataVerification.dataRegulation.type2 = "identificationNumber";
          }
          ctx.dataVerification.dataRegulation.value1 = "";
          ctx.dataVerification.dataRegulation.value2 = "";
        });
      }
    }, ["dropdown", "checkbox", "number", "number_integer", "number_decimal", "text_content", "text_length", "date", "validity"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: v2,
        key: v2
      }, dataVerification[v2]);
    })), ((_context$dataVerifica2 = context.dataVerification) === null || _context$dataVerifica2 === void 0 ? void 0 : (_context$dataVerifica3 = _context$dataVerifica2.dataRegulation) === null || _context$dataVerifica3 === void 0 ? void 0 : _context$dataVerifica3.type) === "dropdown" && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "data-verification-range"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "formulaInputFocus",
      spellCheck: "false",
      value: context.dataVerification.dataRegulation.value1,
      placeholder: dataVerification.placeholder1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }), /* @__PURE__ */ React.createElement("i", {
      className: "icon",
      "aria-hidden": "true",
      onClick: function onClick() {
        return dataSelectRange("dropDown", context.dataVerification.dataRegulation.value1);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "tab",
      width: 18
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "check"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "checkbox",
      checked: context.dataVerification.dataRegulation.type2 === "true",
      id: "mul",
      onChange: function onChange(e) {
        var checked = e.target.checked;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type2 = "".concat(checked);
        });
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "mul"
    }, dataVerification.allowMultiSelect))), ((_context$dataVerifica4 = context.dataVerification) === null || _context$dataVerifica4 === void 0 ? void 0 : (_context$dataVerifica5 = _context$dataVerifica4.dataRegulation) === null || _context$dataVerifica5 === void 0 ? void 0 : _context$dataVerifica5.type) === "checkbox" && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "check-box"
    }, /* @__PURE__ */ React.createElement("span", null, dataVerification.selected, " —— "), /* @__PURE__ */ React.createElement("input", {
      type: "text",
      className: "data-verification-value1",
      placeholder: dataVerification.placeholder2,
      value: (_context$dataVerifica6 = context.dataVerification) === null || _context$dataVerifica6 === void 0 ? void 0 : (_context$dataVerifica7 = _context$dataVerifica6.dataRegulation) === null || _context$dataVerifica7 === void 0 ? void 0 : _context$dataVerifica7.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "check-box"
    }, /* @__PURE__ */ React.createElement("span", null, dataVerification.notSelected, " —— "), /* @__PURE__ */ React.createElement("input", {
      type: "text",
      className: "data-verification-value2",
      placeholder: dataVerification.placeholder2,
      value: (_context$dataVerifica8 = context.dataVerification) === null || _context$dataVerifica8 === void 0 ? void 0 : (_context$dataVerifica9 = _context$dataVerifica8.dataRegulation) === null || _context$dataVerifica9 === void 0 ? void 0 : _context$dataVerifica9.value2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value2 = value;
        });
      }
    }))), (((_context$dataVerifica10 = context.dataVerification) === null || _context$dataVerifica10 === void 0 ? void 0 : (_context$dataVerifica11 = _context$dataVerifica10.dataRegulation) === null || _context$dataVerifica11 === void 0 ? void 0 : _context$dataVerifica11.type) === "number" || ((_context$dataVerifica12 = context.dataVerification) === null || _context$dataVerifica12 === void 0 ? void 0 : (_context$dataVerifica13 = _context$dataVerifica12.dataRegulation) === null || _context$dataVerifica13 === void 0 ? void 0 : _context$dataVerifica13.type) === "number_integer" || ((_context$dataVerifica14 = context.dataVerification) === null || _context$dataVerifica14 === void 0 ? void 0 : (_context$dataVerifica15 = _context$dataVerifica14.dataRegulation) === null || _context$dataVerifica15 === void 0 ? void 0 : _context$dataVerifica15.type) === "number_decimal" || ((_context$dataVerifica16 = context.dataVerification) === null || _context$dataVerifica16 === void 0 ? void 0 : (_context$dataVerifica17 = _context$dataVerifica16.dataRegulation) === null || _context$dataVerifica17 === void 0 ? void 0 : _context$dataVerifica17.type) === "text_length") && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("select", {
      className: "data-verification-type-select",
      value: context.dataVerification.dataRegulation.type2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type2 = value;
          ctx.dataVerification.dataRegulation.value1 = "";
          ctx.dataVerification.dataRegulation.value2 = "";
        });
      }
    }, numberCondition.map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: v2,
        key: v2
      }, dataVerification[v2]);
    })), context.dataVerification.dataRegulation.type2 === "between" || context.dataVerification.dataRegulation.type2 === "notBetween" ? /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "number",
      placeholder: "1",
      value: context.dataVerification.dataRegulation.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }), /* @__PURE__ */ React.createElement("span", null, "-"), /* @__PURE__ */ React.createElement("input", {
      type: "number",
      placeholder: "100",
      value: context.dataVerification.dataRegulation.value2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value2 = value;
        });
      }
    })) : /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "number",
      style: {
        width: "100%"
      },
      placeholder: dataVerification.placeholder3,
      value: context.dataVerification.dataRegulation.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }))), ((_context$dataVerifica18 = context.dataVerification) === null || _context$dataVerifica18 === void 0 ? void 0 : (_context$dataVerifica19 = _context$dataVerifica18.dataRegulation) === null || _context$dataVerifica19 === void 0 ? void 0 : _context$dataVerifica19.type) === "text_content" && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("select", {
      className: "data-verification-type-select",
      value: context.dataVerification.dataRegulation.type2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type2 = value;
          ctx.dataVerification.dataRegulation.value1 = "";
          ctx.dataVerification.dataRegulation.value2 = "";
        });
      }
    }, ["include", "exclude", "equal"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: v2,
        key: v2
      }, dataVerification[v2]);
    })), /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "text",
      style: {
        width: "100%"
      },
      placeholder: dataVerification.placeholder4,
      value: context.dataVerification.dataRegulation.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }))), ((_context$dataVerifica20 = context.dataVerification) === null || _context$dataVerifica20 === void 0 ? void 0 : (_context$dataVerifica21 = _context$dataVerifica20.dataRegulation) === null || _context$dataVerifica21 === void 0 ? void 0 : _context$dataVerifica21.type) === "date" && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("select", {
      className: "data-verification-type-select",
      value: context.dataVerification.dataRegulation.type2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type2 = value;
          ctx.dataVerification.dataRegulation.value1 = "";
          ctx.dataVerification.dataRegulation.value2 = "";
        });
      }
    }, dateCondition.map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: v2,
        key: v2
      }, dataVerification[v2]);
    })), context.dataVerification.dataRegulation.type2 === "between" || context.dataVerification.dataRegulation.type2 === "notBetween" ? /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "date",
      placeholder: "1",
      value: context.dataVerification.dataRegulation.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }), /* @__PURE__ */ React.createElement("span", null, "-"), /* @__PURE__ */ React.createElement("input", {
      type: "date",
      placeholder: "100",
      value: context.dataVerification.dataRegulation.value2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value2 = value;
        });
      }
    })) : /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "date",
      style: {
        width: "100%"
      },
      placeholder: dataVerification.placeholder3,
      value: context.dataVerification.dataRegulation.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.value1 = value;
        });
      }
    }))), ((_context$dataVerifica22 = context.dataVerification) === null || _context$dataVerifica22 === void 0 ? void 0 : (_context$dataVerifica23 = _context$dataVerifica22.dataRegulation) === null || _context$dataVerifica23 === void 0 ? void 0 : _context$dataVerifica23.type) === "validity" && /* @__PURE__ */ React.createElement("div", {
      className: "show-box-item"
    }, /* @__PURE__ */ React.createElement("select", {
      className: "data-verification-type-select",
      value: context.dataVerification.dataRegulation.type2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.type2 = value;
          ctx.dataVerification.dataRegulation.value1 = "";
          ctx.dataVerification.dataRegulation.value2 = "";
        });
      }
    }, ["identificationNumber", "phoneNumber"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: v2,
        key: v2
      }, dataVerification[v2]);
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "box-item"
    }, ["prohibitInput", "hintShow"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "check",
        key: "div".concat(v2)
      }, /* @__PURE__ */ React.createElement("input", {
        type: "checkbox",
        id: v2,
        key: "input".concat(v2),
        checked: context.dataVerification.dataRegulation[v2],
        onChange: function onChange() {
          setContext(function(ctx) {
            var _ctx$dataVerification5;
            var dataRegulation = (_ctx$dataVerification5 = ctx.dataVerification) === null || _ctx$dataVerification5 === void 0 ? void 0 : _ctx$dataVerification5.dataRegulation;
            if (v2 === "prohibitInput") {
              dataRegulation.prohibitInput = !dataRegulation.prohibitInput;
            } else if (v2 === "hintShow") {
              dataRegulation.hintShow = !dataRegulation.hintShow;
            }
          });
        }
      }), /* @__PURE__ */ React.createElement("label", {
        htmlFor: v2,
        key: "label".concat(v2)
      }, dataVerification[v2]));
    }), ((_context$dataVerifica24 = context.dataVerification) === null || _context$dataVerifica24 === void 0 ? void 0 : (_context$dataVerifica25 = _context$dataVerifica24.dataRegulation) === null || _context$dataVerifica25 === void 0 ? void 0 : _context$dataVerifica25.hintShow) && /* @__PURE__ */ React.createElement("div", {
      className: "input-box"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "text",
      style: {
        width: "100%"
      },
      placeholder: dataVerification.placeholder5,
      value: context.dataVerification.dataRegulation.hintValue,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.dataVerification.dataRegulation.hintValue = value;
        });
      }
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        btn("confirm");
      }
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        btn("delete");
      }
    }, dataVerification.deleteVerification), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        btn("close");
      }
    }, button.cancel));
  };
  var ConditionRules = function ConditionRules2(_ref) {
    var type = _ref.type;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _useDialog = useDialog(), hideDialog = _useDialog.hideDialog;
    var _locale = locale(context), conditionformat = _locale.conditionformat, button = _locale.button, protection = _locale.protection, generalDialog = _locale.generalDialog;
    var _useState = reactExports.useState({
      textColor: "#000000",
      cellColor: "#000000"
    }), _useState2 = _slicedToArray(_useState, 2), colorRules = _useState2[0], setColorRules = _useState2[1];
    var close = reactExports.useCallback(function(closeType) {
      if (closeType === "confirm") {
        setContext(function(ctx) {
          ctx.conditionRules.textColor.color = colorRules.textColor;
          ctx.conditionRules.cellColor.color = colorRules.cellColor;
          setConditionRules(ctx, protection, generalDialog, conditionformat, ctx.conditionRules);
        });
      }
      setContext(function(ctx) {
        ctx.conditionRules = {
          rulesType: "",
          rulesValue: "",
          textColor: {
            check: true,
            color: "#000000"
          },
          cellColor: {
            check: true,
            color: "#000000"
          },
          betweenValue: {
            value1: "",
            value2: ""
          },
          dateValue: "",
          repeatValue: "0",
          projectValue: "10"
        };
      });
      hideDialog();
    }, [colorRules, conditionformat, generalDialog, hideDialog, protection, setContext]);
    reactExports.useEffect(function() {
      setContext(function(ctx) {
        ctx.conditionRules.rulesType = type;
        if (!ctx.rangeDialog) return;
        var rangeDialogType = ctx.rangeDialog.type;
        var rangeT = ctx.rangeDialog.rangeTxt;
        if (rangeDialogType === "conditionRulesbetween1") {
          ctx.conditionRules.betweenValue.value1 = rangeT;
        } else if (rangeDialogType === "conditionRulesbetween2") {
          ctx.conditionRules.betweenValue.value2 = rangeT;
        } else if (rangeDialogType.indexOf("conditionRules") >= 0) {
          ctx.conditionRules.rulesValue = rangeT;
        } else if (rangeDialogType === "") {
          ctx.conditionRules = {
            rulesType: type,
            rulesValue: "",
            textColor: {
              check: true,
              color: "#000000"
            },
            cellColor: {
              check: true,
              color: "#000000"
            },
            betweenValue: {
              value1: "",
              value2: ""
            },
            dateValue: "",
            repeatValue: "0",
            projectValue: "10"
          };
        }
        ctx.rangeDialog.type = "";
        ctx.rangeDialog.rangeTxt = "";
      });
    }, []);
    return /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-title"
    }, conditionformat["conditionformat_".concat(type)]), /* @__PURE__ */ React.createElement("div", {
      className: "conditin-rules-value"
    }, conditionformat["conditionformat_".concat(type, "_title")]), (type === "greaterThan" || type === "lessThan" || type === "equal" || type === "textContains") && /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-inpbox"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "condition-rules-input",
      type: "text",
      value: context.conditionRules.rulesValue,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.rulesValue = value;
        });
      }
    })), type === "between" && /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-between-box"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-between-inpbox"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "condition-rules-between-input",
      type: "text",
      value: context.conditionRules.betweenValue.value1,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.betweenValue.value1 = value;
        });
      }
    })), /* @__PURE__ */ React.createElement("span", {
      style: {
        margin: "0px 4px"
      }
    }, conditionformat.to), /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-between-inpbox"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "condition-rules-between-input",
      type: "text",
      value: context.conditionRules.betweenValue.value2,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.betweenValue.value2 = value;
        });
      }
    }))), type === "occurrenceDate" && /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-inpbox"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "date",
      className: "condition-rules-date",
      value: context.conditionRules.dateValue,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.dateValue = value;
        });
      }
    })), type === "duplicateValue" && /* @__PURE__ */ React.createElement("select", {
      className: "condition-rules-select",
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.repeatValue = value;
        });
      }
    }, /* @__PURE__ */ React.createElement("option", {
      value: "0"
    }, conditionformat.duplicateValue), /* @__PURE__ */ React.createElement("option", {
      value: "1"
    }, conditionformat.uniqueValue)), (type === "top10" || type === "top10_percent" || type === "last10" || type === "last10_percent") && /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-project-box"
    }, type === "top10" || type === "top10_percent" ? conditionformat.top : conditionformat.last, /* @__PURE__ */ React.createElement("input", {
      className: "condition-rules-project-input",
      type: "number",
      value: context.conditionRules.projectValue,
      onChange: function onChange(e) {
        var value = e.target.value;
        setContext(function(ctx) {
          ctx.conditionRules.projectValue = value;
        });
      }
    }), type === "top10" || type === "last10" ? conditionformat.oneself : "%"), /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-set-title"
    }, "".concat(conditionformat.setAs, "：")), /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-setbox"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-set"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-color"
    }, /* @__PURE__ */ React.createElement("input", {
      id: "checkTextColor",
      type: "checkbox",
      className: "condition-rules-check",
      checked: context.conditionRules.textColor.check,
      onChange: function onChange(e) {
        var checked = e.target.checked;
        setContext(function(ctx) {
          ctx.conditionRules.textColor.check = checked;
        });
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "checkTextColor",
      className: "condition-rules-label"
    }, conditionformat.textColor), /* @__PURE__ */ React.createElement("input", {
      type: "color",
      className: "condition-rules-select-color",
      value: colorRules.textColor,
      onChange: function onChange(e) {
        var value = e.target.value;
        setColorRules(fn(function(draft) {
          draft.textColor = value;
        }));
      }
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-set"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "condition-rules-color"
    }, /* @__PURE__ */ React.createElement("input", {
      id: "checkCellColor",
      type: "checkbox",
      className: "condition-rules-check",
      checked: context.conditionRules.cellColor.check,
      onChange: function onChange(e) {
        var checked = e.target.checked;
        setContext(function(ctx) {
          ctx.conditionRules.cellColor.check = checked;
        });
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "checkCellColor",
      className: "condition-rules-label"
    }, conditionformat.cellColor), /* @__PURE__ */ React.createElement("input", {
      type: "color",
      className: "condition-rules-select-color",
      value: colorRules.cellColor,
      onChange: function onChange(e) {
        var value = e.target.value;
        setColorRules(fn(function(draft) {
          draft.cellColor = value;
        }));
      }
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        close("confirm");
      }
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        close("close");
      }
    }, button.cancel));
  };
  var RangeDialog = function RangeDialog2() {
    var _context$rangeDialog$, _context$rangeDialog;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog;
    var _locale = locale(context), dataVerification = _locale.dataVerification, button = _locale.button;
    var _useState = reactExports.useState((_context$rangeDialog$ = (_context$rangeDialog = context.rangeDialog) === null || _context$rangeDialog === void 0 ? void 0 : _context$rangeDialog.rangeTxt) !== null && _context$rangeDialog$ !== void 0 ? _context$rangeDialog$ : ""), _useState2 = _slicedToArray(_useState, 2), rangeTxt2 = _useState2[0], setRangeTxt2 = _useState2[1];
    var close = reactExports.useCallback(function() {
      setContext(function(ctx) {
        ctx.rangeDialog.show = false;
        ctx.rangeDialog.singleSelect = false;
      });
      if (!context.rangeDialog) return;
      var rangeDialogType = context.rangeDialog.type;
      if (rangeDialogType.indexOf("between") >= 0) {
        showDialog(/* @__PURE__ */ React.createElement(ConditionRules, {
          type: "between"
        }));
        return;
      }
      if (rangeDialogType.indexOf("conditionRules") >= 0) {
        var rulesType = rangeDialogType.substring("conditionRules".length, rangeDialogType.length);
        showDialog(/* @__PURE__ */ React.createElement(ConditionRules, {
          type: rulesType
        }));
        return;
      }
      showDialog(/* @__PURE__ */ React.createElement(DataVerification, null));
    }, [context.rangeDialog, setContext, showDialog]);
    reactExports.useEffect(function() {
      setRangeTxt2(function(r2) {
        if (context.luckysheet_select_save) {
          var range = context.luckysheet_select_save[context.luckysheet_select_save.length - 1];
          r2 = getRangetxt(context, context.currentSheetId, range, context.currentSheetId);
          return r2;
        }
        return "";
      });
    }, [context, context.luckysheet_select_save]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "range-dialog",
      onClick: function onClick(e) {
        return e.stopPropagation();
      },
      onChange: function onChange(e) {
        return e.stopPropagation();
      },
      onKeyDown: function onKeyDown(e) {
        return e.stopPropagation();
      },
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp(e) {
        return e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "dialog-title"
    }, dataVerification.selectCellRange), /* @__PURE__ */ React.createElement("input", {
      readOnly: true,
      placeholder: dataVerification.selectCellRange2,
      value: rangeTxt2
    }), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      style: {
        marginLeft: "6px"
      },
      onClick: function onClick() {
        setContext(function(ctx) {
          ctx.rangeDialog.rangeTxt = rangeTxt2;
        });
        close();
      }
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        close();
      }
    }, button.close));
  };
  function useOutsideClick(containerRef, handler, deps) {
    reactExports.useEffect(function() {
      function handleClickOutside(e) {
        if (containerRef.current && !containerRef.current.contains(e.target)) {
          handler();
        }
      }
      document.addEventListener("mousedown", handleClickOutside);
      return function() {
        document.removeEventListener("mousedown", handleClickOutside);
      };
    }, deps);
  }
  var DropDownList = function DropDownList2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var containerRef = reactExports.useRef(null);
    var _useState = reactExports.useState([]), _useState2 = _slicedToArray(_useState, 2), list = _useState2[0], setList = _useState2[1];
    var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), isMul = _useState4[0], setIsMul = _useState4[1];
    var _useState5 = reactExports.useState(), _useState6 = _slicedToArray(_useState5, 2), position = _useState6[0], setPosition = _useState6[1];
    var _useState7 = reactExports.useState([]), _useState8 = _slicedToArray(_useState7, 2), selected = _useState8[0], setSelected = _useState8[1];
    var close = reactExports.useCallback(function() {
      setContext(function(ctx) {
        ctx.dataVerificationDropDownList = false;
      });
    }, [setContext]);
    useOutsideClick(containerRef, close, [close]);
    reactExports.useEffect(function() {
      if (!context.luckysheet_select_save) return;
      var last = context.luckysheet_select_save[context.luckysheet_select_save.length - 1];
      var rowIndex = last.row_focus;
      var colIndex = last.column_focus;
      if (rowIndex == null || colIndex == null) return;
      var row = context.visibledatarow[rowIndex];
      var col_pre = colIndex === 0 ? 0 : context.visibledatacolumn[colIndex - 1];
      var d2 = getFlowdata(context);
      if (!d2) return;
      var margeSet = mergeBorder(context, d2, rowIndex, colIndex);
      if (margeSet) {
        var _margeSet$row = _slicedToArray(margeSet.row, 2);
        row = _margeSet$row[1];
        var _margeSet$column = _slicedToArray(margeSet.column, 2);
        col_pre = _margeSet$column[0];
      }
      var index2 = getSheetIndex(context, context.currentSheetId);
      var dataVerification = context.luckysheetfile[index2].dataVerification;
      var item = dataVerification["".concat(rowIndex, "_").concat(colIndex)];
      var dropdownList = getDropdownList(context, item.value1);
      var cellValue = getCellValue(rowIndex, colIndex, d2);
      if (cellValue) {
        setSelected(cellValue.toString().split(","));
      }
      setList(dropdownList);
      setPosition({
        left: col_pre,
        top: row
      });
      setIsMul(item.type2 === "true");
    }, []);
    reactExports.useEffect(function() {
      if (!context.luckysheet_select_save) return;
      var last = context.luckysheet_select_save[context.luckysheet_select_save.length - 1];
      var rowIndex = last.row_focus;
      var colIndex = last.column_focus;
      if (rowIndex == null || colIndex == null) return;
      var index2 = getSheetIndex(context, context.currentSheetId);
      var dataVerification = context.luckysheetfile[index2].dataVerification;
      var item = dataVerification["".concat(rowIndex, "_").concat(colIndex)];
      if (item.type2 !== "true") return;
      var d2 = getFlowdata(context);
      if (!d2) return;
      var cellValue = getCellValue(rowIndex, colIndex, d2);
      if (cellValue) {
        setSelected(cellValue.toString().split(","));
      }
    }, [context.luckysheetfile]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-dataVerification-dropdown-List",
      style: position,
      ref: containerRef,
      onClick: function onClick(e) {
        return e.stopPropagation();
      },
      onChange: function onChange(e) {
        return e.stopPropagation();
      },
      onKeyDown: function onKeyDown(e) {
        return e.stopPropagation();
      },
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp(e) {
        return e.stopPropagation();
      }
    }, list.map(function(v2, i2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "dropdown-List-item",
        key: i2,
        onClick: function onClick() {
          setContext(function(ctx) {
            var arr = selected;
            var index2 = arr.indexOf(v2);
            if (index2 < 0) {
              arr.push(v2);
            } else {
              arr.splice(index2, 1);
            }
            setSelected(arr);
            setDropcownValue(ctx, v2, arr);
          });
        }
      }, /* @__PURE__ */ React.createElement(SVGIcon, {
        name: "check",
        width: 12,
        style: {
          verticalAlign: "middle",
          display: isMul && selected.indexOf(v2) >= 0 ? "inline" : "none"
        }
      }), v2);
    }));
  };
  var SheetOverlay = function SheetOverlay2() {
    var _refs$cellArea$curren, _refs$cellArea$curren2, _context$luckysheet_s, _context$luckysheet_s2, _context$luckysheet_s3, _context$luckysheet_s4, _context$luckysheet_s5, _context$luckysheet_s6, _context$presences$le, _context$presences, _context$linkCard, _context$rangeDialog;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings, refs = _useContext.refs;
    var _locale = locale(context), info = _locale.info, rightclick = _locale.rightclick;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog;
    var containerRef = reactExports.useRef(null);
    var bottomAddRowInputRef = reactExports.useRef(null);
    var dataVerificationHintBoxRef = reactExports.useRef(null);
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert;
    var cellAreaMouseDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      if (e.button !== 2) {
        setContext(function(draftCtx) {
          var _draftCtx$luckysheet_;
          handleCellAreaMouseDown(draftCtx, refs.globalCache, nativeEvent, refs.cellInput.current, refs.cellArea.current, refs.fxInput.current, refs.canvas.current.getContext("2d"));
          if (!_$1.isEmpty((_draftCtx$luckysheet_ = draftCtx.luckysheet_select_save) === null || _draftCtx$luckysheet_ === void 0 ? void 0 : _draftCtx$luckysheet_[0]) && refs.cellInput.current) {
            setTimeout(function() {
              var _refs$cellInput$curre;
              (_refs$cellInput$curre = refs.cellInput.current) === null || _refs$cellInput$curre === void 0 ? void 0 : _refs$cellInput$curre.focus();
            });
          }
        });
      }
    }, [setContext, refs.globalCache, refs.cellInput, refs.cellArea, refs.fxInput, refs.canvas]);
    var cellAreaContextMenu = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleContextMenu(draftCtx, settings, nativeEvent, refs.workbookContainer.current, refs.cellArea.current, "cell");
      });
    }, [refs.workbookContainer, setContext, settings, refs.cellArea]);
    var cellAreaDoubleClick = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleCellAreaDoubleClick(draftCtx, refs.globalCache, settings, nativeEvent, refs.cellArea.current);
      });
    }, [refs.cellArea, refs.globalCache, setContext, settings]);
    var onLeftTopClick = reactExports.useCallback(function() {
      setContext(function(draftCtx) {
        selectAll(draftCtx);
      });
    }, [setContext]);
    var debouncedShowLinkCard = reactExports.useMemo(function() {
      return _$1.debounce(function(globalCache, r2, c2, isEditing) {
        var _globalCache$linkCard;
        var skip = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        if (skip || ((_globalCache$linkCard = globalCache.linkCard) === null || _globalCache$linkCard === void 0 ? void 0 : _globalCache$linkCard.mouseEnter)) return;
        setContext(function(draftCtx) {
          showLinkCard(draftCtx, r2, c2, isEditing);
        });
      }, 800);
    }, [setContext]);
    var overShowLinkCard = reactExports.useCallback(function(ctx, globalCache, e, container, scrollX, scrollY) {
      var rc2 = getCellRowColumn(ctx, e, container, scrollX, scrollY);
      if (rc2 == null) return;
      var link = getCellHyperlink(ctx, rc2.r, rc2.c);
      if (link == null) {
        debouncedShowLinkCard(globalCache, rc2.r, rc2.c, false);
      } else {
        showLinkCard(ctx, rc2.r, rc2.c, false);
        debouncedShowLinkCard(globalCache, rc2.r, rc2.c, false, true);
      }
    }, [debouncedShowLinkCard]);
    var onMouseMove = reactExports.useCallback(function(nativeEvent) {
      setContext(function(draftCtx) {
        overShowLinkCard(draftCtx, refs.globalCache, nativeEvent, containerRef.current, refs.scrollbarX.current, refs.scrollbarY.current);
        handleOverlayMouseMove(draftCtx, refs.globalCache, nativeEvent, refs.cellInput.current, refs.scrollbarX.current, refs.scrollbarY.current, containerRef.current, refs.fxInput.current);
      });
    }, [overShowLinkCard, refs.cellInput, refs.fxInput, refs.globalCache, refs.scrollbarX, refs.scrollbarY, setContext]);
    var onMouseUp = reactExports.useCallback(function(nativeEvent) {
      setContext(function(draftCtx) {
        try {
          handleOverlayMouseUp(draftCtx, refs.globalCache, settings, nativeEvent, refs.scrollbarX.current, refs.scrollbarY.current, containerRef.current, refs.cellInput.current, refs.fxInput.current);
        } catch (e) {
          showAlert(e.message);
        }
      });
    }, [refs.cellInput, refs.fxInput, refs.globalCache, refs.scrollbarX, refs.scrollbarY, setContext, settings, showAlert]);
    var onKeyDownForZoom = reactExports.useCallback(function(ev) {
      var newZoom = handleKeydownForZoom(ev, context.zoomRatio);
      if (newZoom !== context.zoomRatio) {
        setContext(function(ctx) {
          ctx.zoomRatio = newZoom;
          ctx.luckysheetfile[getSheetIndex(ctx, ctx.currentSheetId)].zoomRatio = newZoom;
        });
      }
    }, [context.zoomRatio, setContext]);
    var onTouchStart = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftContext) {
        handleOverlayTouchStart(draftContext, nativeEvent, refs.globalCache);
      });
      e.stopPropagation();
    }, [refs.globalCache, setContext]);
    var onTouchMove = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      setContext(function(draftCtx) {
        handleOverlayTouchMove(draftCtx, nativeEvent, refs.globalCache, refs.scrollbarX.current, refs.scrollbarY.current);
      });
    }, [refs.globalCache, refs.scrollbarX, refs.scrollbarY, setContext]);
    var onTouchEnd = reactExports.useCallback(function() {
      handleOverlayTouchEnd(refs.globalCache);
    }, [refs.globalCache]);
    var handleBottomAddRow = reactExports.useCallback(function() {
      var _bottomAddRowInputRef;
      var valueStr = ((_bottomAddRowInputRef = bottomAddRowInputRef.current) === null || _bottomAddRowInputRef === void 0 ? void 0 : _bottomAddRowInputRef.value) || context.addDefaultRows.toString();
      var value = parseInt(valueStr, 10);
      if (Number.isNaN(value)) {
        return;
      }
      if (value < 1) {
        return;
      }
      var insertRowColOp = {
        type: "row",
        index: context.luckysheetfile[getSheetIndex(context, context.currentSheetId)].data.length - 1,
        count: value,
        direction: "rightbottom",
        id: context.currentSheetId
      };
      setContext(function(draftCtx) {
        try {
          insertRowCol(draftCtx, insertRowColOp, false);
        } catch (err) {
          if (err.message === "maxExceeded") showAlert(rightclick.rowOverLimit);
        }
      }, {
        insertRowColOp
      });
    }, [context, rightclick.rowOverLimit, setContext, showAlert]);
    reactExports.useEffect(function() {
      if (context.warnDialog) {
        setTimeout(function() {
          showDialog(context.warnDialog, "ok");
        }, 240);
      }
    }, [context.warnDialog]);
    reactExports.useEffect(function() {
      refs.cellArea.current.scrollLeft = context.scrollLeft;
      refs.cellArea.current.scrollTop = context.scrollTop;
    }, [context.scrollLeft, context.scrollTop, refs.cellArea, (_refs$cellArea$curren = refs.cellArea.current) === null || _refs$cellArea$curren === void 0 ? void 0 : _refs$cellArea$curren.scrollLeft, (_refs$cellArea$curren2 = refs.cellArea.current) === null || _refs$cellArea$curren2 === void 0 ? void 0 : _refs$cellArea$curren2.scrollTop]);
    reactExports.useLayoutEffect(function() {
      if (context.commentBoxes || context.hoveredCommentBox || context.editingCommentBox) {
        var _context$commentBoxes;
        _$1.concat((_context$commentBoxes = context.commentBoxes) === null || _context$commentBoxes === void 0 ? void 0 : _context$commentBoxes.filter(function(v2) {
          var _context$editingComme;
          return v2.rc !== ((_context$editingComme = context.editingCommentBox) === null || _context$editingComme === void 0 ? void 0 : _context$editingComme.rc);
        }), [context.hoveredCommentBox, context.editingCommentBox]).forEach(function(box) {
          if (box) {
            drawArrow(box.rc, box.size);
          }
        });
      }
    }, [context.commentBoxes, context.hoveredCommentBox, context.editingCommentBox]);
    reactExports.useEffect(function() {
      document.addEventListener("mousemove", onMouseMove);
      return function() {
        document.removeEventListener("mousemove", onMouseMove);
      };
    }, [onMouseMove]);
    reactExports.useEffect(function() {
      document.addEventListener("mouseup", onMouseUp);
      return function() {
        document.removeEventListener("mouseup", onMouseUp);
      };
    }, [onMouseUp]);
    reactExports.useEffect(function() {
      document.addEventListener("keydown", onKeyDownForZoom);
      return function() {
        document.removeEventListener("keydown", onKeyDownForZoom);
      };
    }, [onKeyDownForZoom]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheet-overlay",
      ref: containerRef,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      tabIndex: -1,
      style: {
        width: context.luckysheetTableContentHW[0],
        height: context.luckysheetTableContentHW[1]
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-col-header-wrap"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-left-top",
      onClick: onLeftTopClick,
      style: {
        width: context.rowHeaderWidth - 1.5,
        height: context.columnHeaderHeight - 1.5
      }
    }), /* @__PURE__ */ React.createElement(ColumnHeader, null)), (context.showSearch || context.showReplace) && /* @__PURE__ */ React.createElement(SearchReplace, {
      getContainer: function getContainer() {
        return containerRef.current;
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-row-body"
    }, /* @__PURE__ */ React.createElement(RowHeader, null), /* @__PURE__ */ React.createElement(ScrollBar, {
      axis: "x"
    }), /* @__PURE__ */ React.createElement(ScrollBar, {
      axis: "y"
    }), /* @__PURE__ */ React.createElement("div", {
      ref: refs.cellArea,
      className: "fortune-cell-area",
      onMouseDown: cellAreaMouseDown,
      onDoubleClick: cellAreaDoubleClick,
      onContextMenu: cellAreaContextMenu,
      style: {
        width: context.cellmainWidth,
        height: context.cellmainHeight,
        cursor: context.luckysheet_cell_selected_extend ? "crosshair" : "default"
      }
    }, /* @__PURE__ */ React.createElement("div", {
      id: "fortune-formula-functionrange"
    }), context.formulaRangeSelect && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy fortune-formula-functionrange-select",
      style: context.formulaRangeSelect
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy-top fortune-copy"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy-right fortune-copy"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy-bottom fortune-copy"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy-left fortune-copy"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-selection-copy-hc"
    })), context.formulaRangeHighlight.map(function(v2) {
      var rangeIndex = v2.rangeIndex, backgroundColor = v2.backgroundColor;
      return /* @__PURE__ */ React.createElement("div", {
        key: rangeIndex,
        id: "fortune-formula-functionrange-highlight",
        className: "fortune-selection-highlight fortune-formula-functionrange-highlight",
        style: _$1.omit(v2, "backgroundColor")
      }, ["top", "right", "bottom", "left"].map(function(d2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: d2,
          "data-type": d2,
          className: "fortune-selection-copy-".concat(d2, " fortune-copy"),
          style: {
            backgroundColor
          }
        });
      }), /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-hc",
        style: {
          backgroundColor
        }
      }), ["lt", "rt", "lb", "rb"].map(function(d2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: d2,
          "data-type": d2,
          className: "fortune-selection-highlight-".concat(d2, " luckysheet-highlight"),
          style: {
            backgroundColor
          }
        });
      }));
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-row-count-show luckysheet-count-show",
      id: "luckysheet-row-count-show"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-column-count-show luckysheet-count-show",
      id: "luckysheet-column-count-show"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-change-size-line",
      hidden: !context.luckysheet_cols_change_size && !context.luckysheet_rows_change_size && !context.luckysheet_cols_freeze_drag && !context.luckysheet_rows_freeze_drag
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-freeze-drag-line",
      hidden: !context.luckysheet_cols_freeze_drag && !context.luckysheet_rows_freeze_drag
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cell-selected-focus",
      style: ((_context$luckysheet_s = (_context$luckysheet_s2 = context.luckysheet_select_save) === null || _context$luckysheet_s2 === void 0 ? void 0 : _context$luckysheet_s2.length) !== null && _context$luckysheet_s !== void 0 ? _context$luckysheet_s : 0) > 0 ? function() {
        var _refs$globalCache$fre, _refs$globalCache$fre2;
        var selection = _$1.last(context.luckysheet_select_save);
        return _$1.assign({
          left: selection.left,
          top: selection.top,
          width: selection.width,
          height: selection.height,
          display: "block"
        }, fixRowStyleOverflowInFreeze(context, selection.row_focus || 0, selection.row_focus || 0, (_refs$globalCache$fre = refs.globalCache.freezen) === null || _refs$globalCache$fre === void 0 ? void 0 : _refs$globalCache$fre[context.currentSheetId]), fixColumnStyleOverflowInFreeze(context, selection.column_focus || 0, selection.column_focus || 0, (_refs$globalCache$fre2 = refs.globalCache.freezen) === null || _refs$globalCache$fre2 === void 0 ? void 0 : _refs$globalCache$fre2[context.currentSheetId]));
      }() : {},
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      }
    }), ((_context$luckysheet_s3 = (_context$luckysheet_s4 = context.luckysheet_selection_range) === null || _context$luckysheet_s4 === void 0 ? void 0 : _context$luckysheet_s4.length) !== null && _context$luckysheet_s3 !== void 0 ? _context$luckysheet_s3 : 0) > 0 && /* @__PURE__ */ React.createElement("div", {
      id: "fortune-selection-copy"
    }, context.luckysheet_selection_range.map(function(range) {
      var r1 = range.row[0];
      var r2 = range.row[1];
      var c1 = range.column[0];
      var c2 = range.column[1];
      var row = context.visibledatarow[r2];
      var row_pre = r1 - 1 === -1 ? 0 : context.visibledatarow[r1 - 1];
      var col = context.visibledatacolumn[c2];
      var col_pre = c1 - 1 === -1 ? 0 : context.visibledatacolumn[c1 - 1];
      return /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy",
        key: "".concat(r1, "-").concat(r2, "-").concat(c1, "-").concat(c2),
        style: {
          left: col_pre,
          width: col - col_pre - 1,
          top: row_pre,
          height: row - row_pre - 1
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-top fortune-copy"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-right fortune-copy"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-bottom fortune-copy"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-left fortune-copy"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "fortune-selection-copy-hc"
      }));
    })), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-chart-rangeShow"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-cell-selected-extend"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-cell-selected-move",
      id: "fortune-cell-selected-move",
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      }
    }), ((_context$luckysheet_s5 = (_context$luckysheet_s6 = context.luckysheet_select_save) === null || _context$luckysheet_s6 === void 0 ? void 0 : _context$luckysheet_s6.length) !== null && _context$luckysheet_s5 !== void 0 ? _context$luckysheet_s5 : 0) > 0 && /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-cell-selected-boxs"
    }, context.luckysheet_select_save.map(function(selection, index2) {
      var _refs$globalCache$fre3, _refs$globalCache$fre4;
      return /* @__PURE__ */ React.createElement("div", {
        key: index2,
        id: "luckysheet-cell-selected",
        className: "luckysheet-cell-selected",
        style: _$1.assign({
          left: selection.left_move,
          top: selection.top_move,
          width: selection.width_move,
          height: selection.height_move,
          display: "block"
        }, fixRowStyleOverflowInFreeze(context, selection.row[0], selection.row[1], (_refs$globalCache$fre3 = refs.globalCache.freezen) === null || _refs$globalCache$fre3 === void 0 ? void 0 : _refs$globalCache$fre3[context.currentSheetId]), fixColumnStyleOverflowInFreeze(context, selection.column[0], selection.column[1], (_refs$globalCache$fre4 = refs.globalCache.freezen) === null || _refs$globalCache$fre4 === void 0 ? void 0 : _refs$globalCache$fre4[context.currentSheetId])),
        onMouseDown: function onMouseDown(e) {
          e.stopPropagation();
          var nativeEvent = e.nativeEvent;
          setContext(function(draftCtx) {
            onCellsMoveStart(draftCtx, refs.globalCache, nativeEvent, refs.scrollbarX.current, refs.scrollbarY.current, containerRef.current);
          });
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-inner-border"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-fillhandle",
        onMouseDown: function onMouseDown(e) {
          var nativeEvent = e.nativeEvent;
          setContext(function(draftContext) {
            createDropCellRange(draftContext, nativeEvent, containerRef.current);
          });
          e.stopPropagation();
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-inner-border"
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-draghandle-top luckysheet-cs-draghandle",
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-draghandle-bottom luckysheet-cs-draghandle",
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-draghandle-left luckysheet-cs-draghandle",
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-draghandle-right luckysheet-cs-draghandle",
        onMouseDown: function onMouseDown(e) {
          return e.preventDefault();
        }
      }), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-touchhandle luckysheet-cs-touchhandle-lt"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-touchhandle-btn"
      })), /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-touchhandle luckysheet-cs-touchhandle-rb"
      }, /* @__PURE__ */ React.createElement("div", {
        className: "luckysheet-cs-touchhandle-btn"
      })));
    })), ((_context$presences$le = (_context$presences = context.presences) === null || _context$presences === void 0 ? void 0 : _context$presences.length) !== null && _context$presences$le !== void 0 ? _context$presences$le : 0) > 0 && context.presences.map(function(presence, index2) {
      if (presence.sheetId !== context.currentSheetId) {
        return null;
      }
      var _presence$selection = presence.selection, r2 = _presence$selection.r, c2 = _presence$selection.c, color = presence.color;
      var row_pre = r2 - 1 === -1 ? 0 : context.visibledatarow[r2 - 1];
      var col_pre = c2 - 1 === -1 ? 0 : context.visibledatacolumn[c2 - 1];
      var row = context.visibledatarow[r2];
      var col = context.visibledatacolumn[c2];
      var width = col - col_pre - 1;
      var height = row - row_pre - 1;
      var usernameStyle = {
        maxWidth: width + 1,
        backgroundColor: color
      };
      _$1.set(usernameStyle, r2 === 0 ? "top" : "bottom", height);
      return /* @__PURE__ */ React.createElement("div", {
        key: (presence === null || presence === void 0 ? void 0 : presence.userId) || index2,
        className: "fortune-presence-selection",
        style: {
          left: col_pre,
          top: row_pre - 2,
          width,
          height,
          borderColor: color,
          borderWidth: 1
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "fortune-presence-username",
        style: usernameStyle
      }, presence.username));
    }), ((_context$linkCard = context.linkCard) === null || _context$linkCard === void 0 ? void 0 : _context$linkCard.sheetId) === context.currentSheetId && /* @__PURE__ */ React.createElement(LinkEditCard, _objectSpread2({}, context.linkCard)), ((_context$rangeDialog = context.rangeDialog) === null || _context$rangeDialog === void 0 ? void 0 : _context$rangeDialog.show) && /* @__PURE__ */ React.createElement(RangeDialog, null), /* @__PURE__ */ React.createElement(FilterOptions, {
      getContainer: function getContainer() {
        return containerRef.current;
      }
    }), /* @__PURE__ */ React.createElement(InputBox, null), /* @__PURE__ */ React.createElement(NotationBoxes, null), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-multipleRange-show"
    }), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-dynamicArray-hightShow"
    }), /* @__PURE__ */ React.createElement(ImgBoxs, null), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-dataVerification-dropdown-btn",
      onClick: function onClick() {
        setContext(function(ctx) {
          ctx.dataVerificationDropDownList = true;
          dataVerificationHintBoxRef.current.style.display = "none";
        });
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "combo-arrow",
      width: 16
    })), context.dataVerificationDropDownList && /* @__PURE__ */ React.createElement(DropDownList, null), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-dataVerification-showHintBox",
      className: "luckysheet-mousedown-cancel",
      ref: dataVerificationHintBoxRef
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cell-copy"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-grdblkflowpush"
    }), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-cell-flow_0",
      className: "luckysheet-cell-flow luckysheetsheetchange"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cell-flow-clip"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-grdblkpush"
    }), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheetcoltable_0",
      className: "luckysheet-cell-flow-col"
    }, /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-sheettable_0",
      className: "luckysheet-cell-sheettable",
      style: {
        height: context.rh_height,
        width: context.ch_width
      }
    }), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-bottom-controll-row",
      className: "luckysheet-bottom-controll-row",
      onMouseDown: function onMouseDown(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp2(e) {
        return e.stopPropagation();
      },
      onKeyDown: function onKeyDown(e) {
        return e.stopPropagation();
      },
      onKeyUp: function onKeyUp(e) {
        return e.stopPropagation();
      },
      onKeyPress: function onKeyPress(e) {
        return e.stopPropagation();
      },
      onClick: function onClick(e) {
        return e.stopPropagation();
      },
      onDoubleClick: function onDoubleClick(e) {
        return e.stopPropagation();
      },
      style: {
        left: context.scrollLeft,
        display: context.allowEdit ? "block" : "none"
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-add-row-button",
      onClick: function onClick() {
        handleBottomAddRow();
      }
    }, info.add), /* @__PURE__ */ React.createElement("input", {
      ref: bottomAddRowInputRef,
      type: "text",
      style: {
        width: 50
      },
      placeholder: context.addDefaultRows.toString()
    }), " ", /* @__PURE__ */ React.createElement("span", {
      style: {
        fontSize: 14
      }
    }, info.row), " ", /* @__PURE__ */ React.createElement("span", {
      style: {
        fontSize: 14,
        color: "#9c9c9c"
      }
    }, "(", info.addLast, ")"), /* @__PURE__ */ React.createElement("span", {
      className: "fortune-add-row-button",
      onClick: function onClick() {
        setContext(function(ctx) {
          ctx.scrollTop = 0;
        });
      }
    }, info.backTop))))))));
  };
  var Sheet = function Sheet2(_ref) {
    var _context$config, _context$config2, _context$config3;
    var sheet = _ref.sheet;
    var data = sheet.data;
    var containerRef = reactExports.useRef(null);
    var placeholderRef = reactExports.useRef(null);
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs, settings = _useContext.settings;
    reactExports.useEffect(function() {
      function resize() {
        if (!data) return;
        setContext(function(draftCtx) {
          if (settings.devicePixelRatio === 0) {
            draftCtx.devicePixelRatio = (globalThis || window).devicePixelRatio;
          }
          updateContextWithSheetData(draftCtx, data);
          updateContextWithCanvas(draftCtx, refs.canvas.current, placeholderRef.current);
        });
      }
      window.addEventListener("resize", resize);
      return function() {
        window.removeEventListener("resize", resize);
      };
    }, [data, refs.canvas, setContext, settings.devicePixelRatio]);
    reactExports.useEffect(function() {
      if (!data) return;
      setContext(function(draftCtx) {
        return updateContextWithSheetData(draftCtx, data);
      });
    }, [(_context$config = context.config) === null || _context$config === void 0 ? void 0 : _context$config.rowlen, (_context$config2 = context.config) === null || _context$config2 === void 0 ? void 0 : _context$config2.columnlen, (_context$config3 = context.config) === null || _context$config3 === void 0 ? void 0 : _context$config3.rowhidden, context.config.colhidden, data, context.zoomRatio, setContext]);
    reactExports.useEffect(function() {
      setContext(function(draftCtx) {
        return updateContextWithCanvas(draftCtx, refs.canvas.current, placeholderRef.current);
      });
    }, [refs.canvas, setContext, context.rowHeaderWidth, context.columnHeaderHeight, context.devicePixelRatio]);
    reactExports.useEffect(function() {
      initFreeze(context, refs.globalCache, context.currentSheetId);
    }, [refs.globalCache, sheet.frozen, context.currentSheetId, context.visibledatacolumn, context.visibledatarow]);
    reactExports.useEffect(function() {
      var _refs$globalCache$fre, _freeze$horizontal, _freeze$vertical;
      if (context.groupValuesRefreshData.length > 0) {
        return;
      }
      var tableCanvas = new Canvas(refs.canvas.current, context);
      if (tableCanvas == null) return;
      var freeze2 = (_refs$globalCache$fre = refs.globalCache.freezen) === null || _refs$globalCache$fre === void 0 ? void 0 : _refs$globalCache$fre[sheet.id];
      if ((freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$horizontal = freeze2.horizontal) === null || _freeze$horizontal === void 0 ? void 0 : _freeze$horizontal.freezenhorizontaldata) || (freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$vertical = freeze2.vertical) === null || _freeze$vertical === void 0 ? void 0 : _freeze$vertical.freezenverticaldata)) {
        var _freeze$horizontal2, _freeze$vertical2;
        var horizontalData = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$horizontal2 = freeze2.horizontal) === null || _freeze$horizontal2 === void 0 ? void 0 : _freeze$horizontal2.freezenhorizontaldata;
        var verticallData = freeze2 === null || freeze2 === void 0 ? void 0 : (_freeze$vertical2 = freeze2.vertical) === null || _freeze$vertical2 === void 0 ? void 0 : _freeze$vertical2.freezenverticaldata;
        if (horizontalData && verticallData) {
          var _horizontalData = _slicedToArray(horizontalData, 3), horizontalPx = _horizontalData[0], horizontalScrollTop = _horizontalData[2];
          var _verticallData = _slicedToArray(verticallData, 3), verticalPx = _verticallData[0], verticalScrollWidth = _verticallData[2];
          tableCanvas.drawMain({
            scrollWidth: context.scrollLeft + verticalPx - verticalScrollWidth,
            scrollHeight: context.scrollTop + horizontalPx - horizontalScrollTop,
            offsetLeft: verticalPx - verticalScrollWidth + context.rowHeaderWidth,
            offsetTop: horizontalPx - horizontalScrollTop + context.columnHeaderHeight,
            clear: true
          });
          tableCanvas.drawMain({
            scrollWidth: context.scrollLeft + verticalPx - verticalScrollWidth,
            scrollHeight: horizontalScrollTop,
            drawHeight: horizontalPx,
            offsetLeft: verticalPx - verticalScrollWidth + context.rowHeaderWidth
          });
          tableCanvas.drawMain({
            scrollWidth: verticalScrollWidth,
            scrollHeight: context.scrollTop + horizontalPx - horizontalScrollTop,
            drawWidth: verticalPx,
            offsetTop: horizontalPx - horizontalScrollTop + context.columnHeaderHeight
          });
          tableCanvas.drawMain({
            scrollWidth: verticalScrollWidth,
            scrollHeight: horizontalScrollTop,
            drawWidth: verticalPx,
            drawHeight: horizontalPx
          });
          tableCanvas.drawColumnHeader(context.scrollLeft + verticalPx - verticalScrollWidth, void 0, verticalPx - verticalScrollWidth + context.rowHeaderWidth);
          tableCanvas.drawColumnHeader(verticalScrollWidth, verticalPx);
          tableCanvas.drawRowHeader(context.scrollTop + horizontalPx - horizontalScrollTop, void 0, horizontalPx - horizontalScrollTop + context.columnHeaderHeight);
          tableCanvas.drawRowHeader(horizontalScrollTop, horizontalPx);
          tableCanvas.drawFreezeLine({
            horizontalTop: horizontalPx - horizontalScrollTop + context.columnHeaderHeight - 2,
            verticalLeft: verticalPx - verticalScrollWidth + context.rowHeaderWidth - 2
          });
        } else if (horizontalData) {
          var _horizontalData2 = _slicedToArray(horizontalData, 3), _horizontalPx = _horizontalData2[0], _horizontalScrollTop = _horizontalData2[2];
          tableCanvas.drawMain({
            scrollWidth: context.scrollLeft,
            scrollHeight: context.scrollTop + _horizontalPx - _horizontalScrollTop,
            offsetTop: _horizontalPx - _horizontalScrollTop + context.columnHeaderHeight,
            clear: true
          });
          tableCanvas.drawMain({
            scrollWidth: context.scrollLeft,
            scrollHeight: _horizontalScrollTop,
            drawHeight: _horizontalPx
          });
          tableCanvas.drawColumnHeader(context.scrollLeft);
          tableCanvas.drawRowHeader(context.scrollTop + _horizontalPx - _horizontalScrollTop, void 0, _horizontalPx - _horizontalScrollTop + context.columnHeaderHeight);
          tableCanvas.drawRowHeader(_horizontalScrollTop, _horizontalPx);
          tableCanvas.drawFreezeLine({
            horizontalTop: _horizontalPx - _horizontalScrollTop + context.columnHeaderHeight - 2
          });
        } else if (verticallData) {
          var _verticallData2 = _slicedToArray(verticallData, 3), _verticalPx = _verticallData2[0], _verticalScrollWidth = _verticallData2[2];
          tableCanvas.drawMain({
            scrollWidth: context.scrollLeft + _verticalPx - _verticalScrollWidth,
            scrollHeight: context.scrollTop,
            offsetLeft: _verticalPx - _verticalScrollWidth + context.rowHeaderWidth
          });
          tableCanvas.drawMain({
            scrollWidth: _verticalScrollWidth,
            scrollHeight: context.scrollTop,
            drawWidth: _verticalPx
          });
          tableCanvas.drawRowHeader(context.scrollTop);
          tableCanvas.drawColumnHeader(context.scrollLeft + _verticalPx - _verticalScrollWidth, void 0, _verticalPx - _verticalScrollWidth + context.rowHeaderWidth);
          tableCanvas.drawColumnHeader(_verticalScrollWidth, _verticalPx);
          tableCanvas.drawFreezeLine({
            verticalLeft: _verticalPx - _verticalScrollWidth + context.rowHeaderWidth - 2
          });
        }
      } else {
        tableCanvas.drawMain({
          scrollWidth: context.scrollLeft,
          scrollHeight: context.scrollTop,
          clear: true
        });
        tableCanvas.drawColumnHeader(context.scrollLeft);
        tableCanvas.drawRowHeader(context.scrollTop);
      }
    }, [context, refs.canvas, refs.globalCache.freezen, setContext, sheet.id]);
    reactExports.useEffect(function() {
      if (context.groupValuesRefreshData.length > 0) {
        setContext(function(draftCtx) {
          groupValuesRefresh(draftCtx);
        });
      }
    }, [context.groupValuesRefreshData.length, setContext]);
    var onWheel = reactExports.useCallback(function(e) {
      setContext(function(draftCtx) {
        handleGlobalWheel(draftCtx, e, refs.globalCache, refs.scrollbarX.current, refs.scrollbarY.current);
      });
      e.preventDefault();
    }, [refs.globalCache, refs.scrollbarX, refs.scrollbarY, setContext]);
    reactExports.useEffect(function() {
      var container = containerRef.current;
      container === null || container === void 0 ? void 0 : container.addEventListener("wheel", onWheel);
      return function() {
        container === null || container === void 0 ? void 0 : container.removeEventListener("wheel", onWheel);
      };
    }, [onWheel]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "fortune-sheet-container"
    }, /* @__PURE__ */ React.createElement("div", {
      ref: placeholderRef,
      className: "fortune-sheet-canvas-placeholder"
    }), /* @__PURE__ */ React.createElement("canvas", {
      className: "fortune-sheet-canvas",
      ref: refs.canvas
    }), /* @__PURE__ */ React.createElement(SheetOverlay, null));
  };
  var Button = function Button2(_ref) {
    var tooltip = _ref.tooltip, onClick = _ref.onClick, iconId = _ref.iconId, disabled = _ref.disabled, selected = _ref.selected, children = _ref.children;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-button fortune-toolbar-item",
      onClick,
      "data-tips": tooltip,
      role: "button",
      style: selected ? {
        backgroundColor: "#E7E5EB"
      } : {}
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: iconId,
      style: disabled ? {
        opacity: 0.3
      } : {}
    }), tooltip && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-tooltip"
    }, tooltip), children);
  };
  var Divider = function Divider2() {
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-divider fortune-toolbar-item"
    });
  };
  var MenuDivider = function MenuDivider2() {
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-menu-divider"
    });
  };
  var Combo = function Combo2(_ref) {
    var tooltip = _ref.tooltip, _onClick = _ref.onClick, text2 = _ref.text, iconId = _ref.iconId, children = _ref.children;
    var style = {
      userSelect: "none"
    };
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), open = _useState2[0], setOpen = _useState2[1];
    var _useState3 = reactExports.useState({
      left: 0
    }), _useState4 = _slicedToArray(_useState3, 2), popupPosition = _useState4[0], setPopupPosition = _useState4[1];
    var popupRef = reactExports.useRef(null);
    var buttonRef = reactExports.useRef(null);
    useOutsideClick(popupRef, function() {
      setOpen(false);
    });
    reactExports.useLayoutEffect(function() {
      if (!popupRef.current) {
        return;
      }
      if (!open) {
        setPopupPosition({
          left: 0
        });
      }
      var winW = window.innerWidth;
      var rect = popupRef.current.getBoundingClientRect();
      var menuW = rect.width;
      var left = rect.left;
      if (left + menuW > winW) {
        setPopupPosition({
          left: -rect.width + buttonRef.current.clientWidth
        });
      }
    }, [open]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toobar-combo-container fortune-toolbar-item"
    }, /* @__PURE__ */ React.createElement("div", {
      ref: buttonRef,
      className: "fortune-toolbar-combo"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-combo-button",
      onClick: function onClick(e) {
        if (_onClick) _onClick(e);
        else setOpen(!open);
      },
      "data-tips": tooltip,
      role: "button",
      style
    }, iconId ? /* @__PURE__ */ React.createElement(SVGIcon, {
      name: iconId
    }) : /* @__PURE__ */ React.createElement("span", {
      className: "fortune-toolbar-combo-text"
    }, text2)), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-combo-arrow",
      onClick: function onClick() {
        return setOpen(!open);
      },
      "data-tips": tooltip,
      role: "button",
      style
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "combo-arrow",
      width: 10
    })), tooltip && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-tooltip"
    }, tooltip)), open && /* @__PURE__ */ React.createElement("div", {
      ref: popupRef,
      className: "fortune-toolbar-combo-popup",
      style: popupPosition
    }, children === null || children === void 0 ? void 0 : children(setOpen)));
  };
  var Select = function Select2(_ref) {
    var children = _ref.children, style = _ref.style;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-select",
      style
    }, children);
  };
  var Option = function Option2(_ref2) {
    var iconId = _ref2.iconId, onClick = _ref2.onClick, children = _ref2.children, _onMouseLeave = _ref2.onMouseLeave, _onMouseEnter = _ref2.onMouseEnter;
    return /* @__PURE__ */ React.createElement("div", {
      onClick,
      className: "fortune-toolbar-select-option",
      onMouseLeave: function onMouseLeave(e) {
        return _onMouseLeave === null || _onMouseLeave === void 0 ? void 0 : _onMouseLeave(e);
      },
      onMouseEnter: function onMouseEnter(e) {
        return _onMouseEnter === null || _onMouseEnter === void 0 ? void 0 : _onMouseEnter(e);
      }
    }, iconId && /* @__PURE__ */ React.createElement(SVGIcon, {
      name: iconId
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortuen-toolbar-text"
    }, children));
  };
  var FormulaSearch$1 = function FormulaSearch2(_ref) {
    var _onCancel = _ref.onCancel;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, _useContext$refs = _useContext.refs, cellInput = _useContext$refs.cellInput, globalCache = _useContext$refs.globalCache;
    var _useState = reactExports.useState(0), _useState2 = _slicedToArray(_useState, 2), selectedType = _useState2[0], setSelectedType = _useState2[1];
    var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), selectedFuncIndex = _useState4[0], setSelectedFuncIndex = _useState4[1];
    var _useState5 = reactExports.useState(""), _useState6 = _slicedToArray(_useState5, 2), searchText = _useState6[0], setSearchText = _useState6[1];
    var _locale = locale(context), formulaMore = _locale.formulaMore, functionlist = _locale.functionlist, button = _locale.button;
    var typeList = reactExports.useMemo(function() {
      return [{
        t: 0,
        n: formulaMore.Math
      }, {
        t: 1,
        n: formulaMore.Statistical
      }, {
        t: 2,
        n: formulaMore.Lookup
      }, {
        t: 3,
        n: formulaMore.luckysheet
      }, {
        t: 4,
        n: formulaMore.dataMining
      }, {
        t: 5,
        n: formulaMore.Database
      }, {
        t: 6,
        n: formulaMore.Date
      }, {
        t: 7,
        n: formulaMore.Filter
      }, {
        t: 8,
        n: formulaMore.Financial
      }, {
        t: 9,
        n: formulaMore.Engineering
      }, {
        t: 10,
        n: formulaMore.Logical
      }, {
        t: 11,
        n: formulaMore.Operator
      }, {
        t: 12,
        n: formulaMore.Text
      }, {
        t: 13,
        n: formulaMore.Parser
      }, {
        t: 14,
        n: formulaMore.Array
      }, {
        t: -1,
        n: formulaMore.other
      }];
    }, [formulaMore]);
    var filteredFunctionList = reactExports.useMemo(function() {
      if (searchText) {
        var list = [];
        var text2 = _$1.cloneDeep(searchText.toUpperCase());
        for (var i2 = 0; i2 < functionlist.length; i2 += 1) {
          if (/^[a-zA-Z]+$/.test(text2)) {
            if (functionlist[i2].n.indexOf(text2) !== -1) {
              list.push(functionlist[i2]);
            }
          } else if (functionlist[i2].a.indexOf(text2) !== -1) {
            list.push(functionlist[i2]);
          }
        }
        return list;
      }
      return _$1.filter(functionlist, function(v2) {
        return v2.t === selectedType;
      });
    }, [functionlist, selectedType, searchText]);
    var onConfirm = reactExports.useCallback(function() {
      var _context$luckysheet_s;
      var last = (_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s[context.luckysheet_select_save.length - 1];
      var row_index = last === null || last === void 0 ? void 0 : last.row_focus;
      var col_index = last === null || last === void 0 ? void 0 : last.column_focus;
      if (!last) {
        row_index = 0;
        col_index = 0;
      } else {
        if (row_index == null) {
          var _last$row = _slicedToArray(last.row, 1);
          row_index = _last$row[0];
        }
        if (col_index == null) {
          var _last$column = _slicedToArray(last.column, 1);
          col_index = _last$column[0];
        }
      }
      var formulaTxt = '<span dir="auto" class="luckysheet-formula-text-color">=</span><span dir="auto" class="luckysheet-formula-text-color">'.concat(filteredFunctionList[selectedFuncIndex].n.toUpperCase(), '</span><span dir="auto" class="luckysheet-formula-text-color">(</span>');
      setContext(function(ctx) {
        if (cellInput.current != null) {
          ctx.luckysheetCellUpdate = [row_index, col_index];
          globalCache.doNotUpdateCell = true;
          cellInput.current.innerHTML = formulaTxt;
          var spans = cellInput.current.childNodes;
          if (!_$1.isEmpty(spans)) {
            setCaretPosition(ctx, spans[spans.length - 1], 0, 1);
          }
          ctx.functionHint = filteredFunctionList[selectedFuncIndex].n.toUpperCase();
          ctx.functionCandidates = [];
          if (_$1.isEmpty(ctx.formulaCache.functionlistMap)) {
            for (var i2 = 0; i2 < functionlist.length; i2 += 1) {
              ctx.formulaCache.functionlistMap[functionlist[i2].n] = functionlist[i2];
            }
          }
          _onCancel();
        }
      });
    }, [cellInput, context.luckysheet_select_save, filteredFunctionList, globalCache, selectedFuncIndex, setContext, _onCancel, functionlist]);
    var onCancel = reactExports.useCallback(function() {
      setContext(function(ctx) {
        cancelNormalSelected(ctx);
        if (cellInput.current) {
          cellInput.current.innerHTML = "";
        }
      });
      _onCancel();
    }, [_onCancel, cellInput, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-search-formula"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "inpbox"
    }, /* @__PURE__ */ React.createElement("div", null, formulaMore.findFunctionTitle, "："), /* @__PURE__ */ React.createElement("input", {
      className: "formulaInputFocus",
      id: "searchFormulaListInput",
      placeholder: formulaMore.tipInputFunctionName,
      spellCheck: "false",
      onChange: function onChange(e) {
        return setSearchText(e.target.value);
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "selbox"
    }, /* @__PURE__ */ React.createElement("span", null, formulaMore.selectCategory, "："), /* @__PURE__ */ React.createElement("select", {
      id: "formulaTypeSelect",
      onChange: function onChange(e) {
        setSelectedType(parseInt(e.target.value, 10));
        setSelectedFuncIndex(0);
      }
    }, typeList.map(function(v2) {
      return /* @__PURE__ */ React.createElement("option", {
        key: v2.t,
        value: v2.t
      }, v2.n);
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "listbox",
      style: {
        height: 200
      }
    }, /* @__PURE__ */ React.createElement("div", null, formulaMore.selectFunctionTitle, "："), /* @__PURE__ */ React.createElement("div", {
      className: "formulaList"
    }, filteredFunctionList.map(function(v2, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "listBox".concat(index2 === selectedFuncIndex ? " on" : ""),
        key: v2.n,
        onClick: function onClick() {
          return setSelectedFuncIndex(index2);
        }
      }, /* @__PURE__ */ React.createElement("div", null, v2.n), /* @__PURE__ */ React.createElement("div", null, v2.a));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-dialog-box-button-container"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-primary",
      onClick: onConfirm
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-default",
      onClick: onCancel
    }, button.cancel)));
  };
  var SplitColumn = function SplitColumn2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _locale = locale(context), splitText = _locale.splitText, button = _locale.button;
    var _useState = reactExports.useState(""), _useState2 = _slicedToArray(_useState, 2), splitOperate = _useState2[0], setSplitOperate = _useState2[1];
    var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), otherFlag = _useState4[0], setOtherFlag = _useState4[1];
    var _useState5 = reactExports.useState([]), _useState6 = _slicedToArray(_useState5, 2), tableData = _useState6[0], setTableData = _useState6[1];
    var splitSymbols = reactExports.useRef(null);
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog, hideDialog = _useDialog.hideDialog;
    var certainBtn = reactExports.useCallback(function() {
      hideDialog();
      var dataArr = getDataArr(splitOperate, context);
      var r2 = context.luckysheet_select_save[0].row[0];
      var c2 = context.luckysheet_select_save[0].column[0];
      if (dataArr[0].length === 1) {
        return;
      }
      var dataCover = false;
      var data = getFlowdata(context);
      for (var i2 = 0; i2 < dataArr.length; i2 += 1) {
        for (var j2 = 1; j2 < dataArr[0].length; j2 += 1) {
          var cell = data[r2 + i2][c2 + j2];
          if (!_$1.isNull(cell) && !_$1.isNull(cell.v)) {
            dataCover = true;
            break;
          }
        }
      }
      if (dataCover) {
        showDialog(splitText.splitConfirmToExe, "yesno", function() {
          hideDialog();
          setContext(function(ctx) {
            updateMoreCell(r2, c2, dataArr, ctx);
          });
        });
      } else {
        setContext(function(ctx) {
          updateMoreCell(r2, c2, dataArr, ctx);
        });
      }
    }, [context, hideDialog, setContext, showDialog, splitOperate, splitText.splitConfirmToExe]);
    reactExports.useEffect(function() {
      setTableData(function(table) {
        table = getDataArr(splitOperate, context);
        return table;
      });
    }, [context, splitOperate]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-split-column"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "title"
    }, splitText.splitTextTitle), /* @__PURE__ */ React.createElement("div", {
      className: "splitDelimiters"
    }, splitText.splitDelimiters), /* @__PURE__ */ React.createElement("div", {
      className: "splitSymbols",
      ref: splitSymbols
    }, splitText.splitSymbols.map(function(o2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: o2.value,
        className: "splitSymbol"
      }, /* @__PURE__ */ React.createElement("input", {
        id: o2.value,
        name: o2.value,
        type: "checkbox",
        onClick: function onClick() {
          return setSplitOperate(function(regStr) {
            var _splitSymbols$current;
            return getRegStr(regStr, (_splitSymbols$current = splitSymbols.current) === null || _splitSymbols$current === void 0 ? void 0 : _splitSymbols$current.childNodes);
          });
        }
      }), /* @__PURE__ */ React.createElement("label", {
        htmlFor: o2.value
      }, o2.name));
    }), /* @__PURE__ */ React.createElement("div", {
      className: "splitSymbol"
    }, /* @__PURE__ */ React.createElement("input", {
      id: "other",
      name: "other",
      type: "checkbox",
      onClick: function onClick() {
        setOtherFlag(!otherFlag);
        setSplitOperate(function(regStr) {
          var _splitSymbols$current2;
          return getRegStr(regStr, (_splitSymbols$current2 = splitSymbols.current) === null || _splitSymbols$current2 === void 0 ? void 0 : _splitSymbols$current2.childNodes);
        });
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "other"
    }, splitText.splitOther), /* @__PURE__ */ React.createElement("input", {
      id: "otherValue",
      name: "otherValue",
      type: "text",
      onBlur: function onBlur() {
        if (otherFlag) {
          setSplitOperate(function(regStr) {
            var _splitSymbols$current3;
            return getRegStr(regStr, (_splitSymbols$current3 = splitSymbols.current) === null || _splitSymbols$current3 === void 0 ? void 0 : _splitSymbols$current3.childNodes);
          });
        }
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "splitSymbol splitSimple"
    }, /* @__PURE__ */ React.createElement("input", {
      id: "splitsimple",
      name: "splitsimple",
      type: "checkbox",
      onClick: function onClick() {
        setSplitOperate(function(regStr) {
          var _splitSymbols$current4;
          return getRegStr(regStr, (_splitSymbols$current4 = splitSymbols.current) === null || _splitSymbols$current4 === void 0 ? void 0 : _splitSymbols$current4.childNodes);
        });
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "splitsimple"
    }, splitText.splitContinueSymbol))), /* @__PURE__ */ React.createElement("div", {
      className: "splitDataPreview"
    }, splitText.splitDataPreview), /* @__PURE__ */ React.createElement("div", {
      className: "splitColumnData"
    }, /* @__PURE__ */ React.createElement("table", null, /* @__PURE__ */ React.createElement("tbody", null, tableData.map(function(o2, index2) {
      if (o2.length >= 1) {
        return /* @__PURE__ */ React.createElement("tr", {
          key: index2
        }, o2.map(function(o1) {
          return /* @__PURE__ */ React.createElement("td", {
            key: o2 + o1
          }, o1);
        }));
      }
      return /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("td", null));
    })))), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        certainBtn();
      }
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        hideDialog();
      }
    }, button.cancel));
  };
  var LocationCondition = function LocationCondition2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog, hideDialog = _useDialog.hideDialog;
    var _locale = locale(context), findAndReplace = _locale.findAndReplace, button = _locale.button;
    var _useState = reactExports.useState("locationConstant"), _useState2 = _slicedToArray(_useState, 2), conditionType = _useState2[0], setConditionType = _useState2[1];
    var _useState3 = reactExports.useState({
      locationDate: true,
      locationDigital: true,
      locationString: true,
      locationBool: true,
      locationError: true
    }), _useState4 = _slicedToArray(_useState3, 2), constants = _useState4[0], setConstants = _useState4[1];
    var _useState5 = reactExports.useState({
      locationDate: true,
      locationDigital: true,
      locationString: true,
      locationBool: true,
      locationError: true
    }), _useState6 = _slicedToArray(_useState5, 2), formulas = _useState6[0], setFormulas = _useState6[1];
    var onConfirm = reactExports.useCallback(function() {
      if (conditionType === "locationConstant") {
        var value = getOptionValue(constants);
        var selectRange = getSelectRange(context);
        setContext(function(ctx) {
          var rangeArr = applyLocation(selectRange, conditionType, value, ctx);
          if (rangeArr.length === 0) showDialog(findAndReplace.locationTipNotFindCell, "ok");
        });
      } else if (conditionType === "locationFormula") {
        var _value = getOptionValue(formulas);
        var _selectRange = getSelectRange(context);
        setContext(function(ctx) {
          var rangeArr = applyLocation(_selectRange, conditionType, _value, ctx);
          if (rangeArr.length === 0) showDialog(findAndReplace.locationTipNotFindCell, "ok");
        });
      } else if (conditionType === "locationRowSpan") {
        var _context$luckysheet_s, _context$luckysheet_s2;
        if (((_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s.length) === 0 || ((_context$luckysheet_s2 = context.luckysheet_select_save) === null || _context$luckysheet_s2 === void 0 ? void 0 : _context$luckysheet_s2.length) === 1 && context.luckysheet_select_save[0].row[0] === context.luckysheet_select_save[0].row[1]) {
          showDialog(findAndReplace.locationTiplessTwoRow, "ok");
          return;
        }
        var _selectRange2 = _$1.assignIn([], context.luckysheet_select_save);
        setContext(function(ctx) {
          var rangeArr = applyLocation(_selectRange2, conditionType, void 0, ctx);
          if (rangeArr.length === 0) showDialog(findAndReplace.locationTipNotFindCell, "ok");
        });
      } else if (conditionType === "locationColumnSpan") {
        var _context$luckysheet_s3, _context$luckysheet_s4;
        if (((_context$luckysheet_s3 = context.luckysheet_select_save) === null || _context$luckysheet_s3 === void 0 ? void 0 : _context$luckysheet_s3.length) === 0 || ((_context$luckysheet_s4 = context.luckysheet_select_save) === null || _context$luckysheet_s4 === void 0 ? void 0 : _context$luckysheet_s4.length) === 1 && context.luckysheet_select_save[0].column[0] === context.luckysheet_select_save[0].column[1]) {
          showDialog(findAndReplace.locationTiplessTwoColumn, "ok");
          return;
        }
        var _selectRange3 = _$1.assignIn([], context.luckysheet_select_save);
        setContext(function(ctx) {
          var rangeArr = applyLocation(_selectRange3, conditionType, void 0, ctx);
          if (rangeArr.length === 0) showDialog(findAndReplace.locationTipNotFindCell, "ok");
        });
      } else {
        var _context$luckysheet_s5, _context$luckysheet_s6;
        var _selectRange4;
        if (((_context$luckysheet_s5 = context.luckysheet_select_save) === null || _context$luckysheet_s5 === void 0 ? void 0 : _context$luckysheet_s5.length) === 0 || ((_context$luckysheet_s6 = context.luckysheet_select_save) === null || _context$luckysheet_s6 === void 0 ? void 0 : _context$luckysheet_s6.length) === 1 && context.luckysheet_select_save[0].row[0] === context.luckysheet_select_save[0].row[1] && context.luckysheet_select_save[0].column[0] === context.luckysheet_select_save[0].column[1]) {
          var flowdata = getFlowdata(context, context.currentSheetId);
          _selectRange4 = [{
            row: [0, flowdata.length - 1],
            column: [0, flowdata[0].length - 1]
          }];
        } else {
          _selectRange4 = _$1.assignIn([], context.luckysheet_select_save);
        }
        setContext(function(ctx) {
          var rangeArr = applyLocation(_selectRange4, conditionType, void 0, ctx);
          if (rangeArr.length === 0) showDialog(findAndReplace.locationTipNotFindCell, "ok");
        });
      }
    }, [conditionType, constants, context, findAndReplace.locationTipNotFindCell, findAndReplace.locationTiplessTwoColumn, findAndReplace.locationTiplessTwoRow, formulas, setContext, showDialog]);
    var isSelect = reactExports.useCallback(function(currentType) {
      return conditionType === currentType;
    }, [conditionType]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-location-condition"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "title"
    }, findAndReplace.location), /* @__PURE__ */ React.createElement("div", {
      className: "listbox"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "listItem"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "radio",
      name: "locationType",
      id: "locationConstant",
      checked: isSelect("locationConstant"),
      onChange: function onChange() {
        setConditionType("locationConstant");
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "locationConstant"
    }, findAndReplace.locationConstant), /* @__PURE__ */ React.createElement("div", {
      className: "subbox"
    }, ["locationDate", "locationDigital", "locationString", "locationBool", "locationError"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "subItem",
        key: v2
      }, /* @__PURE__ */ React.createElement("input", {
        type: "checkbox",
        disabled: !isSelect("locationConstant"),
        checked: constants[v2],
        onChange: function onChange() {
          setConstants(fn(function(draft) {
            _$1.set(draft, v2, !draft[v2]);
          }));
        }
      }), /* @__PURE__ */ React.createElement("label", {
        htmlFor: v2,
        style: {
          color: isSelect("locationConstant") ? "#000" : "#666"
        }
      }, findAndReplace[v2]));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "listItem"
    }, /* @__PURE__ */ React.createElement("input", {
      type: "radio",
      name: "locationType",
      id: "locationFormula",
      checked: isSelect("locationFormula"),
      onChange: function onChange() {
        setConditionType("locationFormula");
      }
    }), /* @__PURE__ */ React.createElement("label", {
      htmlFor: "locationFormula"
    }, findAndReplace.locationFormula), /* @__PURE__ */ React.createElement("div", {
      className: "subbox"
    }, ["locationDate", "locationDigital", "locationString", "locationBool", "locationError"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "subItem",
        key: v2
      }, /* @__PURE__ */ React.createElement("input", {
        type: "checkbox",
        disabled: !isSelect("locationFormula"),
        checked: formulas[v2],
        onChange: function onChange() {
          setFormulas(fn(function(draft) {
            _$1.set(draft, v2, !draft[v2]);
          }));
        }
      }), /* @__PURE__ */ React.createElement("label", {
        htmlFor: v2,
        style: {
          color: isSelect("locationFormula") ? "#000" : "#666"
        }
      }, findAndReplace[v2]));
    }))), ["locationNull", "locationRowSpan", "locationColumnSpan"].map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "listItem",
        key: v2
      }, /* @__PURE__ */ React.createElement("input", {
        type: "radio",
        name: v2,
        checked: isSelect(v2),
        onChange: function onChange() {
          setConditionType(v2);
        }
      }), /* @__PURE__ */ React.createElement("label", {
        htmlFor: v2
      }, findAndReplace[v2]));
    })), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        hideDialog();
        onConfirm();
      }
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-close",
      onClick: function onClick() {
        hideDialog();
      }
    }, button.cancel));
  };
  var ConditionalFormat = function ConditionalFormat2(_ref) {
    var items = _ref.items, setOpen = _ref.setOpen;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog;
    var _locale = locale(context), conditionformat = _locale.conditionformat;
    var showSubMenu = reactExports.useCallback(function(e) {
      var target = e.target;
      var menuItem = target.className === "fortune-toolbar-menu-line" ? target.parentElement : target;
      var menuItemRect = menuItem.getBoundingClientRect();
      var workbookContainerRect = refs.workbookContainer.current.getBoundingClientRect();
      var subMenu = menuItem.querySelector(".condition-format-sub-menu");
      if (_$1.isNil(subMenu)) return;
      var menuItemStyle = window.getComputedStyle(menuItem);
      var menuItemPaddingRight = parseFloat(menuItemStyle.getPropertyValue("padding-right").replace("px", ""));
      if (workbookContainerRect.right - menuItemRect.right < parseFloat(subMenu.style.width.replace("px", ""))) {
        subMenu.style.display = "block";
        subMenu.style.right = "".concat(menuItemRect.width - menuItemPaddingRight, "px");
      } else {
        subMenu.style.display = "block";
        subMenu.style.right = "".concat(-(parseFloat(subMenu.style.width.replace("px", "")) + menuItemPaddingRight), "px");
      }
    }, [refs.workbookContainer]);
    var hideSubMenu = reactExports.useCallback(function(e) {
      var target = e.target;
      if (target.className === "condition-format-sub-menu") {
        target.style.display = "none";
        return;
      }
      var subMenu = target.className === "condition-format-item" ? target.parentElement : target.querySelector(".condition-format-sub-menu");
      if (_$1.isNil(subMenu)) return;
      subMenu.style.display = "none";
    }, []);
    var getConditionFormatItem = reactExports.useCallback(function(name) {
      if (name === "-") {
        return /* @__PURE__ */ React.createElement(MenuDivider, {
          key: name
        });
      }
      if (name === "highlightCellRules") {
        return /* @__PURE__ */ React.createElement(Option, {
          key: name,
          onMouseEnter: showSubMenu,
          onMouseLeave: hideSubMenu
        }, /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name], /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        }), /* @__PURE__ */ React.createElement("div", {
          className: "condition-format-sub-menu",
          style: {
            display: "none",
            width: 150
          }
        }, [{
          text: "greaterThan",
          value: ">"
        }, {
          text: "lessThan",
          value: "<"
        }, {
          text: "between",
          value: "[]"
        }, {
          text: "equal",
          value: "="
        }, {
          text: "textContains",
          value: "()"
        }, {
          text: "occurrenceDate",
          value: conditionformat.yesterday
        }, {
          text: "duplicateValue",
          value: "##"
        }].map(function(v2) {
          return /* @__PURE__ */ React.createElement("div", {
            className: "condition-format-item",
            key: v2.text,
            onClick: function onClick() {
              setOpen(false);
              showDialog(/* @__PURE__ */ React.createElement(ConditionRules, {
                type: v2.text
              }));
            }
          }, conditionformat[v2.text], /* @__PURE__ */ React.createElement("span", null, v2.value));
        }))));
      }
      if (name === "itemSelectionRules") {
        return /* @__PURE__ */ React.createElement(Option, {
          key: name,
          onMouseEnter: showSubMenu,
          onMouseLeave: hideSubMenu
        }, /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line"
        }, conditionformat[name], /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        }), /* @__PURE__ */ React.createElement("div", {
          className: "condition-format-sub-menu",
          style: {
            display: "none",
            width: 180
          }
        }, [{
          text: "top10",
          value: conditionformat.top10
        }, {
          text: "top10_percent",
          value: conditionformat.top10_percent
        }, {
          text: "last10",
          value: conditionformat.last10
        }, {
          text: "last10_percent",
          value: conditionformat.last10_percent
        }, {
          text: "aboveAverage",
          value: conditionformat.above
        }, {
          text: "belowAverage",
          value: conditionformat.below
        }].map(function(v2) {
          return /* @__PURE__ */ React.createElement("div", {
            className: "condition-format-item",
            key: v2.text,
            onClick: function onClick() {
              setOpen(false);
              showDialog(/* @__PURE__ */ React.createElement(ConditionRules, {
                type: v2.text
              }));
            }
          }, conditionformat[v2.text], /* @__PURE__ */ React.createElement("span", null, v2.value));
        }))));
      }
      if (name === "dataBar") {
        return /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name], /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        }));
      }
      if (name === "colorGradation") {
        return /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name], /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        }));
      }
      if (name === "icons") {
        return /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name]);
      }
      if (name === "newFormatRule") {
        return /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name]);
      }
      if (name === "deleteRule") {
        return /* @__PURE__ */ React.createElement(Option, {
          key: name,
          onMouseEnter: showSubMenu,
          onMouseLeave: hideSubMenu
        }, /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line"
        }, conditionformat[name], /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        }), /* @__PURE__ */ React.createElement("div", {
          className: "condition-format-sub-menu",
          style: {
            display: "none",
            width: 150
          }
        }, ["deleteSheetRule"].map(function(v2) {
          return /* @__PURE__ */ React.createElement("div", {
            className: "condition-format-item",
            key: v2,
            style: {
              padding: "6px 10px"
            },
            onClick: function onClick() {
              setContext(function(ctx) {
                updateItem(ctx);
              });
            }
          }, conditionformat[v2]);
        }))));
      }
      if (name === "manageRules") {
        return /* @__PURE__ */ React.createElement("div", {
          className: "fortune-toolbar-menu-line",
          key: "div".concat(name)
        }, conditionformat[name]);
      }
      return /* @__PURE__ */ React.createElement("div", null);
    }, [conditionformat, hideSubMenu, setContext, setOpen, showDialog, showSubMenu]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "condition-format"
    }, /* @__PURE__ */ React.createElement(Select, {
      style: {
        overflow: "visible"
      }
    }, items.map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: "option".concat(v2)
      }, getConditionFormatItem(v2));
    })));
  };
  var CustomIcon = function CustomIcon2(_ref) {
    var iconName = _ref.iconName, _ref$width = _ref.width, width = _ref$width === void 0 ? 24 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? 24 : _ref$height, content = _ref.content;
    var innrContent = reactExports.useMemo(function() {
      if (iconName) {
        return /* @__PURE__ */ React.createElement("svg", {
          width,
          height
        }, /* @__PURE__ */ React.createElement("use", {
          xlinkHref: "#".concat(iconName)
        }));
      }
      if (content) {
        return content;
      }
      return /* @__PURE__ */ React.createElement("svg", {
        width,
        height: width
      }, /* @__PURE__ */ React.createElement("use", {
        xlinkHref: "#default"
      }));
    }, [content, height, iconName, width]);
    return /* @__PURE__ */ React.createElement("div", {
      style: {
        width,
        height,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }, innrContent);
  };
  var CustomButton = function CustomButton2(_ref) {
    var tooltip = _ref.tooltip, onClick = _ref.onClick, selected = _ref.selected, children = _ref.children, iconName = _ref.iconName, icon = _ref.icon;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-button fortune-toolbar-item",
      onClick,
      "data-tips": tooltip,
      role: "button",
      style: selected ? {
        backgroundColor: "#E7E5EB"
      } : {}
    }, /* @__PURE__ */ React.createElement(CustomIcon, {
      iconName,
      content: icon
    }), tooltip && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-tooltip"
    }, tooltip), children);
  };
  var palette = [["#000000", "#444444", "#666666", "#999999", "#cccccc", "#eeeeee", "#f3f3f3", "#ffffff"], ["#f00f00", "#f90f90", "#ff0ff0", "#0f00f0", "#0ff0ff", "#00f00f", "#90f90f", "#f0ff0f"], ["#f4cccc", "#fce5cd", "#fff2cc", "#d9ead3", "#d0e0e3", "#cfe2f3", "#d9d2e9", "#ead1dc"], ["#ea9999", "#f9cb9c", "#ffe599", "#b6d7a8", "#a2c4c9", "#9fc5e8", "#b4a7d6", "#d5a6bd"], ["#e06666", "#f6b26b", "#ffd966", "#93c47d", "#76a5af", "#6fa8dc", "#8e7cc3", "#c27ba0"], ["#c00c00", "#e69138", "#f1c232", "#6aa84f", "#45818e", "#3d85c6", "#674ea7", "#a64d79"], ["#900900", "#b45f06", "#bf9000", "#38761d", "#134f5c", "#0b5394", "#351c75", "#741b47"], ["#600600", "#783f04", "#7f6000", "#274e13", "#0c343d", "#073763", "#20124d", "#4c1130"]];
  var ColorPicker = function ColorPicker2(_ref) {
    var onPick = _ref.onPick;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-color-picker"
    }, palette.map(function(rows, i2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: i2,
        className: "fortune-toolbar-color-picker-row"
      }, rows.map(function(c2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: c2,
          className: "fortune-toolbar-color-picker-item",
          onClick: function onClick() {
            return onPick(c2);
          },
          style: {
            backgroundColor: c2
          }
        });
      }));
    }));
  };
  var CustomColor = function CustomColor2(_ref) {
    var onCustomPick = _ref.onCustomPick, onColorPick = _ref.onColorPick;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context;
    var _locale = locale(context), toolbar = _locale.toolbar, sheetconfig = _locale.sheetconfig, button = _locale.button;
    var _useState = reactExports.useState("#000000"), _useState2 = _slicedToArray(_useState, 2), inputColor = _useState2[0], setInputColor = _useState2[1];
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-custom-color"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "color-reset",
      onClick: function onClick() {
        return onCustomPick(void 0);
      }
    }, sheetconfig.resetColor), /* @__PURE__ */ React.createElement("div", {
      className: "custom-color"
    }, /* @__PURE__ */ React.createElement("div", null, toolbar.customColor, ":"), /* @__PURE__ */ React.createElement("input", {
      type: "color",
      value: inputColor,
      onChange: function onChange(e) {
        return setInputColor(e.target.value);
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        onCustomPick(inputColor);
      }
    }, button.confirm)), /* @__PURE__ */ React.createElement(ColorPicker, {
      onPick: function onPick(color) {
        onColorPick(color);
      }
    }));
  };
  var size = [{
    Text: "1",
    value: "Thin",
    strokeDasharray: "1,0",
    strokeWidth: "1"
  }, {
    Text: "2",
    value: "Hair",
    strokeDasharray: "1,5",
    strokeWidth: "1"
  }, {
    Text: "3",
    value: "Dotted",
    strokeDasharray: "2,5",
    strokeWidth: "2"
  }, {
    Text: "4",
    value: "Dashed",
    strokeDasharray: "5,5",
    strokeWidth: "2"
  }, {
    Text: "5",
    value: "DashDot",
    strokeDasharray: "20,5,5,10,5,5",
    strokeWidth: "2"
  }, {
    Text: "6",
    value: "DashDotDot",
    strokeDasharray: "20,5,5,5,5,10,5,5,5,5",
    strokeWidth: "2"
  }, {
    Text: "8",
    value: "Medium",
    strokeDasharray: "2,0",
    strokeWidth: "2"
  }, {
    Text: "9",
    value: "MediumDashed",
    strokeDasharray: "3,5",
    strokeWidth: "3"
  }, {
    Text: "10",
    value: "MediumDashDot",
    strokeDasharray: "20,5,5,10,5,5",
    strokeWidth: "3"
  }, {
    Text: "11",
    value: "MediumDashDotDot",
    strokeDasharray: "5,5,5,5,20,5,5,5,5,10",
    strokeWidth: "3"
  }, {
    Text: "13",
    value: "Thick",
    strokeDasharray: "2,0",
    strokeWidth: "3"
  }];
  var CustomBorder = function CustomBorder2(_ref) {
    var onPick = _ref.onPick;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, refs = _useContext.refs;
    var _locale = locale(context), border = _locale.border;
    var _useState = reactExports.useState("#000000"), _useState2 = _slicedToArray(_useState, 2), changeColor = _useState2[0], setchangeColor = _useState2[1];
    var _useState3 = reactExports.useState("1"), _useState4 = _slicedToArray(_useState3, 2), changeStyle = _useState4[0], setchangeStyle = _useState4[1];
    var colorRef = reactExports.useRef(null);
    var styleRef = reactExports.useRef(null);
    var colorPreviewRef = reactExports.useRef(null);
    var _useState5 = reactExports.useState(""), _useState6 = _slicedToArray(_useState5, 2), previewWith = _useState6[0], setPreviewWith = _useState6[1];
    var _useState7 = reactExports.useState(""), _useState8 = _slicedToArray(_useState7, 2), previewdasharry = _useState8[0], setPreviewdasharray = _useState8[1];
    var showBorderSubMenu = reactExports.useCallback(function(e) {
      var target = e.target;
      var menuItemRect = target.getBoundingClientRect();
      var subMenuItem = target.querySelector(".fortune-border-select-menu");
      if (_$1.isNil(subMenuItem)) return;
      subMenuItem.style.display = "block";
      var workbookContainerRect = refs.workbookContainer.current.getBoundingClientRect();
      if (workbookContainerRect.width - menuItemRect.right > parseFloat(subMenuItem.style.width.replace("px", ""))) {
        subMenuItem.style.left = "".concat(menuItemRect === null || menuItemRect === void 0 ? void 0 : menuItemRect.width, "px");
      } else {
        subMenuItem.style.left = "-".concat(subMenuItem.style.width);
      }
    }, [refs.workbookContainer]);
    var hideBorderSubMenu = reactExports.useCallback(function() {
      styleRef.current.style.display = "none";
      colorRef.current.style.display = "none";
    }, []);
    var changePreviewStyle = reactExports.useCallback(function(width, dasharray) {
      setPreviewWith(width);
      setPreviewdasharray(dasharray);
    }, []);
    return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-border-select-option",
      key: "borderColor",
      onMouseEnter: function onMouseEnter(e) {
        showBorderSubMenu(e);
      },
      onMouseLeave: function onMouseLeave() {
        hideBorderSubMenu();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-menu-line"
    }, border.borderColor, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "rightArrow",
      style: {
        width: "14px"
      }
    })), /* @__PURE__ */ React.createElement("div", {
      ref: colorPreviewRef,
      className: "fortune-border-color-preview",
      style: {
        backgroundColor: changeColor
      }
    }), /* @__PURE__ */ React.createElement("div", {
      ref: colorRef,
      className: "fortune-border-select-menu",
      style: {
        display: "none",
        width: "166px"
      }
    }, /* @__PURE__ */ React.createElement(CustomColor, {
      onCustomPick: function onCustomPick(color) {
        onPick(color, changeStyle);
        colorPreviewRef.current.style.backgroundColor = changeColor;
        setchangeColor(color);
      },
      onColorPick: function onColorPick(color) {
        onPick(color, changeStyle);
        setchangeColor(color);
      }
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-border-select-option",
      key: "borderStyle",
      onMouseEnter: function onMouseEnter(e) {
        showBorderSubMenu(e);
      },
      onMouseLeave: function onMouseLeave() {
        hideBorderSubMenu();
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-toolbar-menu-line"
    }, border.borderStyle, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "rightArrow",
      style: {
        width: "14px"
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-border-style-preview"
    }, /* @__PURE__ */ React.createElement("svg", {
      width: "90"
    }, /* @__PURE__ */ React.createElement("g", {
      fill: "none",
      stroke: "black",
      strokeWidth: previewWith
    }, /* @__PURE__ */ React.createElement("path", {
      strokeDasharray: previewdasharry,
      d: "M0 0 l90 0"
    })))), /* @__PURE__ */ React.createElement("div", {
      ref: styleRef,
      className: "fortune-border-select-menu fortune-toolbar-select",
      style: {
        display: "none",
        width: "110px"
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-border-style-picker-menu fortune-border-style-reset",
      onClick: function onClick() {
        onPick(changeColor, "1");
        changePreviewStyle("1", "1,0");
      }
    }, border.borderDefault), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-boder-style-picker"
    }, size.map(function(items, i2) {
      return /* @__PURE__ */ React.createElement("div", {
        key: i2,
        className: "fortune-border-style-picker-menu",
        onClick: function onClick() {
          onPick(changeColor, items.Text);
          setchangeStyle(items.Text);
          changePreviewStyle(items.strokeWidth, items.strokeDasharray);
        }
      }, /* @__PURE__ */ React.createElement("svg", {
        height: "10",
        width: "90"
      }, /* @__PURE__ */ React.createElement("g", {
        fill: "none",
        stroke: "black",
        strokeWidth: items.strokeWidth
      }, /* @__PURE__ */ React.createElement("path", {
        strokeDasharray: items.strokeDasharray,
        d: "M0 5 l85 0"
      }))));
    })))));
  };
  var FormatSearch = function FormatSearch2(_ref) {
    var type = _ref.type, _onCancel = _ref.onCancel;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, cellInput = _useContext.refs.cellInput;
    var _useState = reactExports.useState(2), _useState2 = _slicedToArray(_useState, 2), decimalPlace = _useState2[0], setDecimalPlace = _useState2[1];
    var _useState3 = reactExports.useState(0), _useState4 = _slicedToArray(_useState3, 2), selectedFormatIndex = _useState4[0], setSelectedFormatIndex = _useState4[1];
    var _locale = locale(context), button = _locale.button, format = _locale.format, currencyDetail = _locale.currencyDetail, dateFmtList = _locale.dateFmtList;
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog;
    var toolbarFormatAll = reactExports.useMemo(function() {
      return {
        currency: currencyDetail,
        date: dateFmtList,
        number: []
      };
    }, [currencyDetail, dateFmtList]);
    var toolbarFormat = reactExports.useMemo(function() {
      return toolbarFormatAll[type];
    }, [toolbarFormatAll, type]);
    var tips = _$1.get(format, type);
    var onConfirm = reactExports.useCallback(function() {
      if (decimalPlace < 0 || decimalPlace > 9) {
        _onCancel();
        showDialog(format.tipDecimalPlaces, "ok");
        return;
      }
      setContext(function(ctx) {
        var index2 = getSheetIndex(ctx, ctx.currentSheetId);
        if (_$1.isNil(index2)) return;
        var selectedFormat = toolbarFormat[selectedFormatIndex].value;
        _$1.forEach(ctx.luckysheet_select_save, function(selection) {
          for (var r2 = selection.row[0]; r2 <= selection.row[1]; r2 += 1) {
            for (var c2 = selection.column[0]; c2 <= selection.column[1]; c2 += 1) {
              var _ctx$luckysheetfile$i, _ctx$luckysheetfile$i2, _ctx$luckysheetfile$i3, _ctx$luckysheetfile$i4;
              if (((_ctx$luckysheetfile$i = ctx.luckysheetfile[index2].data) === null || _ctx$luckysheetfile$i === void 0 ? void 0 : _ctx$luckysheetfile$i[r2][c2]) && ((_ctx$luckysheetfile$i2 = ctx.luckysheetfile[index2].data) === null || _ctx$luckysheetfile$i2 === void 0 ? void 0 : (_ctx$luckysheetfile$i3 = _ctx$luckysheetfile$i2[r2][c2]) === null || _ctx$luckysheetfile$i3 === void 0 ? void 0 : (_ctx$luckysheetfile$i4 = _ctx$luckysheetfile$i3.ct) === null || _ctx$luckysheetfile$i4 === void 0 ? void 0 : _ctx$luckysheetfile$i4.t) === "n") {
                var zero = 0;
                ctx.luckysheetfile[index2].data[r2][c2].ct.fa = "".concat(selectedFormat).concat(zero.toFixed(decimalPlace));
                ctx.luckysheetfile[index2].data[r2][c2].m = update("".concat(selectedFormat).concat(zero.toFixed(decimalPlace)), ctx.luckysheetfile[index2].data[r2][c2].v);
              }
            }
          }
        });
        _onCancel();
      });
    }, [_onCancel, decimalPlace, format.tipDecimalPlaces, selectedFormatIndex, setContext, showDialog, toolbarFormat]);
    var onCancel = reactExports.useCallback(function() {
      setContext(function(ctx) {
        cancelNormalSelected(ctx);
        if (cellInput.current) {
          cellInput.current.innerHTML = "";
        }
      });
      _onCancel();
    }, [_onCancel, cellInput, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-search-format"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "listbox",
      style: {
        height: 200
      }
    }, /* @__PURE__ */ React.createElement("div", {
      style: {
        marginBottom: 16
      }
    }, tips, format.format, "："), /* @__PURE__ */ React.createElement("div", {
      className: "inpbox",
      style: type === "currency" ? {
        display: "block"
      } : {
        display: "none"
      }
    }, format.decimalPlaces, "：", /* @__PURE__ */ React.createElement("input", {
      className: "decimal-places-input",
      id: "decimal-places-input",
      min: 0,
      max: 9,
      defaultValue: 2,
      type: "number",
      onChange: function onChange(e) {
        setDecimalPlace(parseInt(e.target.value, 10));
      }
    })), /* @__PURE__ */ React.createElement("div", {
      className: "format-list"
    }, toolbarFormat.map(function(v2, index2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "listBox".concat(index2 === selectedFormatIndex ? " on" : ""),
        key: v2.name,
        onClick: function onClick() {
          setSelectedFormatIndex(index2);
        }
      }, /* @__PURE__ */ React.createElement("div", null, v2.name), /* @__PURE__ */ React.createElement("div", null, v2.value));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-dialog-box-button-container",
      style: type === "currency" ? {
        marginTop: 40
      } : {
        marginTop: 30
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-primary",
      onClick: onConfirm
    }, button.confirm), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-message-box-button button-default",
      onClick: onCancel
    }, button.cancel)));
  };
  var Toolbar = function Toolbar2(_ref) {
    var _context$luckysheet_s, _flowdata$row, _settings$customToolb;
    var setMoreItems = _ref.setMoreItems, moreItemsOpen = _ref.moreItemsOpen;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs, settings = _useContext.settings, handleUndo = _useContext.handleUndo, handleRedo = _useContext.handleRedo;
    var contextRef = reactExports.useRef(context);
    var containerRef = reactExports.useRef(null);
    var _useState = reactExports.useState(-1), _useState2 = _slicedToArray(_useState, 2), toolbarWrapIndex = _useState2[0], setToolbarWrapIndex = _useState2[1];
    var _useState3 = reactExports.useState([]), _useState4 = _slicedToArray(_useState3, 2), itemLocations = _useState4[0], setItemLocations = _useState4[1];
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog, hideDialog = _useDialog.hideDialog;
    var firstSelection = (_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s[0];
    var flowdata = getFlowdata(context);
    contextRef.current = context;
    var row = firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.row_focus;
    var col = firstSelection === null || firstSelection === void 0 ? void 0 : firstSelection.column_focus;
    var cell = flowdata && row != null && col != null ? flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$row = flowdata[row]) === null || _flowdata$row === void 0 ? void 0 : _flowdata$row[col] : void 0;
    var _locale = locale(context), toolbar = _locale.toolbar, merge = _locale.merge, border = _locale.border, freezen = _locale.freezen, defaultFmt = _locale.defaultFmt, formula = _locale.formula, sort = _locale.sort, align = _locale.align, textWrap = _locale.textWrap, rotation = _locale.rotation, screenshot = _locale.screenshot, filter = _locale.filter, splitText = _locale.splitText, findAndReplace = _locale.findAndReplace, comment = _locale.comment, fontarray = _locale.fontarray;
    var toolbarFormat = locale(context).format;
    var sheetWidth = context.luckysheetTableContentHW[0];
    var _useState5 = reactExports.useState("#000000"), _useState6 = _slicedToArray(_useState5, 2), customColor = _useState6[0], setcustomColor = _useState6[1];
    var _useState7 = reactExports.useState("1"), _useState8 = _slicedToArray(_useState7, 2), customStyle = _useState8[0], setcustomStyle = _useState8[1];
    var showSubMenu = reactExports.useCallback(function(e, className) {
      var target = e.target;
      var menuItem = target.className === "fortune-toolbar-menu-line" ? target.parentElement : target;
      var menuItemRect = menuItem.getBoundingClientRect();
      var workbookContainerRect = refs.workbookContainer.current.getBoundingClientRect();
      var subMenu = menuItem.querySelector(".".concat(className));
      if (_$1.isNil(subMenu)) return;
      var menuItemStyle = window.getComputedStyle(menuItem);
      var menuItemPaddingRight = parseFloat(menuItemStyle.getPropertyValue("padding-right").replace("px", ""));
      if (workbookContainerRect.right - menuItemRect.right < parseFloat(subMenu.style.width.replace("px", ""))) {
        subMenu.style.display = "block";
        subMenu.style.right = "".concat(menuItemRect.width - menuItemPaddingRight, "px");
      } else {
        subMenu.style.display = "block";
        subMenu.style.right = className === "more-format" ? "".concat(-(parseFloat(subMenu.style.width.replace("px", "")) + 0), "px") : "".concat(-(parseFloat(subMenu.style.width.replace("px", "")) + menuItemPaddingRight), "px");
      }
    }, [refs.workbookContainer]);
    var hideSubMenu = reactExports.useCallback(function(e, className) {
      var target = e.target;
      if (target.className === "".concat(className)) {
        target.style.display = "none";
        return;
      }
      var subMenu = target.className === "condition-format-item" ? target.parentElement : target.querySelector(".".concat(className));
      if (_$1.isNil(subMenu)) return;
      subMenu.style.display = "none";
    }, []);
    reactExports.useEffect(function() {
      setToolbarWrapIndex(-1);
    }, [settings.toolbarItems, settings.customToolbarItems]);
    reactExports.useEffect(function() {
      if (toolbarWrapIndex === -1) {
        var container = containerRef.current;
        if (!container) return;
        var items = container.querySelectorAll(".fortune-toolbar-item");
        if (!items) return;
        var locations = [];
        var containerRect = container.getBoundingClientRect();
        for (var i2 = 0; i2 < items.length; i2 += 1) {
          var item = items[i2];
          var itemRect = item.getBoundingClientRect();
          locations.push(itemRect.left - containerRect.left + itemRect.width);
        }
        setItemLocations(locations);
      }
    }, [toolbarWrapIndex, sheetWidth]);
    reactExports.useEffect(function() {
      if (itemLocations.length === 0) return;
      var container = containerRef.current;
      if (!container) return;
      var moreButtonWidth = 50;
      for (var i2 = itemLocations.length - 1; i2 >= 0; i2 -= 1) {
        var loc = itemLocations[i2];
        if (loc + moreButtonWidth < container.clientWidth) {
          setToolbarWrapIndex(i2 - itemLocations.length + settings.toolbarItems.length);
          if (i2 === itemLocations.length - 1) {
            setMoreItems(null);
          }
          break;
        }
      }
    }, [itemLocations, setMoreItems, settings.toolbarItems.length, sheetWidth]);
    var getToolbarItem = reactExports.useCallback(function(name, i2) {
      var _toolbarItemSelectedF;
      var tooltip = toolbar[name];
      if (name === "|") {
        return /* @__PURE__ */ React.createElement(Divider, {
          key: i2
        });
      }
      if (["font-color", "background"].includes(name)) {
        var pick = function pick2(color) {
          setContext(function(draftCtx) {
            return (name === "font-color" ? handleTextColor : handleTextBackground)(draftCtx, refs.cellInput.current, color);
          });
          if (name === "font-color") {
            refs.globalCache.recentTextColor = color;
          } else {
            refs.globalCache.recentBackgroundColor = color;
          }
        };
        return /* @__PURE__ */ React.createElement("div", {
          style: {
            position: "relative"
          },
          key: name
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            width: 17,
            height: 2,
            backgroundColor: name === "font-color" ? refs.globalCache.recentTextColor : refs.globalCache.recentBackgroundColor,
            position: "absolute",
            bottom: 8,
            left: 9,
            zIndex: 100
          }
        }), /* @__PURE__ */ React.createElement(Combo, {
          iconId: name,
          tooltip,
          onClick: function onClick() {
            var color = name === "font-color" ? refs.globalCache.recentTextColor : refs.globalCache.recentBackgroundColor;
            if (color) pick(color);
          }
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(CustomColor, {
            onCustomPick: function onCustomPick(color) {
              pick(color);
              setOpen(false);
            },
            onColorPick: pick
          });
        }));
      }
      if (name === "format") {
        var currentFmt = defaultFmt[0].text;
        if (cell) {
          var curr = normalizedCellAttr(cell, "ct");
          var format = _$1.find(defaultFmt, function(v2) {
            return v2.value === (curr === null || curr === void 0 ? void 0 : curr.fa);
          });
          if ((curr === null || curr === void 0 ? void 0 : curr.fa) != null) {
            if (format != null) {
              currentFmt = format.text;
            } else {
              currentFmt = defaultFmt[defaultFmt.length - 1].text;
            }
          }
        }
        return /* @__PURE__ */ React.createElement(Combo, {
          text: currentFmt,
          key: name,
          tooltip
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, defaultFmt.map(function(_ref2, ii2) {
            var text2 = _ref2.text, value = _ref2.value, example = _ref2.example;
            if (value === "split") {
              return /* @__PURE__ */ React.createElement(MenuDivider, {
                key: ii2
              });
            }
            if (value === "fmtOtherSelf") {
              return /* @__PURE__ */ React.createElement(Option, {
                key: value,
                onMouseEnter: function onMouseEnter(e) {
                  return showSubMenu(e, "more-format");
                },
                onMouseLeave: function onMouseLeave(e) {
                  return hideSubMenu(e, "more-format");
                }
              }, /* @__PURE__ */ React.createElement("div", {
                className: "fortune-toolbar-menu-line"
              }, /* @__PURE__ */ React.createElement("div", null, text2), /* @__PURE__ */ React.createElement(SVGIcon, {
                name: "rightArrow",
                width: 14
              })), /* @__PURE__ */ React.createElement("div", {
                className: "more-format toolbar-item-sub-menu",
                style: {
                  display: "none",
                  width: 150,
                  bottom: 10,
                  top: void 0
                }
              }, [{
                text: toolbarFormat.moreCurrency,
                onclick: function onclick() {
                  showDialog(/* @__PURE__ */ React.createElement(FormatSearch, {
                    onCancel: hideDialog,
                    type: "currency"
                  }));
                  setOpen(false);
                }
              }].map(function(v2) {
                return /* @__PURE__ */ React.createElement("div", {
                  className: "set-background-item",
                  key: v2.text,
                  onClick: function onClick() {
                    v2.onclick();
                    setOpen(false);
                  }
                }, v2.text);
              })));
            }
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setOpen(false);
                setContext(function(ctx) {
                  var d2 = getFlowdata(ctx);
                  if (d2 == null) return;
                  updateFormat(ctx, refs.cellInput.current, d2, "ct", value);
                });
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, /* @__PURE__ */ React.createElement("div", null, text2), /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-subtext"
            }, example)));
          }));
        });
      }
      if (name === "font") {
        var current = fontarray[0];
        if ((cell === null || cell === void 0 ? void 0 : cell.ff) != null) {
          if (_$1.isNumber(cell.ff)) {
            current = fontarray[cell.ff];
          } else {
            current = cell.ff;
          }
        }
        return /* @__PURE__ */ React.createElement(Combo, {
          text: current,
          key: name,
          tooltip
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, fontarray.map(function(o2) {
            return /* @__PURE__ */ React.createElement(Option, {
              key: o2,
              onClick: function onClick() {
                setContext(function(ctx) {
                  current = o2;
                  var d2 = getFlowdata(ctx);
                  if (!d2) return;
                  updateFormat(ctx, refs.cellInput.current, d2, "ff", o2);
                });
                setOpen(false);
              }
            }, o2);
          }));
        });
      }
      if (name === "font-size") {
        return /* @__PURE__ */ React.createElement(Combo, {
          text: cell ? normalizedCellAttr(cell, "fs", context.defaultFontSize) : context.defaultFontSize.toString(),
          key: name,
          tooltip
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, [9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72].map(function(num) {
            return /* @__PURE__ */ React.createElement(Option, {
              key: num,
              onClick: function onClick() {
                setContext(function(draftContext) {
                  return handleTextSize(draftContext, refs.cellInput.current, num, refs.canvas.current.getContext("2d"));
                });
                setOpen(false);
              }
            }, num);
          }));
        });
      }
      if (name === "horizontal-align") {
        var _$find;
        var items = [{
          title: "align-left",
          text: align.left,
          value: 1
        }, {
          title: "align-center",
          text: align.center,
          value: 0
        }, {
          title: "align-right",
          text: align.right,
          value: 2
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: ((_$find = _$1.find(items, function(item) {
            return "".concat(item.value) === "".concat(cell === null || cell === void 0 ? void 0 : cell.ht);
          })) === null || _$find === void 0 ? void 0 : _$find.title) || "align-left",
          key: name,
          tooltip: toolbar.horizontalAlign
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, items.map(function(_ref3) {
            var text2 = _ref3.text, title = _ref3.title;
            return /* @__PURE__ */ React.createElement(Option, {
              key: title,
              onClick: function onClick() {
                setContext(function(ctx) {
                  handleHorizontalAlign(ctx, refs.cellInput.current, title.replace("align-", ""));
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: title
            })));
          }));
        });
      }
      if (name === "vertical-align") {
        var _$find2;
        var _items = [{
          title: "align-top",
          text: align.top,
          value: 1
        }, {
          title: "align-middle",
          text: align.middle,
          value: 0
        }, {
          title: "align-bottom",
          text: align.bottom,
          value: 2
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: ((_$find2 = _$1.find(_items, function(item) {
            return "".concat(item.value) === "".concat(cell === null || cell === void 0 ? void 0 : cell.vt);
          })) === null || _$find2 === void 0 ? void 0 : _$find2.title) || "align-top",
          key: name,
          tooltip: toolbar.verticalAlign
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items.map(function(_ref4) {
            var text2 = _ref4.text, title = _ref4.title;
            return /* @__PURE__ */ React.createElement(Option, {
              key: title,
              onClick: function onClick() {
                setContext(function(ctx) {
                  handleVerticalAlign(ctx, refs.cellInput.current, title.replace("align-", ""));
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: title
            })));
          }));
        });
      }
      if (name === "undo") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip,
          key: name,
          disabled: refs.globalCache.undoList.length === 0,
          onClick: function onClick() {
            return handleUndo();
          }
        });
      }
      if (name === "redo") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip,
          key: name,
          disabled: refs.globalCache.redoList.length === 0,
          onClick: function onClick() {
            return handleRedo();
          }
        });
      }
      if (name === "screenshot") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip,
          key: name,
          onClick: function onClick() {
            var imgsrc = handleScreenShot(contextRef.current);
            if (imgsrc) {
              showDialog(/* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", null, screenshot.screenshotTipSuccess), /* @__PURE__ */ React.createElement("img", {
                src: imgsrc,
                alt: "",
                style: {
                  maxWidth: "100%",
                  maxHeight: "100%"
                }
              })));
            }
          }
        });
      }
      if (name === "splitColumn") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip,
          key: name,
          onClick: function onClick() {
            if (context.allowEdit === false) return;
            if (_$1.isUndefined(context.luckysheet_select_save)) {
              showDialog(splitText.tipNoSelect, "ok");
            } else {
              var currentColumn = context.luckysheet_select_save[context.luckysheet_select_save.length - 1].column;
              if (context.luckysheet_select_save.length > 1) {
                showDialog(splitText.tipNoMulti, "ok");
              } else if (currentColumn[0] !== currentColumn[1]) {
                showDialog(splitText.tipNoMultiColumn, "ok");
              } else {
                showDialog(/* @__PURE__ */ React.createElement(SplitColumn, null));
              }
            }
          }
        });
      }
      if (name === "dataVerification") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip,
          key: name,
          onClick: function onClick() {
            if (context.allowEdit === false) return;
            showDialog(/* @__PURE__ */ React.createElement(DataVerification, null));
          }
        });
      }
      if (name === "locationCondition") {
        var _items2 = [{
          text: findAndReplace.location,
          value: "location"
        }, {
          text: findAndReplace.locationFormula,
          value: "locationFormula"
        }, {
          text: findAndReplace.locationDate,
          value: "locationDate"
        }, {
          text: findAndReplace.locationDigital,
          value: "locationDigital"
        }, {
          text: findAndReplace.locationString,
          value: "locationString"
        }, {
          text: findAndReplace.locationError,
          value: "locationError"
        }, {
          text: findAndReplace.locationRowSpan,
          value: "locationRowSpan"
        }, {
          text: findAndReplace.columnSpan,
          value: "locationColumnSpan"
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "locationCondition",
          key: name,
          tooltip: findAndReplace.location
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items2.map(function(_ref5) {
            var text2 = _ref5.text, value = _ref5.value;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                var _context$luckysheet_s2, _context$luckysheet_s3;
                if (context.luckysheet_select_save == null) {
                  showDialog(freezen.noSeletionError, "ok");
                  return;
                }
                var last2 = context.luckysheet_select_save[0];
                var range;
                var rangeArr = [];
                if (((_context$luckysheet_s2 = context.luckysheet_select_save) === null || _context$luckysheet_s2 === void 0 ? void 0 : _context$luckysheet_s2.length) === 0 || ((_context$luckysheet_s3 = context.luckysheet_select_save) === null || _context$luckysheet_s3 === void 0 ? void 0 : _context$luckysheet_s3.length) === 1 && last2.row[0] === last2.row[1] && last2.column[0] === last2.column[1]) {
                  range = [{
                    row: [0, flowdata.length - 1],
                    column: [0, flowdata[0].length - 1]
                  }];
                } else {
                  range = _$1.assignIn([], context.luckysheet_select_save);
                }
                if (value === "location") {
                  showDialog(/* @__PURE__ */ React.createElement(LocationCondition, null));
                } else if (value === "locationFormula") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationFormula", "all", ctx);
                  });
                } else if (value === "locationDate") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationConstant", "d", ctx);
                  });
                } else if (value === "locationDigital") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationConstant", "n", ctx);
                  });
                } else if (value === "locationString") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationConstant", "s,g", ctx);
                  });
                } else if (value === "locationError") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationConstant", "e", ctx);
                  });
                } else if (value === "locationCondition") {
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationCF", void 0, ctx);
                  });
                } else if (value === "locationRowSpan") {
                  var _context$luckysheet_s4, _context$luckysheet_s5;
                  if (((_context$luckysheet_s4 = context.luckysheet_select_save) === null || _context$luckysheet_s4 === void 0 ? void 0 : _context$luckysheet_s4.length) === 0 || ((_context$luckysheet_s5 = context.luckysheet_select_save) === null || _context$luckysheet_s5 === void 0 ? void 0 : _context$luckysheet_s5.length) === 1 && context.luckysheet_select_save[0].row[0] === context.luckysheet_select_save[0].row[1]) {
                    showDialog(findAndReplace.locationTiplessTwoRow, "ok");
                    return;
                  }
                  range = _$1.assignIn([], context.luckysheet_select_save);
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationRowSpan", void 0, ctx);
                  });
                } else if (value === "locationColumnSpan") {
                  var _context$luckysheet_s6, _context$luckysheet_s7;
                  if (((_context$luckysheet_s6 = context.luckysheet_select_save) === null || _context$luckysheet_s6 === void 0 ? void 0 : _context$luckysheet_s6.length) === 0 || ((_context$luckysheet_s7 = context.luckysheet_select_save) === null || _context$luckysheet_s7 === void 0 ? void 0 : _context$luckysheet_s7.length) === 1 && context.luckysheet_select_save[0].column[0] === context.luckysheet_select_save[0].column[1]) {
                    showDialog(findAndReplace.locationTiplessTwoColumn, "ok");
                    return;
                  }
                  range = _$1.assignIn([], context.luckysheet_select_save);
                  setContext(function(ctx) {
                    rangeArr = applyLocation(range, "locationColumnSpan", void 0, ctx);
                  });
                }
                if (rangeArr.length === 0 && value !== "location") showDialog(findAndReplace.locationTipNotFindCell, "ok");
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2));
          }));
        });
      }
      if (name === "conditionFormat") {
        var _items3 = ["highlightCellRules", "itemSelectionRules", "-", "deleteRule"];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "conditionFormat",
          key: name,
          tooltip: toolbar.conditionalFormat
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(ConditionalFormat, {
            items: _items3,
            setOpen
          });
        });
      }
      if (name === "image") {
        return /* @__PURE__ */ React.createElement(Button, {
          iconId: name,
          tooltip: toolbar.insertImage,
          key: name,
          onClick: function onClick() {
            if (context.allowEdit === false) return;
            showImgChooser();
          }
        }, /* @__PURE__ */ React.createElement("input", {
          id: "fortune-img-upload",
          type: "file",
          accept: "image/*",
          style: {
            display: "none"
          },
          onChange: function onChange(e) {
            var _e$currentTarget$file;
            var file = (_e$currentTarget$file = e.currentTarget.files) === null || _e$currentTarget$file === void 0 ? void 0 : _e$currentTarget$file[0];
            if (!file) return;
            var render = new FileReader();
            render.readAsDataURL(file);
            render.onload = function(event) {
              var _event$target;
              if (event.target == null) return;
              var src = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;
              var image = new Image();
              image.onload = function() {
                setContext(function(draftCtx) {
                  insertImage(draftCtx, image);
                });
              };
              image.src = src;
            };
            e.currentTarget.value = "";
          }
        }));
      }
      if (name === "comment") {
        var _context$luckysheet_s8, _flowdata$row_index, _flowdata$row_index$c;
        var last = (_context$luckysheet_s8 = context.luckysheet_select_save) === null || _context$luckysheet_s8 === void 0 ? void 0 : _context$luckysheet_s8[context.luckysheet_select_save.length - 1];
        var row_index = last === null || last === void 0 ? void 0 : last.row_focus;
        var col_index = last === null || last === void 0 ? void 0 : last.column_focus;
        if (!last) {
          row_index = 0;
          col_index = 0;
        } else {
          if (row_index == null) {
            var _last$row = _slicedToArray(last.row, 1);
            row_index = _last$row[0];
          }
          if (col_index == null) {
            var _last$column = _slicedToArray(last.column, 1);
            col_index = _last$column[0];
          }
        }
        var itemData;
        if ((flowdata === null || flowdata === void 0 ? void 0 : (_flowdata$row_index = flowdata[row_index]) === null || _flowdata$row_index === void 0 ? void 0 : (_flowdata$row_index$c = _flowdata$row_index[col_index]) === null || _flowdata$row_index$c === void 0 ? void 0 : _flowdata$row_index$c.ps) != null) {
          itemData = [{
            key: "edit",
            text: comment.edit,
            onClick: editComment
          }, {
            key: "delete",
            text: comment.delete,
            onClick: deleteComment
          }, {
            key: "showOrHide",
            text: comment.showOne,
            onClick: showHideComment
          }, {
            key: "showOrHideAll",
            text: comment.showAll,
            onClick: showHideAllComments
          }];
        } else {
          itemData = [{
            key: "new",
            text: comment.insert,
            onClick: newComment
          }, {
            key: "showOrHideAll",
            text: comment.showAll,
            onClick: showHideAllComments
          }];
        }
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: name,
          key: name,
          tooltip
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, itemData.map(function(_ref6) {
            var key = _ref6.key, text2 = _ref6.text, _onClick = _ref6.onClick;
            return /* @__PURE__ */ React.createElement(Option, {
              key,
              onClick: function onClick() {
                setContext(function(draftContext) {
                  return _onClick(draftContext, refs.globalCache, row_index, col_index);
                });
                setOpen(false);
              }
            }, text2);
          }));
        });
      }
      if (name === "quick-formula") {
        var _itemData = [{
          text: formula.sum,
          value: "SUM"
        }, {
          text: formula.average,
          value: "AVERAGE"
        }, {
          text: formula.count,
          value: "COUNT"
        }, {
          text: formula.max,
          value: "MAX"
        }, {
          text: formula.min,
          value: "MIN"
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "formula-sum",
          key: name,
          tooltip: toolbar.autoSum,
          onClick: function onClick() {
            return setContext(function(ctx) {
              handleSum(ctx, refs.cellInput.current, refs.fxInput.current, refs.globalCache);
            });
          }
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _itemData.map(function(_ref7) {
            var value = _ref7.value, text2 = _ref7.text;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  autoSelectionFormula(ctx, refs.cellInput.current, refs.fxInput.current, value, refs.globalCache);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, /* @__PURE__ */ React.createElement("div", null, text2), /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-subtext"
            }, value)));
          }), /* @__PURE__ */ React.createElement(MenuDivider, null), /* @__PURE__ */ React.createElement(Option, {
            key: "formula",
            onClick: function onClick() {
              showDialog(/* @__PURE__ */ React.createElement(FormulaSearch$1, {
                onCancel: hideDialog
              }));
              setOpen(false);
            }
          }, "".concat(formula.find, "...")));
        });
      }
      if (name === "merge-cell") {
        var itemdata = [{
          text: merge.mergeAll,
          value: "merge-all"
        }, {
          text: merge.mergeV,
          value: "merge-vertical"
        }, {
          text: merge.mergeH,
          value: "merge-horizontal"
        }, {
          text: merge.mergeCancel,
          value: "merge-cancel"
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "merge-all",
          key: name,
          tooltip,
          text: "合并单元格",
          onClick: function onClick() {
            return setContext(function(ctx) {
              handleMerge(ctx, "merge-all");
            });
          }
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, itemdata.map(function(_ref8) {
            var text2 = _ref8.text, value = _ref8.value;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  handleMerge(ctx, value);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: value,
              style: {
                marginRight: 4
              }
            }), text2));
          }));
        });
      }
      if (name === "border") {
        var _items4 = [{
          text: border.borderTop,
          value: "border-top"
        }, {
          text: border.borderBottom,
          value: "border-bottom"
        }, {
          text: border.borderLeft,
          value: "border-left"
        }, {
          text: border.borderRight,
          value: "border-right"
        }, {
          text: "",
          value: "divider"
        }, {
          text: border.borderNone,
          value: "border-none"
        }, {
          text: border.borderAll,
          value: "border-all"
        }, {
          text: border.borderOutside,
          value: "border-outside"
        }, {
          text: "",
          value: "divider"
        }, {
          text: border.borderInside,
          value: "border-inside"
        }, {
          text: border.borderHorizontal,
          value: "border-horizontal"
        }, {
          text: border.borderVertical,
          value: "border-vertical"
        }, {
          text: border.borderSlash,
          value: "border-slash"
        }, {
          text: "",
          value: "divider"
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "border-all",
          key: name,
          tooltip,
          text: "边框设置",
          onClick: function onClick() {
            return setContext(function(ctx) {
              handleBorder(ctx, "border-all", customColor, customStyle);
            });
          }
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items4.map(function(_ref9, ii2) {
            var text2 = _ref9.text, value = _ref9.value;
            return value !== "divider" ? /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  handleBorder(ctx, value, customColor, customStyle);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: value
            }))) : /* @__PURE__ */ React.createElement(MenuDivider, {
              key: ii2
            });
          }), /* @__PURE__ */ React.createElement(CustomBorder, {
            onPick: function onPick(color, style) {
              setcustomColor(color);
              setcustomStyle(style);
            }
          }));
        });
      }
      if (name === "freeze") {
        var _items5 = [{
          text: freezen.freezenRowRange,
          value: "freeze-row"
        }, {
          text: freezen.freezenColumnRange,
          value: "freeze-col"
        }, {
          text: freezen.freezenRCRange,
          value: "freeze-row-col"
        }, {
          text: freezen.freezenCancel,
          value: "freeze-cancel"
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "freeze-row-col",
          key: name,
          tooltip,
          onClick: function onClick() {
            return setContext(function(ctx) {
              handleFreeze(ctx, "freeze-row-col");
            });
          }
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items5.map(function(_ref10) {
            var text2 = _ref10.text, value = _ref10.value;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  handleFreeze(ctx, value);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: value
            })));
          }));
        });
      }
      if (name === "text-wrap") {
        var _items6 = [{
          text: textWrap.clip,
          iconId: "text-clip",
          value: "clip"
        }, {
          text: textWrap.overflow,
          iconId: "text-overflow",
          value: "overflow"
        }, {
          text: textWrap.wrap,
          iconId: "text-wrap",
          value: "wrap"
        }];
        var _curr = _items6[0];
        if ((cell === null || cell === void 0 ? void 0 : cell.tb) != null) {
          _curr = _$1.get(_items6, cell.tb);
        }
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: _curr.iconId,
          key: name,
          tooltip: toolbar.textWrap
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items6.map(function(_ref11) {
            var text2 = _ref11.text, iconId = _ref11.iconId, value = _ref11.value;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  var d2 = getFlowdata(ctx);
                  if (d2 == null) return;
                  updateFormat(ctx, refs.cellInput.current, d2, "tb", value);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: iconId
            })));
          }));
        });
      }
      if (name === "text-rotation") {
        var _items7 = [{
          text: rotation.none,
          iconId: "text-rotation-none",
          value: "none"
        }, {
          text: rotation.angleup,
          iconId: "text-rotation-angleup",
          value: "angleup"
        }, {
          text: rotation.angledown,
          iconId: "text-rotation-angledown",
          value: "angledown"
        }, {
          text: rotation.vertical,
          iconId: "text-rotation-vertical",
          value: "vertical"
        }, {
          text: rotation.rotationUp,
          iconId: "text-rotation-up",
          value: "rotation-up"
        }, {
          text: rotation.rotationDown,
          iconId: "text-rotation-down",
          value: "rotation-down"
        }];
        var _curr2 = _items7[0];
        if ((cell === null || cell === void 0 ? void 0 : cell.tr) != null) {
          _curr2 = _$1.get(_items7, cell.tr);
        }
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: _curr2.iconId,
          key: name,
          tooltip: toolbar.textRotate
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items7.map(function(_ref12) {
            var text2 = _ref12.text, iconId = _ref12.iconId, value = _ref12.value;
            return /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                setContext(function(ctx) {
                  var d2 = getFlowdata(ctx);
                  if (d2 == null) return;
                  updateFormat(ctx, refs.cellInput.current, d2, "tr", value);
                });
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: iconId
            })));
          }));
        });
      }
      if (name === "filter") {
        var _items8 = [{
          iconId: "sort-asc",
          value: "sort-asc",
          text: sort.asc,
          onClick: function onClick() {
            setContext(function(ctx) {
              handleSort(ctx, true);
            });
          }
        }, {
          iconId: "sort-desc",
          value: "sort-desc",
          text: sort.desc,
          onClick: function onClick() {
            setContext(function(ctx) {
              handleSort(ctx, false);
            });
          }
        }, {
          iconId: "",
          value: "divider"
        }, {
          iconId: "filter1",
          value: "filter",
          text: filter.filter,
          onClick: function onClick() {
            return setContext(function(draftCtx) {
              createFilter(draftCtx);
            });
          }
        }, {
          iconId: "eraser",
          value: "eraser",
          text: filter.clearFilter,
          onClick: function onClick() {
            return setContext(function(draftCtx) {
              clearFilter(draftCtx);
            });
          }
        }];
        return /* @__PURE__ */ React.createElement(Combo, {
          iconId: "filter",
          key: name,
          tooltip: toolbar.sortAndFilter
        }, function(setOpen) {
          return /* @__PURE__ */ React.createElement(Select, null, _items8.map(function(_ref13, index2) {
            var text2 = _ref13.text, iconId = _ref13.iconId, value = _ref13.value, _onClick2 = _ref13.onClick;
            return value !== "divider" ? /* @__PURE__ */ React.createElement(Option, {
              key: value,
              onClick: function onClick() {
                _onClick2 === null || _onClick2 === void 0 ? void 0 : _onClick2();
                setOpen(false);
              }
            }, /* @__PURE__ */ React.createElement("div", {
              className: "fortune-toolbar-menu-line"
            }, text2, /* @__PURE__ */ React.createElement(SVGIcon, {
              name: iconId
            }))) : /* @__PURE__ */ React.createElement(MenuDivider, {
              key: "divider-".concat(index2)
            });
          }));
        });
      }
      return /* @__PURE__ */ React.createElement(Button, {
        iconId: name,
        tooltip,
        key: name,
        selected: (_toolbarItemSelectedF = toolbarItemSelectedFunc(name)) === null || _toolbarItemSelectedF === void 0 ? void 0 : _toolbarItemSelectedF(cell),
        onClick: function onClick() {
          return setContext(function(draftCtx) {
            var _toolbarItemClickHand;
            (_toolbarItemClickHand = toolbarItemClickHandler(name)) === null || _toolbarItemClickHand === void 0 ? void 0 : _toolbarItemClickHand(draftCtx, refs.cellInput.current, refs.globalCache);
          });
        }
      });
    }, [toolbar, cell, setContext, refs.cellInput, refs.fxInput, refs.globalCache, defaultFmt, align, handleUndo, handleRedo, flowdata, formula, showDialog, hideDialog, merge, border, freezen, screenshot, sort, textWrap, rotation, filter, splitText, findAndReplace, context.luckysheet_select_save, context.defaultFontSize, context.allowEdit, comment, fontarray, hideSubMenu, showSubMenu, refs.canvas, customColor, customStyle, toolbarFormat.moreCurrency]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "fortune-toolbar"
    }, settings.customToolbarItems.map(function(n2) {
      return /* @__PURE__ */ React.createElement(CustomButton, {
        tooltip: n2.tooltip,
        onClick: n2.onClick,
        key: n2.key,
        icon: n2.icon,
        iconName: n2.iconName
      }, n2.children);
    }), ((_settings$customToolb = settings.customToolbarItems) === null || _settings$customToolb === void 0 ? void 0 : _settings$customToolb.length) > 0 ? /* @__PURE__ */ React.createElement(Divider, {
      key: "customDivider"
    }) : null, (toolbarWrapIndex === -1 ? settings.toolbarItems : settings.toolbarItems.slice(0, toolbarWrapIndex + 1)).map(function(name, i2) {
      return getToolbarItem(name, i2);
    }), toolbarWrapIndex !== -1 && toolbarWrapIndex < settings.toolbarItems.length - 1 ? /* @__PURE__ */ React.createElement(Button, {
      iconId: "more",
      tooltip: toolbar.toolMore,
      onClick: function onClick() {
        if (moreItemsOpen) {
          setMoreItems(null);
        } else {
          setMoreItems(settings.toolbarItems.slice(toolbarWrapIndex + 1).map(function(name, i2) {
            return getToolbarItem(name, i2);
          }));
        }
      }
    }) : null);
  };
  var LocationBox = function LocationBox2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context;
    var rangeText = reactExports.useMemo(function() {
      var lastSelection = _$1.last(context.luckysheet_select_save);
      if (!(lastSelection && lastSelection.row_focus != null && lastSelection.column_focus != null)) return "";
      var rf2 = lastSelection.row_focus;
      var cf2 = lastSelection.column_focus;
      if (context.config.merge != null && "".concat(rf2, "_").concat(cf2) in context.config.merge) {
        return getRangetxt(context, context.currentSheetId, {
          column: [cf2, cf2],
          row: [rf2, rf2]
        });
      }
      return getRangetxt(context, context.currentSheetId, lastSelection);
    }, [context.currentSheetId, context.luckysheet_select_save]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-name-box-container"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-name-box",
      tabIndex: 0,
      dir: "ltr",
      "aria-autocomplete": "list"
    }, rangeText));
  };
  var FxEditor = function FxEditor2() {
    var _context$luckysheet_s, _context$luckysheet_s4;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
    var lastKeyDownEventRef = reactExports.useRef();
    var inputContainerRef = reactExports.useRef(null);
    var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), isHidenRC = _useState4[0], setIsHidenRC = _useState4[1];
    var firstSelection = (_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s[0];
    var prevFirstSelection = usePrevious(firstSelection);
    var prevSheetId = usePrevious(context.currentSheetId);
    var recentText = reactExports.useRef("");
    reactExports.useEffect(function() {
      setIsHidenRC(isShowHidenCR(context));
      if (_$1.isEqual(prevFirstSelection, firstSelection) && context.currentSheetId === prevSheetId) {
        return;
      }
      var d2 = getFlowdata(context);
      var value = "";
      if (firstSelection) {
        var _d$r;
        var r2 = firstSelection.row_focus;
        var c2 = firstSelection.column_focus;
        if (_$1.isNil(r2) || _$1.isNil(c2)) return;
        var cell = d2 === null || d2 === void 0 ? void 0 : (_d$r = d2[r2]) === null || _d$r === void 0 ? void 0 : _d$r[c2];
        if (cell) {
          if (isInlineStringCell(cell)) {
            value = getInlineStringNoStyle(r2, c2, d2);
          } else if (cell.f) {
            value = getCellValue(r2, c2, d2, "f");
          } else {
            value = valueShowEs(r2, c2, d2);
          }
        }
        refs.fxInput.current.innerHTML = escapeHTMLTag(escapeScriptTag(value));
      } else {
        refs.fxInput.current.innerHTML = "";
      }
    }, [context.luckysheetfile, context.currentSheetId, context.luckysheet_select_save]);
    var onFocus = reactExports.useCallback(function() {
      var _context$luckysheet_s2, _context$luckysheet_s3;
      if (context.allowEdit === false) {
        return;
      }
      if (((_context$luckysheet_s2 = (_context$luckysheet_s3 = context.luckysheet_select_save) === null || _context$luckysheet_s3 === void 0 ? void 0 : _context$luckysheet_s3.length) !== null && _context$luckysheet_s2 !== void 0 ? _context$luckysheet_s2 : 0) > 0 && !context.luckysheet_cell_selected_move) {
        setFocused(true);
        setContext(function(draftCtx) {
          var last = draftCtx.luckysheet_select_save[draftCtx.luckysheet_select_save.length - 1];
          var row_index = last.row_focus;
          var col_index = last.column_focus;
          draftCtx.luckysheetCellUpdate = [row_index, col_index];
          refs.globalCache.doNotFocus = true;
        });
      }
    }, [context.allowEdit, context.luckysheet_cell_selected_move, (_context$luckysheet_s4 = context.luckysheet_select_save) === null || _context$luckysheet_s4 === void 0 ? void 0 : _context$luckysheet_s4.length, refs.globalCache, setContext]);
    var onKeyDown = reactExports.useCallback(function(e) {
      if (context.allowEdit === false) {
        return;
      }
      lastKeyDownEventRef.current = new KeyboardEvent(e.type, e.nativeEvent);
      var key = e.key;
      recentText.current = refs.fxInput.current.innerText;
      if (key === "ArrowLeft" || key === "ArrowRight") {
        e.stopPropagation();
      }
      setContext(function(draftCtx) {
        if (context.luckysheetCellUpdate.length > 0) {
          switch (key) {
            case "Enter": {
              var lastCellUpdate = _$1.clone(draftCtx.luckysheetCellUpdate);
              updateCell(draftCtx, draftCtx.luckysheetCellUpdate[0], draftCtx.luckysheetCellUpdate[1], refs.fxInput.current);
              draftCtx.luckysheet_select_save = [{
                row: [lastCellUpdate[0], lastCellUpdate[0]],
                column: [lastCellUpdate[1], lastCellUpdate[1]],
                row_focus: lastCellUpdate[0],
                column_focus: lastCellUpdate[1]
              }];
              moveHighlightCell(draftCtx, "down", 1);
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            case "Escape": {
              cancelNormalSelected(draftCtx);
              moveHighlightCell(draftCtx, "down", 0);
              e.preventDefault();
              e.stopPropagation();
              break;
            }
            case "ArrowLeft": {
              rangeHightlightselected(draftCtx, refs.fxInput.current);
              break;
            }
            case "ArrowRight": {
              rangeHightlightselected(draftCtx, refs.fxInput.current);
              break;
            }
          }
        }
      });
    }, [context.allowEdit, context.luckysheetCellUpdate.length, refs.fxInput, setContext]);
    var onChange = reactExports.useCallback(function() {
      var e = lastKeyDownEventRef.current;
      if (!e) return;
      var kcode = e.keyCode;
      if (!kcode) return;
      if (!(kcode >= 112 && kcode <= 123 || kcode <= 46 || kcode === 144 || kcode === 108 || e.ctrlKey || e.altKey || e.shiftKey && (kcode === 37 || kcode === 38 || kcode === 39 || kcode === 40)) || kcode === 8 || kcode === 32 || kcode === 46 || e.ctrlKey && kcode === 86) {
        setContext(function(draftCtx) {
          handleFormulaInput(draftCtx, refs.cellInput.current, refs.fxInput.current, kcode, recentText.current);
        });
      }
    }, [refs.cellInput, refs.fxInput, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-fx-editor"
    }, /* @__PURE__ */ React.createElement(LocationBox, null), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-fx-icon"
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "fx",
      width: 18,
      height: 18
    })), /* @__PURE__ */ React.createElement("div", {
      ref: inputContainerRef,
      className: "fortune-fx-input-container"
    }, /* @__PURE__ */ React.createElement(ContentEditable, {
      innerRef: function innerRef(e) {
        refs.fxInput.current = e;
      },
      className: "fortune-fx-input",
      id: "luckysheet-functionbox-cell",
      "aria-autocomplete": "list",
      onFocus,
      onKeyDown,
      onChange,
      onBlur: function onBlur() {
        return setFocused(false);
      },
      tabIndex: 0,
      allowEdit: context.allowEdit === true ? !isHidenRC : context.allowEdit
    }), focused && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormulaSearch, {
      style: {
        top: inputContainerRef.current.clientHeight
      }
    }), /* @__PURE__ */ React.createElement(FormulaHint, {
      style: {
        top: inputContainerRef.current.clientHeight
      }
    }))));
  };
  var SheetItem = function SheetItem2(_ref) {
    var sheet = _ref.sheet, isDropPlaceholder = _ref.isDropPlaceholder;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), editing = _useState2[0], setEditing = _useState2[1];
    var containerRef = reactExports.useRef(null);
    var editable = reactExports.useRef(null);
    var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), dragOver = _useState4[0], setDragOver = _useState4[1];
    var _useState5 = reactExports.useState("#c3c3c3"), _useState6 = _slicedToArray(_useState5, 2), svgColor = _useState6[0], setSvgColor = _useState6[1];
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert;
    reactExports.useEffect(function() {
      setContext(function(draftCtx) {
        var r2 = context.sheetScrollRecord[draftCtx === null || draftCtx === void 0 ? void 0 : draftCtx.currentSheetId];
        if (r2) {
          var _r$scrollLeft, _r$scrollTop, _r$luckysheet_select_, _r$luckysheet_select_2;
          draftCtx.scrollLeft = (_r$scrollLeft = r2.scrollLeft) !== null && _r$scrollLeft !== void 0 ? _r$scrollLeft : 0;
          draftCtx.scrollTop = (_r$scrollTop = r2.scrollTop) !== null && _r$scrollTop !== void 0 ? _r$scrollTop : 0;
          draftCtx.luckysheet_select_status = (_r$luckysheet_select_ = r2.luckysheet_select_status) !== null && _r$luckysheet_select_ !== void 0 ? _r$luckysheet_select_ : false;
          draftCtx.luckysheet_select_save = (_r$luckysheet_select_2 = r2.luckysheet_select_save) !== null && _r$luckysheet_select_2 !== void 0 ? _r$luckysheet_select_2 : void 0;
        } else {
          draftCtx.scrollLeft = 0;
          draftCtx.scrollTop = 0;
          draftCtx.luckysheet_select_status = false;
          draftCtx.luckysheet_select_save = void 0;
        }
        draftCtx.luckysheet_selection_range = [];
      });
    }, [context.currentSheetId, context.sheetScrollRecord, setContext]);
    reactExports.useEffect(function() {
      if (!editable.current) return;
      if (editing) {
        if (window.getSelection) {
          var range = document.createRange();
          range.selectNodeContents(editable.current);
          if (range.startContainer && document.body.contains(range.startContainer)) {
            var selection = window.getSelection();
            selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
            selection === null || selection === void 0 ? void 0 : selection.addRange(range);
          }
        } else if (document.selection) {
          var _range = document.body.createTextRange();
          _range.moveToElementText(editable.current);
          _range.select();
        }
      }
      editable.current.dataset.oldText = editable.current.innerText;
    }, [editing]);
    var onBlur = reactExports.useCallback(function() {
      setContext(function(draftCtx) {
        try {
          editSheetName(draftCtx, editable.current);
        } catch (e) {
          showAlert(e.message);
        }
      });
      setEditing(false);
    }, [setContext, showAlert]);
    var onKeyDown = reactExports.useCallback(function(e) {
      if (e.key === "Enter") {
        var _editable$current;
        (_editable$current = editable.current) === null || _editable$current === void 0 ? void 0 : _editable$current.blur();
      }
      e.stopPropagation();
    }, []);
    var onDragStart = reactExports.useCallback(function(e) {
      if (context.allowEdit === true) e.dataTransfer.setData("sheetId", "".concat(sheet.id));
      e.stopPropagation();
    }, [context.allowEdit, sheet.id]);
    var onDrop = reactExports.useCallback(function(e) {
      if (context.allowEdit === false) return;
      var draggingId = e.dataTransfer.getData("sheetId");
      setContext(function(draftCtx) {
        var droppingId = sheet.id;
        var draggingSheet;
        var droppingSheet;
        _$1.sortBy(draftCtx.luckysheetfile, ["order"]).forEach(function(f2, i2) {
          f2.order = i2;
          if (f2.id === draggingId) {
            draggingSheet = f2;
          } else if (f2.id === droppingId) {
            droppingSheet = f2;
          }
        });
        if (draggingSheet && droppingSheet) {
          draggingSheet.order = droppingSheet.order - 0.1;
          _$1.sortBy(draftCtx.luckysheetfile, ["order"]).forEach(function(f2, i2) {
            f2.order = i2;
          });
        } else if (draggingSheet && isDropPlaceholder) {
          draggingSheet.order = draftCtx.luckysheetfile.length;
        }
      });
      setDragOver(false);
      e.stopPropagation();
    }, [context.allowEdit, isDropPlaceholder, setContext, sheet.id]);
    return /* @__PURE__ */ React.createElement("div", {
      onDragOver: function onDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
      },
      onDragEnter: function onDragEnter(e) {
        setDragOver(true);
        e.stopPropagation();
      },
      onDragLeave: function onDragLeave(e) {
        setDragOver(false);
        e.stopPropagation();
      },
      onDragEnd: function onDragEnd(e) {
        setDragOver(false);
        e.stopPropagation();
      },
      onDrop,
      onDragStart,
      draggable: context.allowEdit && !editing,
      key: sheet.id,
      ref: containerRef,
      className: isDropPlaceholder ? "fortune-sheettab-placeholder" : "luckysheet-sheets-item".concat(context.currentSheetId === sheet.id ? " luckysheet-sheets-item-active" : ""),
      onClick: function onClick() {
        if (isDropPlaceholder) return;
        setContext(function(draftCtx) {
          draftCtx.sheetScrollRecord[draftCtx.currentSheetId] = {
            scrollLeft: draftCtx.scrollLeft,
            scrollTop: draftCtx.scrollTop,
            luckysheet_select_status: draftCtx.luckysheet_select_status,
            luckysheet_select_save: draftCtx.luckysheet_select_save,
            luckysheet_selection_range: draftCtx.luckysheet_selection_range
          };
          draftCtx.dataVerificationDropDownList = false;
          draftCtx.currentSheetId = sheet.id;
          draftCtx.zoomRatio = sheet.zoomRatio || 1;
          cancelActiveImgItem(draftCtx, refs.globalCache);
          cancelNormalSelected(draftCtx);
        });
      },
      onContextMenu: function onContextMenu(e) {
        if (isDropPlaceholder) return;
        var rect = refs.workbookContainer.current.getBoundingClientRect();
        var pageX = e.pageX, pageY = e.pageY;
        setContext(function(ctx) {
          ctx.dataVerificationDropDownList = false;
          ctx.currentSheetId = sheet.id;
          ctx.zoomRatio = sheet.zoomRatio || 1;
          ctx.sheetTabContextMenu = {
            x: pageX - rect.left + rect.x,
            y: pageY - rect.top + rect.y,
            sheet,
            onRename: function onRename() {
              return setEditing(true);
            }
          };
        });
      },
      style: {
        borderLeft: dragOver ? "2px solid #0188fb" : "",
        display: sheet.hide === 1 ? "none" : ""
      }
    }, /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-sheets-item-name",
      spellCheck: "false",
      suppressContentEditableWarning: true,
      contentEditable: isDropPlaceholder ? false : editing,
      onDoubleClick: function onDoubleClick() {
        return setEditing(true);
      },
      onBlur,
      onKeyDown,
      ref: editable,
      style: dragOver ? {
        pointerEvents: "none"
      } : {}
    }, sheet.name), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-sheets-item-function",
      onMouseEnter: function onMouseEnter() {
        return setSvgColor("#5c5c5c");
      },
      onMouseLeave: function onMouseLeave() {
        return setSvgColor("#c3c3c3");
      },
      onClick: function onClick(e) {
        if (isDropPlaceholder || context.allowEdit === false) return;
        var rect = refs.workbookContainer.current.getBoundingClientRect();
        var pageX = e.pageX, pageY = e.pageY;
        setContext(function(ctx) {
          ctx.currentSheetId = sheet.id;
          ctx.sheetTabContextMenu = {
            x: pageX - rect.left + rect.x,
            y: pageY - rect.top + rect.y,
            sheet,
            onRename: function onRename() {
              return setEditing(true);
            }
          };
        });
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "downArrow",
      width: 12,
      style: {
        fill: svgColor
      }
    })), !!sheet.color && /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-sheets-item-color",
      style: {
        background: sheet.color
      }
    }));
  };
  var presets = [{
    text: "10%",
    value: 0.1
  }, {
    text: "30%",
    value: 0.3
  }, {
    text: "50%",
    value: 0.5
  }, {
    text: "70%",
    value: 0.7
  }, {
    text: "100%",
    value: 1
  }, {
    text: "150%",
    value: 1.5
  }, {
    text: "200%",
    value: 2
  }, {
    text: "300%",
    value: 3
  }, {
    text: "400%",
    value: 4
  }];
  var ZoomControl = function ZoomControl2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var menuRef = reactExports.useRef(null);
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), radioMenuOpen = _useState2[0], setRadioMenuOpen = _useState2[1];
    useOutsideClick(menuRef, function() {
      setRadioMenuOpen(false);
    }, []);
    var zoomTo = reactExports.useCallback(function(val) {
      val = parseFloat(val.toFixed(1));
      if (val > MAX_ZOOM_RATIO || val < MIN_ZOOM_RATIO) {
        return;
      }
      setContext(function(ctx) {
        var index2 = getSheetIndex(ctx, ctx.currentSheetId);
        if (index2 == null) {
          return;
        }
        ctx.luckysheetfile[index2].zoomRatio = val;
        ctx.zoomRatio = val;
      }, {
        noHistory: true
      });
    }, [setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-container"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-button",
      onClick: function onClick(e) {
        zoomTo(context.zoomRatio - 0.1);
        e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "minus",
      width: 16,
      height: 16
    })), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-ratio"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-ratio-current fortune-zoom-button",
      onClick: function onClick() {
        return setRadioMenuOpen(true);
      }
    }, (context.zoomRatio * 100).toFixed(0), "%"), radioMenuOpen && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-ratio-menu",
      ref: menuRef
    }, presets.map(function(v2) {
      return /* @__PURE__ */ React.createElement("div", {
        className: "fortune-zoom-ratio-item",
        key: v2.text,
        onClick: function onClick(e) {
          zoomTo(v2.value);
          e.preventDefault();
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "fortune-zoom-ratio-text"
      }, v2.text));
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-zoom-button",
      onClick: function onClick(e) {
        zoomTo(context.zoomRatio + 0.1);
        e.stopPropagation();
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "plus",
      width: 16,
      height: 16
    })));
  };
  var SheetTab = function SheetTab2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings, refs = _useContext.refs;
    var tabContainerRef = reactExports.useRef(null);
    var leftScrollRef = reactExports.useRef(null);
    var rightScrollRef = reactExports.useRef(null);
    var _useState = reactExports.useState(false), _useState2 = _slicedToArray(_useState, 2), isShowScrollBtn = _useState2[0], setIsShowScrollBtn = _useState2[1];
    var _useState3 = reactExports.useState(true), _useState4 = _slicedToArray(_useState3, 2), isShowBoundary = _useState4[0], setIsShowBoundary = _useState4[1];
    var scrollDelta = 150;
    var scrollBy = reactExports.useCallback(function(amount) {
      var _tabContainerRef$curr;
      if (tabContainerRef.current == null || tabContainerRef.current.scrollLeft == null) {
        return;
      }
      var scrollLeft = tabContainerRef.current.scrollLeft;
      if (scrollLeft + amount <= 0) setIsShowBoundary(true);
      else if (scrollLeft > 0) setIsShowBoundary(false);
      (_tabContainerRef$curr = tabContainerRef.current) === null || _tabContainerRef$curr === void 0 ? void 0 : _tabContainerRef$curr.scrollBy({
        left: amount,
        behavior: "smooth"
      });
    }, []);
    reactExports.useEffect(function() {
      var tabCurrent = tabContainerRef.current;
      if (!tabCurrent) return;
      setIsShowScrollBtn(tabCurrent.scrollWidth - 2 > tabCurrent.clientWidth);
    }, [context.luckysheetfile]);
    var onAddSheetClick = reactExports.useCallback(function() {
      return setTimeout(function() {
        setContext(function(draftCtx) {
          if (draftCtx.luckysheetCellUpdate.length > 0) {
            updateCell(draftCtx, draftCtx.luckysheetCellUpdate[0], draftCtx.luckysheetCellUpdate[1], refs.cellInput.current);
          }
          addSheet(draftCtx, settings);
        }, {
          addSheetOp: true
        });
        var tabCurrent = tabContainerRef.current;
        setIsShowScrollBtn(tabCurrent.scrollWidth > tabCurrent.clientWidth);
      });
    }, [refs.cellInput, setContext, settings]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-sheet-area luckysheet-noselected-text",
      onContextMenu: function onContextMenu(e) {
        return e.preventDefault();
      },
      id: "luckysheet-sheet-area"
    }, /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-sheet-content"
    }, context.allowEdit && /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheettab-button",
      onClick: onAddSheetClick
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "plus",
      width: 16,
      height: 16
    })), context.allowEdit && /* @__PURE__ */ React.createElement("div", {
      className: "sheet-list-container"
    }, /* @__PURE__ */ React.createElement("div", {
      id: "all-sheets",
      className: "fortune-sheettab-button",
      ref: tabContainerRef,
      onMouseDown: function onMouseDown(e) {
        e.stopPropagation();
        setContext(function(ctx) {
          ctx.showSheetList = _$1.isUndefined(ctx.showSheetList) ? true : !ctx.showSheetList;
          ctx.sheetTabContextMenu = {};
        });
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "all-sheets",
      width: 16,
      height: 16
    }))), /* @__PURE__ */ React.createElement("div", {
      id: "luckysheet-sheets-m",
      className: "luckysheet-sheets-m lucky-button-custom"
    }, /* @__PURE__ */ React.createElement("i", {
      className: "iconfont luckysheet-iconfont-caidan2"
    })), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheettab-container",
      id: "fortune-sheettab-container"
    }, !isShowBoundary && /* @__PURE__ */ React.createElement("div", {
      className: "boundary boundary-left"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheettab-container-c",
      id: "fortune-sheettab-container-c",
      ref: tabContainerRef
    }, _$1.sortBy(context.luckysheetfile, function(s2) {
      return Number(s2.order);
    }).map(function(sheet) {
      return /* @__PURE__ */ React.createElement(SheetItem, {
        key: sheet.id,
        sheet
      });
    })), isShowBoundary && isShowScrollBtn && /* @__PURE__ */ React.createElement("div", {
      className: "boundary boundary-right"
    })), isShowScrollBtn && /* @__PURE__ */ React.createElement("div", {
      id: "fortune-sheettab-leftscroll",
      className: "fortune-sheettab-scroll",
      ref: leftScrollRef,
      onClick: function onClick() {
        scrollBy(-scrollDelta);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "arrow-doubleleft",
      width: 12,
      height: 12
    })), isShowScrollBtn && /* @__PURE__ */ React.createElement("div", {
      id: "fortune-sheettab-rightscroll",
      className: "fortune-sheettab-scroll",
      ref: rightScrollRef,
      onClick: function onClick() {
        scrollBy(scrollDelta);
      }
    }, /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "arrow-doubleright",
      width: 12,
      height: 12
    }))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheet-area-right"
    }, /* @__PURE__ */ React.createElement(ZoomControl, null)));
  };
  var Divider$1 = function Divider2() {
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-context-menu-divider"
    });
  };
  var Menu = function Menu2(_ref) {
    var _onClick = _ref.onClick, _onMouseLeave = _ref.onMouseLeave, _onMouseEnter = _ref.onMouseEnter, children = _ref.children;
    var containerRef = reactExports.useRef(null);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "luckysheet-cols-menuitem luckysheet-mousedown-cancel",
      onClick: function onClick(e) {
        return _onClick === null || _onClick === void 0 ? void 0 : _onClick(e, containerRef.current);
      },
      onMouseLeave: function onMouseLeave(e) {
        return _onMouseLeave === null || _onMouseLeave === void 0 ? void 0 : _onMouseLeave(e, containerRef.current);
      },
      onMouseEnter: function onMouseEnter(e) {
        return _onMouseEnter === null || _onMouseEnter === void 0 ? void 0 : _onMouseEnter(e, containerRef.current);
      }
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-cols-menuitem-content luckysheet-mousedown-cancel"
    }, children));
  };
  var CustomSort = function CustomSort2() {
    var _useState = reactExports.useState([]), _useState2 = _slicedToArray(_useState, 2), rangeColChar = _useState2[0], setRangeColChar = _useState2[1];
    var _useState3 = reactExports.useState(true), _useState4 = _slicedToArray(_useState3, 2), ascOrDesc = _useState4[0], setAscOrDesc = _useState4[1];
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _useState5 = reactExports.useState("0"), _useState6 = _slicedToArray(_useState5, 2), selectedValue = _useState6[0], setSelectedValue = _useState6[1];
    var _useState7 = reactExports.useState(false), _useState8 = _slicedToArray(_useState7, 2), isTitleChange = _useState8[0], setIstitleChange = _useState8[1];
    var _locale = locale(context), sort = _locale.sort;
    var _useDialog = useDialog(), hideDialog = _useDialog.hideDialog;
    var col_start = context.luckysheet_select_save[0].column[0];
    var col_end = context.luckysheet_select_save[0].column[1];
    var row_start = context.luckysheet_select_save[0].row[0];
    var row_end = context.luckysheet_select_save[0].row[1];
    var sheetIndex = getSheetIndex(context, context.currentSheetId);
    var handleSelectChange = function handleSelectChange2(event) {
      setSelectedValue(event.target.value);
    };
    var handleRadioChange = reactExports.useCallback(function(e) {
      var sortValue = e.target.value;
      setAscOrDesc(sortValue === "asc");
    }, []);
    var handleTitleChange = reactExports.useCallback(function(e) {
      var value = e.target.checked;
      setIstitleChange(value);
    }, []);
    reactExports.useEffect(function() {
      var list = [];
      if (isTitleChange) {
        for (var i2 = col_start; i2 <= col_end; i2 += 1) {
          var _context$luckysheetfi, _context$luckysheetfi2;
          var cell = (_context$luckysheetfi = context.luckysheetfile[sheetIndex].data) === null || _context$luckysheetfi === void 0 ? void 0 : (_context$luckysheetfi2 = _context$luckysheetfi[row_start]) === null || _context$luckysheetfi2 === void 0 ? void 0 : _context$luckysheetfi2[i2];
          var colHeaderValue = (cell === null || cell === void 0 ? void 0 : cell.m) || (cell === null || cell === void 0 ? void 0 : cell.v);
          if (colHeaderValue) {
            list.push(colHeaderValue);
          } else {
            var ColumnChar = indexToColumnChar(i2);
            list.push("".concat(sort.columnOperation, " ").concat(ColumnChar));
          }
        }
      } else {
        for (var _i = col_start; _i <= col_end; _i += 1) {
          var _ColumnChar = indexToColumnChar(_i);
          list.push(_ColumnChar);
        }
      }
      setRangeColChar(list);
    }, [col_end, col_start, context.luckysheetfile, isTitleChange, row_start, sheetIndex, sort.columnOperation]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sort"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sort-title"
    }, /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("span", null, sort.sortRangeTitle), indexToColumnChar(col_start), row_start + 1, /* @__PURE__ */ React.createElement("span", null, sort.sortRangeTitleTo), indexToColumnChar(col_end), row_end + 1)), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sort-modal"
    }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("input", {
      type: "checkbox",
      id: "fortune-sort-haveheader",
      onChange: handleTitleChange
    }), /* @__PURE__ */ React.createElement("span", null, sort.hasTitle)), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sort-tablec"
    }, /* @__PURE__ */ React.createElement("table", {
      cellSpacing: "0"
    }, /* @__PURE__ */ React.createElement("tbody", null, /* @__PURE__ */ React.createElement("tr", null, /* @__PURE__ */ React.createElement("td", {
      style: {
        width: "190px"
      }
    }, sort.sortBy, /* @__PURE__ */ React.createElement("select", {
      name: "sort_0",
      onChange: handleSelectChange
    }, rangeColChar.map(function(col, index2) {
      return /* @__PURE__ */ React.createElement("option", {
        value: index2,
        key: index2
      }, col);
    }))), /* @__PURE__ */ React.createElement("td", null, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("input", {
      type: "radio",
      value: "asc",
      defaultChecked: true,
      name: "sort_0",
      onChange: handleRadioChange
    }), /* @__PURE__ */ React.createElement("span", null, sort.asc)), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("input", {
      type: "radio",
      value: "desc",
      name: "sort_0",
      onChange: handleRadioChange
    }), /* @__PURE__ */ React.createElement("span", null, sort.desc))))))))), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sort-button"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        setContext(function(draftCtx) {
          sortSelection(draftCtx, ascOrDesc, parseInt(selectedValue, 10));
          draftCtx.contextMenu = {};
        });
        hideDialog();
      }
    }, sort.confirm)));
  };
  var ContextMenu = function ContextMenu2() {
    var _useDialog = useDialog(), showDialog = _useDialog.showDialog;
    var containerRef = reactExports.useRef(null);
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings;
    var contextMenu = context.contextMenu;
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert;
    var _locale = locale(context), rightclick = _locale.rightclick, drag = _locale.drag, generalDialog = _locale.generalDialog, info = _locale.info;
    var getMenuElement = reactExports.useCallback(function(name, i2) {
      var _context$luckysheet_s;
      var selection = (_context$luckysheet_s = context.luckysheet_select_save) === null || _context$luckysheet_s === void 0 ? void 0 : _context$luckysheet_s[0];
      if (name === "|") {
        return /* @__PURE__ */ React.createElement(Divider$1, {
          key: "divider-".concat(i2)
        });
      }
      if (name === "copy") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              var _draftCtx$luckysheet_;
              if (((_draftCtx$luckysheet_ = draftCtx.luckysheet_select_save) === null || _draftCtx$luckysheet_ === void 0 ? void 0 : _draftCtx$luckysheet_.length) > 1) {
                showAlert(rightclick.noMulti, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              handleCopy(draftCtx);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.copy);
      }
      if (name === "paste") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              handlePasteByClick(draftCtx);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.paste);
      }
      if (name === "insert-column") {
        return (selection === null || selection === void 0 ? void 0 : selection.row_select) ? null : ["left", "right"].map(function(dir) {
          var _context$lang, _context$lang2;
          return /* @__PURE__ */ React.createElement(Menu, {
            key: "add-col-".concat(dir),
            onClick: function onClick(e) {
              var _context$luckysheet_s2, _context$luckysheet_s3, _context$luckysheet_s4, _e$target$querySelect;
              var position = (_context$luckysheet_s2 = context.luckysheet_select_save) === null || _context$luckysheet_s2 === void 0 ? void 0 : (_context$luckysheet_s3 = _context$luckysheet_s2[0]) === null || _context$luckysheet_s3 === void 0 ? void 0 : (_context$luckysheet_s4 = _context$luckysheet_s3.column) === null || _context$luckysheet_s4 === void 0 ? void 0 : _context$luckysheet_s4[0];
              if (position == null) return;
              var countStr = (_e$target$querySelect = e.target.querySelector("input")) === null || _e$target$querySelect === void 0 ? void 0 : _e$target$querySelect.value;
              if (countStr == null) return;
              var count = parseInt(countStr, 10);
              if (count < 1) return;
              var direction = dir === "left" ? "lefttop" : "rightbottom";
              var insertRowColOp = {
                type: "column",
                index: position,
                count,
                direction,
                id: context.currentSheetId
              };
              setContext(function(draftCtx) {
                try {
                  insertRowCol(draftCtx, insertRowColOp);
                  draftCtx.contextMenu = {};
                } catch (err) {
                  if (err.message === "maxExceeded") showAlert(rightclick.columnOverLimit, "ok");
                  else if (err.message === "readOnly") showAlert(rightclick.cannotInsertOnColumnReadOnly, "ok");
                  draftCtx.contextMenu = {};
                }
              }, {
                insertRowColOp
              });
            }
          }, /* @__PURE__ */ React.createElement(React.Fragment, null, _$1.startsWith((_context$lang = context.lang) !== null && _context$lang !== void 0 ? _context$lang : "", "zh") && /* @__PURE__ */ React.createElement(React.Fragment, null, rightclick.to, /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-".concat(dir)
          }, rightclick[dir])), "".concat(rightclick.insert, "  "), /* @__PURE__ */ React.createElement("input", {
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onKeyDown: function onKeyDown(e) {
              return e.stopPropagation();
            },
            type: "text",
            className: "luckysheet-mousedown-cancel",
            placeholder: rightclick.number,
            defaultValue: "1"
          }), /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-word luckysheet-mousedown-cancel"
          }, "".concat(rightclick.column, "  ")), !_$1.startsWith((_context$lang2 = context.lang) !== null && _context$lang2 !== void 0 ? _context$lang2 : "", "zh") && /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-".concat(dir)
          }, rightclick[dir])));
        });
      }
      if (name === "insert-row") {
        return (selection === null || selection === void 0 ? void 0 : selection.column_select) ? null : ["top", "bottom"].map(function(dir) {
          var _context$lang3, _context$lang4;
          return /* @__PURE__ */ React.createElement(Menu, {
            key: "add-row-".concat(dir),
            onClick: function onClick(e, container) {
              var _context$luckysheet_s5, _context$luckysheet_s6, _context$luckysheet_s7, _container$querySelec;
              var position = (_context$luckysheet_s5 = context.luckysheet_select_save) === null || _context$luckysheet_s5 === void 0 ? void 0 : (_context$luckysheet_s6 = _context$luckysheet_s5[0]) === null || _context$luckysheet_s6 === void 0 ? void 0 : (_context$luckysheet_s7 = _context$luckysheet_s6.row) === null || _context$luckysheet_s7 === void 0 ? void 0 : _context$luckysheet_s7[0];
              if (position == null) return;
              var countStr = (_container$querySelec = container.querySelector("input")) === null || _container$querySelec === void 0 ? void 0 : _container$querySelec.value;
              if (countStr == null) return;
              var count = parseInt(countStr, 10);
              if (count < 1) return;
              var direction = dir === "top" ? "lefttop" : "rightbottom";
              var insertRowColOp = {
                type: "row",
                index: position,
                count,
                direction,
                id: context.currentSheetId
              };
              setContext(function(draftCtx) {
                try {
                  insertRowCol(draftCtx, insertRowColOp);
                  draftCtx.contextMenu = {};
                } catch (err) {
                  if (err.message === "maxExceeded") showAlert(rightclick.rowOverLimit, "ok");
                  else if (err.message === "readOnly") showAlert(rightclick.cannotInsertOnRowReadOnly, "ok");
                  draftCtx.contextMenu = {};
                }
              }, {
                insertRowColOp
              });
            }
          }, /* @__PURE__ */ React.createElement(React.Fragment, null, _$1.startsWith((_context$lang3 = context.lang) !== null && _context$lang3 !== void 0 ? _context$lang3 : "", "zh") && /* @__PURE__ */ React.createElement(React.Fragment, null, rightclick.to, /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-".concat(dir)
          }, rightclick[dir])), "".concat(rightclick.insert, "  "), /* @__PURE__ */ React.createElement("input", {
            onClick: function onClick(e) {
              return e.stopPropagation();
            },
            onKeyDown: function onKeyDown(e) {
              return e.stopPropagation();
            },
            type: "text",
            className: "luckysheet-mousedown-cancel",
            placeholder: rightclick.number,
            defaultValue: "1"
          }), /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-word luckysheet-mousedown-cancel"
          }, "".concat(rightclick.row, "  ")), !_$1.startsWith((_context$lang4 = context.lang) !== null && _context$lang4 !== void 0 ? _context$lang4 : "", "zh") && /* @__PURE__ */ React.createElement("span", {
            className: "luckysheet-cols-rows-shift-".concat(dir)
          }, rightclick[dir])));
        });
      }
      if (name === "delete-column") {
        return (selection === null || selection === void 0 ? void 0 : selection.column_select) && /* @__PURE__ */ React.createElement(Menu, {
          key: "delete-col",
          onClick: function onClick() {
            if (!selection) return;
            var _selection$column = _slicedToArray(selection.column, 2), st_index = _selection$column[0], ed_index = _selection$column[1];
            var deleteRowColOp = {
              type: "column",
              start: st_index,
              end: ed_index,
              id: context.currentSheetId
            };
            setContext(function(draftCtx) {
              var _draftCtx$luckysheet_2, _draftCtx$luckysheetf, _draftCtx$luckysheetf2;
              if (((_draftCtx$luckysheet_2 = draftCtx.luckysheet_select_save) === null || _draftCtx$luckysheet_2 === void 0 ? void 0 : _draftCtx$luckysheet_2.length) > 1) {
                showAlert(rightclick.noMulti, "ok");
                draftCtx.contextMenu = {};
                draftCtx.dataVerificationDropDownList = false;
                return;
              }
              var slen = ed_index - st_index + 1;
              var index2 = getSheetIndex(draftCtx, context.currentSheetId);
              if (((_draftCtx$luckysheetf = draftCtx.luckysheetfile[index2].data) === null || _draftCtx$luckysheetf === void 0 ? void 0 : (_draftCtx$luckysheetf2 = _draftCtx$luckysheetf[0]) === null || _draftCtx$luckysheetf2 === void 0 ? void 0 : _draftCtx$luckysheetf2.length) <= slen) {
                showAlert(rightclick.cannotDeleteAllColumn, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              try {
                deleteRowCol(draftCtx, deleteRowColOp);
              } catch (e) {
                if (e.message === "readOnly") {
                  showAlert(rightclick.cannotDeleteColumnReadOnly, "ok");
                }
              }
              draftCtx.contextMenu = {};
            }, {
              deleteRowColOp
            });
          }
        }, rightclick.deleteSelected, rightclick.column);
      }
      if (name === "delete-row") {
        return (selection === null || selection === void 0 ? void 0 : selection.row_select) && /* @__PURE__ */ React.createElement(Menu, {
          key: "delete-row",
          onClick: function onClick() {
            if (!selection) return;
            var _selection$row = _slicedToArray(selection.row, 2), st_index = _selection$row[0], ed_index = _selection$row[1];
            var deleteRowColOp = {
              type: "row",
              start: st_index,
              end: ed_index,
              id: context.currentSheetId
            };
            setContext(function(draftCtx) {
              var _draftCtx$luckysheet_3, _draftCtx$luckysheetf3;
              if (((_draftCtx$luckysheet_3 = draftCtx.luckysheet_select_save) === null || _draftCtx$luckysheet_3 === void 0 ? void 0 : _draftCtx$luckysheet_3.length) > 1) {
                showAlert(rightclick.noMulti, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              var slen = ed_index - st_index + 1;
              var index2 = getSheetIndex(draftCtx, context.currentSheetId);
              if (((_draftCtx$luckysheetf3 = draftCtx.luckysheetfile[index2].data) === null || _draftCtx$luckysheetf3 === void 0 ? void 0 : _draftCtx$luckysheetf3.length) <= slen) {
                showAlert(rightclick.cannotDeleteAllRow, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              try {
                deleteRowCol(draftCtx, deleteRowColOp);
              } catch (e) {
                if (e.message === "readOnly") {
                  showAlert(rightclick.cannotDeleteRowReadOnly, "ok");
                }
              }
              draftCtx.contextMenu = {};
            }, {
              deleteRowColOp
            });
          }
        }, rightclick.deleteSelected, rightclick.row);
      }
      if (name === "hide-row") {
        return (selection === null || selection === void 0 ? void 0 : selection.row_select) === true && ["hideSelected", "showHide"].map(function(item) {
          return /* @__PURE__ */ React.createElement(Menu, {
            key: item,
            onClick: function onClick() {
              setContext(function(draftCtx) {
                var msg = "";
                if (item === "hideSelected") {
                  msg = hideSelected(draftCtx, "row");
                } else if (item === "showHide") {
                  showSelected(draftCtx, "row");
                }
                if (msg === "noMulti") {
                  showDialog(drag.noMulti);
                }
                draftCtx.contextMenu = {};
              });
            }
          }, rightclick[item] + rightclick.row);
        });
      }
      if (name === "hide-column") {
        return (selection === null || selection === void 0 ? void 0 : selection.column_select) === true && ["hideSelected", "showHide"].map(function(item) {
          return /* @__PURE__ */ React.createElement(Menu, {
            key: item,
            onClick: function onClick() {
              setContext(function(draftCtx) {
                var msg = "";
                if (item === "hideSelected") {
                  msg = hideSelected(draftCtx, "column");
                } else if (item === "showHide") {
                  showSelected(draftCtx, "column");
                }
                if (msg === "noMulti") {
                  showDialog(drag.noMulti);
                }
                draftCtx.contextMenu = {};
              });
            }
          }, rightclick[item] + rightclick.column);
        });
      }
      if (name === "set-row-height") {
        var _context$luckysheet_s8, _context$luckysheet_s9;
        var rowHeight = (selection === null || selection === void 0 ? void 0 : selection.height) || context.defaultrowlen;
        var shownRowHeight = ((_context$luckysheet_s8 = context.luckysheet_select_save) === null || _context$luckysheet_s8 === void 0 ? void 0 : _context$luckysheet_s8.some(function(section) {
          return section.height_move !== (rowHeight + 1) * (section.row[1] - section.row[0] + 1) - 1;
        })) ? "" : rowHeight;
        return ((_context$luckysheet_s9 = context.luckysheet_select_save) === null || _context$luckysheet_s9 === void 0 ? void 0 : _context$luckysheet_s9.some(function(section) {
          return section.row_select;
        })) ? /* @__PURE__ */ React.createElement(Menu, {
          key: "set-row-height",
          onClick: function onClick(e, container) {
            var _container$querySelec2;
            var targetRowHeight = (_container$querySelec2 = container.querySelector("input")) === null || _container$querySelec2 === void 0 ? void 0 : _container$querySelec2.value;
            setContext(function(draftCtx) {
              if (_$1.isUndefined(targetRowHeight) || targetRowHeight === "" || parseInt(targetRowHeight, 10) <= 0 || parseInt(targetRowHeight, 10) > 545) {
                showAlert(info.tipRowHeightLimit, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              var numRowHeight = parseInt(targetRowHeight, 10);
              var rowHeightList = {};
              _$1.forEach(draftCtx.luckysheet_select_save, function(section) {
                for (var rowNum = section.row[0]; rowNum <= section.row[1]; rowNum += 1) {
                  rowHeightList[rowNum] = numRowHeight;
                }
              });
              index.setRowHeight(draftCtx, rowHeightList, {}, true);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.row, rightclick.height, /* @__PURE__ */ React.createElement("input", {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          onKeyDown: function onKeyDown(e) {
            return e.stopPropagation();
          },
          type: "number",
          min: 1,
          max: 545,
          className: "luckysheet-mousedown-cancel",
          placeholder: rightclick.number,
          defaultValue: shownRowHeight,
          style: {
            width: "40px"
          }
        }), "px") : null;
      }
      if (name === "set-column-width") {
        var _context$luckysheet_s10, _context$luckysheet_s11;
        var colWidth = (selection === null || selection === void 0 ? void 0 : selection.width) || context.defaultcollen;
        var shownColWidth = ((_context$luckysheet_s10 = context.luckysheet_select_save) === null || _context$luckysheet_s10 === void 0 ? void 0 : _context$luckysheet_s10.some(function(section) {
          return section.width_move !== (colWidth + 1) * (section.column[1] - section.column[0] + 1) - 1;
        })) ? "" : colWidth;
        return ((_context$luckysheet_s11 = context.luckysheet_select_save) === null || _context$luckysheet_s11 === void 0 ? void 0 : _context$luckysheet_s11.some(function(section) {
          return section.column_select;
        })) ? /* @__PURE__ */ React.createElement(Menu, {
          key: "set-column-width",
          onClick: function onClick(e, container) {
            var _container$querySelec3;
            var targetColWidth = (_container$querySelec3 = container.querySelector("input")) === null || _container$querySelec3 === void 0 ? void 0 : _container$querySelec3.value;
            setContext(function(draftCtx) {
              if (_$1.isUndefined(targetColWidth) || targetColWidth === "" || parseInt(targetColWidth, 10) <= 0 || parseInt(targetColWidth, 10) > 2038) {
                showAlert(info.tipColumnWidthLimit, "ok");
                draftCtx.contextMenu = {};
                return;
              }
              var numColWidth = parseInt(targetColWidth, 10);
              var colWidthList = {};
              _$1.forEach(draftCtx.luckysheet_select_save, function(section) {
                for (var colNum = section.column[0]; colNum <= section.column[1]; colNum += 1) {
                  colWidthList[colNum] = numColWidth;
                }
              });
              index.setColumnWidth(draftCtx, colWidthList, {}, true);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.column, rightclick.width, /* @__PURE__ */ React.createElement("input", {
          onClick: function onClick(e) {
            return e.stopPropagation();
          },
          onKeyDown: function onKeyDown(e) {
            return e.stopPropagation();
          },
          type: "number",
          min: 1,
          max: 545,
          className: "luckysheet-mousedown-cancel",
          placeholder: rightclick.number,
          defaultValue: shownColWidth,
          style: {
            width: "40px"
          }
        }), "px") : null;
      }
      if (name === "clear") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              var allowEdit = isAllowEdit(draftCtx);
              if (!allowEdit) return;
              if (draftCtx.activeImg != null) {
                removeActiveImage(draftCtx);
              } else {
                var msg = deleteSelectedCellText(draftCtx);
                if (msg === "partMC") {
                  showDialog(generalDialog.partiallyError, "ok");
                } else if (msg === "allowEdit") {
                  showDialog(generalDialog.readOnlyError, "ok");
                } else if (msg === "dataNullError") {
                  showDialog(generalDialog.dataNullError, "ok");
                }
              }
              draftCtx.contextMenu = {};
              jfrefreshgrid(draftCtx, null, void 0);
            });
          }
        }, rightclick.clearContent);
      }
      if (name === "orderAZ") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              sortSelection(draftCtx, true);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.orderAZ);
      }
      if (name === "orderZA") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              sortSelection(draftCtx, false);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.orderZA);
      }
      if (name === "sort") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              showDialog(/* @__PURE__ */ React.createElement(CustomSort, null));
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.sortSelection);
      }
      if (name === "filter") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              createFilter(draftCtx);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.filterSelection);
      }
      if (name === "image") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              showImgChooser();
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.image);
      }
      if (name === "link") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            setContext(function(draftCtx) {
              handleLink(draftCtx);
              draftCtx.contextMenu = {};
            });
          }
        }, rightclick.link);
      }
      return null;
    }, [context.currentSheetId, context.lang, context.luckysheet_select_save, context.defaultrowlen, context.defaultcollen, rightclick, info, setContext, showAlert, showDialog, drag, generalDialog]);
    reactExports.useLayoutEffect(function() {
      if (!containerRef.current) {
        return;
      }
      var winH = window.innerHeight;
      var winW = window.innerWidth;
      var rect = containerRef.current.getBoundingClientRect();
      var menuW = rect.width;
      var menuH = rect.height;
      var top = contextMenu.y || 0;
      var left = contextMenu.x || 0;
      var hasOverflow = false;
      if (left + menuW > winW) {
        left -= menuW;
        hasOverflow = true;
      }
      if (top + menuH > winH) {
        top -= menuH;
        hasOverflow = true;
      }
      if (top < 0) {
        top = 0;
        hasOverflow = true;
      }
      if (hasOverflow) {
        setContext(function(draftCtx) {
          draftCtx.contextMenu.x = left;
          draftCtx.contextMenu.y = top;
        });
      }
    }, [contextMenu.x, contextMenu.y, setContext]);
    if (_$1.isEmpty(context.contextMenu)) return null;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-context-menu luckysheet-cols-menu",
      ref: containerRef,
      onContextMenu: function onContextMenu(e) {
        return e.stopPropagation();
      },
      style: {
        left: contextMenu.x,
        top: contextMenu.y
      }
    }, context.contextMenu.headerMenu === true ? settings.headerContextMenu.map(function(menu, i2) {
      return getMenuElement(menu, i2);
    }) : settings.cellContextMenu.map(function(menu, i2) {
      return getMenuElement(menu, i2);
    }));
  };
  var SVGDefines = function SVGDefines2() {
    return /* @__PURE__ */ React.createElement("svg", {
      style: {
        position: "absolute",
        width: 0,
        height: 0
      },
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "add"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "4.75",
      y: "4.75",
      width: "14.5",
      height: "14.5",
      rx: "0.75",
      stroke: "#424A59",
      strokeOpacity: "0.9",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "11.25",
      y: "8.5",
      width: "1.5",
      height: "7",
      fill: "#535B68"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "15.5",
      y: "11.25",
      width: "1.5",
      height: "7",
      transform: "rotate(90 15.5 11.25)",
      fill: "#535B68"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-bottom"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M9.25 12.5L12.0002 15.5L14.75 12.5H9.25Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.5",
      y: "16.5",
      width: "13",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "11.25",
      y: "5.5",
      width: "1.5",
      height: "7.5",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-center"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M5 6.75H19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M8 12H16",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5 17.25L19 17.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-justify"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M19.5 6.5H4.5",
      stroke: "#525C6F",
      strokeWidth: "1.5",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M19.5 12L4.5 12",
      stroke: "#525C6F",
      strokeWidth: "1.5",
      strokeLinejoin: "round"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M19.5 17.5H4.5",
      stroke: "#525C6F",
      strokeWidth: "1.5",
      strokeLinejoin: "round"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-left"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M5 6.75H19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5 12H13",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5 17.25L19 17.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-middle"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M9.25 16.5L12.0002 13.5L14.75 16.5H9.25Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M9.25 7L12.0002 10L14.75 7L9.25 7Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.5",
      y: "11",
      width: "13",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "11.25",
      y: "16",
      width: "1.5",
      height: "3.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "11.25",
      y: "4",
      width: "1.5",
      height: "3.5",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-right"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M5 6.75H19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M11 12H19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5 17.25L19 17.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "align-top"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M9.25 11L12.0002 8L14.75 11H9.25Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.5",
      y: "5.5",
      width: "13",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "11.25",
      y: "10.5",
      width: "1.5",
      height: "7.5",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "bold"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M6.30566 5.07617V18.9992H12.4872C13.9107 18.9992 15.0417 18.7067 15.8607 18.1607C16.8162 17.4977 17.3037 16.4837 17.3037 15.1187C17.3037 14.1827 17.0307 13.4417 16.5237 12.8567C16.0167 12.2717 15.3147 11.8817 14.3982 11.7257C15.1002 11.4917 15.6657 11.1212 16.0947 10.6142C16.5042 10.0487 16.7187 9.36617 16.7187 8.58617C16.7187 7.49417 16.3482 6.63617 15.6072 6.01217C14.8467 5.38817 13.8132 5.07617 12.5262 5.07617H6.30566ZM7.90466 6.42167H12.1557C13.1307 6.42167 13.8717 6.59717 14.3787 6.98717C14.8857 7.37717 15.1392 7.96217 15.1392 8.74217C15.1392 9.54167 14.8662 10.1462 14.3592 10.5557C13.8522 10.9457 13.1112 11.1602 12.1362 11.1602H7.90466V6.42167ZM7.90466 12.4862H12.3507C13.4232 12.4862 14.2422 12.6812 14.8077 13.1102C15.3927 13.5392 15.7047 14.2022 15.7047 15.0992C15.7047 15.9962 15.3537 16.6787 14.6712 17.1077C14.0862 17.4587 13.3257 17.6537 12.3507 17.6537H7.90466V12.4862Z",
      fill: "#394259"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-all"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-bottom"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "18.25",
      x2: "19",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-color"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M16 10.9106L18.9511 13.8617L14.5431 18.2697H11.592V15.3186L16 10.9106Z",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6.5 6.5H17.5V9.84613H19V6.5V5H17.5H6.5H5V6.5V17.5V19H6.5H9.84616V17.5H6.5V6.5Z",
      fill: "#535A68"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-horizontal"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "18.25",
      x2: "19",
      y2: "18.25",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border_diagonal_down"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "17.9697",
      y1: "18.0303",
      x2: "5.96967",
      y2: "6.03033",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border_diagonal_up"
    }, /* @__PURE__ */ React.createElement("line", {
      y1: "-0.75",
      x2: "16.9706",
      y2: "-0.75",
      transform: "matrix(0.707107 -0.707107 -0.707107 -0.707107 5.5 17.5)",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-inside"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-left"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5.75",
      y1: "19",
      x2: "5.75",
      y2: "5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-none"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-outside"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-right"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "18.25",
      y1: "19",
      x2: "18.25",
      y2: "5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-vertical"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "18.25",
      y1: "19",
      x2: "18.25",
      y2: "5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-slash"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "5.75",
      y1: "5.75",
      x2: "17.95",
      y2: "17.95",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-style"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "5.75",
      x2: "19",
      y2: "5.75",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "12.25",
      x2: "7.5",
      y2: "12.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "8.8252",
      y1: "12.25",
      x2: "11.3252",
      y2: "12.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12.6504",
      y1: "12.25",
      x2: "15.1504",
      y2: "12.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "16.4746",
      y1: "12.25",
      x2: "18.9746",
      y2: "12.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "18.25",
      x2: "6.5",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "7.08008",
      y1: "18.25",
      x2: "8.58008",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "9.16016",
      y1: "18.25",
      x2: "10.6602",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "11.2402",
      y1: "18.25",
      x2: "12.7402",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "13.3203",
      y1: "18.25",
      x2: "14.8203",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "15.4004",
      y1: "18.25",
      x2: "16.9004",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "17.4805",
      y1: "18.25",
      x2: "18.9805",
      y2: "18.25",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "border-top"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#CCCED2",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "5",
      y1: "5.75",
      x2: "19",
      y2: "5.75",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 18 18",
      fill: "none",
      id: "close"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M13.9255 5L5.00091 13.9246",
      stroke: "#262A33",
      strokeOpacity: "0.9",
      strokeWidth: "1.5",
      strokeLinecap: "round"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M13.9255 13.9238L5.00091 4.9992",
      stroke: "#262A33",
      strokeOpacity: "0.9",
      strokeWidth: "1.5",
      strokeLinecap: "round"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 10 24",
      fill: "none",
      id: "combo-arrow"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M8 10H2L5 14L8 10Z",
      fill: "#A6A6A6"
    })), /* @__PURE__ */ React.createElement("symbol", {
      fill: "none",
      viewBox: "0 0 24 24",
      id: "comment"
    }, /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.968 15.7L12 17.956l2.032-2.258H18.5v-10h-13v10h4.468zm1.289 3.673L9.3 17.2H5.5A1.5 1.5 0 014 15.7v-10a1.5 1.5 0 011.5-1.5h13A1.5 1.5 0 0120 5.7v10a1.5 1.5 0 01-1.5 1.5h-3.8l-1.957 2.174a1 1 0 01-1.486 0z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M7 8.2h10v1.5H7V8.2zM7 11.699h6v1.5H7z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "strike-through"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "6",
      y: "11.5",
      width: "13",
      height: "1.5",
      fill: "#394259"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M9.00344 11.5C9.69342 11.9717 10.6431 12.3814 11.8525 12.729C13.071 13.0815 13.9121 13.4403 14.376 13.8052C14.8398 14.1639 15.0718 14.6742 15.0718 15.3359C15.0718 15.9977 14.8213 16.5203 14.3203 16.9038C13.8193 17.2873 13.0988 17.479 12.1587 17.479C11.1506 17.479 10.3434 17.244 9.7373 16.7739C9.13737 16.2977 8.8374 15.6514 8.8374 14.835H7.04688C7.04688 15.6204 7.26335 16.3224 7.69629 16.9409C8.13542 17.5594 8.757 18.048 9.56104 18.4067C10.3651 18.7593 11.231 18.9355 12.1587 18.9355C13.5874 18.9355 14.7285 18.6077 15.582 17.9521C16.4355 17.2904 16.8623 16.4121 16.8623 15.3174C16.8623 14.6309 16.7077 14.034 16.3984 13.5269C16.0954 13.0197 15.6253 12.5775 14.9883 12.2002C14.581 11.9526 14.0705 11.7192 13.457 11.5H9.00344Z",
      fill: "#394259"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M7.71685 10C7.5547 9.61466 7.47363 9.19458 7.47363 8.73975C7.47363 7.67594 7.8973 6.79769 8.74463 6.10498C9.59814 5.40609 10.7052 5.05664 12.0659 5.05664C12.9937 5.05664 13.8193 5.236 14.543 5.59473C15.2728 5.95345 15.8356 6.44824 16.2314 7.0791C16.6335 7.70996 16.8345 8.39958 16.8345 9.14795H15.0439C15.0439 8.33154 14.7842 7.69141 14.2646 7.22754C13.7451 6.75749 13.0122 6.52246 12.0659 6.52246C11.1877 6.52246 10.5011 6.71729 10.0063 7.10693C9.51774 7.4904 9.27344 8.02539 9.27344 8.71191C9.27344 9.2095 9.46296 9.63887 9.84201 10H7.71685Z",
      fill: "#394259"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "clear-format"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "8",
      y1: "18.25",
      x2: "20",
      y2: "18.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M14 7.12132L17.8787 11L10 18.8787L6.12132 15L14 7.12132ZM14 5L15.0607 6.06066L18.9393 9.93934L20 11L18.9393 12.0607L12 19L8 19L5.06066 16.0607L4 15L5.06066 13.9393L12.9393 6.06066L14 5Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "13.9375",
      y: "6.12316",
      width: "6.98528",
      height: "5.7265",
      transform: "rotate(45 13.9375 6.12316)",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "image"
    }, /* @__PURE__ */ React.createElement("circle", {
      cx: "8.75",
      cy: "8.75",
      r: "1.25",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "4.75",
      y: "5.25",
      width: "14.5",
      height: "13.5",
      rx: "0.75",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M7 19L12.984 11.8949C13.1659 11.6789 13.4905 11.6563 13.7006 11.845L19.5 17.0556",
      stroke: "#525C6F",
      strokeWidth: "1.5",
      strokeLinejoin: "round"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "italic"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M11 5H16V6.5H11V5Z",
      fill: "#394259"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M9 17.5H14V19H9V17.5Z",
      fill: "#394259"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M10.7598 17.877L12.7598 5.87695L14.2394 6.12355L12.2394 18.1236L10.7598 17.877Z",
      fill: "#394259"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "merge-cancel"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M13 14.9998L16.5 11.9996L13 8.99982V14.9998Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M11 14.9998L7.5 11.9996L11 8.99982L11 14.9998Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "10",
      y: "11.2498",
      width: "4.5",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.5 6.49982H6.5L6.5 17.4998H9.5V15.4999H11V17.4998V18.9998H9.5H6.5H5V17.4998L5 6.49982V4.99982H6.5H9.5L11 4.99982V6.49982V8.49988H9.5V6.49982ZM13 15.4999V15.9998V17.4998V18.9998H14.5H17.5H19V17.4998V6.49982V4.99982H17.5H14.5H13V6.49982V7.99982V8.49988H14.5V7.99982V6.49982H17.5V17.4998H14.5L14.5 15.9998V15.4999H13Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "merge-horizontal"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M11 15L14.5 11.9998L11 9V15Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "5",
      y: "11.25",
      width: "8.5",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6.5 6.5H7.5H9.5H11V5H9.5H6.5H5V6.5V17.5V19H6.5H9.5H11V17.5H9.5H7.5H6.5V6.5ZM13 16V15.5H14.5V16V17.5H17.5V6.5H14.5V8V8.5H13V8V6.5V5H14.5H17.5H19V6.5V17.5V19H17.5H14.5H13V17.5V16Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "merge-vertical"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M9 10.9998L12.0002 14.4998L15 10.9998L9 10.9998Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "12.75",
      y: "4.99982",
      width: "8.5",
      height: "1.5",
      transform: "rotate(90 12.75 4.99982)",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M17.5 6.49982L17.5 7L17.5 10.9998H19V9.49982V6.49982V4.99982H17.5L6.5 4.99982H5V6.49982L5 9.49982V10.9998H6.5V9.49982L6.5 7L6.5 6.49982L17.5 6.49982ZM8 12.9998L8.5 12.9998V14.4998H8H6.5V17.4998H17.5V14.4998H16H15.5V12.9998H16H17.5H19L19 14.4998V17.4998V18.9998H17.5H6.5L5 18.9998L5 17.4998V14.4998V12.9998H6.5H8Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "merge-all"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M15.5 14.9998L12 11.9996L15.5 8.99982V14.9998Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M8.5 14.9998L12 11.9996L8.5 8.99982L8.5 14.9998Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "7",
      y: "11.2498",
      width: "2.5",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "14.5",
      y: "11.2498",
      width: "2.5",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.5 6.49982H6.5L6.5 17.4998H9.5V15.4999H11V17.4998V18.9998H9.5H6.5H5V17.4998L5 6.49982V4.99982H6.5H9.5L11 4.99982V6.49982V8.49988H9.5V6.49982ZM13 15.4999V15.9998V17.4998V18.9998H14.5H17.5H19V17.4998V6.49982V4.99982H17.5H14.5H13V6.49982V7.99982V8.49988H14.5V7.99982V6.49982H17.5V17.4998H14.5L14.5 15.9998V15.4999H13Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      fill: "none",
      viewBox: "0 0 16 16",
      id: "plus"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M8 1.715v12.571M1.714 8h12.572",
      stroke: "#666",
      strokeWidth: "1.714"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      version: "1.1",
      "p-id": "4116",
      id: "minus"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M801.895 542.105h-579.79C205.479 542.105 192 528.627 192 512c0-16.627 13.479-30.105 30.105-30.105h579.789C818.521 481.895 832 495.373 832 512c0 16.627-13.479 30.105-30.105 30.105z",
      "p-id": "4117"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "-100 -100 1224 1224",
      fill: "#525C6F",
      id: "background"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M766.4 744.3c43.7 0 79.4-36.2 79.4-80.5 0-53.5-79.4-140.8-79.4-140.8S687 610.3 687 663.8c0 44.3 35.7 80.5 79.4 80.5zM389.3 700.2c7.1 7.1 18.6 7.1 25.6 0l256.1-256c7.1-7.1 7.1-18.6 0-25.6l-256-256c-0.6-0.6-1.3-1.2-2-1.7l-78.2-78.2c-3.5-3.5-9.3-3.5-12.8 0l-48 48c-3.5 3.5-3.5 9.3 0 12.8l67.2 67.2-207.8 207.9c-7.1 7.1-7.1 18.6 0 25.6l255.9 256z m12.9-448.6l178.9 178.9H223.4l178.8-178.9zM904 816H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "-100 -100 1224 1224",
      fill: "#525C6F",
      id: "font-color"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M904 816H120c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-80c0-4.4-3.6-8-8-8zM253.7 736h85c4.2 0 8-2.7 9.3-6.8l53.7-166h219.2l53.2 166c1.3 4 5 6.8 9.3 6.8h89.1c1.1 0 2.2-0.2 3.2-0.5 5.1-1.8 7.8-7.3 6-12.4L573.6 118.6c-1.4-3.9-5.1-6.6-9.2-6.6H462.1c-4.2 0-7.9 2.6-9.2 6.6L244.5 723.1c-0.4 1-0.5 2.1-0.5 3.2-0.1 5.3 4.3 9.7 9.7 9.7z m255.9-516.1h4.1l83.8 263.8H424.9l84.7-263.8z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "text-overflow"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M16.5 15L20 11.9998L16.5 9V15Z",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("rect", {
      x: "7",
      y: "11.25",
      width: "9.5",
      height: "1.5",
      fill: "#525C6F"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "4.75",
      y1: "5",
      x2: "4.75",
      y2: "19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12.25",
      y1: "5",
      x2: "12.25",
      y2: "9.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12.25",
      y1: "14.5",
      x2: "12.25",
      y2: "19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "text-wrap"
    }, /* @__PURE__ */ React.createElement("line", {
      x1: "4.75",
      y1: "5",
      x2: "4.75",
      y2: "19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "19.25",
      y1: "5",
      x2: "19.25",
      y2: "19",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M7.00001 16.2502L9.99 13.5V15.5H12.0005C13.9335 15.5 15.5005 13.933 15.5005 12C15.5005 10.067 13.9335 8.5 12.0005 8.5H7V7H12.0005C14.7619 7 17.0005 9.23857 17.0005 12C17.0005 14.7614 14.7619 17 12.0005 17H9.99V19L7.00001 16.2502Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "underline"
    }, /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M17 19H7V17.5H17V19Z",
      fill: "#394259"
    }), /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M9.25 5V12.25C9.25 13.7688 10.4812 15 12 15C13.5188 15 14.75 13.7688 14.75 12.25V5H16.25V12.25C16.25 14.5972 14.3472 16.5 12 16.5C9.65278 16.5 7.75 14.5972 7.75 12.25V5H9.25Z",
      fill: "#394259"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "undo"
    }, /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M3.5 7.75001L7.2019 10.835V8.5H13.25C15.4591 8.5 17.25 10.2909 17.25 12.5C17.25 14.7091 15.4591 16.5 13.25 16.5H7V18H13.25C16.2876 18 18.75 15.5376 18.75 12.5C18.75 9.46244 16.2876 7 13.25 7H7.2019V4.66547L3.5 7.75001Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "redo"
    }, /* @__PURE__ */ React.createElement("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M20.5 7.75001L16.7981 10.835V8.5H10.75C8.54086 8.5 6.75 10.2909 6.75 12.5C6.75 14.7091 8.54086 16.5 10.75 16.5H17V18H10.75C7.71243 18 5.25 15.5376 5.25 12.5C5.25 9.46244 7.71243 7 10.75 7H16.7981V4.66547L20.5 7.75001Z",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "fx"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M841 370c3-3.3 2.7-8.3-0.6-11.3-1.5-1.3-3.4-2.1-5.3-2.1h-72.6c-2.4 0-4.6 1-6.1 2.8L633.5 504.6c-2.9 3.4-7.9 3.8-11.3 0.9-0.9-0.8-1.6-1.7-2.1-2.8l-63.5-141.3c-1.3-2.9-4.1-4.7-7.3-4.7H380.7l0.9-4.7 8-42.3c10.5-55.4 38-81.4 85.8-81.4 18.6 0 35.5 1.7 48.8 4.7l14.1-66.8c-22.6-4.7-35.2-6.1-54.9-6.1-103.3 0-156.4 44.3-175.9 147.3l-9.4 49.4h-97.6c-3.8 0-7.1 2.7-7.8 6.4L181.9 415c-0.9 4.3 1.9 8.6 6.2 9.5 0.5 0.1 1.1 0.2 1.6 0.2H284l-89 429.9c-0.9 4.3 1.9 8.6 6.2 9.5 0.5 0.1 1.1 0.2 1.6 0.2H269c3.8 0 7.1-2.7 7.8-6.4l89.7-433.1h135.8l68.2 139.1c1.4 2.9 1 6.4-1.2 8.8l-180.6 203c-2.9 3.3-2.6 8.4 0.7 11.3 1.5 1.3 3.4 2 5.3 2h72.7c2.4 0 4.6-1 6.1-2.8l123.7-146.7c2.8-3.4 7.9-3.8 11.3-1 0.9 0.8 1.6 1.7 2.1 2.8L676.4 784c1.3 2.8 4.1 4.7 7.3 4.7h64.6c4.4 0 8-3.6 8-8 0-1.2-0.3-2.4-0.8-3.5l-95.2-198.9c-1.4-2.9-0.9-6.4 1.3-8.8L841 370z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "currency-format"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M675.861333 192l45.610667 44.906667-166.997333 169.6h237.525333v64H544v144.597333h248v64H544v176.597333h-64v-176.597333H232v-64H480v-144.597333H232v-64h237.482667l-166.954667-169.6L348.138667 192 512 358.464 675.861333 192z",
      "p-id": "5490"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "percentage-format"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M855.7 210.8l-42.4-42.4c-3.1-3.1-8.2-3.1-11.3 0L168.3 801.9c-3.1 3.1-3.1 8.2 0 11.3l42.4 42.4c3.1 3.1 8.2 3.1 11.3 0L855.6 222c3.2-3 3.2-8.1 0.1-11.2zM304 448c79.4 0 144-64.6 144-144s-64.6-144-144-144-144 64.6-144 144 64.6 144 144 144z m0-216c39.7 0 72 32.3 72 72s-32.3 72-72 72-72-32.3-72-72 32.3-72 72-72zM720 576c-79.4 0-144 64.6-144 144s64.6 144 144 144 144-64.6 144-144-64.6-144-144-144z m0 216c-39.7 0-72-32.3-72-72s32.3-72 72-72 72 32.3 72 72-32.3 72-72 72z",
      "p-id": "5920"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "number-decrease"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M132.266667 597.333333h76.8a4.266667 4.266667 0 0 0 4.266666-4.266666v-76.8a4.266667 4.266667 0 0 0-4.266666-4.266667H132.266667a4.266667 4.266667 0 0 0-4.266667 4.266667v76.8a4.266667 4.266667 0 0 0 4.266667 4.266666z m367.616-403.925333a94.72 94.72 0 0 0-27.306667-17.322667c-25.514667-10.496-54.954667-11.392-81.706667-5.632-36.778667 7.936-66.56 31.872-84.906666 64.256-19.797333 34.816-28.16 77.397333-28.16 139.178667 0 61.184 8.405333 102.4 28.16 137.941333a125.866667 125.866667 0 0 0 112.768 67.797334c48.64 0 90.581333-25.6 113.365333-67.84 19.2-34.773333 28.16-77.354667 28.16-135.552 0-50.432-5.888-104.106667-32.768-148.394667a148.906667 148.906667 0 0 0-27.562667-34.474667z m-81.066667 314.197333c-38.954667 0-59.306667-45.568-59.306667-134.4 0-88.149333 20.394667-133.76 58.794667-133.76 39.594667 0 59.306667 45.653333 59.306667 135.552 0 87.04-20.394667 132.565333-58.794667 132.565334z m289.024 212.394667a4.266667 4.266667 0 0 1-4.266667-4.266667V640l-103.68 103.68a4.266667 4.266667 0 0 0 0 6.016L704 853.333333v-75.733333a4.266667 4.266667 0 0 1 4.266667-4.266667H896v-53.333333h-187.733333z",
      "p-id": "6524"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "number-increase"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M132.266667 597.333333h76.8a4.266667 4.266667 0 0 0 4.266666-4.266666v-76.8a4.266667 4.266667 0 0 0-4.266666-4.266667H132.266667a4.266667 4.266667 0 0 0-4.266667 4.266667v76.8a4.266667 4.266667 0 0 0 4.266667 4.266666z m366.848-402.944a111.530667 111.530667 0 0 0-45.226667-21.76 142.933333 142.933333 0 0 0-71.253333 1.152A130.56 130.56 0 0 0 305.92 234.666667c-19.797333 34.816-28.16 77.397333-28.16 139.178666 0 61.184 8.405333 102.4 28.16 137.941334a125.866667 125.866667 0 0 0 112.768 67.797333c48.64 0 90.581333-25.6 113.365333-67.84 19.2-34.773333 28.16-77.354667 28.16-135.552 0-61.696-11.178667-141.653333-61.098666-181.888z m-79.872 313.173334c-38.954667 0-59.306667-45.568-59.306667-134.4 0-88.149333 20.394667-133.76 58.794667-133.76 39.594667 0 59.306667 45.653333 59.306666 135.552 0 87.04-20.394667 132.565333-58.794666 132.565333z m335.232 71.978666c48.64 0 90.581333-25.6 113.365333-67.84 19.2-34.730667 28.16-77.312 28.16-135.509333 0-47.786667-3.84-99.114667-27.093333-141.909333-27.178667-50.176-82.944-75.392-139.093334-64.554667l-12.8 3.157333A128.64 128.64 0 0 0 641.706667 234.666667c-19.797333 34.773333-28.16 77.354667-28.16 139.093333 0 61.184 8.405333 102.4 28.16 137.941333a125.866667 125.866667 0 0 0 112.768 67.754667z m0-340.053333c39.594667 0 59.306667 45.653333 59.306666 135.552 0 86.954667-20.394667 132.565333-58.794666 132.565333-38.954667 0-59.306667-45.568-59.306667-134.4 0-88.192 20.394667-133.76 58.794667-133.76z m34.858666 476.16a4.266667 4.266667 0 0 1-4.266666 4.266667H597.333333v53.333333h187.733334a4.266667 4.266667 0 0 1 4.266666 4.266667V853.333333l103.68-103.68a4.266667 4.266667 0 0 0 0-6.016L789.333333 640v75.733333z",
      "p-id": "6702"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      id: "format-painter"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M15.1004 6.5L6.90039 6.5V9.8L15.1004 9.8L15.1004 6.5ZM15.1004 5C15.9288 5 16.6004 5.67157 16.6004 6.5V9.8C16.6004 10.6284 15.9288 11.3 15.1004 11.3H6.90039C6.07196 11.3 5.40039 10.6284 5.40039 9.8V6.5C5.40039 5.67157 6.07196 5 6.90039 5H15.1004Z"
    }), /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M17.7174 8.90039H15.3262V7.40039H18.4674C18.8816 7.40039 19.2174 7.73618 19.2174 8.15039V13.7859C19.2174 14.163 18.9374 14.4814 18.5634 14.5297L10.8174 15.5299V19.0004H9.31738V14.8705C9.31738 14.4934 9.59736 14.175 9.97134 14.1267L17.7174 13.1265V8.90039Z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1096 1096",
      id: "formula-sum"
    }, /* @__PURE__ */ React.createElement("path", {
      fill: "#525C6F",
      d: "M725.333333 853.333333H256c-17.066667 0-29.866667-8.533333-38.4-25.6-8.533333-17.066667-4.266667-34.133333 4.266667-46.933333l230.4-268.8-230.4-268.8c-8.533333-12.8-12.8-34.133333-4.266667-46.933333 8.533333-17.066667 21.333333-25.6 38.4-25.6h469.333333c46.933333 0 85.333333 38.4 85.333334 85.333333v85.333333c0 25.6-17.066667 42.666667-42.666667 42.666667s-42.666667-17.066667-42.666667-42.666667V256H349.866667l196.266666 226.133333c12.8 17.066667 12.8 38.4 0 55.466667L349.866667 768H725.333333v-85.333333c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667v85.333333c0 46.933333-38.4 85.333333-85.333334 85.333333z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "arrow-doubleleft"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M272.9 512l265.4-339.1c4.1-5.2 0.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3c-9.1 11.6-9.1 27.9 0 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512z"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M576.9 512l265.4-339.1c4.1-5.2 0.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3c-9.1 11.6-9.1 27.9 0 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "arrow-doubleright"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1c-4.1 5.2-0.4 12.9 6.3 12.9h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M837.2 492.3L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1c-4.1 5.2-0.4 12.9 6.3 12.9h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "freeze-col"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5.75 12H18.25M12 5.5V18.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M12 12L5.5 17.75",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M11.25 6L5.75 11.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "freeze-row"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5.75 12H18.25M12 5.5V18.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M18 6.5L11.5 12.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M11.25 6L5.75 11.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "freeze-row-col"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M5.75 12H18.25M12 5.5V18.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M18 6L5.75 18.25",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M11.25 6L5.75 11.5",
      stroke: "#525C6F",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 24 24",
      fill: "none",
      id: "freeze-cancel"
    }, /* @__PURE__ */ React.createElement("rect", {
      x: "5.75",
      y: "5.75",
      width: "12.5",
      height: "12.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "6.5",
      y1: "12",
      x2: "17.5",
      y2: "12",
      stroke: "#535A68",
      strokeWidth: "1.5"
    }), /* @__PURE__ */ React.createElement("line", {
      x1: "12",
      y1: "17.5",
      x2: "12",
      y2: "6.5",
      stroke: "#535A68",
      strokeWidth: "1.5"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "sort-desc"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M839.6 433.8L749 150.5c-1.2-3.9-4.8-6.5-8.9-6.5h-77.4c-4.1 0-7.6 2.6-8.9 6.5l-91.3 283.3c-0.3 0.9-0.5 1.9-0.5 2.9 0 5.1 4.2 9.3 9.3 9.3h56.4c4.2 0 7.8-2.8 9-6.8l17.5-61.6h89l17.3 61.5c1.1 4 4.8 6.8 9 6.8h61.2c1 0 1.9-0.1 2.8-0.4 2.4-0.8 4.3-2.4 5.5-4.6 1.1-2.2 1.3-4.7 0.6-7.1zM663.3 325.5l32.8-116.9h6.3l32.1 116.9h-71.2z",
      "p-id": "2016"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M806.8 818.4H677.2v-0.4l132.6-188.9c1.1-1.6 1.7-3.4 1.7-5.4v-36.4c0-5.1-4.2-9.3-9.3-9.3h-204c-5.1 0-9.3 4.2-9.3 9.3v43c0 5.1 4.2 9.3 9.3 9.3h122.6v0.4L587.7 828.9c-1.1 1.6-1.7 3.4-1.7 5.4v36.4c0 5.1 4.2 9.3 9.3 9.3h211.4c5.1 0 9.3-4.2 9.3-9.3v-43c0.1-5.1-4.1-9.3-9.2-9.3z",
      "p-id": "2017"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M416 702h-76V172c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v530h-76c-6.7 0-10.5 7.8-6.3 13l112 141.9c3.2 4.1 9.4 4.1 12.6 0l112-141.9c4.1-5.2 0.4-13-6.3-13z",
      "p-id": "2018"
    })), /* @__PURE__ */ React.createElement("svg", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "sort-asc"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M839.6 433.8L749 150.5c-1.2-3.9-4.8-6.5-8.9-6.5h-77.4c-4.1 0-7.6 2.6-8.9 6.5l-91.3 283.3c-0.3 0.9-0.5 1.9-0.5 2.9 0 5.1 4.2 9.3 9.3 9.3h56.4c4.2 0 7.8-2.8 9-6.8l17.5-61.6h89l17.3 61.5c1.1 4 4.8 6.8 9 6.8h61.2c1 0 1.9-0.1 2.8-0.4 2.4-0.8 4.3-2.4 5.5-4.6 1.1-2.2 1.3-4.7 0.6-7.1zM663.3 325.5l32.8-116.9h6.3l32.1 116.9h-71.2z",
      "p-id": "2263"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M806.8 818.4H677.2v-0.4l132.6-188.9c1.1-1.6 1.7-3.4 1.7-5.4v-36.4c0-5.1-4.2-9.3-9.3-9.3h-204c-5.1 0-9.3 4.2-9.3 9.3v43c0 5.1 4.2 9.3 9.3 9.3h122.6v0.4L587.7 828.9c-1.1 1.6-1.7 3.4-1.7 5.4v36.4c0 5.1 4.2 9.3 9.3 9.3h211.4c5.1 0 9.3-4.2 9.3-9.3v-43c0.1-5.1-4.1-9.3-9.2-9.3z",
      "p-id": "2264"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M310.3 167.1c-3.2-4.1-9.4-4.1-12.6 0L185.7 309c-4.2 5.3-0.4 13 6.3 13h76v530c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V322h76c6.7 0 10.5-7.8 6.3-13l-112-141.9z",
      "p-id": "2265"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "more"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M224 597.333333C183.466667 597.333333 149.333333 563.2 149.333333 522.666667S183.466667 448 224 448s74.666667 34.133333 74.666667 74.666667-32 74.666667-74.666667 74.666666zM512 597.333333c-40.533333 0-74.666667-34.133333-74.666667-74.666666S471.466667 448 512 448s74.666667 34.133333 74.666667 74.666667S554.666667 597.333333 512 597.333333zM800 597.333333c-40.533333 0-74.666667-34.133333-74.666667-74.666666s34.133333-74.666667 74.666667-74.666667 74.666667 34.133333 74.666667 74.666667-32 74.666667-74.666667 74.666666z"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      width: "24",
      height: "24",
      id: "text-clip"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M217.6 810.666667h76.8a4.266667 4.266667 0 0 0 4.266667-4.266667V217.6a4.266667 4.266667 0 0 0-4.266667-4.266667H217.6a4.266667 4.266667 0 0 0-4.266667 4.266667v588.8a4.266667 4.266667 0 0 0 4.266667 4.266667zM725.333333 217.6v247.466667a4.266667 4.266667 0 0 1-4.266666 4.266666H388.266667a4.266667 4.266667 0 0 0-4.266667 4.266667v76.8a4.266667 4.266667 0 0 0 4.266667 4.266667h332.8a4.266667 4.266667 0 0 1 4.266666 4.266666v247.466667a4.266667 4.266667 0 0 0 4.266667 4.266667h76.8a4.266667 4.266667 0 0 0 4.266667-4.266667V217.6a4.266667 4.266667 0 0 0-4.266667-4.266667h-76.8a4.266667 4.266667 0 0 0-4.266667 4.266667z",
      "p-id": "13371",
      fill: "#525C6F"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-none"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M657.066667 620.088889c24.177778 0 39.822222-24.177778 31.288889-46.933333L509.155556 150.755556c-14.222222-34.133333-64-34.133333-78.222223 0L250.311111 573.155556c-9.955556 22.755556 7.111111 46.933333 31.288889 46.933333 14.222222 0 25.6-8.533333 31.288889-21.333333l36.977778-92.444445h240.355555l36.977778 92.444445c4.266667 12.8 17.066667 21.333333 29.866667 21.333333z m-285.866667-170.666667L469.333333 203.377778l98.133334 246.044444H371.2zM704 662.755556c-11.377778 11.377778-11.377778 28.444444 0 39.822222l45.511111 45.511111H204.8c-15.644444 0-28.444444 12.8-28.444444 28.444444s12.8 28.444444 28.444444 28.444445h544.711111l-45.511111 45.511111c-11.377778 11.377778-11.377778 28.444444 0 39.822222 11.377778 11.377778 28.444444 11.377778 39.822222 0L839.111111 796.444444c11.377778-11.377778 11.377778-28.444444 0-39.822222l-93.866667-93.866666c-11.377778-11.377778-29.866667-11.377778-41.244444 0z",
      "p-id": "17165"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-angleup"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M634.311111 398.222222c17.066667-17.066667 11.377778-45.511111-11.377778-54.044444L196.266667 170.666667c-35.555556-14.222222-69.688889 21.333333-55.466667 55.466666l172.088889 426.666667c8.533333 22.755556 38.4 28.444444 54.044444 11.377778 9.955556-9.955556 12.8-24.177778 7.111111-36.977778l-39.822222-91.022222 170.666667-170.666667 91.022222 39.822222c12.8 4.266667 28.444444 2.844444 38.4-7.111111z m-322.844444 81.066667l-105.244445-243.2L449.422222 341.333333l-137.955555 137.955556zM696.888889 393.955556c0 15.644444 12.8 28.444444 28.444444 28.444444h64L403.911111 807.822222c-11.377778 11.377778-11.377778 28.444444 0 39.822222 11.377778 11.377778 28.444444 11.377778 39.822222 0l385.422223-385.422222V526.222222c0 15.644444 12.8 28.444444 28.444444 28.444445s28.444444-12.8 28.444444-28.444445v-133.688889c0-15.644444-12.8-28.444444-28.444444-28.444444h-133.688889c-14.222222 1.422222-27.022222 14.222222-27.022222 29.866667z",
      "p-id": "17929"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-angledown"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M625.777778 634.311111c17.066667 17.066667 45.511111 11.377778 54.044444-11.377778l172.088889-426.666666c14.222222-35.555556-21.333333-69.688889-55.466667-55.466667L371.2 312.888889c-22.755556 8.533333-28.444444 38.4-11.377778 54.044444 9.955556 9.955556 24.177778 12.8 36.977778 7.111111l91.022222-39.822222 170.666667 170.666667-39.822222 92.444444c-4.266667 11.377778-2.844444 27.022222 7.111111 36.977778z m-81.066667-322.844444l243.2-105.244445L682.666667 449.422222l-137.955556-137.955555zM630.044444 696.888889c-15.644444 0-28.444444 12.8-28.444444 28.444444v64L216.177778 403.911111c-11.377778-11.377778-28.444444-11.377778-39.822222 0-11.377778 11.377778-11.377778 28.444444 0 39.822222l385.422222 385.422223H497.777778c-15.644444 0-28.444444 12.8-28.444445 28.444444s12.8 28.444444 28.444445 28.444444h133.688889c15.644444 0 28.444444-12.8 28.444444-28.444444v-133.688889c-1.422222-14.222222-14.222222-27.022222-29.866667-27.022222z",
      "p-id": "18084"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-vertical"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M465.066667 672.711111c-24.177778 0-39.822222-24.177778-31.288889-46.933333l179.2-423.822222c14.222222-34.133333 64-34.133333 78.222222 0L871.822222 625.777778c9.955556 22.755556-7.111111 46.933333-31.288889 46.933333-14.222222 0-25.6-8.533333-31.288889-21.333333l-36.977777-92.444445H531.911111l-36.977778 92.444445c-4.266667 12.8-17.066667 21.333333-29.866666 21.333333z m285.866666-170.666667L652.8 256 554.666667 502.044444h196.266666zM157.866667 704c11.377778-11.377778 28.444444-11.377778 39.822222 0l45.511111 45.511111V204.8c0-15.644444 12.8-28.444444 28.444444-28.444444s28.444444 12.8 28.444445 28.444444v544.711111l45.511111-45.511111c11.377778-11.377778 28.444444-11.377778 39.822222 0 11.377778 11.377778 11.377778 28.444444 0 39.822222L292.977778 839.111111c-11.377778 11.377778-28.444444 11.377778-39.822222 0l-93.866667-93.866667c-12.8-11.377778-12.8-29.866667-1.422222-41.244444z",
      "p-id": "18239"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-up"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M620.088889 366.933333c0-24.177778-24.177778-39.822222-46.933333-31.288889L150.755556 514.844444c-34.133333 14.222222-34.133333 64 0 78.222223l423.822222 179.2c22.755556 9.955556 46.933333-7.111111 46.933333-31.288889 0-14.222222-8.533333-25.6-21.333333-31.288889l-92.444445-36.977778V433.777778l92.444445-36.977778c11.377778-4.266667 19.911111-17.066667 19.911111-29.866667z m-170.666667 285.866667L203.377778 554.666667l246.044444-98.133334v196.266667zM662.755556 320c11.377778 11.377778 28.444444 11.377778 39.822222 0l45.511111-45.511111v544.711111c0 15.644444 12.8 28.444444 28.444444 28.444444s28.444444-12.8 28.444445-28.444444V274.488889l45.511111 45.511111c11.377778 11.377778 28.444444 11.377778 39.822222 0 11.377778-11.377778 11.377778-28.444444 0-39.822222L796.444444 184.888889c-11.377778-11.377778-28.444444-11.377778-39.822222 0l-93.866666 93.866667c-11.377778 11.377778-11.377778 29.866667 0 41.244444z",
      "p-id": "18394"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "screenshot"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M320 704V128H256v128H128v64h128v448h448v128h64v-128h128v-64H320z m384-64h64V256H384v64h320v320z",
      "p-id": "3788"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "conditionFormat",
      width: "20"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M128 128h768v768H128V128z m64 512v128h128v-128H192z m256 0v128h192v-128H448zM192 448v128h128V448H192z m0-192v128h128V256H192z m192 0v128h192V256H384z m320 384v128h128v-128h-128z m0-192v128h128V448h-128z m0-192v128h128V256h-128z",
      "p-id": "1955"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "splitColumn"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M143.36 184.32v163.84h737.28v-163.84h-737.28z m-40.96-40.96h819.2v245.76h-819.2v-245.76z m342.016 333.824l67.584 67.584 67.584-67.584c8.192-8.192 20.48-8.192 28.672 0 8.192 8.192 8.192 20.48 0 28.672l-96.256 96.256-96.256-96.256c-8.192-8.192-8.192-20.48 0-28.672 8.192-8.192 20.48-8.192 28.672 0z m-342.016 157.696h368.64v245.76h-368.64v-245.76z m450.56 0h368.64v245.76h-368.64v-245.76z m-409.6 204.8h286.72v-163.84h-286.72v163.84z m450.56 0h286.72v-163.84h-286.72v163.84z",
      "p-id": "1984"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "locationCondition"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M938.666667 388.266667H584.533333V247.466667a21.333333 21.333333 0 0 0-21.333333-21.333334H85.333333A21.333333 21.333333 0 0 0 64 247.466667v324.266666a21.333333 21.333333 0 0 0 21.333333 21.333334h277.333334V785.066667a21.333333 21.333333 0 0 0 21.333333 21.333333h554.666667a21.333333 21.333333 0 0 0 21.333333-21.333333V409.6a21.333333 21.333333 0 0 0-21.333333-21.333333z m-832 162.133333v-281.6h435.2v119.466667H384a21.333333 21.333333 0 0 0-21.333333 21.333333v140.8h-256z",
      "p-id": "9672"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "dataVerification"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M510.9 921.6l-107.8-66.2c-124.6-76.5-202-214.8-202-361.1V243.9h21.7c205.1 0 262-115.5 267.8-128.6l5.7-13 28.7-0.3 6.2 13.1c5.9 13.3 62.8 128.8 267.8 128.8h21.7v250.4c0 146.3-77.4 284.6-202 361.1l-107.8 66.2zM244.5 287v207.3c0 131.2 69.5 255.4 181.3 324.1l85.1 52.2 85.1-52.2c111.8-68.6 181.3-192.8 181.3-324.1V287c-157.7-6.1-234.1-77.8-266.4-121.7-32.2 43.8-108.6 115.6-266.4 121.7z",
      "p-id": "5514"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M502.2 617.3c-5.6 0-11.1-2.1-15.4-6.4L410 534.1c-8.5-8.5-8.5-22.2 0-30.7s22.2-8.5 30.7 0l61.4 61.4 108.7-108.7c8.5-8.5 22.2-8.5 30.7 0s8.5 22.2 0 30.7l-124 124.1c-4.2 4.2-9.8 6.4-15.3 6.4z",
      "p-id": "5515"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "text-rotation-down"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M403.911111 657.066667c0 24.177778 24.177778 39.822222 46.933333 31.288889L873.244444 509.155556c34.133333-14.222222 34.13333299-64 0-78.222223L450.844444 250.311111c-22.755556-9.955556-46.933333 7.111111-46.933333 31.288889 0 14.222222 8.533333 25.6 21.333333 31.288889l92.444445 36.977778-1e-8 240.355555-92.44444499 36.977778c-12.8 4.266667-21.333333 17.066667-21.333333 29.866667z m170.666667-285.86666701L820.622222 469.33333299l-246.044444 98.13333401L574.577778 371.19999999zM361.244444 704c-11.377778-11.377778-28.444444-11.377778-39.822222 0l-45.511111 45.511111L275.911111 204.79999999c0-15.644444-12.8-28.444444-28.44444399-28.44444399s-28.444444 12.8-28.44444501 28.444444l-1e-8 544.711111-45.51111099-45.511111c-11.377778-11.377778-28.444444-11.377778-39.822222 0-11.377778 11.377778-11.377778 28.444444 0 39.822222L227.555556 839.111111c11.377778 11.377778 28.444444 11.377778 39.822222-1e-8l93.866666-93.86666699c11.377778-11.377778 11.377778-29.866667 0-41.244444z",
      "p-id": "10914"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "search"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M469.333 192c153.174 0 277.334 124.16 277.334 277.333 0 68.054-24.534 130.411-65.216 178.688L846.336 818.24l-48.341 49.877L630.4 695.125a276.053 276.053 0 0 1-161.067 51.542C316.16 746.667 192 622.507 192 469.333S316.16 192 469.333 192z m0 64C351.51 256 256 351.51 256 469.333s95.51 213.334 213.333 213.334 213.334-95.51 213.334-213.334S587.157 256 469.333 256z",
      "p-id": "11202"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "link"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M577.155781 655.619241L431.54903 801.139578a119.509873 119.509873 0 0 1-169.111224 0l-26.442532-25.924051a119.6827 119.6827 0 0 1 0-169.111223L366.393249 475.274262a21.344135 21.344135 0 0 1 30.417553 0 21.516962 21.516962 0 0 1 0 30.503966L266.585654 636.176203a76.389536 76.389536 0 0 0 0 108.016877l26.442532 26.442532a76.389536 76.389536 0 0 0 108.016877 0l145.520338-145.606751a76.389536 76.389536 0 0 0 0-108.016878L535.763713 505.864641A21.516962 21.516962 0 0 1 535.763713 475.274262a21.344135 21.344135 0 0 1 30.417553 0l11.233755 11.147341a119.6827 119.6827 0 0 1-0.25924 169.197638z",
      "p-id": "28239"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M546.565401 517.011983L535.763713 505.864641A21.516962 21.516962 0 0 1 535.763713 475.274262a21.344135 21.344135 0 0 1 30.417553 0l11.233755 11.147341",
      "p-id": "28240"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M446.844219 368.380759l145.606751-145.520337a119.509873 119.509873 0 0 1 169.111224 0l26.442532 26.356118a119.6827 119.6827 0 0 1 0 169.111224L657.606751 548.639325a21.344135 21.344135 0 0 1-30.417553 0 21.516962 21.516962 0 0 1 0-30.503966l130.225148-130.311562a76.389536 76.389536 0 0 0 0-108.016877l-26.442532-26.442532a76.389536 76.389536 0 0 0-108.016877 0L477.434599 398.971139a76.389536 76.389536 0 0 0 0 108.016878L488.581941 518.481013a21.516962 21.516962 0 0 1 0 30.503966 21.344135 21.344135 0 0 1-30.417553 0l-11.233755-11.147342a119.6827 119.6827 0 0 1-0.086414-169.456878z",
      "p-id": "28241"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M477.434599 506.988017L488.581941 518.481013a21.516962 21.516962 0 0 1 0 30.503966 21.344135 21.344135 0 0 1-30.417553 0l-11.233755-11.147342",
      "p-id": "28242"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "copy"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M832 128c-12.8-76.8-76.8-128-160-128h-448C102.4 0 0 102.4 0 224v448c0 76.8 57.6 140.8 128 160 12.8 76.8 76.8 128 160 128h512c89.6 0 160-70.4 160-160v-512c0-76.8-57.6-140.8-128-160zM64 672v-448C64 134.4 134.4 64 224 64h448c44.8 0 76.8 25.6 89.6 64H288C198.4 128 128 198.4 128 288v473.6c-38.4-12.8-64-44.8-64-89.6z m832 128c0 51.2-44.8 96-96 96h-512c-51.2 0-96-44.8-96-96v-512C192 236.8 236.8 192 288 192h512c51.2 0 96 44.8 96 96v512z",
      "p-id": "28791"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "pencil"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M966.283012 57.28336A194.600516 194.600516 0 0 0 828.144425 0.000203c-49.932663 0-100.118792 19.009897-138.138586 57.283157l-667.12066 667.12066-22.811877 276.784103c-1.013861 12.166334 8.61782 22.304946 20.530689 22.304946h1.774257l276.784104-22.811876 667.12066-667.12066c76.293054-76.293054 76.293054-199.984119 0-276.277173zM271.534635 941.116848l-205.813821 16.72871L82.702989 751.778272l547.231575-547.231575 189.085111 189.085111-547.48504 547.48504zM922.686981 289.964502l-60.071275 60.071275-189.085111-189.085111 60.071275-60.071275c25.34653-25.34653 58.803949-39.033656 94.542555-39.033656 35.738607 0 69.196026 13.940591 94.542556 39.033656 52.213851 52.213851 52.213851 136.87126 0 189.085111z",
      "p-id": "40167"
    })), /* @__PURE__ */ React.createElement("symbol", {
      fill: "#535A68",
      id: "unlink",
      viewBox: "0 0 1024 1024"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M240.469333 240.469333l241.194667 241.194667 90.965333-90.965333a42.88 42.88 0 0 1 60.672 60.672L542.293333 542.293333l241.237334 241.237334a42.666667 42.666667 0 0 1-60.330667 60.330666l-119.936-119.893333-151.893333 151.893333a214.4 214.4 0 0 1-309.674667-296.533333l6.4-6.698667 151.936-151.893333-119.893333-119.893333a42.666667 42.666667 0 0 1 60.330666-60.373334z m120.192 240.896l-151.893333 151.893334a128.64 128.64 0 0 0 176.426667 187.136l5.546666-5.162667 151.850667-151.936-60.629333-60.629333-30.592 30.634666a42.88 42.88 0 1 1-60.672-60.672l30.634666-30.592-60.672-60.672z m515.2-333.226666a214.4 214.4 0 0 1 0 303.232l-121.301333 121.258666A42.88 42.88 0 1 1 693.973333 512l121.258667-121.301333a128.64 128.64 0 0 0-181.930667-181.930667L512 330.069333a42.88 42.88 0 1 1-60.629333-60.629333l121.258666-121.301333a214.4 214.4 0 0 1 303.232 0z m-333.653333 273.365333l-60.373333 60.330667 60.330666 60.330666 60.330667-60.330666-60.330667-60.330667z",
      "p-id": "39251"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "filter"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M872.533333 134.4c-12.8-10.666667-29.866667-17.066667-49.066666-17.066667H198.4C157.866667 117.333333 123.733333 151.466667 123.733333 192c0 17.066667 6.4 34.133333 17.066667 49.066667l256 302.933333v251.733333c0 12.8 6.4 23.466667 17.066667 27.733334l162.133333 81.066666c4.266667 2.133333 8.533333 4.266667 14.933333 4.266667 6.4 0 10.666667-2.133333 17.066667-4.266667 8.533333-6.4 14.933333-17.066667 14.933333-27.733333V541.866667l256-302.933334c12.8-14.933333 19.2-34.133333 17.066667-53.333333 2.133333-19.2-6.4-38.4-23.466667-51.2z m-38.4 64L569.6 509.866667c-4.266667 6.4-8.533333 12.8-8.533333 21.333333v292.266667l-98.133334-49.066667V531.2c0-8.533333-2.133333-14.933333-8.533333-21.333333L189.866667 198.4c0-2.133333-2.133333-4.266667-2.133334-6.4 0-6.4 4.266667-10.666667 10.666667-10.666667h625.066667c2.133333 0 4.266667 0 6.4 2.133334 2.133333 2.133333 4.266667 6.4 4.266666 6.4 2.133333 2.133333 2.133333 6.4 0 8.533333z",
      "p-id": "43580"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "filter1"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M608 864C588.8 864 576 851.2 576 832L576 448c0-6.4 6.4-19.2 12.8-25.6L787.2 256c6.4-6.4 6.4-19.2 0-19.2 0-6.4-6.4-12.8-19.2-12.8L256 224c-12.8 0-19.2 6.4-19.2 12.8 0 6.4-6.4 12.8 6.4 19.2l198.4 166.4C441.6 428.8 448 441.6 448 448l0 256c0 19.2-12.8 32-32 32S384 723.2 384 704L384 460.8 198.4 307.2c-25.6-25.6-32-64-19.2-96C185.6 179.2 217.6 160 256 160L768 160c32 0 64 19.2 76.8 51.2 12.8 32 6.4 70.4-19.2 89.6l-192 160L633.6 832C640 851.2 627.2 864 608 864z",
      "p-id": "43727"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "eraser"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M596.437333 85.333333a42.837333 42.837333 0 0 0-30.549333 13.824l-469.333333 512a42.666667 42.666667 0 0 0 1.28 59.008l170.666666 170.666667A42.496 42.496 0 0 0 298.666667 853.333333h512v-85.333333h-195.669334l311.168-311.168a42.538667 42.538667 0 0 0 0-60.330667l-298.666666-298.666666A43.221333 43.221333 0 0 0 596.437333 85.333333z m-102.144 682.666667H316.330667l-129.28-129.28 268.8-293.205333 230.485333 230.485333-192.042667 192z m252.373334-252.330667l-233.130667-233.130666 85.12-92.842667L835.669333 426.666667 746.666667 515.669333z",
      "p-id": "50819"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1057 1024",
      fill: "#535A68",
      id: "sort"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M438.634667 192v644.202667l-0.810667 5.781333c-1.152 7.210667-2.304 8.704-8.64 17.002667l-7.168 3.925333c-15.914667 8.490667-18.282667 7.168-38.4-3.925333L149.333333 624.533333l45.269334-45.226666 180.032 180.138666V192h64z m216.96 10.005333l231.04 231.146667-45.269334 45.248L661.333333 298.261333V865.706667h-64V226.133333a34.133333 34.133333 0 0 1 58.282667-24.128z",
      "p-id": "52781"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "filter-fill"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M776.341333 170.666667a64 64 0 0 1 49.557334 104.512L627.541333 517.76v273.386667L398.293333 687.018667v-169.237334l-192.469333-243.413333A64 64 0 0 1 256 170.666667h520.341333z",
      "p-id": "18344"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#ffffff",
      id: "filter-fill-white"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M776.341333 170.666667a64 64 0 0 1 49.557334 104.512L627.541333 517.76v273.386667L398.293333 687.018667v-169.237334l-192.469333-243.413333A64 64 0 0 1 256 170.666667h520.341333z",
      "p-id": "18344"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "all-sheets"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M849.427 1000.999h-157.9c-73.785 0-132.809-59.029-132.809-132.809v-258.243c0-14.759 10.33-26.562 25.088-29.513 4.427-1.472 8.853-2.953 13.278-2.953h252.337c73.785 0 132.809 59.029 132.809 132.809v157.9c-1.472 72.309-60.5 132.809-132.809 132.809zM616.268 636.505v231.684c0 39.844 32.468 73.785 73.785 73.785h157.9c39.844 0 73.785-32.468 73.785-73.785v-157.9c0-39.844-32.468-73.785-73.785-73.785h-231.684z",
      "p-id": "4941"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M315.23 1000.999h-147.571c-76.736 0-137.241-61.981-137.241-137.241v-147.571c0-76.736 61.981-137.241 137.241-137.241h247.911c4.427 0 8.853 1.472 13.278 2.953 14.759 1.472 25.088 14.759 25.088 29.513v253.814c0 73.785-61.981 135.764-138.711 135.764zM167.657 636.505c-42.796 0-78.211 35.418-78.211 78.211v147.571c0 44.269 35.418 78.211 78.211 78.211h147.571c42.796 0 78.211-35.418 78.211-78.211v-225.779h-225.779z",
      "p-id": "4942"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M415.576 471.232h-255.291c-72.309 0-129.859-57.549-129.859-129.859v-163.801c0-72.309 57.549-129.859 129.859-129.859h163.801c72.309 0 129.859 57.549 129.859 129.859v261.199c0 14.759-10.33 26.562-25.088 29.513-4.427 1.472-8.853 2.953-13.278 2.953zM158.805 105.259c-38.369 0-70.836 32.468-70.836 70.836v165.279c0 38.369 32.468 70.836 70.836 70.836h234.634v-234.634c0-38.369-32.468-70.836-70.836-70.836h-163.801z",
      "p-id": "4943"
    }), /* @__PURE__ */ React.createElement("path", {
      d: "M847.948 471.232h-252.337c-4.427 0-8.853-1.472-13.278-2.953-14.759-1.472-25.088-14.759-25.088-29.513v-258.243c0-73.785 60.5-134.287 134.287-134.287h156.423c73.785 0 134.287 60.5 134.287 134.287v156.423c-1.472 73.785-60.5 134.287-134.287 134.287zM616.268 412.199h230.207c41.318 0 75.263-33.941 75.263-75.263v-156.423c0-41.318-33.941-75.263-75.263-75.263h-156.423c-41.318 0-75.263 33.941-75.263 75.263v231.684z",
      "p-id": "4944"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "hidden"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M849.152 665.429333c62.762667-69.674667 86.826667-138.538667 87.296-139.904a42.410667 42.410667 0 0 0 0-27.008C935.552 495.658667 837.674667 213.333333 512 213.333333c-37.802667 0-72.192 4.138667-104.064 10.837334l75.776 75.776c9.301333-0.554667 18.517333-1.28 28.288-1.28 228.309333 0 316.757333 164.096 338.176 213.333333a369.365333 369.365333 0 0 1-60.544 93.866667l59.52 59.562666zM512 810.666667c78.293333 0 143.146667-16.597333 196.906667-41.429334l156.928 156.928 60.330666-60.330666-768-768-60.330666 60.330666 141.610666 141.610667c-111.530667 83.285333-151.338667 196.906667-151.936 198.698667a42.410667 42.410667 0 0 0 0 27.008C88.448 528.341333 186.325333 810.666667 512 810.666667zM299.989333 360.32l96.938667 96.938667c-22.229333 47.488-14.378667 106.282667 24.533333 145.194666s97.706667 46.805333 145.194667 24.533334l76.842667 76.842666A394.325333 394.325333 0 0 1 512 725.333333c-228.309333 0-316.757333-164.096-338.176-213.333333a366.933333 366.933333 0 0 1 126.165333-151.68z",
      "p-id": "19355"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "check"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M439.439404 776.947278a32.717146 32.717146 0 0 1-21.343097-7.892761L185.810916 570.228169c-13.779841-11.795651-15.389502-32.527834-3.593851-46.308698 11.795651-13.778818 32.528857-15.390525 46.308699-3.593852L435.957093 697.877431l349.863273-405.566946c11.846816-13.736862 32.588209-15.265682 46.323025-3.415796 13.733792 11.847839 15.263635 32.587186 3.414773 46.322002l-371.235023 430.340165c-6.492878 7.52744-15.661701 11.390421-24.883737 11.390422z",
      fill: "",
      "p-id": "5612"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#A8ABB0",
      id: "rightArrow"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M781.963636 495.709091l-418.909091-323.490909c-20.945455-16.290909-37.236364-9.309091-37.236363 16.290909v646.981818c0 25.6 16.290909 32.581818 37.236363 16.290909l418.909091-323.490909c11.636364-9.309091 11.636364-23.272727 0-32.581818z",
      "p-id": "5380"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "downArrow"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M163.396608 289.168384c-40.577024 0-66.526208 54.183936-35.44064 85.25824L477.217792 723.704832c20.031488 20.031488 49.82272 20.031488 69.853184 0l349.274112-349.278208c30.30528-30.294016 6.677504-85.25824-34.927616-85.25824L163.396608 289.168384z",
      "p-id": "2683"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#272636",
      id: "headDownArrow"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M0 511.976727C0 229.678545 229.725091 0 511.976727 0s511.976727 229.632 511.976727 511.976727c0 282.391273-229.725091 511.976727-511.976727 511.976727C229.725091 1024 0 794.368 0 511.976727M955.717818 511.976727c0-244.898909-199.121455-444.206545-443.741091-444.206545-244.666182 0-443.694545 199.307636-443.694545 444.206545 0 244.945455 199.121455 444.253091 443.694545 444.253091C756.642909 956.276364 955.717818 756.968727 955.717818 511.976727M230.027636 419.025455c0-6.562909 2.420364-13.102545 7.563636-18.059636 9.914182-9.960727 26.042182-9.960727 36.096 0l238.289455 236.916364L750.312727 401.105455c9.960727-9.914182 26.135273-9.914182 36.305455 0 9.914182 9.960727 9.914182 26.042182 0 35.956364L511.976727 709.678545 237.474909 436.922182C232.424727 432.104727 230.027636 425.588364 230.027636 419.025455",
      "p-id": "5142"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      id: "tab"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M960 591.424V368.96c0-0.288 0.16-0.512 0.16-0.768S960 367.68 960 367.424V192a32 32 0 0 0-32-32H96a32 32 0 0 0-32 32v175.424c0 0.288-0.16 0.512-0.16 0.768s0.16 0.48 0.16 0.768v222.464c0 0.288-0.16 0.512-0.16 0.768s0.16 0.48 0.16 0.768V864a32 32 0 0 0 32 32h832a32 32 0 0 0 32-32v-271.04c0-0.288 0.16-0.512 0.16-0.768S960 591.68 960 591.424z m-560-31.232v-160H608v160h-208z m208 64V832h-208v-207.808H608z m-480-224h208v160H128v-160z m544 0h224v160h-224v-160zM896 224v112.192H128V224h768zM128 624.192h208V832H128v-207.808zM672 832v-207.808h224V832h-224z",
      "p-id": "3023"
    })), /* @__PURE__ */ React.createElement("symbol", {
      viewBox: "0 0 1024 1024",
      fill: "#535A68",
      id: "default"
    }, /* @__PURE__ */ React.createElement("path", {
      d: "M844.8 896c25.6 0 51.2-19.2 51.2-51.2v-185.6h-51.2c-44.8 0-83.2-38.4-83.2-83.2s38.4-83.2 83.2-83.2h51.2V313.6c0-25.6-19.2-51.2-51.2-51.2h-134.4c0-70.4-57.6-128-128-128S448 185.6 448 256H313.6c-25.6 0-51.2 19.2-51.2 51.2V448C185.6 448 128 505.6 128 576s57.6 128 128 128v134.4c0 25.6 19.2 51.2 51.2 51.2h185.6v-51.2c0-44.8 38.4-83.2 83.2-83.2 44.8 0 83.2 38.4 83.2 83.2v57.6h185.6zM576 710.4c-70.4 0-128 57.6-128 128H307.2v-185.6H256c-44.8 0-83.2-38.4-83.2-83.2S211.2 492.8 256 492.8h51.2V307.2h185.6V256c0-44.8 38.4-83.2 83.2-83.2 44.8 0 83.2 38.4 83.2 83.2v51.2h185.6V448c-70.4 0-128 57.6-128 128s57.6 128 128 128v140.8H704c6.4-70.4-51.2-134.4-128-134.4z",
      fill: "",
      "p-id": "36983"
    }))));
  };
  var ChangeColor = function ChangeColor2(_ref) {
    var triggerParentUpdate = _ref.triggerParentUpdate;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var _locale = locale(context), toolbar = _locale.toolbar, sheetconfig = _locale.sheetconfig, button = _locale.button;
    var _useState = reactExports.useState("#000000"), _useState2 = _slicedToArray(_useState, 2), inputColor = _useState2[0], setInputColor = _useState2[1];
    var _useState3 = reactExports.useState(context.luckysheetfile[getSheetIndex(context, context.currentSheetId)].color), _useState4 = _slicedToArray(_useState3, 2), selectColor = _useState4[0], setSelectColor = _useState4[1];
    var certainBtn = reactExports.useCallback(function() {
      setSelectColor(inputColor);
    }, [inputColor]);
    reactExports.useEffect(function() {
      setContext(function(ctx) {
        if (ctx.allowEdit === false) return;
        var index2 = getSheetIndex(ctx, ctx.currentSheetId);
        ctx.luckysheetfile[index2].color = selectColor;
      });
    }, [selectColor, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      id: "fortune-change-color"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "color-reset",
      onClick: function onClick() {
        return setSelectColor(void 0);
      }
    }, sheetconfig.resetColor), /* @__PURE__ */ React.createElement("div", {
      className: "custom-color"
    }, /* @__PURE__ */ React.createElement("div", null, toolbar.customColor, ":"), /* @__PURE__ */ React.createElement("input", {
      type: "color",
      value: inputColor,
      onChange: function onChange(e) {
        return setInputColor(e.target.value);
      },
      onFocus: function onFocus() {
        triggerParentUpdate(true);
      },
      onBlur: function onBlur() {
        triggerParentUpdate(false);
      }
    }), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        certainBtn();
      }
    }, button.confirm)), /* @__PURE__ */ React.createElement(ColorPicker, {
      onPick: function onPick(color) {
        setInputColor(color);
        setSelectColor(color);
      }
    }));
  };
  var SheetTabContextMenu = function SheetTabContextMenu2() {
    var _settings$sheetTabCon;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings;
    var _context$sheetTabCont = context.sheetTabContextMenu, x2 = _context$sheetTabCont.x, y2 = _context$sheetTabCont.y, sheet = _context$sheetTabCont.sheet, onRename = _context$sheetTabCont.onRename;
    var _locale = locale(context), sheetconfig = _locale.sheetconfig;
    var _useState = reactExports.useState({
      x: -1,
      y: -1
    }), _useState2 = _slicedToArray(_useState, 2), position = _useState2[0], setPosition = _useState2[1];
    var _useState3 = reactExports.useState(false), _useState4 = _slicedToArray(_useState3, 2), isShowChangeColor = _useState4[0], setIsShowChangeColor = _useState4[1];
    var _useState5 = reactExports.useState(false), _useState6 = _slicedToArray(_useState5, 2), isShowInputColor = _useState6[0], setIsShowInputColor = _useState6[1];
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert, hideAlert = _useAlert.hideAlert;
    var containerRef = reactExports.useRef(null);
    var close = reactExports.useCallback(function() {
      setContext(function(ctx) {
        ctx.sheetTabContextMenu = {};
      });
    }, [setContext]);
    reactExports.useLayoutEffect(function() {
      var _containerRef$current;
      var rect = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect();
      if (rect && x2 != null && y2 != null) {
        setPosition({
          x: x2,
          y: y2 - rect.height
        });
      }
    }, [x2, y2]);
    useOutsideClick(containerRef, close, [close]);
    var moveSheet = reactExports.useCallback(function(delta) {
      if (context.allowEdit === false) return;
      if (!sheet) return;
      setContext(function(ctx) {
        var currentOrder = -1;
        _$1.sortBy(ctx.luckysheetfile, ["order"]).forEach(function(_sheet, i2) {
          _sheet.order = i2;
          if (_sheet.id === sheet.id) {
            currentOrder = i2;
          }
        });
        index.setSheetOrder(ctx, _defineProperty({}, sheet.id, currentOrder + delta));
      });
    }, [context.allowEdit, setContext, sheet]);
    var hideSheet2 = reactExports.useCallback(function() {
      if (context.allowEdit === false) return;
      if (!sheet) return;
      setContext(function(ctx) {
        var shownSheets = ctx.luckysheetfile.filter(function(oneSheet) {
          return _$1.isUndefined(oneSheet.hide) || (oneSheet === null || oneSheet === void 0 ? void 0 : oneSheet.hide) !== 1;
        });
        if (shownSheets.length > 1) {
          index.hideSheet(ctx, sheet.id);
        } else {
          showAlert(sheetconfig.noMoreSheet, "ok");
        }
      });
    }, [context.allowEdit, setContext, sheet, showAlert, sheetconfig]);
    var copySheet2 = reactExports.useCallback(function() {
      if (context.allowEdit === false) return;
      if (!(sheet === null || sheet === void 0 ? void 0 : sheet.id)) return;
      setContext(function(ctx) {
        index.copySheet(ctx, sheet.id);
      }, {
        addSheetOp: true
      });
    }, [context.allowEdit, setContext, sheet === null || sheet === void 0 ? void 0 : sheet.id]);
    var updateShowInputColor = reactExports.useCallback(function(state) {
      setIsShowInputColor(state);
    }, []);
    var focusSheet = reactExports.useCallback(function() {
      if (context.allowEdit === false) return;
      if (!(sheet === null || sheet === void 0 ? void 0 : sheet.id)) return;
      setContext(function(ctx) {
        _$1.forEach(ctx.luckysheetfile, function(sheetfile) {
          sheetfile.status = sheet.id === sheetfile.id ? 1 : 0;
        });
      });
    }, [context.allowEdit, setContext, sheet === null || sheet === void 0 ? void 0 : sheet.id]);
    if (!sheet || x2 == null || y2 == null) return null;
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-context-menu luckysheet-cols-menu",
      onContextMenu: function onContextMenu(e) {
        return e.stopPropagation();
      },
      style: {
        left: position.x,
        top: position.y,
        overflow: "visible"
      },
      ref: containerRef
    }, (_settings$sheetTabCon = settings.sheetTabContextMenu) === null || _settings$sheetTabCon === void 0 ? void 0 : _settings$sheetTabCon.map(function(name, i2) {
      if (name === "delete") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            var shownSheets = context.luckysheetfile.filter(function(singleSheet) {
              return _$1.isUndefined(singleSheet.hide) || singleSheet.hide !== 1;
            });
            if (context.luckysheetfile.length > 1 && shownSheets.length > 1) {
              showAlert(sheetconfig.confirmDelete, "yesno", function() {
                setContext(function(ctx) {
                  deleteSheet(ctx, sheet.id);
                }, {
                  deleteSheetOp: {
                    id: sheet.id
                  }
                });
                hideAlert();
              });
            } else {
              showAlert(sheetconfig.noMoreSheet, "ok");
            }
            close();
          }
        }, sheetconfig.delete);
      }
      if (name === "rename") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            onRename === null || onRename === void 0 ? void 0 : onRename();
            close();
          }
        }, sheetconfig.rename);
      }
      if (name === "move") {
        return /* @__PURE__ */ React.createElement(React.Fragment, {
          key: name
        }, /* @__PURE__ */ React.createElement(Menu, {
          onClick: function onClick() {
            moveSheet(-1.5);
            close();
          }
        }, sheetconfig.moveLeft), /* @__PURE__ */ React.createElement(Menu, {
          onClick: function onClick() {
            moveSheet(1.5);
            close();
          }
        }, sheetconfig.moveRight));
      }
      if (name === "hide") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            hideSheet2();
            close();
          }
        }, sheetconfig.hide);
      }
      if (name === "copy") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            copySheet2();
            close();
          }
        }, sheetconfig.copy);
      }
      if (name === "color") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onMouseEnter: function onMouseEnter() {
            setIsShowChangeColor(true);
          },
          onMouseLeave: function onMouseLeave() {
            if (!isShowInputColor) {
              setIsShowChangeColor(false);
            }
          }
        }, sheetconfig.changeColor, /* @__PURE__ */ React.createElement("span", {
          className: "change-color-triangle"
        }, /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "rightArrow",
          width: 18
        })), isShowChangeColor && context.allowEdit && /* @__PURE__ */ React.createElement(ChangeColor, {
          triggerParentUpdate: updateShowInputColor
        }));
      }
      if (name === "focus") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            focusSheet();
            close();
          }
        }, sheetconfig.focus);
      }
      if (name === "|") {
        return /* @__PURE__ */ React.createElement(Divider$1, {
          key: "divide-".concat(i2)
        });
      }
      return null;
    }));
  };
  var MoreItemsContaier = function MoreItemsContaier2(_ref) {
    var onClose = _ref.onClose, children = _ref.children;
    var containerRef = reactExports.useRef(null);
    useOutsideClick(containerRef, function() {
      onClose === null || onClose === void 0 ? void 0 : onClose();
    }, [containerRef, onClose]);
    return /* @__PURE__ */ React.createElement("div", {
      ref: containerRef,
      className: "fortune-toolbar-more-container"
    }, children);
  };
  function generateAPIs(context, setContext, handleUndo, handleRedo, settings, cellInput, scrollbarX, scrollbarY) {
    return {
      applyOp: function applyOp(ops) {
        setContext(function(ctx_) {
          var _ops$, _ops$$path, _ops$2, _ops$2$path, _ops$3;
          var _opToPatch = opToPatch(ctx_, ops), _opToPatch2 = _slicedToArray(_opToPatch, 2), patches = _opToPatch2[0], specialOps = _opToPatch2[1];
          if (specialOps.length > 0) {
            var _specialOps = _slicedToArray(specialOps, 1), specialOp = _specialOps[0];
            if (specialOp.op === "insertRowCol") {
              try {
                insertRowCol(ctx_, specialOp.value, false);
              } catch (e) {
                console.error(e);
              }
            } else if (specialOp.op === "deleteRowCol") {
              deleteRowCol(ctx_, specialOp.value);
            } else if (specialOp.op === "addSheet") {
              var _patches$filter, _patches$filter$, _specialOp$value;
              var name = (_patches$filter = patches.filter(function(path) {
                return path.path[0] === "name";
              })) === null || _patches$filter === void 0 ? void 0 : (_patches$filter$ = _patches$filter[0]) === null || _patches$filter$ === void 0 ? void 0 : _patches$filter$.value;
              if ((_specialOp$value = specialOp.value) === null || _specialOp$value === void 0 ? void 0 : _specialOp$value.id) {
                addSheet(ctx_, settings, specialOp.value.id, false, name, specialOp.value);
              }
              var fileIndex = getSheetIndex(ctx_, specialOp.value.id);
              index.initSheetData(ctx_, fileIndex, specialOp.value);
            } else if (specialOp.op === "deleteSheet") {
              deleteSheet(ctx_, specialOp.value.id);
              patches.length = 0;
            }
          }
          if (((_ops$ = ops[0]) === null || _ops$ === void 0 ? void 0 : (_ops$$path = _ops$.path) === null || _ops$$path === void 0 ? void 0 : _ops$$path[0]) === "filter_select") ctx_.luckysheet_filter_save = ops[0].value;
          else if (((_ops$2 = ops[0]) === null || _ops$2 === void 0 ? void 0 : (_ops$2$path = _ops$2.path) === null || _ops$2$path === void 0 ? void 0 : _ops$2$path[0]) === "hide") {
            if (ctx_.currentSheetId === ops[0].id) {
              var shownSheets = ctx_.luckysheetfile.filter(function(sheet) {
                return (_$1.isUndefined(sheet.hide) || (sheet === null || sheet === void 0 ? void 0 : sheet.hide) !== 1) && sheet.id !== ops[0].id;
              });
              ctx_.currentSheetId = _$1.sortBy(shownSheets, function(sheet) {
                return sheet.order;
              })[0].id;
            }
          }
          createFilterOptions(ctx_, ctx_.luckysheet_filter_save, (_ops$3 = ops[0]) === null || _ops$3 === void 0 ? void 0 : _ops$3.id);
          if (patches.length === 0) return;
          try {
            pn(ctx_, patches);
          } catch (e) {
            console.error(e);
          }
        }, {
          noHistory: true
        });
      },
      getCellValue: function getCellValue2(row, column) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return index.getCellValue(context, row, column, options);
      },
      setCellValue: function setCellValue2(row, column, value) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return setContext(function(draftCtx) {
          return index.setCellValue(draftCtx, row, column, value, cellInput, options);
        });
      },
      clearCell: function clearCell2(row, column) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return setContext(function(draftCtx) {
          return index.clearCell(draftCtx, row, column, options);
        });
      },
      setCellFormat: function setCellFormat2(row, column, attr, value) {
        var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
        return setContext(function(draftCtx) {
          return index.setCellFormat(draftCtx, row, column, attr, value, options);
        });
      },
      autoFillCell: function autoFillCell2(copyRange, applyRange, direction) {
        return setContext(function(draftCtx) {
          return index.autoFillCell(draftCtx, copyRange, applyRange, direction);
        });
      },
      freeze: function freeze2(type, range) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return setContext(function(draftCtx) {
          return index.freeze(draftCtx, type, range, options);
        });
      },
      insertRowOrColumn: function insertRowOrColumn2(type, index$12, count) {
        var direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rightbottom";
        var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
        return setContext(function(draftCtx) {
          return index.insertRowOrColumn(draftCtx, type, index$12, count, direction, options);
        });
      },
      deleteRowOrColumn: function deleteRowOrColumn2(type, start, end) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return setContext(function(draftCtx) {
          return index.deleteRowOrColumn(draftCtx, type, start, end, options);
        });
      },
      setRowHeight: function setRowHeight2(rowInfo) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var custom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return setContext(function(draftCtx) {
          return index.setRowHeight(draftCtx, rowInfo, options, custom);
        });
      },
      setColumnWidth: function setColumnWidth2(columnInfo) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var custom = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        return setContext(function(draftCtx) {
          return index.setColumnWidth(draftCtx, columnInfo, options, custom);
        });
      },
      getRowHeight: function getRowHeight2(rows) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return index.getRowHeight(context, rows, options);
      },
      getColumnWidth: function getColumnWidth2(columns) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return index.getColumnWidth(context, columns, options);
      },
      getSelection: function getSelection2() {
        return index.getSelection(context);
      },
      getFlattenRange: function getFlattenRange2(range) {
        return index.getFlattenRange(context, range);
      },
      getCellsByFlattenRange: function getCellsByFlattenRange2(range) {
        return index.getCellsByFlattenRange(context, range);
      },
      getSelectionCoordinates: function getSelectionCoordinates2() {
        return index.getSelectionCoordinates(context);
      },
      getCellsByRange: function getCellsByRange2(range) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return index.getCellsByRange(context, range, options);
      },
      getHtmlByRange: function getHtmlByRange2(range) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return index.getHtmlByRange(context, range, options);
      },
      setSelection: function setSelection2(range) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return setContext(function(draftCtx) {
          return index.setSelection(draftCtx, range, options);
        });
      },
      setCellValuesByRange: function setCellValuesByRange2(data, range) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return setContext(function(draftCtx) {
          return index.setCellValuesByRange(draftCtx, data, range, cellInput, options);
        });
      },
      setCellFormatByRange: function setCellFormatByRange2(attr, value, range) {
        var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return setContext(function(draftCtx) {
          return index.setCellFormatByRange(draftCtx, attr, value, range, options);
        });
      },
      mergeCells: function mergeCells2(ranges, type) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return setContext(function(draftCtx) {
          return index.mergeCells(draftCtx, ranges, type, options);
        });
      },
      cancelMerge: function cancelMerge2(ranges) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return setContext(function(draftCtx) {
          return index.cancelMerge(draftCtx, ranges, options);
        });
      },
      getAllSheets: function getAllSheets2() {
        return index.getAllSheets(context);
      },
      getSheet: function getSheet2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return index.getSheetWithLatestCelldata(context, options);
      },
      addSheet: function addSheet2() {
        return setContext(function(draftCtx) {
          return index.addSheet(draftCtx, settings);
        });
      },
      deleteSheet: function deleteSheet2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return setContext(function(draftCtx) {
          return index.deleteSheet(draftCtx, options);
        });
      },
      updateSheet: function updateSheet2(data) {
        return setContext(function(draftCtx) {
          return index.updateSheet(draftCtx, data);
        });
      },
      activateSheet: function activateSheet2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return setContext(function(draftCtx) {
          return index.activateSheet(draftCtx, options);
        });
      },
      setSheetName: function setSheetName2(name) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return setContext(function(draftCtx) {
          return index.setSheetName(draftCtx, name, options);
        });
      },
      setSheetOrder: function setSheetOrder2(orderList) {
        return setContext(function(draftCtx) {
          return index.setSheetOrder(draftCtx, orderList);
        });
      },
      scroll: function scroll2(options) {
        return index.scroll(context, scrollbarX, scrollbarY, options);
      },
      addPresences: function addPresences(newPresences) {
        setContext(function(draftCtx) {
          draftCtx.presences = _$1.differenceBy(draftCtx.presences || [], newPresences, function(v2) {
            return v2.userId == null ? v2.username : v2.userId;
          }).concat(newPresences);
        });
      },
      removePresences: function removePresences(arr) {
        setContext(function(draftCtx) {
          if (draftCtx.presences != null) {
            draftCtx.presences = _$1.differenceBy(draftCtx.presences, arr, function(v2) {
              return v2.userId == null ? v2.username : v2.userId;
            });
          }
        });
      },
      handleUndo,
      handleRedo,
      calculateFormula: function calculateFormula() {
        setContext(function(draftCtx) {
          _$1.forEach(draftCtx.luckysheetfile, function(sheet_obj) {
            index.calculateSheetFromula(draftCtx, sheet_obj.id);
          });
        });
      },
      dataToCelldata: function dataToCelldata2(data) {
        return index.dataToCelldata(data);
      },
      celldataToData: function celldataToData2(celldata, rowCount, colCount) {
        return index.celldataToData(celldata, rowCount, colCount);
      }
    };
  }
  var SelectItem = function SelectItem2(_ref) {
    var item = _ref.item, isChecked = _ref.isChecked, _onChange = _ref.onChange, isItemVisible = _ref.isItemVisible;
    var checked = reactExports.useMemo(function() {
      return isChecked(item.key);
    }, [isChecked, item.key]);
    return isItemVisible(item) ? /* @__PURE__ */ React.createElement("div", {
      className: "select-item"
    }, /* @__PURE__ */ React.createElement("input", {
      className: "filter-checkbox",
      type: "checkbox",
      checked,
      onChange: function onChange() {
        _onChange(item, !checked);
      }
    }), /* @__PURE__ */ React.createElement("div", null, item.text), /* @__PURE__ */ React.createElement("span", {
      className: "count"
    }, "( ".concat(item.rows.length, " )"))) : null;
  };
  var DateSelectTreeItem = function DateSelectTreeItem2(_ref2) {
    var item = _ref2.item, _ref2$depth = _ref2.depth, depth = _ref2$depth === void 0 ? 0 : _ref2$depth, initialExpand = _ref2.initialExpand, onExpand = _ref2.onExpand, isChecked = _ref2.isChecked, _onChange2 = _ref2.onChange, isItemVisible = _ref2.isItemVisible;
    var _useState = reactExports.useState(initialExpand(item.key)), _useState2 = _slicedToArray(_useState, 2), expand = _useState2[0], setExpand = _useState2[1];
    var checked = reactExports.useMemo(function() {
      return isChecked(item.key);
    }, [isChecked, item.key]);
    return isItemVisible(item) ? /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", {
      className: "select-item",
      style: {
        marginLeft: -2 + depth * 20
      },
      onClick: function onClick() {
        onExpand === null || onExpand === void 0 ? void 0 : onExpand(item.key, !expand);
        setExpand(!expand);
      }
    }, _$1.isEmpty(item.children) ? /* @__PURE__ */ React.createElement("div", {
      style: {
        width: 10
      }
    }) : /* @__PURE__ */ React.createElement("div", {
      className: "filter-caret ".concat(expand ? "down" : "right"),
      style: {
        cursor: "pointer"
      }
    }), /* @__PURE__ */ React.createElement("input", {
      className: "filter-checkbox",
      type: "checkbox",
      checked,
      onChange: function onChange() {
        _onChange2(item, !checked);
      },
      onClick: function onClick(e) {
        return e.stopPropagation();
      }
    }), /* @__PURE__ */ React.createElement("div", null, item.text), /* @__PURE__ */ React.createElement("span", {
      className: "count"
    }, "( ".concat(item.rows.length, " )"))), expand && item.children.map(function(v2) {
      return /* @__PURE__ */ React.createElement(DateSelectTreeItem2, _objectSpread2({
        key: v2.key,
        item: v2,
        depth: depth + 1
      }, {
        initialExpand,
        onExpand,
        isChecked,
        onChange: _onChange2,
        isItemVisible
      }));
    })) : null;
  };
  var DateSelectTree = function DateSelectTree2(_ref3) {
    var dates = _ref3.dates, initialExpand = _ref3.initialExpand, onExpand = _ref3.onExpand, isChecked = _ref3.isChecked, onChange = _ref3.onChange, isItemVisible = _ref3.isItemVisible;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, dates.map(function(v2) {
      return /* @__PURE__ */ React.createElement(DateSelectTreeItem, _objectSpread2({
        key: v2.key,
        item: v2
      }, {
        initialExpand,
        onExpand,
        isChecked,
        onChange,
        isItemVisible
      }));
    }));
  };
  var FilterMenu = function FilterMenu2() {
    var _settings$filterConte;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, settings = _useContext.settings;
    var containerRef = reactExports.useRef(null);
    var contextRef = reactExports.useRef(context);
    var byColorMenuRef = reactExports.useRef(null);
    var subMenuRef = reactExports.useRef(null);
    var filterContextMenu = context.filterContextMenu;
    var _ref4 = filterContextMenu || {
      startRow: null,
      startCol: null,
      endRow: null,
      endCol: null,
      col: null,
      listBoxMaxHeight: 400
    }, startRow = _ref4.startRow, startCol = _ref4.startCol, endRow = _ref4.endRow, endCol = _ref4.endCol, col = _ref4.col, listBoxMaxHeight = _ref4.listBoxMaxHeight;
    var _locale = locale(context), filter = _locale.filter;
    var _useState3 = reactExports.useState({
      dates: [],
      dateRowMap: {},
      values: [],
      valueRowMap: {},
      visibleRows: [],
      flattenValues: []
    }), _useState4 = _slicedToArray(_useState3, 2), data = _useState4[0], setData = _useState4[1];
    var _useState5 = reactExports.useState([]), _useState6 = _slicedToArray(_useState5, 2), datesUncheck = _useState6[0], setDatesUncheck = _useState6[1];
    var _useState7 = reactExports.useState([]), _useState8 = _slicedToArray(_useState7, 2), valuesUncheck = _useState8[0], setValuesUncheck = _useState8[1];
    var dateTreeExpandState = reactExports.useRef({});
    var hiddenRows = reactExports.useRef([]);
    var _useState9 = reactExports.useState([]), _useState10 = _slicedToArray(_useState9, 2), showValues = _useState10[0], setShowValues = _useState10[1];
    var _useState11 = reactExports.useState(""), _useState12 = _slicedToArray(_useState11, 2), searchText = _useState12[0], setSearchText = _useState12[1];
    var _useState13 = reactExports.useState(), _useState14 = _slicedToArray(_useState13, 2), subMenuPos = _useState14[0], setSubMenuPos = _useState14[1];
    var _useState15 = reactExports.useState({
      bgColors: [],
      fcColors: []
    }), _useState16 = _slicedToArray(_useState15, 2), filterColors = _useState16[0], setFilterColors = _useState16[1];
    var _useState17 = reactExports.useState(false), _useState18 = _slicedToArray(_useState17, 2), showSubMenu = _useState18[0], setShowSubMenu = _useState18[1];
    var _useAlert = useAlert(), showAlert = _useAlert.showAlert;
    var mouseHoverSubMenu = reactExports.useRef(false);
    var close = reactExports.useCallback(function() {
      setContext(function(ctx) {
        ctx.filterContextMenu = void 0;
      });
    }, [setContext]);
    useOutsideClick(containerRef, close, [close]);
    var initialExpand = reactExports.useCallback(function(key) {
      var expand = dateTreeExpandState.current[key];
      if (expand == null) {
        dateTreeExpandState.current[key] = true;
        return true;
      }
      return expand;
    }, []);
    var onExpand = reactExports.useCallback(function(key, expand) {
      dateTreeExpandState.current[key] = expand;
    }, []);
    var searchValues = reactExports.useMemo(function() {
      return _$1.debounce(function(text2) {
        setShowValues(_$1.filter(data.flattenValues, function(v2) {
          return v2.toLowerCase().indexOf(text2.toLowerCase()) > -1;
        }));
      }, 300);
    }, [data.flattenValues]);
    var selectAll2 = reactExports.useCallback(function() {
      setDatesUncheck([]);
      setValuesUncheck([]);
      hiddenRows.current = [];
    }, []);
    var clearAll = reactExports.useCallback(function() {
      setDatesUncheck(_$1.keys(data.dateRowMap));
      setValuesUncheck(_$1.keys(data.valueRowMap));
      hiddenRows.current = data.visibleRows;
    }, [data.dateRowMap, data.valueRowMap, data.visibleRows]);
    var inverseSelect = reactExports.useCallback(function() {
      setDatesUncheck(fn(function(draft) {
        return _$1.xor(draft, _$1.keys(data.dateRowMap));
      }));
      setValuesUncheck(fn(function(draft) {
        return _$1.xor(draft, _$1.keys(data.valueRowMap));
      }));
      hiddenRows.current = _$1.xor(hiddenRows.current, data.visibleRows);
    }, [data.dateRowMap, data.valueRowMap, data.visibleRows]);
    var onColorSelectChange = reactExports.useCallback(function(key, color, checked) {
      setFilterColors(fn(function(draft) {
        var colorData = _$1.find(_$1.get(draft, key), function(v2) {
          return v2.color === color;
        });
        colorData.checked = checked;
      }));
    }, []);
    var delayHideSubMenu = reactExports.useMemo(function() {
      return _$1.debounce(function() {
        if (mouseHoverSubMenu.current) return;
        setShowSubMenu(false);
      }, 200);
    }, []);
    var sortData = reactExports.useCallback(function(asc) {
      if (col == null) return;
      setContext(function(draftCtx) {
        var errMsg = orderbydatafiler(draftCtx, startRow, startCol, endRow, endCol, col, asc);
        if (errMsg != null) showAlert(errMsg);
      });
    }, [col, setContext, startRow, startCol, endRow, endCol, showAlert]);
    var renderColorList = reactExports.useCallback(function(key, title, colors2, onSelectChange) {
      return colors2.length > 1 ? /* @__PURE__ */ React.createElement("div", {
        key
      }, /* @__PURE__ */ React.createElement("div", {
        className: "title"
      }, title), /* @__PURE__ */ React.createElement("div", {
        className: "color-list"
      }, colors2.map(function(v2) {
        return /* @__PURE__ */ React.createElement("div", {
          key: v2.color,
          className: "item",
          onClick: function onClick() {
            return onSelectChange(key, v2.color, !v2.checked);
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "color-label",
          style: {
            backgroundColor: v2.color
          }
        }), /* @__PURE__ */ React.createElement("input", {
          className: "luckysheet-mousedown-cancel",
          type: "checkbox",
          checked: v2.checked,
          onChange: function onChange() {
          }
        }));
      }))) : null;
    }, []);
    reactExports.useLayoutEffect(function() {
      if (!containerRef.current || !filterContextMenu) {
        return;
      }
      var winH = window.innerHeight;
      var winW = window.innerWidth;
      var rect = containerRef.current.getBoundingClientRect();
      var menuW = rect.width;
      var menuH = 350;
      var top = filterContextMenu.y;
      var left = filterContextMenu.x;
      var hasOverflow = false;
      if (left + menuW > winW) {
        left -= menuW;
        hasOverflow = true;
      }
      if (top + menuH > winH) {
        top -= menuH;
        hasOverflow = true;
      }
      if (top < 0) {
        top = 0;
        hasOverflow = true;
      }
      var containerH = winH - rect.top - 350;
      if (containerH < 0) {
        containerH = 100;
      }
      if (filterContextMenu.x === left && filterContextMenu.y === top && filterContextMenu.listBoxMaxHeight === containerH) {
        return;
      }
      setContext(function(draftCtx) {
        if (hasOverflow) {
          _$1.set(draftCtx, "filterContextMenu.x", left);
          _$1.set(draftCtx, "filterContextMenu.y", top);
        }
        _$1.set(draftCtx, "filterContextMenu.listBoxMaxHeight", containerH);
      });
    }, [filterContextMenu, setContext]);
    reactExports.useLayoutEffect(function() {
      var _byColorMenuRef$curre, _subMenuRef$current;
      var rect = (_byColorMenuRef$curre = byColorMenuRef.current) === null || _byColorMenuRef$curre === void 0 ? void 0 : _byColorMenuRef$curre.getBoundingClientRect();
      var subMenuRect = (_subMenuRef$current = subMenuRef.current) === null || _subMenuRef$current === void 0 ? void 0 : _subMenuRef$current.getBoundingClientRect();
      if (rect == null || subMenuRect == null) return;
      if (subMenuPos.left < rect.right) return;
      var winW = window.innerWidth;
      var hasOverflow = false;
      var pos = {
        top: rect.top - 5
      };
      if (rect.right + subMenuRect.width > winW) {
        hasOverflow = true;
        _$1.set(pos, "left", rect.left - subMenuRect.width);
      }
      if (hasOverflow) {
        setSubMenuPos(pos);
      }
    }, [subMenuPos]);
    reactExports.useEffect(function() {
      if (col == null) return;
      setSearchText("");
      setShowSubMenu(false);
      dateTreeExpandState.current = {};
      hiddenRows.current = (filterContextMenu === null || filterContextMenu === void 0 ? void 0 : filterContextMenu.hiddenRows) || [];
      var res = getFilterColumnValues(contextRef.current, col, startRow, endRow, startCol);
      setData(_$1.omit(res, ["datesUncheck", "valuesUncheck"]));
      setDatesUncheck(res.datesUncheck);
      setValuesUncheck(res.valuesUncheck);
      setShowValues(res.flattenValues);
    }, [col, endRow, startRow, startCol, hiddenRows, filterContextMenu === null || filterContextMenu === void 0 ? void 0 : filterContextMenu.hiddenRows]);
    reactExports.useEffect(function() {
      if (col == null) return;
      setFilterColors(getFilterColumnColors(contextRef.current, col, startRow, endRow));
    }, [col, endRow, startRow]);
    if (filterContextMenu == null) return null;
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-context-menu luckysheet-cols-menu fortune-filter-menu",
      id: "luckysheet-\\${menuid}-menu",
      ref: containerRef,
      style: {
        left: filterContextMenu.x,
        top: filterContextMenu.y
      }
    }, (_settings$filterConte = settings.filterContextMenu) === null || _settings$filterConte === void 0 ? void 0 : _settings$filterConte.map(function(name, i2) {
      if (name === "|") {
        return /* @__PURE__ */ React.createElement(Divider$1, {
          key: "divider-".concat(i2)
        });
      }
      if (name === "sort-by-asc") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            return sortData(true);
          }
        }, filter.sortByAsc);
      }
      if (name === "sort-by-desc") {
        return /* @__PURE__ */ React.createElement(Menu, {
          key: name,
          onClick: function onClick() {
            return sortData(false);
          }
        }, filter.sortByDesc);
      }
      if (name === "filter-by-color") {
        return /* @__PURE__ */ React.createElement("div", {
          key: name,
          ref: byColorMenuRef,
          onMouseEnter: function onMouseEnter() {
            var _byColorMenuRef$curre2;
            if (!containerRef.current || !filterContextMenu) {
              return;
            }
            setShowSubMenu(true);
            var rect = (_byColorMenuRef$curre2 = byColorMenuRef.current) === null || _byColorMenuRef$curre2 === void 0 ? void 0 : _byColorMenuRef$curre2.getBoundingClientRect();
            if (rect == null) return;
            setSubMenuPos({
              top: rect.top - 5,
              left: rect.right
            });
          },
          onMouseLeave: delayHideSubMenu
        }, /* @__PURE__ */ React.createElement(Menu, {
          onClick: function onClick() {
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "filter-bycolor-container"
        }, filter.filterByColor, /* @__PURE__ */ React.createElement("div", {
          className: "filter-caret right"
        }))));
      }
      if (name === "filter-by-condition") {
        return /* @__PURE__ */ React.createElement("div", {
          key: "name"
        }, /* @__PURE__ */ React.createElement(Menu, {
          onClick: function onClick() {
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "filter-caret right"
        }), filter.filterByCondition), /* @__PURE__ */ React.createElement("div", {
          className: "luckysheet-\\${menuid}-bycondition",
          style: {
            display: "none"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "luckysheet-flat-menu-button luckysheet-mousedown-cancel",
          id: "luckysheet-\\${menuid}-selected"
        }, /* @__PURE__ */ React.createElement("span", {
          className: "luckysheet-mousedown-cancel",
          "data-value": "null",
          "data-type": "0"
        }, filter.filiterInputNone), /* @__PURE__ */ React.createElement("div", {
          className: "luckysheet-mousedown-cancel"
        }, /* @__PURE__ */ React.createElement("i", {
          className: "fa fa-sort",
          "aria-hidden": "true"
        })))));
      }
      if (name === "filter-by-value") {
        return /* @__PURE__ */ React.createElement("div", {
          key: name
        }, /* @__PURE__ */ React.createElement(Menu, {
          onClick: function onClick() {
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "filter-caret right"
        }), filter.filterByValues), /* @__PURE__ */ React.createElement("div", {
          className: "luckysheet-filter-byvalue"
        }, /* @__PURE__ */ React.createElement("div", {
          className: "fortune-menuitem-row byvalue-btn-row"
        }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("span", {
          className: "fortune-byvalue-btn",
          onClick: selectAll2
        }, filter.filterValueByAllBtn), " - ", /* @__PURE__ */ React.createElement("span", {
          className: "fortune-byvalue-btn",
          onClick: clearAll
        }, filter.filterValueByClearBtn), " - ", /* @__PURE__ */ React.createElement("span", {
          className: "fortune-byvalue-btn",
          onClick: inverseSelect
        }, filter.filterValueByInverseBtn)), /* @__PURE__ */ React.createElement("div", {
          className: "byvalue-filter-icon"
        }, /* @__PURE__ */ React.createElement(SVGIcon, {
          name: "filter-fill",
          style: {
            width: 20,
            height: 20
          }
        }))), /* @__PURE__ */ React.createElement("div", {
          className: "filtermenu-input-container"
        }, /* @__PURE__ */ React.createElement("input", {
          type: "text",
          onKeyDown: function onKeyDown(e) {
            return e.stopPropagation();
          },
          placeholder: filter.filterValueByTip,
          className: "luckysheet-mousedown-cancel",
          id: "luckysheet-\\${menuid}-byvalue-input",
          value: searchText,
          onChange: function onChange(e) {
            setSearchText(e.target.value);
            searchValues(e.target.value);
          }
        })), /* @__PURE__ */ React.createElement("div", {
          id: "luckysheet-filter-byvalue-select",
          style: {
            maxHeight: listBoxMaxHeight
          }
        }, /* @__PURE__ */ React.createElement(DateSelectTree, {
          dates: data.dates,
          onExpand,
          initialExpand,
          isChecked: function isChecked(key) {
            return _$1.find(datesUncheck, function(v2) {
              return v2.match(key) != null;
            }) == null;
          },
          onChange: function onChange(item, checked) {
            var rows = hiddenRows.current;
            hiddenRows.current = checked ? _$1.without.apply(_$1, [rows].concat(_toConsumableArray(item.rows))) : _$1.union(rows, item.rows);
            setDatesUncheck(fn(function(draft) {
              return checked ? _$1.without.apply(_$1, [draft].concat(_toConsumableArray(item.dateValues))) : _$1.union(draft, item.dateValues);
            }));
          },
          isItemVisible: function isItemVisible(item) {
            return showValues.length === data.flattenValues.length ? true : _$1.findIndex(showValues, function(v2) {
              return v2.match(item.key) != null;
            }) > -1;
          }
        }), data.values.map(function(v2) {
          return /* @__PURE__ */ React.createElement(SelectItem, {
            key: v2.key,
            item: v2,
            isChecked: function isChecked(key) {
              return !_$1.includes(valuesUncheck, key);
            },
            onChange: function onChange(item, checked) {
              var rows = hiddenRows.current;
              hiddenRows.current = checked ? _$1.without.apply(_$1, [rows].concat(_toConsumableArray(item.rows))) : _$1.concat(rows, item.rows);
              setValuesUncheck(fn(function(draft) {
                if (checked) {
                  _$1.pull(draft, item.key);
                } else {
                  draft.push(item.key);
                }
              }));
            },
            isItemVisible: function isItemVisible(item) {
              return showValues.length === data.flattenValues.length ? true : _$1.includes(showValues, item.text);
            }
          });
        }))));
      }
      return null;
    }), /* @__PURE__ */ React.createElement(Divider$1, null), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-menuitem-row"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        if (col == null) return;
        setContext(function(draftCtx) {
          var rowHidden = _$1.reduce(hiddenRows.current, function(pre, curr) {
            pre[curr] = 0;
            return pre;
          }, {});
          saveFilter(draftCtx, hiddenRows.current.length > 0, rowHidden, {}, startRow, endRow, col, startCol, endCol);
          hiddenRows.current = [];
          draftCtx.filterContextMenu = void 0;
        });
      }
    }, filter.filterConform), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-default",
      onClick: function onClick() {
        setContext(function(draftCtx) {
          draftCtx.filterContextMenu = void 0;
        });
      }
    }, filter.filterCancel), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-danger",
      onClick: function onClick() {
        setContext(function(draftCtx) {
          clearFilter(draftCtx);
        });
      }
    }, filter.clearFilter))), showSubMenu && /* @__PURE__ */ React.createElement("div", {
      ref: subMenuRef,
      className: "luckysheet-filter-bycolor-submenu",
      style: subMenuPos,
      onMouseEnter: function onMouseEnter() {
        mouseHoverSubMenu.current = true;
      },
      onMouseLeave: function onMouseLeave() {
        mouseHoverSubMenu.current = false;
        setShowSubMenu(false);
      }
    }, filterColors.bgColors.length < 2 && filterColors.fcColors.length < 2 ? /* @__PURE__ */ React.createElement("div", {
      className: "one-color-tip"
    }, filter.filterContainerOneColorTip) : /* @__PURE__ */ React.createElement(React.Fragment, null, [{
      key: "bgColors",
      title: filter.filiterByColorTip,
      colors: filterColors.bgColors
    }, {
      key: "fcColors",
      title: filter.filiterByTextColorTip,
      colors: filterColors.fcColors
    }].map(function(v2) {
      return renderColorList(v2.key, v2.title, v2.colors, onColorSelectChange);
    }), /* @__PURE__ */ React.createElement("div", {
      className: "button-basic button-primary",
      onClick: function onClick() {
        if (col == null) return;
        setContext(function(draftCtx) {
          var rowHidden = _$1.reduce(_$1(filterColors).values().flatten().map(function(v2) {
            return v2.checked ? [] : v2.rows;
          }).flatten().valueOf(), function(pre, curr) {
            pre[curr] = 0;
            return pre;
          }, {});
          saveFilter(draftCtx, !_$1.isEmpty(rowHidden), rowHidden, {}, startRow, endRow, col, startCol, endCol);
          hiddenRows.current = [];
          draftCtx.filterContextMenu = void 0;
        });
      }
    }, filter.filterConform))));
  };
  var SheetHiddenButton = function SheetHiddenButton2(_ref) {
    var style = _ref.style, sheet = _ref.sheet;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var showSheet2 = reactExports.useCallback(function() {
      if (context.allowEdit === false) return;
      if (!sheet) return;
      setContext(function(ctx) {
        index.showSheet(ctx, sheet.id);
      });
    }, [context.allowEdit, setContext, sheet]);
    return /* @__PURE__ */ React.createElement("div", {
      style,
      onClick: function onClick(e) {
        e.stopPropagation();
        showSheet2();
      },
      className: "fortune-sheet-hidden-button"
    }, (sheet === null || sheet === void 0 ? void 0 : sheet.hide) === 1 ? /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "hidden",
      width: 16,
      height: 16,
      style: {
        marginTop: "7px"
      }
    }) : "");
  };
  var SheetListItem = function SheetListItem2(_ref) {
    var sheet = _ref.sheet, isDropPlaceholder = _ref.isDropPlaceholder;
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext, refs = _useContext.refs;
    var containerRef = reactExports.useRef(null);
    reactExports.useEffect(function() {
      setContext(function(draftCtx) {
        var r2 = context.sheetScrollRecord[draftCtx === null || draftCtx === void 0 ? void 0 : draftCtx.currentSheetId];
        if (r2) {
          var _r$scrollLeft, _r$scrollTop, _r$luckysheet_select_, _r$luckysheet_select_2;
          draftCtx.scrollLeft = (_r$scrollLeft = r2.scrollLeft) !== null && _r$scrollLeft !== void 0 ? _r$scrollLeft : 0;
          draftCtx.scrollTop = (_r$scrollTop = r2.scrollTop) !== null && _r$scrollTop !== void 0 ? _r$scrollTop : 0;
          draftCtx.luckysheet_select_status = (_r$luckysheet_select_ = r2.luckysheet_select_status) !== null && _r$luckysheet_select_ !== void 0 ? _r$luckysheet_select_ : false;
          draftCtx.luckysheet_select_save = (_r$luckysheet_select_2 = r2.luckysheet_select_save) !== null && _r$luckysheet_select_2 !== void 0 ? _r$luckysheet_select_2 : void 0;
        } else {
          draftCtx.scrollLeft = 0;
          draftCtx.scrollTop = 0;
          draftCtx.luckysheet_select_status = false;
          draftCtx.luckysheet_select_save = void 0;
        }
        draftCtx.luckysheet_selection_range = [];
      });
    }, [context.currentSheetId, context.sheetScrollRecord, setContext]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-sheet-list-item",
      key: sheet.id,
      ref: containerRef,
      onClick: function onClick() {
        if (isDropPlaceholder) return;
        setContext(function(draftCtx) {
          draftCtx.sheetScrollRecord[draftCtx.currentSheetId] = {
            scrollLeft: draftCtx.scrollLeft,
            scrollTop: draftCtx.scrollTop,
            luckysheet_select_status: draftCtx.luckysheet_select_status,
            luckysheet_select_save: draftCtx.luckysheet_select_save,
            luckysheet_selection_range: draftCtx.luckysheet_selection_range
          };
          draftCtx.currentSheetId = sheet.id;
          draftCtx.zoomRatio = sheet.zoomRatio || 1;
          cancelActiveImgItem(draftCtx, refs.globalCache);
          cancelNormalSelected(draftCtx);
        });
      }
    }, /* @__PURE__ */ React.createElement("span", {
      className: "fortune-sheet-selected-check-sapce"
    }, sheet.id === context.currentSheetId && /* @__PURE__ */ React.createElement(SVGIcon, {
      name: "check",
      width: 16,
      height: 16,
      style: {
        lineHeight: 30,
        verticalAlign: "middle"
      }
    })), /* @__PURE__ */ React.createElement("span", {
      className: "luckysheet-sheets-item-name fortune-sheet-list-item-name",
      spellCheck: "false"
    }, !!sheet.color && /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-sheets-list-item-color",
      style: {
        background: sheet.color
      }
    }), sheet.name), sheet.hide && /* @__PURE__ */ React.createElement(SheetHiddenButton, {
      sheet
    }));
  };
  var SheetList = function SheetList2() {
    var _useContext = reactExports.useContext(WorkbookContext), context = _useContext.context, setContext = _useContext.setContext;
    var containerRef = reactExports.useRef(null);
    var close = reactExports.useCallback(function() {
      setContext(function(ctx) {
        ctx.showSheetList = false;
      });
    }, [setContext]);
    useOutsideClick(containerRef, close, [close]);
    return /* @__PURE__ */ React.createElement("div", {
      className: "fortune-context-menu luckysheet-cols-menu fortune-sheet-list",
      ref: containerRef
    }, _$1.sortBy(context.luckysheetfile, function(s2) {
      return Number(s2.order);
    }).map(function(singleSheet) {
      return /* @__PURE__ */ React.createElement(SheetListItem, {
        sheet: singleSheet,
        key: singleSheet.id
      });
    }));
  };
  var _excluded = ["onChange", "onOp", "data"];
  T();
  var Workbook = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
    var _context$luckysheetfi;
    var onChange = _ref.onChange, onOp = _ref.onOp, originalData = _ref.data, props = _objectWithoutProperties(_ref, _excluded);
    var globalCache = reactExports.useRef({
      undoList: [],
      redoList: []
    });
    var _useState = reactExports.useState(defaultContext(globalCache.current)), _useState2 = _slicedToArray(_useState, 2), context = _useState2[0], setContext = _useState2[1];
    var _locale = locale(context), formula = _locale.formula;
    var cellInput = reactExports.useRef(null);
    var fxInput = reactExports.useRef(null);
    var canvas = reactExports.useRef(null);
    var scrollbarX = reactExports.useRef(null);
    var scrollbarY = reactExports.useRef(null);
    var cellArea = reactExports.useRef(null);
    var workbookContainer = reactExports.useRef(null);
    var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), moreToolbarItems = _useState4[0], setMoreToolbarItems = _useState4[1];
    var _useState5 = reactExports.useState({
      numberC: 0,
      count: 0,
      sum: 0,
      max: 0,
      min: 0,
      average: ""
    }), _useState6 = _slicedToArray(_useState5, 2), calInfo = _useState6[0], setCalInfo = _useState6[1];
    var mergedSettings = reactExports.useMemo(function() {
      return _$1.assign(_$1.cloneDeep(defaultSettings), props);
    }, _toConsumableArray(_$1.values(props)));
    reactExports.useEffect(function() {
      var selection = context.luckysheet_select_save;
      var lang = props.lang;
      if (selection) {
        var re2 = calcSelectionInfo(context, lang);
        setCalInfo(re2);
      }
    }, [context.luckysheet_select_save]);
    var initSheetData2 = reactExports.useCallback(function(draftCtx, newData, index2) {
      var _lastRow$r, _lastCol$c;
      var celldata = newData.celldata, row = newData.row, column = newData.column;
      var lastRow = _$1.maxBy(celldata, "r");
      var lastCol = _$1.maxBy(celldata, "c");
      var lastRowNum = ((_lastRow$r = lastRow === null || lastRow === void 0 ? void 0 : lastRow.r) !== null && _lastRow$r !== void 0 ? _lastRow$r : 0) + 1;
      var lastColNum = ((_lastCol$c = lastCol === null || lastCol === void 0 ? void 0 : lastCol.c) !== null && _lastCol$c !== void 0 ? _lastCol$c : 0) + 1;
      if (row != null && column != null && row > 0 && column > 0) {
        lastRowNum = Math.max(lastRowNum, row);
        lastColNum = Math.max(lastColNum, column);
      } else {
        lastRowNum = Math.max(lastRowNum, draftCtx.defaultrowNum);
        lastColNum = Math.max(lastColNum, draftCtx.defaultcolumnNum);
      }
      if (lastRowNum && lastColNum) {
        var expandedData = _$1.times(lastRowNum, function() {
          return _$1.times(lastColNum, function() {
            return null;
          });
        });
        celldata === null || celldata === void 0 ? void 0 : celldata.forEach(function(d2) {
          expandedData[d2.r][d2.c] = d2.v;
        });
        draftCtx.luckysheetfile = fn(draftCtx.luckysheetfile, function(d2) {
          d2[index2].data = expandedData;
          delete d2[index2].celldata;
          return d2;
        });
        return expandedData;
      }
      return null;
    }, []);
    var emitOp = reactExports.useCallback(function(ctx, patches, options) {
      var undo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if (onOp) {
        onOp(patchToOp(ctx, patches, options, undo));
      }
    }, [onOp]);
    function reduceUndoList(ctx, ctxBefore) {
      var sheetsId = ctx.luckysheetfile.map(function(sheet2) {
        return sheet2.id;
      });
      var sheetDeletedByMe = globalCache.current.undoList.filter(function(undo) {
        var _undo$options;
        return (_undo$options = undo.options) === null || _undo$options === void 0 ? void 0 : _undo$options.deleteSheetOp;
      }).map(function(item) {
        var _item$options, _item$options$deleteS;
        return (_item$options = item.options) === null || _item$options === void 0 ? void 0 : (_item$options$deleteS = _item$options.deleteSheetOp) === null || _item$options$deleteS === void 0 ? void 0 : _item$options$deleteS.id;
      });
      globalCache.current.undoList = globalCache.current.undoList.filter(function(undo) {
        var _undo$options2, _undo$options3, _undo$options4, _undo$options5;
        return ((_undo$options2 = undo.options) === null || _undo$options2 === void 0 ? void 0 : _undo$options2.deleteSheetOp) || ((_undo$options3 = undo.options) === null || _undo$options3 === void 0 ? void 0 : _undo$options3.id) === void 0 || _$1.indexOf(sheetsId, (_undo$options4 = undo.options) === null || _undo$options4 === void 0 ? void 0 : _undo$options4.id) !== -1 || _$1.indexOf(sheetDeletedByMe, (_undo$options5 = undo.options) === null || _undo$options5 === void 0 ? void 0 : _undo$options5.id) !== -1;
      });
      if (ctxBefore.luckysheetfile.length > ctx.luckysheetfile.length) {
        var sheetDeleted = ctxBefore.luckysheetfile.filter(function(oneSheet) {
          return _$1.indexOf(ctx.luckysheetfile.map(function(item) {
            return item.id;
          }), oneSheet.id) === -1;
        }).map(function(item) {
          return getSheetIndex(ctxBefore, item.id);
        });
        var deletedIndex = sheetDeleted[0];
        globalCache.current.undoList = globalCache.current.undoList.map(function(oneStep) {
          oneStep.patches = oneStep.patches.map(function(onePatch) {
            if (typeof onePatch.path[1] === "number" && onePatch.path[1] > deletedIndex) {
              onePatch.path[1] -= 1;
            }
            return onePatch;
          });
          oneStep.inversePatches = oneStep.inversePatches.map(function(onePatch) {
            if (typeof onePatch.path[1] === "number" && onePatch.path[1] > deletedIndex) {
              onePatch.path[1] -= 1;
            }
            return onePatch;
          });
          return oneStep;
        });
      }
    }
    function dataToCelldata2(data) {
      var cellData = [];
      for (var row = 0; row < (data === null || data === void 0 ? void 0 : data.length); row += 1) {
        for (var col = 0; col < ((_data$row = data[row]) === null || _data$row === void 0 ? void 0 : _data$row.length); col += 1) {
          var _data$row;
          if (data[row][col] !== null) {
            cellData.push({
              r: row,
              c: col,
              v: data[row][col]
            });
          }
        }
      }
      return cellData;
    }
    var setContextWithProduce = reactExports.useCallback(function(recipe) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      setContext(function(ctx_) {
        var _produceWithPatches = cn(ctx_, recipe), _produceWithPatches2 = _slicedToArray(_produceWithPatches, 3), result = _produceWithPatches2[0], patches = _produceWithPatches2[1], inversePatches = _produceWithPatches2[2];
        if (patches.length > 0 && !options.noHistory) {
          if (options.logPatch) {
            console.info("patch", patches);
          }
          var filteredPatches = filterPatch(patches);
          var filteredInversePatches = filterPatch(inversePatches);
          if (filteredInversePatches.length > 0) {
            options.id = ctx_.currentSheetId;
            if (options.deleteSheetOp) {
              var target = ctx_.luckysheetfile.filter(function(sheet2) {
                var _options$deleteSheetO;
                return sheet2.id === ((_options$deleteSheetO = options.deleteSheetOp) === null || _options$deleteSheetO === void 0 ? void 0 : _options$deleteSheetO.id);
              });
              if (target) {
                var index2 = getSheetIndex(ctx_, options.deleteSheetOp.id);
                options.deletedSheet = {
                  id: options.deleteSheetOp.id,
                  index: index2,
                  value: _$1.cloneDeep(ctx_.luckysheetfile[index2])
                };
                options.deletedSheet.value.celldata = dataToCelldata2(options.deletedSheet.value.data);
                delete options.deletedSheet.value.data;
                options.deletedSheet.value.status = 0;
                filteredInversePatches = [{
                  op: "add",
                  path: ["luckysheetfile", 0],
                  value: options.deletedSheet.value
                }];
              }
            } else if (options.addSheetOp) {
              options.addSheet = {};
              options.addSheet.id = result.luckysheetfile[result.luckysheetfile.length - 1].id;
            }
            globalCache.current.undoList.push({
              patches: filteredPatches,
              inversePatches: filteredInversePatches,
              options
            });
            globalCache.current.redoList = [];
            emitOp(result, filteredPatches, options);
          }
        } else {
          var _patches$, _patches$$value, _ctx_$luckysheetfile;
          if ((patches === null || patches === void 0 ? void 0 : (_patches$ = patches[0]) === null || _patches$ === void 0 ? void 0 : (_patches$$value = _patches$.value) === null || _patches$$value === void 0 ? void 0 : _patches$$value.length) < (ctx_ === null || ctx_ === void 0 ? void 0 : (_ctx_$luckysheetfile = ctx_.luckysheetfile) === null || _ctx_$luckysheetfile === void 0 ? void 0 : _ctx_$luckysheetfile.length)) {
            reduceUndoList(result, ctx_);
          }
        }
        return result;
      });
    }, [emitOp]);
    var handleUndo = reactExports.useCallback(function() {
      var history = globalCache.current.undoList.pop();
      if (history) {
        setContext(function(ctx_) {
          var _history$options, _history$options3;
          if ((_history$options = history.options) === null || _history$options === void 0 ? void 0 : _history$options.deleteSheetOp) {
            var _history$options$dele, _history$options$dele2;
            history.inversePatches[0].path[1] = ctx_.luckysheetfile.length;
            var order = (_history$options$dele = history.options.deletedSheet) === null || _history$options$dele === void 0 ? void 0 : (_history$options$dele2 = _history$options$dele.value) === null || _history$options$dele2 === void 0 ? void 0 : _history$options$dele2.order;
            var sheetsRight = ctx_.luckysheetfile.filter(function(sheet2) {
              var _history$options2, _history$options2$del;
              return (sheet2 === null || sheet2 === void 0 ? void 0 : sheet2.order) >= order && sheet2.id !== (history === null || history === void 0 ? void 0 : (_history$options2 = history.options) === null || _history$options2 === void 0 ? void 0 : (_history$options2$del = _history$options2.deleteSheetOp) === null || _history$options2$del === void 0 ? void 0 : _history$options2$del.id);
            });
            _$1.forEach(sheetsRight, function(sheet2) {
              history.inversePatches.push({
                op: "replace",
                path: ["luckysheetfile", getSheetIndex(ctx_, sheet2.id), "order"],
                value: (sheet2 === null || sheet2 === void 0 ? void 0 : sheet2.order) + 1
              });
            });
          }
          var newContext = pn(ctx_, history.inversePatches);
          globalCache.current.redoList.push(history);
          var inversedOptions = inverseRowColOptions(history.options);
          if (inversedOptions === null || inversedOptions === void 0 ? void 0 : inversedOptions.insertRowColOp) {
            inversedOptions.restoreDeletedCells = true;
          }
          if ((_history$options3 = history.options) === null || _history$options3 === void 0 ? void 0 : _history$options3.addSheetOp) {
            var _inversedOptions$addS;
            var index2 = getSheetIndex(ctx_, history.options.addSheet.id);
            inversedOptions.addSheet = {
              id: history.options.addSheet.id,
              index: index2,
              value: _$1.cloneDeep(ctx_.luckysheetfile[index2])
            };
            inversedOptions.addSheet.value.celldata = dataToCelldata2((_inversedOptions$addS = inversedOptions.addSheet.value) === null || _inversedOptions$addS === void 0 ? void 0 : _inversedOptions$addS.data);
            delete inversedOptions.addSheet.value.data;
          }
          emitOp(newContext, history.inversePatches, inversedOptions, true);
          return newContext;
        });
      }
    }, [emitOp]);
    var handleRedo = reactExports.useCallback(function() {
      var history = globalCache.current.redoList.pop();
      if (history) {
        setContext(function(ctx_) {
          var newContext = pn(ctx_, history.patches);
          globalCache.current.undoList.push(history);
          emitOp(newContext, history.patches, history.options);
          return newContext;
        });
      }
    }, [emitOp]);
    reactExports.useEffect(function() {
      if (context.luckysheet_select_save != null) {
        var _mergedSettings$hooks, _mergedSettings$hooks2;
        (_mergedSettings$hooks = mergedSettings.hooks) === null || _mergedSettings$hooks === void 0 ? void 0 : (_mergedSettings$hooks2 = _mergedSettings$hooks.afterSelectionChange) === null || _mergedSettings$hooks2 === void 0 ? void 0 : _mergedSettings$hooks2.call(_mergedSettings$hooks, context.currentSheetId, context.luckysheet_select_save[0]);
      }
    }, [context.currentSheetId, context.luckysheet_select_save, mergedSettings.hooks]);
    var providerValue = reactExports.useMemo(function() {
      return {
        context,
        setContext: setContextWithProduce,
        settings: mergedSettings,
        handleUndo,
        handleRedo,
        refs: {
          globalCache: globalCache.current,
          cellInput,
          fxInput,
          canvas,
          scrollbarX,
          scrollbarY,
          cellArea,
          workbookContainer
        }
      };
    }, [context, handleRedo, handleUndo, mergedSettings, setContextWithProduce]);
    reactExports.useEffect(function() {
      if (!_$1.isEmpty(context.luckysheetfile)) {
        onChange === null || onChange === void 0 ? void 0 : onChange(context.luckysheetfile);
      }
    }, [context.luckysheetfile, onChange]);
    reactExports.useEffect(function() {
      setContextWithProduce(function(draftCtx) {
        var _draftCtx$luckysheetf4, _draftCtx$luckysheet_;
        draftCtx.defaultcolumnNum = mergedSettings.column;
        draftCtx.defaultrowNum = mergedSettings.row;
        draftCtx.defaultFontSize = mergedSettings.defaultFontSize;
        if (_$1.isEmpty(draftCtx.luckysheetfile)) {
          var newData = fn(originalData, function(draftData) {
            ensureSheetIndex(draftData, mergedSettings.generateSheetId);
          });
          draftCtx.luckysheetfile = newData;
          newData.forEach(function(newDatum) {
            var _draftCtx$luckysheetf;
            var index2 = getSheetIndex(draftCtx, newDatum.id);
            var sheet3 = (_draftCtx$luckysheetf = draftCtx.luckysheetfile) === null || _draftCtx$luckysheetf === void 0 ? void 0 : _draftCtx$luckysheetf[index2];
            initSheetData2(draftCtx, sheet3, index2);
          });
        }
        if (mergedSettings.devicePixelRatio > 0) {
          draftCtx.devicePixelRatio = mergedSettings.devicePixelRatio;
        }
        draftCtx.lang = mergedSettings.lang;
        draftCtx.allowEdit = mergedSettings.allowEdit;
        draftCtx.hooks = mergedSettings.hooks;
        if (_$1.isEmpty(draftCtx.currentSheetId)) {
          initSheetIndex(draftCtx);
        }
        var sheetIdx = getSheetIndex(draftCtx, draftCtx.currentSheetId);
        if (sheetIdx == null) {
          var _draftCtx$luckysheetf2, _draftCtx$luckysheetf3;
          if (((_draftCtx$luckysheetf2 = (_draftCtx$luckysheetf3 = draftCtx.luckysheetfile) === null || _draftCtx$luckysheetf3 === void 0 ? void 0 : _draftCtx$luckysheetf3.length) !== null && _draftCtx$luckysheetf2 !== void 0 ? _draftCtx$luckysheetf2 : 0) > 0) {
            sheetIdx = 0;
            draftCtx.currentSheetId = draftCtx.luckysheetfile[0].id;
          }
        }
        if (sheetIdx == null) return;
        var sheet2 = (_draftCtx$luckysheetf4 = draftCtx.luckysheetfile) === null || _draftCtx$luckysheetf4 === void 0 ? void 0 : _draftCtx$luckysheetf4[sheetIdx];
        if (!sheet2) return;
        var data = sheet2.data;
        if (_$1.isEmpty(data)) {
          var temp = initSheetData2(draftCtx, sheet2, sheetIdx);
          if (!_$1.isNull(temp)) {
            data = temp;
          }
        }
        if (_$1.isEmpty(draftCtx.luckysheet_select_save) && !_$1.isEmpty(sheet2.luckysheet_select_save)) {
          draftCtx.luckysheet_select_save = sheet2.luckysheet_select_save;
        }
        if (((_draftCtx$luckysheet_ = draftCtx.luckysheet_select_save) === null || _draftCtx$luckysheet_ === void 0 ? void 0 : _draftCtx$luckysheet_.length) === 0) {
          var _data, _data$, _data$$, _data2, _data2$, _data2$$, _data2$$$mc, _data3, _data3$, _data3$$, _data3$$$mc;
          if (((_data = data) === null || _data === void 0 ? void 0 : (_data$ = _data[0]) === null || _data$ === void 0 ? void 0 : (_data$$ = _data$[0]) === null || _data$$ === void 0 ? void 0 : _data$$.mc) && !_$1.isNil((_data2 = data) === null || _data2 === void 0 ? void 0 : (_data2$ = _data2[0]) === null || _data2$ === void 0 ? void 0 : (_data2$$ = _data2$[0]) === null || _data2$$ === void 0 ? void 0 : (_data2$$$mc = _data2$$.mc) === null || _data2$$$mc === void 0 ? void 0 : _data2$$$mc.rs) && !_$1.isNil((_data3 = data) === null || _data3 === void 0 ? void 0 : (_data3$ = _data3[0]) === null || _data3$ === void 0 ? void 0 : (_data3$$ = _data3$[0]) === null || _data3$$ === void 0 ? void 0 : (_data3$$$mc = _data3$$.mc) === null || _data3$$$mc === void 0 ? void 0 : _data3$$$mc.cs)) {
            draftCtx.luckysheet_select_save = [{
              row: [0, data[0][0].mc.rs - 1],
              column: [0, data[0][0].mc.cs - 1]
            }];
          } else {
            draftCtx.luckysheet_select_save = [{
              row: [0, 0],
              column: [0, 0]
            }];
          }
        }
        draftCtx.config = _$1.isNil(sheet2.config) ? {} : sheet2.config;
        draftCtx.insertedImgs = sheet2.images;
        draftCtx.zoomRatio = _$1.isNil(sheet2.zoomRatio) ? 1 : sheet2.zoomRatio;
        draftCtx.rowHeaderWidth = mergedSettings.rowHeaderWidth * draftCtx.zoomRatio;
        draftCtx.columnHeaderHeight = mergedSettings.columnHeaderHeight * draftCtx.zoomRatio;
        if (!_$1.isNil(sheet2.defaultRowHeight)) {
          draftCtx.defaultrowlen = Number(sheet2.defaultRowHeight);
        } else {
          draftCtx.defaultrowlen = mergedSettings.defaultRowHeight;
        }
        if (!_$1.isNil(sheet2.addRows)) {
          draftCtx.addDefaultRows = Number(sheet2.addRows);
        } else {
          draftCtx.addDefaultRows = mergedSettings.addRows;
        }
        if (!_$1.isNil(sheet2.defaultColWidth)) {
          draftCtx.defaultcollen = Number(sheet2.defaultColWidth);
        } else {
          draftCtx.defaultcollen = mergedSettings.defaultColWidth;
        }
        if (!_$1.isNil(sheet2.showGridLines)) {
          var showGridLines = sheet2.showGridLines;
          if (showGridLines === 0 || showGridLines === false) {
            draftCtx.showGridLines = false;
          } else {
            draftCtx.showGridLines = true;
          }
        } else {
          draftCtx.showGridLines = true;
        }
        if (_$1.isNil(mergedSettings.lang)) {
          var lang = navigator.languages && navigator.languages[0] || navigator.language || navigator.userLanguage;
          draftCtx.lang = lang;
        }
      }, {
        noHistory: true
      });
    }, [context.currentSheetId, context.luckysheetfile.length, originalData, mergedSettings.defaultRowHeight, mergedSettings.defaultColWidth, mergedSettings.column, mergedSettings.row, mergedSettings.defaultFontSize, mergedSettings.devicePixelRatio, mergedSettings.lang, mergedSettings.allowEdit, mergedSettings.hooks, mergedSettings.generateSheetId, setContextWithProduce, initSheetData2, mergedSettings.rowHeaderWidth, mergedSettings.columnHeaderHeight, mergedSettings.addRows]);
    var onKeyDown = reactExports.useCallback(function(e) {
      var nativeEvent = e.nativeEvent;
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyZ") {
        if (e.shiftKey) {
          handleRedo();
        } else {
          handleUndo();
        }
        e.stopPropagation();
        return;
      }
      if ((e.ctrlKey || e.metaKey) && e.code === "KeyY") {
        handleRedo();
        e.stopPropagation();
        e.preventDefault();
        return;
      }
      setContextWithProduce(function(draftCtx) {
        handleGlobalKeyDown(draftCtx, cellInput.current, fxInput.current, nativeEvent, globalCache.current, handleUndo, handleRedo, canvas.current.getContext("2d"));
      });
    }, [handleRedo, handleUndo, setContextWithProduce]);
    var onPaste = reactExports.useCallback(function(e) {
      var _document$activeEleme;
      if (cellInput.current === document.activeElement || ((_document$activeEleme = document.activeElement) === null || _document$activeEleme === void 0 ? void 0 : _document$activeEleme.className) === "fortune-sheet-overlay") {
        var clipboardData = e.clipboardData;
        if (!clipboardData) {
          clipboardData = window.clipboardData;
        }
        var txtdata = clipboardData.getData("text/html") || clipboardData.getData("text/plain");
        var ele = document.createElement("div");
        ele.innerHTML = txtdata;
        var trList = ele.querySelectorAll("table tr");
        var maxRow = trList.length + context.luckysheet_select_save[0].row[0];
        var rowToBeAdded = maxRow - context.luckysheetfile[getSheetIndex(context, context.currentSheetId)].data.length;
        var range = context.luckysheet_select_save;
        if (rowToBeAdded > 0) {
          var insertRowColOp = {
            type: "row",
            index: context.luckysheetfile[getSheetIndex(context, context.currentSheetId)].data.length - 1,
            count: rowToBeAdded,
            direction: "rightbottom",
            id: context.currentSheetId
          };
          setContextWithProduce(function(draftCtx) {
            insertRowCol(draftCtx, insertRowColOp);
            draftCtx.luckysheet_select_save = range;
          }, {
            insertRowColOp
          });
        }
        setContextWithProduce(function(draftCtx) {
          try {
            handlePaste(draftCtx, e);
          } catch (err) {
            console.error(err);
          }
        });
      }
    }, [context, setContextWithProduce]);
    var onMoreToolbarItemsClose = reactExports.useCallback(function() {
      setMoreToolbarItems(null);
    }, []);
    reactExports.useEffect(function() {
      document.addEventListener("paste", onPaste);
      return function() {
        document.removeEventListener("paste", onPaste);
      };
    }, [onPaste]);
    reactExports.useImperativeHandle(ref, function() {
      return generateAPIs(context, setContextWithProduce, handleUndo, handleRedo, mergedSettings, cellInput.current, scrollbarX.current, scrollbarY.current);
    }, [context, setContextWithProduce, handleUndo, handleRedo, mergedSettings]);
    var i2 = getSheetIndex(context, context.currentSheetId);
    if (i2 == null) {
      return null;
    }
    var sheet = (_context$luckysheetfi = context.luckysheetfile) === null || _context$luckysheetfi === void 0 ? void 0 : _context$luckysheetfi[i2];
    if (!sheet) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(WorkbookContext.Provider, {
      value: providerValue
    }, /* @__PURE__ */ React.createElement(ModalProvider, null, /* @__PURE__ */ React.createElement("div", {
      className: "fortune-container",
      ref: workbookContainer,
      onKeyDown
    }, /* @__PURE__ */ React.createElement(SVGDefines, null), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-workarea"
    }, mergedSettings.showToolbar && /* @__PURE__ */ React.createElement(Toolbar, {
      moreItemsOpen: moreToolbarItems !== null,
      setMoreItems: setMoreToolbarItems
    }), mergedSettings.showFormulaBar && /* @__PURE__ */ React.createElement(FxEditor, null)), /* @__PURE__ */ React.createElement(Sheet, {
      sheet
    }), mergedSettings.showSheetTabs && /* @__PURE__ */ React.createElement(SheetTab, null), /* @__PURE__ */ React.createElement(ContextMenu, null), /* @__PURE__ */ React.createElement(FilterMenu, null), /* @__PURE__ */ React.createElement(SheetTabContextMenu, null), context.showSheetList && /* @__PURE__ */ React.createElement(SheetList, null), moreToolbarItems && /* @__PURE__ */ React.createElement(MoreItemsContaier, {
      onClose: onMoreToolbarItemsClose
    }, moreToolbarItems), !_$1.isEmpty(context.contextMenu) && /* @__PURE__ */ React.createElement("div", {
      onMouseDown: function onMouseDown() {
        setContextWithProduce(function(draftCtx) {
          draftCtx.contextMenu = {};
          draftCtx.filterContextMenu = void 0;
          draftCtx.showSheetList = void 0;
        });
      },
      onMouseMove: function onMouseMove(e) {
        return e.stopPropagation();
      },
      onMouseUp: function onMouseUp(e) {
        return e.stopPropagation();
      },
      onContextMenu: function onContextMenu(e) {
        e.preventDefault();
        e.stopPropagation();
      },
      className: "fortune-popover-backdrop"
    }), /* @__PURE__ */ React.createElement("div", {
      className: "fortune-stat-area"
    }, /* @__PURE__ */ React.createElement("div", {
      className: "luckysheet-sheet-selection-calInfo"
    }, !!calInfo.count && /* @__PURE__ */ React.createElement("div", {
      style: {
        width: "60px"
      }
    }, formula.count, ": ", calInfo.count), !!calInfo.numberC && !!calInfo.sum && /* @__PURE__ */ React.createElement("div", null, formula.sum, ": ", calInfo.sum), !!calInfo.numberC && !!calInfo.average && /* @__PURE__ */ React.createElement("div", null, formula.average, ": ", calInfo.average), !!calInfo.numberC && !!calInfo.max && /* @__PURE__ */ React.createElement("div", null, formula.max, ": ", calInfo.max), !!calInfo.numberC && !!calInfo.min && /* @__PURE__ */ React.createElement("div", null, formula.min, ": ", calInfo.min))))));
  });
  const App = () => {
    const [data, setData] = reactExports.useState([{ name: "Sheet1", celldata: [] }]);
    const [isLoaded, setIsLoaded] = reactExports.useState(false);
    const loadData = reactExports.useCallback(async () => {
      try {
        const currentNote = await api.getActiveContextNote();
        if (!currentNote) {
          console.error("Note not found");
          return;
        }
        const childrenNotes = await currentNote.getChildNotes();
        let dataNote = childrenNotes.find((n2) => n2.title === "data.json" && !n2.isDeleted);
        if (!dataNote) {
          return;
        }
        const jsonContent = await dataNote.getJsonContent();
        if (jsonContent) {
          if (!Array.isArray(jsonContent)) {
            setData([{ name: "Sheet1", celldata: [] }]);
          } else {
            setData(jsonContent.map((sheet) => ({
              ...sheet,
              celldata: index.dataToCelldata(sheet.data || []),
              data: void 0
            })));
          }
        }
      } catch (err) {
        console.error("Failed to load spreadsheet data", err);
      } finally {
        setTimeout(() => setIsLoaded(true), 100);
      }
    }, []);
    const saveData = reactExports.useCallback(async (newData) => {
      if (!isLoaded) {
        return;
      }
      try {
        const content = JSON.stringify(newData);
        const currentNote = await api.getActiveContextNote();
        if (!currentNote) {
          console.error("Note not found");
          return;
        }
        const childNotes = await currentNote.getChildNotes();
        let dataNote = childNotes.find((n2) => n2.title === "data.json" && !n2.isDeleted);
        if (!dataNote) {
          const note = await api.runOnBackend(({ currentNoteId, content: content2 }) => {
            const { note: note2 } = api.createNewNote({
              parentNoteId: currentNoteId,
              title: "data.json",
              type: "code",
              mime: "application/json",
              content: content2
            });
            api.log(`Created data note ${note2.noteId()}`);
            return note2;
          }, [{ currentNoteId: currentNote.noteId, content }]);
          api.refreshIncludedNote(note.noteId);
        } else {
          await api.runOnBackend(({ dataNoteId, content: content2 }) => {
            const dNote = api.getNote(dataNoteId);
            dNote.setContent(content2, { forceFrontendReload: true, forceSave: true });
          }, [{ dataNoteId: dataNote.noteId, content }]);
          api.refreshIncludedNote(dataNote.noteId);
        }
      } catch (err) {
        console.error("Failed to save spreadsheet data", err);
      }
    }, [isLoaded]);
    const onDataChange = reactExports.useCallback((d2) => {
      if (!isLoaded) return;
      saveData(d2);
    }, [isLoaded, saveData]);
    reactExports.useEffect(() => {
      if (!isLoaded) {
        loadData();
        const forceResize = () => window.dispatchEvent(new Event("resize"));
        const [t1, t2] = [setTimeout(forceResize, 100), setTimeout(forceResize, 500)];
        return () => {
          clearTimeout(t1);
          clearTimeout(t2);
        };
      }
    }, [isLoaded]);
    if (!api) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "API not found. Make sure note type is Trillium renderNote." });
    } else if (!isLoaded) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Loading spreadsheet data..." });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: {
      width: "100%",
      height: "100%",
      minHeight: "calc(70vh - 100px)",
      /* Force visible height */
      position: "relative",
      display: "flex",
      flexDirection: "column",
      margin: 0,
      padding: 0,
      overflow: "hidden"
    }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Workbook, { data, onChange: onDataChange }) });
  };
  const getFrontendApi = () => {
    try {
      if (typeof api !== "undefined") return api;
      if (typeof window !== "undefined" && window.api) return window.api;
      return null;
    } catch (e) {
      console.error("Trilium Spreadsheet: api not found. Make sure note type is JS Frontend.", e);
    }
  };
  (function main() {
    const triliumApi = getFrontendApi();
    let retryCount = 0;
    const maxRetries = 3;
    const retryInterval = 100;
    function tryMount() {
      if (!triliumApi) {
        console.error("Trilium Spreadsheet: api not found. Make sure note type is JS Frontend.");
        return;
      } else if (triliumApi && triliumApi.$container && triliumApi.$container.length) {
        const container = triliumApi.$container[0];
        container.innerHTML = "";
        container.style.display = "flex";
        container.style.flexDirection = "column";
        container.style.height = "100%";
        container.style.width = "100%";
        const rootDiv = document.createElement("div");
        rootDiv.style.flex = "1";
        rootDiv.style.height = "100%";
        rootDiv.className = "fortune-sheet-mount";
        container.appendChild(rootDiv);
        client.createRoot(rootDiv).render(
          /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
        );
      } else {
        if (retryCount < maxRetries) {
          retryCount++;
          console.log(`Spreadsheet: Waiting for container... (${retryCount}/${maxRetries})`);
          setTimeout(tryMount, retryInterval);
        } else {
          console.error("Trilium Spreadsheet: api found but $container is missing after retries. Make sure note type is JS Frontend.");
        }
      }
    }
    tryMount();
  })();
})();
